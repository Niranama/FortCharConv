var tipuesearch = {"pages":[{"title":" FortCharConv ","text":"FortCharConv Developer Info Niranama","tags":"home","loc":"index.html"},{"title":"Equation – FortCharConv ","text":"type, public :: Equation an equation type that can be used to parse strings/texts expressing\n  mathematical expressions to 'FunctionParser' so that a system of\n  equations can be evaluated at runtime. Components Type Visibility Attributes Name Initial integer(kind=IP), public :: NEQ number of equations integer(kind=IP), public :: NVR number of variables character(len=256), public, ALLOCATABLE :: EQText (:) texts expressing equations character(len=30), public, ALLOCATABLE :: VarText (:) texts expressing variable names real(kind=FP), public, ALLOCATABLE :: Values (:) values of variables Source Code TYPE Equation !&#94; an equation type that can be used to parse strings/texts expressing !   mathematical expressions to 'FunctionParser' so that a system of !   equations can be evaluated at runtime. INTEGER ( KIND = IP ) :: NEQ !! number of equations INTEGER ( KIND = IP ) :: NVR !! number of variables CHARACTER ( LEN = 256 ), ALLOCATABLE :: EQText (:) !! texts expressing equations CHARACTER ( LEN = 30 ), ALLOCATABLE :: VarText (:) !! texts expressing variable names REAL ( KIND = FP ), ALLOCATABLE :: Values (:) !! values of variables END TYPE Equation","tags":"","loc":"type\\equation.html"},{"title":"UserParam – FortCharConv ","text":"type, public :: UserParam a user parameter type used to modernize legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public :: NR number of real parameters integer(kind=IP), public :: NI number of integer parameters real(kind=FP), public, ALLOCATABLE :: RPar (:) real parameters integer(kind=IP), public, ALLOCATABLE :: IPar (:) integer parameters Source Code TYPE UserParam !! a user parameter type used to modernize legacy code INTEGER ( KIND = IP ) :: NR !! number of real parameters INTEGER ( KIND = IP ) :: NI !! number of integer parameters REAL ( KIND = FP ), ALLOCATABLE :: RPar (:) !! real parameters INTEGER ( KIND = IP ), ALLOCATABLE :: IPar (:) !! integer parameters END TYPE UserParam","tags":"","loc":"type\\userparam.html"},{"title":"WorkSpace – FortCharConv ","text":"type, public :: WorkSpace a workspace type used to modernize legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public :: LRW number of real workspace variables integer(kind=IP), public :: LIW number of integer workspace variables real(kind=FP), public, ALLOCATABLE :: RVar (:) real workspace variables integer(kind=IP), public, ALLOCATABLE :: IVar (:) integer workspace variables Source Code TYPE WorkSpace !! a workspace type used to modernize legacy code INTEGER ( KIND = IP ) :: LRW !! number of real workspace variables INTEGER ( KIND = IP ) :: LIW !! number of integer workspace variables REAL ( KIND = FP ), ALLOCATABLE :: RVar (:) !! real workspace variables INTEGER ( KIND = IP ), ALLOCATABLE :: IVar (:) !! integer workspace variables END TYPE WorkSpace","tags":"","loc":"type\\workspace.html"},{"title":"SharePar – FortCharConv ","text":"type, public :: SharePar a share parameter type used to modernize common block of legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public, LEN :: NR number of real and integer parameters integer(kind=IP), public, LEN :: NI number of real and integer parameters real(kind=FP), public :: RPar (NR) real parameters integer(kind=IP), public :: IPar (NI) integer parameters Source Code TYPE SharePar ( NR , NI ) !! a share parameter type used to modernize common block of legacy code INTEGER ( KIND = IP ), LEN :: NR , NI !! number of real and integer parameters REAL ( KIND = FP ) :: RPar ( NR ) !! real parameters INTEGER ( KIND = IP ) :: IPar ( NI ) !! integer parameters END TYPE SharePar","tags":"","loc":"type\\sharepar.html"},{"title":"SaveVar – FortCharConv ","text":"type, public :: SaveVar a saved variable type used to modernize legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public, LEN :: NR number of real, integer and logical parameters integer(kind=IP), public, LEN :: NL number of real, integer and logical parameters real(kind=FP), public :: RVar (NR) number of real parameters integer(kind=IP), public :: IVar (NI) number of integer parameters logical, public :: LVar (NL) number of logical parameters Source Code TYPE SaveVar ( NR , NI , NL ) !! a saved variable type used to modernize legacy code INTEGER ( KIND = IP ), LEN :: NR , NI , NL !! number of real, integer and logical parameters REAL ( KIND = FP ) :: RVar ( NR ) !! number of real parameters INTEGER ( KIND = IP ) :: IVar ( NI ) !! number of integer parameters LOGICAL :: LVar ( NL ) !! number of logical parameters END TYPE SaveVar","tags":"","loc":"type\\savevar.html"},{"title":"Container – FortCharConv ","text":"type, public, BIND(C) :: Container container type that utilize 'c' pointer (C_PTR) type Components Type Visibility Attributes Name Initial type(C_PTR), public :: Store = C_NULL_PTR Source Code TYPE , BIND ( C ) :: Container !! container type that utilize 'c' pointer (C_PTR) type TYPE ( C_PTR ) :: Store = C_NULL_PTR END TYPE Container","tags":"","loc":"type\\container.html"},{"title":"SInt128 – FortCharConv ","text":"type, public :: SInt128 a 128-bit signed integer type where the base of its components is 2**64. Components Type Visibility Attributes Name Initial integer(kind=I8B), public :: High upper 64 bits treated as signed integer integer(kind=I8B), public :: Low lower 64 bits treated as unsigned integer Constructor public        interface SInt128 Constructor Interface : SInt128 Purpose :  To construct a 128-bit signed integer from\n  other Fortran intrinsic types or 32- and 64-bit unsigned integers Usage : --->    I128 = SInt128(IntrinsicType)   ! constructor for Fortran intrinsic types --->    I128 = SInt128(UType, Negative) ! 32- and 64-bit unsigned integers where I128 has negative value if 'Negative' is true Note :  The different between 32-bit signed (I32) and unsigned (U32) integer types\n            is that I32 is treated as signed while U32 is treated as unsigned although\n            both are actually the 32-bit Fortran intrinsic integer type. private  function I32_To_I128(I32) result(I128) To convert a signed 32-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I32 number treated as signed Return Value type( SInt128 ) private  function I64_To_I128(I64) result(I128) To convert a signed 64-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: I64 number treated as signed Return Value type( SInt128 ) private  function U32_To_I128(U32, Negative) result(I128) To convert an unsigned 32-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: U32 number treated as unsigned logical, intent(in) :: Negative true if the 128-bit integer value is negative otherwise, the 128-bit integer value is positive Return Value type( SInt128 ) private  function U64_To_I128(U64, Negative) result(I128) To convert an unsigned 64-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: U64 number treated as unsigned logical, intent(in) :: Negative true if the 128-bit integer value is negative otherwise, the 128-bit integer value is positive Return Value type( SInt128 ) private  function R32_To_I128(R32) result(I128) To convert a 32-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: R32 Return Value type( SInt128 ) private  function R64_To_I128(R64) result(I128) To convert a 64-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: R64 Return Value type( SInt128 ) private  function R128_To_I128(R128) result(I128) To convert a 128-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: R128 Return Value type( SInt128 ) private  function DecString_To_I128(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a signed 128-bit integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( SInt128 ) number Source Code TYPE SInt128 INTEGER ( KIND = I8B ) :: High !! upper 64 bits treated as signed integer INTEGER ( KIND = I8B ) :: Low !! lower 64 bits treated as unsigned integer END TYPE SInt128","tags":"","loc":"type\\sint128.html"},{"title":"UInt128 – FortCharConv ","text":"type, public :: UInt128 a 128-bit unsigned integer type where the base of its components is 2**64. Components Type Visibility Attributes Name Initial integer(kind=I8B), public :: High upper 64 bits treated as unsigned integer integer(kind=I8B), public :: Low lower 64 bits treated as unsigned integer Constructor public        interface UInt128 Constructor Interface : UInt128 Purpose :  To construct a 128-bit unsigned integer from\n  other Fortran intrinsic types Usage : --->    U128 = UInt128(OtherType) private  function I32_To_U128(I32, AsUnsigned) result(U128) To convert a signed 32-bit integer number to an unsigned 128-bit integer number\n or to convert an unsigned 32-bit integer number to an unsigned 128-bit integer\n number if the specified flag is present and true. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I32 number treated as signed (default) logical, intent(in), optional :: AsUnsigned if present and true, number treated as unsigned Return Value type( UInt128 ) private  function I64_To_U128(I64, AsUnsigned) result(U128) To convert a signed 64-bit integer number to an unsigned 128-bit integer number\nor to convert an unsigned 64-bit integer number to an unsigned 128-bit integer\nnumber if the specified flag is present and true. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: I64 number treated as signed (default) logical, intent(in), optional :: AsUnsigned if present and true, number treated as unsigned Return Value type( UInt128 ) private  function R32_To_U128(R32) result(U128) To convert a 32-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: R32 Return Value type( UInt128 ) private  function R64_To_U128(R64) result(U128) To convert a 64-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: R64 Return Value type( UInt128 ) private  function R128_To_U128(R128) result(U128) To convert a 128-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: R128 Return Value type( UInt128 ) private  function DecString_To_U128(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an unsigned 128-bit integer value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( UInt128 ) number Source Code TYPE UInt128 INTEGER ( KIND = I8B ) :: High !! upper 64 bits treated as unsigned integer INTEGER ( KIND = I8B ) :: Low !! lower 64 bits treated as unsigned integer END TYPE UInt128","tags":"","loc":"type\\uint128.html"},{"title":"I32_ToChar_Basic – FortCharConv","text":"public  function I32_ToChar_Basic(Number) result(cStr) To convert a 32-bit integer to a decimal string using basic (naive) algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I32_ToChar_Basic ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using basic (naive) algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 INTEGER ( KIND = I4B ), PARAMETER :: Base = 10 CHARACTER ( LEN = 1 ), PARAMETER :: NumStr ( 0 : 9 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I4B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I4B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I4B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0 ) THEN cStr = '0' RETURN END IF IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = PosNum / Base ! compute the remainder RemNum = CurNum - PosNum * Base ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0 ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0 ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I32_ToChar_Basic","tags":"","loc":"proc\\i32_tochar_basic.html"},{"title":"I32_ToChar_CC – FortCharConv","text":"public  function I32_ToChar_CC(Number) result(cStr) To convert a 32-bit integer to a decimal string using CC algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I32_ToChar_CC ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using CC algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I4B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I4B ) :: NxtNum ! next round of positive number INTEGER ( KIND = I4B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Start , Finish !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 10000 ) THEN Start = 1 IF ( PosNum < 100 ) THEN wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 IF ( wStr ( Start : Start ) == '0' ) Start = 2 ELSE wStr ( 1 : 4 ) = Char4Digits ( PosNum ) Finish = 4 IF ( wStr ( Start : Start ) == '0' ) Start = 2 END IF ELSE ! compute the next round of working number NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! NxtNum = PosNum/10000 ! compute the remainder RemNum = PosNum - NxtNum * Divisor ! RemNum = MOD(PosNum, 10000) ! convert the remainder to a working string wStr ( 7 : 10 ) = Char4Digits ( RemNum ) Finish = 10 PosNum = NxtNum IF ( PosNum < 10000 ) THEN IF ( PosNum < 100 ) THEN wStr ( 5 : 6 ) = Char2Digits ( PosNum ) Start = 5 IF ( wStr ( Start : Start ) == '0' ) Start = 6 ELSE wStr ( 3 : 6 ) = Char4Digits ( PosNum ) Start = 3 IF ( wStr ( Start : Start ) == '0' ) Start = 4 END IF ELSE ! compute the next round of working number NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! NxtNum = PosNum/10000 ! compute the remainder RemNum = PosNum - NxtNum * Divisor ! RemNum = MOD(PosNum, 10000) ! convert the remainder to a working string wStr ( 3 : 6 ) = Char4Digits ( RemNum ) IF ( NxtNum > 0 ) THEN IF ( NxtNum < 10 ) THEN wStr ( 2 : 2 ) = Char2Digits ( NxtNum )( 2 : 2 ) Start = 2 ELSE wStr ( 1 : 2 ) = Char2Digits ( NxtNum ) Start = 1 END IF ELSE Start = 3 END IF END IF END IF IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_CC","tags":"","loc":"proc\\i32_tochar_cc.html"},{"title":"I32_ToChar_YY – FortCharConv","text":"public  function I32_ToChar_YY(Number) result(cStr) To convert a 32-bit integer to a decimal string using YY algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I32_ToChar_YY ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using YY algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I4B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I4B ) :: AA , BB , CC , DD INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD INTEGER ( KIND = I4B ) :: AABBCC , DDEE , EE !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100 ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 10000 ) THEN ! 3-4 digits AA = INT ( SHIFTR ( PosNum * 5243 , 19 ), KIND = I4B ) ! PosNum / 100 BB = PosNum - AA * 100 ! MOD(PosNum, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) Finish = 4 ELSEIF ( PosNum < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( PosNum * 429497_I8B , 32 ), KIND = I4B ) ! PosNum / 10000 BBCC = PosNum - AA * 10000 ! MOD(PosNum, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) Finish = 6 ELSEIF ( PosNum < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( PosNum * 109951163_I8B , 40 ), KIND = I4B ) ! PosNum / 10000 CCDD = PosNum - AABB * 10000 ! MOD(PosNum, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) wStr ( 7 : 8 ) = Char2Digits ( DD ) Finish = 8 ELSE ! 9-10 digits AABBCC = INT ( SHIFTR ( PosNum * 3518437209_I8B , 45 ), KIND = I4B ) ! PosNum / 10000 AA = INT ( SHIFTR ( AABBCC * 429497_I8B , 32 ), KIND = I4B ) ! aabbcc / 10000 DDEE = PosNum - AABBCC * 10000 ! MOD(PosNum, 10000) BBCC = AABBCC - AA * 10000 ! MOD(aabbcc, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! bbcc / 100 DD = SHIFTR ( DDEE * 5243 , 19 ) ! ddee / 100 CC = BBCC - BB * 100 ! MOD(bbcc, 100) EE = DDEE - DD * 100 ! MOD(ddee, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) wStr ( 7 : 8 ) = Char2Digits ( DD ) wStr ( 9 : 10 ) = Char2Digits ( EE ) Finish = 10 END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_YY","tags":"","loc":"proc\\i32_tochar_yy.html"},{"title":"I32_ToChar_YYLL – FortCharConv","text":"public  function I32_ToChar_YYLL(Number) result(cStr) To convert a 32-bit integer to a decimal string using YY algorithm with large table Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I32_ToChar_YYLL ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using YY algorithm with large table IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I4B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I4B ) :: AA INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD INTEGER ( KIND = I4B ) :: BBCCDDEE , DDEE !** FLOW ! set positive number PosNum = ABS ( Number ) Start = 1 ! start the conversion IF ( PosNum < 10000 ) THEN ! 1-4 digits wStr ( 1 : 4 ) = Char4Digits ( PosNum ) IF ( wStr ( 1 : 1 ) == '0' ) THEN Start = 2 IF ( wStr ( 2 : 2 ) == '0' ) THEN Start = 3 IF ( wStr ( 3 : 3 ) == '0' ) THEN Start = 4 END IF END IF END IF Finish = 4 ELSEIF ( PosNum < 100000000 ) THEN ! 5-8 digits AABB = INT ( SHIFTR ( PosNum * 109951163_I8B , 40 ), KIND = I4B ) ! PosNum / 10000 CCDD = PosNum - AABB * 10000 ! MOD(PosNum, 10000) wStr ( 1 : 4 ) = Char4Digits ( AABB ) wStr ( 5 : 8 ) = Char4Digits ( CCDD ) IF ( wStr ( 1 : 1 ) == '0' ) THEN Start = 2 IF ( wStr ( 2 : 2 ) == '0' ) THEN Start = 3 IF ( wStr ( 3 : 3 ) == '0' ) THEN Start = 4 END IF END IF END IF Finish = 8 ELSE ! 9-10 digits AA = INT ( SHIFTR ( PosNum * 1441151881_I8B , 57 ), KIND = I4B ) ! PosNum / 100000000 BBCCDDEE = PosNum - AA * 100000000 ! MOD(PosNum, 100000000) BBCC = INT ( SHIFTR ( BBCCDDEE * 109951163_I8B , 40 ), KIND = I4B ) ! BBCCDDEE / 10000 DDEE = BBCCDDEE - BBCC * 10000 ! MOD(BBCCDDEE, 10000) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 6 ) = Char4Digits ( BBCC ) wStr ( 7 : 10 ) = Char4Digits ( DDEE ) IF ( wStr ( 1 : 1 ) == '0' ) THEN Start = 2 END IF Finish = 10 END IF IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_YYLL","tags":"","loc":"proc\\i32_tochar_yyll.html"},{"title":"I32_ToChar_JEA – FortCharConv","text":"public  function I32_ToChar_JEA(Number) result(cStr) To convert a 32-bit integer to a decimal string using JEA algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I32_ToChar_JEA ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using JEA algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 REAL ( KIND = QP ), PARAMETER :: R1 = 1.0_QP REAL ( KIND = QP ), PARAMETER :: R2 = 2.0_QP INTEGER ( KIND = I8B ), PARAMETER :: K24 = INT ( R2 ** 24 / 1.0E2_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K32 = INT ( R2 ** 32 / 1.0E4_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K48 = INT ( R2 ** 48 / 1.0E6_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K57 = INT ( R2 ** 57 / 1.0E8_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M24 = SHIFTL ( 1_I8B , 24 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M32 = SHIFTL ( 1_I8B , 32 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M57 = SHIFTL ( 1_I8B , 57 ) - 1_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I8B ) :: F0 , F2 , F4 , F6 , F8 !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 10000_I8B ) THEN ! 3-4 digits F0 = K24 * PosNum F2 = IAND ( F0 , M24 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 24 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 24 )) Finish = 4 ELSEIF ( PosNum < 1000000_I8B ) THEN ! 5-6 digits F0 = K32 * PosNum F2 = IAND ( F0 , M32 ) * 100_I8B F4 = IAND ( F2 , M32 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 32 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 32 )) wStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 32 )) Finish = 6 ELSEIF ( PosNum < 100000000_I8B ) THEN ! 7-8 digits F0 = SHIFTR ( K48 * PosNum , 16 ) F2 = IAND ( F0 , M32 ) * 100_I8B F4 = IAND ( F2 , M32 ) * 100_I8B F6 = IAND ( F4 , M32 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 32 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 32 )) wStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 32 )) wStr ( 7 : 8 ) = Char2Digits ( SHIFTR ( F6 , 32 )) Finish = 8 ELSE ! 9-10 digits F0 = K57 * PosNum F2 = IAND ( F0 , M57 ) * 100_I8B F4 = IAND ( F2 , M57 ) * 100_I8B F6 = IAND ( F4 , M57 ) * 100_I8B F8 = IAND ( F6 , M57 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 57 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 57 )) wStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 57 )) wStr ( 7 : 8 ) = Char2Digits ( SHIFTR ( F6 , 57 )) wStr ( 9 : 10 ) = Char2Digits ( SHIFTR ( F8 , 57 )) Finish = 10 END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_JEA","tags":"","loc":"proc\\i32_tochar_jea.html"},{"title":"I64_ToChar_Basic – FortCharConv","text":"public  function I64_ToChar_Basic(Number) result(cStr) To convert a 64-bit integer to a decimal string using basic (naive) algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I64_ToChar_Basic ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using basic (naive) algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 19 INTEGER ( KIND = I8B ), PARAMETER :: Base = 10_I8B CHARACTER ( LEN = 1 ), PARAMETER :: NumStr ( 0 : 9 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I8B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I8B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I8B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0_I8B ) THEN cStr = '0' RETURN END IF IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = PosNum / Base ! compute the remainder RemNum = CurNum - PosNum * Base ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0_I8B ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0_I8B ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I64_ToChar_Basic","tags":"","loc":"proc\\i64_tochar_basic.html"},{"title":"I64_ToChar_CC – FortCharConv","text":"public  function I64_ToChar_CC(Number) result(cStr) To convert a 64-bit integer to a decimal string using CC algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I64_ToChar_CC ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using CC algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 19 INTEGER ( KIND = I8B ), PARAMETER :: Div1E8 = 100000000_I8B ! multiplier and shift for 19 digits and divisor of 1.0E8 INTEGER ( KIND = I8B ), PARAMETER :: M90 = INT ( Z 'ABCC77118461CEFD' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: S90 = 90 - 64 ! multiplier for 11 digits and divisor of 1.0E8 INTEGER ( KIND = I8B ), PARAMETER :: M64 = INT ( Z '0000002AF31DC462' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I8B ) :: NxtNum , RemNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 1000000000_I8B ) THEN ! utilize I32_ToChar_CC routine cStr = I32_ToChar_CC ( INT ( Number , KIND = I4B )) RETURN ELSE ! compute NxtNum = PosNum/100000000 NxtNum = SHIFTR ( U128_Multiply_High ( PosNum , M90 ), S90 ) ! compute RemNum = MOD(PosNum, 100000000) RemNum = PosNum - NxtNum * Div1E8 ! convert the remainder to a working string CALL Write_8_Digits ( INT ( RemNum , KIND = I4B ), wStr ( 12 : 19 )) PosNum = NxtNum IF ( PosNum > Div1E8 ) THEN ! compute NxtNum = PosNum/100000000 NxtNum = U128_Multiply_High ( PosNum , M64 ) ! compute RemNum = MOD(PosNum, 100000000) RemNum = PosNum - NxtNum * Div1E8 ! convert the remainder to a working string CALL Write_8_Digits ( INT ( RemNum , KIND = I4B ), wStr ( 4 : 11 )) ! convert the rest IF ( NxtNum < 10 ) THEN wStr ( 3 : 3 ) = Char2Digits ( NxtNum )( 2 : 2 ) Start = 3 ELSEIF ( NxtNum < 100 ) THEN wStr ( 2 : 3 ) = Char2Digits ( NxtNum ) Start = 2 ELSE wStr ( 1 : 3 ) = Char4Digits ( NxtNum )( 2 : 4 ) Start = 1 END IF ELSE ! convert the rest Start = 3 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 4 : 11 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: ! multiplier and shift for 4-byte integer and divisor of 10000 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosNum , NxtNum , RemNum !** FLOW ! set working number PosNum = Number ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = PosNum - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) ! convert the rest cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE PARAMETER DECLARATIONS: ! multiplier and shift for 4-byte integer and divisor of 10000 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosNum , NxtNum , RemNum !** FLOW PosNum = Number IF ( PosNum < 10000 ) THEN IF ( PosNum < 100 ) THEN cStr ( 7 : 8 ) = Char2Digits ( PosNum ) Start = 7 IF ( cStr ( Start : Start ) == '0' ) Start = 8 ELSE cStr ( 5 : 8 ) = Char4Digits ( PosNum ) Start = 5 IF ( cStr ( Start : Start ) == '0' ) Start = 6 END IF ELSE ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = PosNum - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) IF ( NxtNum < 100 ) THEN cStr ( 3 : 4 ) = Char2Digits ( NxtNum ) Start = 3 IF ( cStr ( Start : Start ) == '0' ) Start = 4 ELSE cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) Start = 2 END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** END FUNCTION I64_ToChar_CC","tags":"","loc":"proc\\i64_tochar_cc.html"},{"title":"I64_ToChar_YY – FortCharConv","text":"public  function I64_ToChar_YY(Number) result(cStr) To convert a 64-bit integer to a decimal string using YY algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I64_ToChar_YY ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using YY algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum , TmpNum , HiNum , LoNum , MidNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start conversion and store digits in working string IF ( PosNum < 100000000_I8B ) THEN ! 1-8 digits Start = 12 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 13 : 20 )) ELSEIF ( PosNum < 10000000000000000_I8B ) THEN ! 9-16 digits HiNum = PosNum / 100000000_I8B LoNum = PosNum - HiNum * 100000000_I8B ! MOD(PosNum, 100000000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) Start = 4 + Write_1_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 5 : 12 )) ELSE ! 17-20 digits TmpNum = PosNum / 100000000_I8B LoNum = PosNum - TmpNum * 100000000_I8B ! MOD(PosNum, 100000000) HiNum = TmpNum / 10000_I8B MidNum = TmpNum - HiNum * 10000_I8B ! MOD(TmpNum, 10000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) CALL Write_4_Digits ( INT ( MidNum , KIND = I4B ), wStr ( 9 : 12 )) Start = Write_5_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 1 : 8 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB ! working indices !** FLOW AA = SHIFTR ( Number * 5243 , 19 ) ! Number / 100 BB = Number - AA * 100 ! MOD(Number, 100) cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD ! working variables !** FLOW IF ( Number < 100 ) THEN ! 1-2 digits AA = Number IF ( AA < 10 ) THEN cStr ( 8 : 8 ) = Char2Digits ( AA )( 2 : 2 ) Start = 8 ELSE cStr ( 7 : 8 ) = Char2Digits ( AA ) Start = 7 END IF ELSEIF ( Number < 10000 ) THEN ! 3-4 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 5243_I8B , 19 ), KIND = I4B ) ! Number / 100 BB = Number - AA * 100 ! MOD(Number, 100) IF ( AA < 10 ) THEN cStr ( 6 : 6 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 7 : 8 ) = Char2Digits ( BB ) Start = 6 ELSE cStr ( 5 : 6 ) = Char2Digits ( AA ) cStr ( 7 : 8 ) = Char2Digits ( BB ) Start = 5 END IF ELSEIF ( Number < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 429497_I8B , 32 ), KIND = I4B ) ! Number / 10000 BBCC = Number - AA * 10000 ! MOD(Number, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) IF ( AA < 10 ) THEN cStr ( 4 : 4 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 4 ELSE cStr ( 3 : 4 ) = Char2Digits ( AA ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 3 END IF ELSEIF ( Number < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) IF ( AA < 10 ) THEN cStr ( 2 : 2 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 2 ELSE cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 1 END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** FUNCTION Write_5_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_5_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 5 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD ! working variables !** FLOW IF ( Number < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 429497_I8B , 32 ), KIND = I4B ) ! Number / 10000 BBCC = Number - AA * 10000 ! MOD(Number, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) IF ( AA < 10 ) THEN cStr ( 4 : 4 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 4 ELSE cStr ( 3 : 4 ) = Char2Digits ( AA ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 3 END IF ELSEIF ( Number < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) IF ( AA < 10 ) THEN cStr ( 2 : 2 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 2 ELSE cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 1 END IF END IF RETURN END FUNCTION Write_5_to_8_Digits !************************************************************************** END FUNCTION I64_ToChar_YY","tags":"","loc":"proc\\i64_tochar_yy.html"},{"title":"I64_ToChar_YYLL – FortCharConv","text":"public  function I64_ToChar_YYLL(Number) result(cStr) To convert a 64-bit integer to a decimal string using YY algorithm with large table Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I64_ToChar_YYLL ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using YY algorithm with large table IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum , TmpNum , HiNum , LoNum , MidNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start conversion and store digits in working string IF ( PosNum < 100000000_I8B ) THEN ! 1-8 digits Start = 12 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 13 : 20 )) ELSEIF ( PosNum < 10000000000000000_I8B ) THEN ! 9-16 digits HiNum = PosNum / 100000000_I8B LoNum = PosNum - HiNum * 100000000_I8B ! MOD(PosNum, 100000000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) Start = 4 + Write_1_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 5 : 12 )) ELSE ! 17-20 digits TmpNum = PosNum / 100000000_I8B LoNum = PosNum - TmpNum * 100000000_I8B ! MOD(PosNum, 100000000) HiNum = TmpNum / 10000_I8B MidNum = TmpNum - HiNum * 10000_I8B ! MOD(TmpNum, 10000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) CALL Write_4_Digits ( INT ( MidNum , KIND = I4B ), wStr ( 9 : 12 )) Start = Write_5_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 1 : 8 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW cStr ( 1 : 4 ) = Char4Digits ( Number ) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD !** FLOW IF ( Number < 10000 ) THEN ! 1-4 digits cStr ( 5 : 8 ) = Char4Digits ( Number ) Start = 5 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 6 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 7 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 8 END IF END IF END IF ELSE ! 5-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 2 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 3 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 4 END IF END IF END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** FUNCTION Write_5_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_5_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 5 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 2 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 3 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 4 END IF END IF END IF RETURN END FUNCTION Write_5_to_8_Digits !************************************************************************** END FUNCTION I64_ToChar_YYLL","tags":"","loc":"proc\\i64_tochar_yyll.html"},{"title":"I64_ToChar_JEA – FortCharConv","text":"public  function I64_ToChar_JEA(Number) result(cStr) To convert a 64-bit integer to a decimal string using JEA algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Source Code FUNCTION I64_ToChar_JEA ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using JEA algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 REAL ( KIND = QP ), PARAMETER :: R1 = 1.0_QP REAL ( KIND = QP ), PARAMETER :: R2 = 2.0_QP INTEGER ( KIND = I8B ), PARAMETER :: K24 = INT ( R2 ** 24 / 1.0E2_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K32 = INT ( R2 ** 32 / 1.0E4_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K48 = INT ( R2 ** 48 / 1.0E6_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K57 = INT ( R2 ** 57 / 1.0E8_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M24 = SHIFTL ( 1_I8B , 24 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M32 = SHIFTL ( 1_I8B , 32 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M57 = SHIFTL ( 1_I8B , 57 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: MaxU32 = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) !  4,294,967,296 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I8B ) :: F0 , F2 , F4 , F6 , F8 INTEGER ( KIND = I8B ) :: Z , Y !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 1000000_I8B ) THEN ! 3-6 digits IF ( PosNum < 10000_I8B ) THEN ! 3-4 digits CALL Write_4_Digits ( PosNum , wStr ( 1 : 4 )) Finish = 4 ELSE ! 5-6 digits CALL Write_6_Digits ( PosNum , wStr ( 1 : 6 )) Finish = 6 END IF ELSEIF ( PosNum < MaxU32 ) THEN ! 7-10 digits IF ( PosNum < 100000000_I8B ) THEN ! 7-8 digits CALL Write_8_Digits ( PosNum , wStr ( 1 : 8 )) Finish = 8 ELSE ! 9-10 digits CALL Write_10_Digits ( PosNum , wStr ( 1 : 10 )) Finish = 10 END IF ELSE Z = MOD ( PosNum , 100000000_I8B ) PosNum = PosNum / 100000000_I8B IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Start = 3 ELSEIF ( PosNum < 1000000_I8B ) THEN ! 3-6 digits IF ( PosNum < 10000_I8B ) THEN ! 3-4 digits CALL Write_4_Digits ( PosNum , wStr ( 1 : 4 )) Start = 5 ELSE ! 5-6 digits CALL Write_6_Digits ( PosNum , wStr ( 1 : 6 )) Start = 7 END IF ELSEIF ( PosNum < 100000000_I8B ) THEN ! 7-8 digits CALL Write_8_Digits ( PosNum , wStr ( 1 : 8 )) Start = 9 ELSEIF ( PosNum < MaxU32 ) THEN ! 9-10 digits CALL Write_10_Digits ( PosNum , wStr ( 1 : 10 )) Start = 11 ELSE Y = MOD ( PosNum , 100000000_I8B ) PosNum = PosNum / 100000000_I8B ! n is 2, 3, or 4 digits (if n < 10 it would have been handled above) IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Start = 3 ELSE F0 = K24 * PosNum F2 = IAND ( F0 , M24 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 24 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 24 )) Start = 5 END IF ! do 8 digits Finish = Start + 7 CALL Write_8_Digits ( Y , wStr ( Start : Finish )) Start = Finish + 1 END IF ! do 8 digits Finish = Start + 7 CALL Write_8_Digits ( Z , wStr ( Start : Finish )) END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN CONTAINS SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F0 = K24 * Number F2 = IAND ( F0 , M24 ) * 100_I8B cStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 24 )) cStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 24 )) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** SUBROUTINE Write_6_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_6_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 6 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F0 = K32 * Number F2 = IAND ( F0 , M32 ) * 100_I8B F4 = IAND ( F2 , M32 ) * 100_I8B cStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 32 )) cStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 32 )) cStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 32 )) RETURN END SUBROUTINE Write_6_Digits !************************************************************************** SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( Number * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = INT ( Number - AABB * 10000 , KIND = I4B ) ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) ! Note: the following statements (original code by JEA algorithm) !       do not write correct numbers sometimes !        F0 = SHIFTR(K48*Number, 16) !        F2 = IAND(F0, M32)*100_I8B !        F4 = IAND(F2, M32)*100_I8B !        F6 = IAND(F4, M32)*100_I8B !        cStr(1:2) = Char2Digits(SHIFTR(F0, 32)) !        cStr(3:4) = Char2Digits(SHIFTR(F2, 32)) !        cStr(5:6) = Char2Digits(SHIFTR(F4, 32)) !        cStr(7:8) = Char2Digits(SHIFTR(F6, 32)) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_10_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_10_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F0 = K57 * Number F2 = IAND ( F0 , M57 ) * 100_I8B F4 = IAND ( F2 , M57 ) * 100_I8B F6 = IAND ( F4 , M57 ) * 100_I8B F8 = IAND ( F6 , M57 ) * 100_I8B cStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 57 )) cStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 57 )) cStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 57 )) cStr ( 7 : 8 ) = Char2Digits ( SHIFTR ( F6 , 57 )) cStr ( 9 : 10 ) = Char2Digits ( SHIFTR ( F8 , 57 )) RETURN END SUBROUTINE Write_10_Digits !************************************************************************** END FUNCTION I64_ToChar_JEA","tags":"","loc":"proc\\i64_tochar_jea.html"},{"title":"RealDP_ToString_DragonBox – FortCharConv","text":"public  function RealDP_ToString_DragonBox(Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character (decimal) string\nusing the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string Source Code FUNCTION RealDP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a double-precision floating-point value to a character (decimal) string ! using the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I8B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = DP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I8B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I8B )) THEN ! zero SigDec = 0_I8B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealDP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealDP_ToString_DragonBox","tags":"","loc":"proc\\realdp_tostring_dragonbox.html"},{"title":"RealDP_ToString_Ryu – FortCharConv","text":"public  function RealDP_ToString_Ryu(Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character (decimal) string\nusing the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string Source Code FUNCTION RealDP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a double-precision floating-point value to a character (decimal) string ! using the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I8B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = DP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I8B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I8B )) THEN ! zero SigDec = 0_I8B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealDP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealDP_ToString_Ryu","tags":"","loc":"proc\\realdp_tostring_ryu.html"},{"title":"RealDP_ToString_Schubfach – FortCharConv","text":"public  function RealDP_ToString_Schubfach(Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character (decimal) string\nusing the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string Source Code FUNCTION RealDP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a double-precision floating-point value to a character (decimal) string ! using the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I8B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = DP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I8B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I8B )) THEN ! zero SigDec = 0_I8B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealDP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealDP_ToString_Schubfach","tags":"","loc":"proc\\realdp_tostring_schubfach.html"},{"title":"RealDP_FromString_FastFloat – FortCharConv","text":"public  function RealDP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number Source Code FUNCTION RealDP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the FastFloat algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using FastFloat algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , Aux % Truncated , Aux % Indices , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_FastFloat","tags":"","loc":"proc\\realdp_fromstring_fastfloat.html"},{"title":"RealDP_FromString_LibC – FortCharConv","text":"public  function RealDP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the LibC algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number Source Code FUNCTION RealDP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the LibC algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using LibC algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_LibC ( SigDec , ExpDec , cStr , Aux % Start , Aux % Truncated , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_LibC","tags":"","loc":"proc\\realdp_fromstring_libc.html"},{"title":"RealDP_FromString_YY – FortCharConv","text":"public  function RealDP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the YY algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number Source Code FUNCTION RealDP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the YY algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using YY's algorithm +++ RawVal = Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_YY","tags":"","loc":"proc\\realdp_fromstring_yy.html"},{"title":"RealDP_FromString_Lemire – FortCharConv","text":"public  function RealDP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number Source Code FUNCTION RealDP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the Lemire algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using Lemire's algorithm +++ RawVal = Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_Lemire","tags":"","loc":"proc\\realdp_fromstring_lemire.html"},{"title":"I32_FromChar – FortCharConv","text":"public  function I32_FromChar(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number Source Code FUNCTION I32_FromChar ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to an integer value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxDigit = 10 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF END IF ! check for leading zero(s) Number = 0 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigit ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigit ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MIN_I32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MAX_I32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MIN_I32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar","tags":"","loc":"proc\\i32_fromchar.html"},{"title":"I64_FromChar – FortCharConv","text":"public  function I64_FromChar(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number Source Code FUNCTION I64_FromChar ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to an integer value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxDigit = 19 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I8B ), PARAMETER :: LBase = 10_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigit ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigit ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MIN_I64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MAX_I64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MIN_I64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar","tags":"","loc":"proc\\i64_fromchar.html"},{"title":"Compare – FortCharConv","text":"public interface Compare Function Interface : Compare Purpose :  To compare two signed integers of the same kind and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething Module Procedures private pure function I8_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function I16_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function I32_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function I64_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value integer(kind=I4B)","tags":"","loc":"interface\\compare.html"},{"title":"HighestOneBit – FortCharConv","text":"public interface HighestOneBit Function Interface : HighestOneBit Purpose :  To return an integer value (same kind as the specified integer value) with at most a single one-bit, in the position of the highest-order (leftmost) one-bit in the input. Usage : --->    OUTPUT = HighestOneBit(INPUT) Module Procedures private pure function I32_HighestOneBit(InVal) result(OutVal) To return an 32-bit integer value with at most a single one-bit, in the\nposition of the highest-order (leftmost) one-bit in the specified\n32-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_HighestOneBit(InVal) result(OutVal) To return an 64-bit integer value with at most a single one-bit, in the\nposition of the highest-order (leftmost) one-bit in the specified\n64-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B)","tags":"","loc":"interface\\highestonebit.html"},{"title":"LowestOneBit – FortCharConv","text":"public interface LowestOneBit Function Interface : LowestOneBit Purpose :  To return an integer value (same kind as the specified integer value) with at most a single one-bit, in the position of the lowest-order (rightmost) one-bit in the input. Usage : --->    OUTPUT = LowestOneBit(INPUT) Module Procedures private pure function I32_LowestOneBit(InVal) result(OutVal) To return an 32-bit integer value with at most a single one-bit, in the\nposition of the lowest-order (rightmost) one-bit in the specified\n32-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_LowestOneBit(InVal) result(OutVal) To return an 64-bit integer value with at most a single one-bit, in the\nposition of the lowest-order (rightmost) one-bit in the specified\n64-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B)","tags":"","loc":"interface\\lowestonebit.html"},{"title":"ReverseBits – FortCharConv","text":"public interface ReverseBits Function Interface : ReverseBits Purpose :  To return an integer value (same kind as the specified integer value) obtained by reversing the order of the bits in the two's complement binary representation of the input. Usage : --->    OUTPUT = ReverseBits(INPUT) Module Procedures private pure function I32_ReverseBits(InVal) result(OutVal) To return an 32-bit integer value obtained by reversing the order of the\nbits in the two's complement binary representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_ReverseBits(InVal) result(OutVal) To return an 64-bit integer value obtained by reversing the order of the\nbits in the two's complement binary representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B)","tags":"","loc":"interface\\reversebits.html"},{"title":"ReverseBytes – FortCharConv","text":"public interface ReverseBytes Function Interface : ReverseBits Purpose :  To return an integer value (same kind as the specified integer value) obtained by reversing the order of the bytes in the two's complement binary representation of the input. Usage : --->    OUTPUT = ReverseBytes(INPUT) Module Procedures private pure function I32_ReverseBytes(InVal) result(OutVal) To return an 32-bit integer value obtained by reversing the order of the\nbytes in the two's complement representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_ReverseBytes(InVal) result(OutVal) To return an 64-bit integer value obtained by reversing the order of the\nbytes in the two's complement representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B)","tags":"","loc":"interface\\reversebytes.html"},{"title":"SigNum – FortCharConv","text":"public interface SigNum Function Interface : SigNum Purpose :  To return the sign of the specified input where the return value is -1 if the specified value is negative 0 if the specified value is zero 1 if the specified value is positive Usage : --->    SignFlag = SigNum(INPUT) Module Procedures private pure function I32_SigNum(Val) result(Sign) To return the sign of the specified input where the return value is -1 if the specified value is negative 0 if the specified value is zero 1 if the specified value is positive. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val Return Value integer(kind=I4B) private pure function I64_SigNum(Val) result(Sign) To return the sign of the specified input where the return value is -1 if the specified value is negative 0 if the specified value is zero 1 if the specified value is positive. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Val Return Value integer(kind=I4B)","tags":"","loc":"interface\\signum.html"},{"title":"ToHexStrSigned – FortCharConv","text":"public interface ToHexStrSigned Function Interface : ToHexStrSigned Purpose :  To convert a signed integer to a hexadecimal string Usage : --->    Str = ToHexStrSigned(I32) Module Procedures private pure function I32_ToHexString(Number) result(cStr) To convert a signed 32-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE private pure function I64_ToHexString(Number) result(cStr) To convert a signed 64-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\tohexstrsigned.html"},{"title":"ToDecStrSigned – FortCharConv","text":"public interface ToDecStrSigned Function Interface : ToDecStrSigned Purpose :  To convert a signed integer to a decimal string Usage : --->    Str = ToDecStrSigned(I64) Module Procedures private  function I32_ToDecString(Number) result(cStr) To convert an integer number to decimal string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE private  function I64_ToDecString(Number) result(cStr) To convert an integer number to decimal string Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\todecstrsigned.html"},{"title":"ASSIGNMENT(=) – FortCharConv","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a 128-bit signed integer and\n  other signed integers (32- and 64-bit integers) Usage : --->    I128 = OtherType Module Procedures private  subroutine I128_From_I32(I128, I32) To convert a signed 32-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(out) :: I128 integer(kind=I4B), intent(in) :: I32 number treated as signed private  subroutine I128_From_I64(I128, I64) To convert a signed 64-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(out) :: I128 integer(kind=I8B), intent(in) :: I64 number treated as signed private  subroutine I128_To_I32(I32, I128) To convert a signed 128-bit integer number to a signed 32-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(out) :: I32 number treated as signed type( SInt128 ), intent(in) :: I128 private  subroutine I128_To_I64(I64, I128) To convert a signed 128-bit integer number to a signed 64-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(out) :: I64 number treated as signed type( SInt128 ), intent(in) :: I128","tags":"","loc":"interface\\assignment(=).html"},{"title":"SInt128 – FortCharConv","text":"public interface SInt128 Constructor Interface : SInt128 Purpose :  To construct a 128-bit signed integer from\n  other Fortran intrinsic types or 32- and 64-bit unsigned integers Usage : --->    I128 = SInt128(IntrinsicType)   ! constructor for Fortran intrinsic types --->    I128 = SInt128(UType, Negative) ! 32- and 64-bit unsigned integers where I128 has negative value if 'Negative' is true Note :  The different between 32-bit signed (I32) and unsigned (U32) integer types\n            is that I32 is treated as signed while U32 is treated as unsigned although\n            both are actually the 32-bit Fortran intrinsic integer type. Module Procedures private  function I32_To_I128(I32) result(I128) To convert a signed 32-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I32 number treated as signed Return Value type( SInt128 ) private  function I64_To_I128(I64) result(I128) To convert a signed 64-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: I64 number treated as signed Return Value type( SInt128 ) private  function U32_To_I128(U32, Negative) result(I128) To convert an unsigned 32-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: U32 number treated as unsigned logical, intent(in) :: Negative true if the 128-bit integer value is negative otherwise, the 128-bit integer value is positive Return Value type( SInt128 ) private  function U64_To_I128(U64, Negative) result(I128) To convert an unsigned 64-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: U64 number treated as unsigned logical, intent(in) :: Negative true if the 128-bit integer value is negative otherwise, the 128-bit integer value is positive Return Value type( SInt128 ) private  function R32_To_I128(R32) result(I128) To convert a 32-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: R32 Return Value type( SInt128 ) private  function R64_To_I128(R64) result(I128) To convert a 64-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: R64 Return Value type( SInt128 ) private  function R128_To_I128(R128) result(I128) To convert a 128-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: R128 Return Value type( SInt128 ) private  function DecString_To_I128(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a signed 128-bit integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( SInt128 ) number","tags":"","loc":"interface\\sint128.html"},{"title":"ToU32 – FortCharConv","text":"public interface ToU32 Function Interface : ToU32 Purpose :  To convert a 128-bit signed integer to a \n  32-bit unsigned integer Usage : --->    U32 = ToU32(I128) Module Procedures private  function U32_From_I128(I128) result(U32) To convert a signed 128-bit integer number to an unsigned 32-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B) number treated as unsigned","tags":"","loc":"interface\\tou32.html"},{"title":"ToU64 – FortCharConv","text":"public interface ToU64 Function Interface : ToU64 Purpose :  To convert a 128-bit signed integer to a \n  64-bit unsigned integer Usage : --->    U64 = ToU64(I128) Module Procedures private  function U64_From_I128(I128) result(U64) To convert a signed 128-bit integer number to an unsigned 64-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I8B) number treated as unsigned","tags":"","loc":"interface\\tou64.html"},{"title":"ToU128 – FortCharConv","text":"public interface ToU128 Function Interface : ToU128 Purpose :  To convert a 128-bit signed integer to a \n  128-bit unsigned integer Usage : --->    U128 = ToU128(I128) Module Procedures private  function U128_From_I128(I128) result(U128) To convert a signed 128-bit integer to an unsigned 128-bit integer Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value type( UInt128 )","tags":"","loc":"interface\\tou128.html"},{"title":"ToR32 – FortCharConv","text":"public interface ToR32 Function Interface : ToR32 Purpose :  To convert a 128-bit signed integer to\n  a 32-bit floating point (real) number Usage : --->    R32 = ToR32(I128) Module Procedures private  function R32_From_I128(I128) result(R32) To convert a signed 128-bit integer number to a 32-bit floating point number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value real(kind=SP)","tags":"","loc":"interface\\tor32.html"},{"title":"ToR64 – FortCharConv","text":"public interface ToR64 Function Interface : ToR64 Purpose :  To convert a 128-bit signed integer to\n  a 64-bit floating point (real) number Usage : --->    R64 = ToR64(I128) Module Procedures private  function R64_From_I128(I128) result(R64) To convert a signed 128-bit integer number to a 64-bit floating point number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value real(kind=DP)","tags":"","loc":"interface\\tor64.html"},{"title":"ToR128 – FortCharConv","text":"public interface ToR128 Function Interface : ToR128 Purpose :  To convert a 128-bit signed integer to\n  a 128-bit floating point (real) number Usage : --->    R128 = ToR128(I128) Module Procedures private  function R128_From_I128(I128) result(R128) To convert a signed 128-bit integer number to a 128-bit floating point number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value real(kind=QP)","tags":"","loc":"interface\\tor128.html"},{"title":"ToDecString – FortCharConv","text":"public interface ToDecString Function Interface : ToDecString Purpose :  To convert a 128-bit signed integer to\n  a decimal string Usage : --->    Str = ToDecString(I128) Module Procedures private  function DecString_From_I128(I128) result(Str) To convert a signed 128-bit integer number to a decimal string Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\todecstring.html"},{"title":"ToHexString – FortCharConv","text":"public interface ToHexString Function Interface : ToHexString Purpose :  To convert a 128-bit signed integer to\n  a hexadecimal string Usage : --->    Str = ToHexString(I128) Module Procedures private  function HexString_From_I128(I128) result(Str) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\tohexstring.html"},{"title":"OPERATOR(==) – FortCharConv","text":"public interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two 128-bit signed integers are equal return .TRUE. if both values are equal; otherwise return .FALSE. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething Module Procedures private  function I128_Equal(LHS, RHS) result(Flag) To check whether two SInt128 objects are equal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(==).html"},{"title":"OPERATOR(/=) – FortCharConv","text":"public interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two 128-bit signed integers are not equal return .TRUE. if both values are NOT equal; otherwise return .FALSE. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething Module Procedures private  function I128_NotEqual(LHS, RHS) result(Flag) To check whether two SInt128 objects are NOT equal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(SLASH=).html"},{"title":"OPERATOR(<) – FortCharConv","text":"public interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value return .TRUE. if LHS < RHS; otherwise return .FALSE. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething Module Procedures private  function I128_LessThan(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is less than the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(lt).html"},{"title":"OPERATOR(<=) – FortCharConv","text":"public interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value return .TRUE. if LHS <= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething Module Procedures private  function I128_LessEqual(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is less than or equal to the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(lt=).html"},{"title":"OPERATOR(>) – FortCharConv","text":"public interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value return .TRUE. if LHS > RHS; otherwise return .FALSE. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething Module Procedures private  function I128_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is greater than the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(gt).html"},{"title":"OPERATOR(>=) – FortCharConv","text":"public interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value return .TRUE. if LHS >= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething Module Procedures private  function I128_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is greater than or equal to the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(gt=).html"},{"title":"Compare – FortCharConv","text":"public interface Compare Function Interface : Compare Purpose :  To compare two 128-bit signed integers and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething Module Procedures private  function I128_Compare(LHS, RHS) result(Flag) To compare LHS and RHS objects. -> return -1 if LHS < RHS -> return  0 if LHS == RHS -> return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value integer(kind=I4B)","tags":"","loc":"interface\\compare~2.html"},{"title":"OPERATOR(+) – FortCharConv","text":"public interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two signed integers\n  (at least one of which is a 128-bit signed integer) or\n  to add a unary plus sign to a 128-bit signed integer\n  (which has no effect on the signed integer) Usage : --->    OUTPUT = +INPUT --->    OUTPUT = FIRST_IN + SECOND_IN Module Procedures private  function I128_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the Sint128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) private  function I128_Plus_I128(LhsVal, RhsVal) result(OutVal) To perform addition of two SInt128 objects (Lhs + Rhs) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Plus_I32(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I32_Plus_I128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Plus_I64(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I64_Plus_I128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 )","tags":"","loc":"interface\\operator(+).html"},{"title":"OPERATOR(-) – FortCharConv","text":"public interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two signed integers\n  (at least one of which is a 128-bit signed integer) or\n  to perform a negation of a 128-bit signed integer Usage : --->    OUTPUT = -INPUT --->    OUTPUT = FIRST_IN - SECOND_IN Important Note :  For subtraction of signed integers (unlike unsigned one),\n  value of FIRST_IN can be less than SECOND_IN. Module Procedures private  function I128_Negate(InVal) result(OutVal) To negate the Uint128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) private  function I128_Minus_I128(LhsVal, RhsVal) result(OutVal) To perform subtraction of two SInt128 objects (Lhs - Rhs) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Minus_I32(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I32_Minus_I128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Minus_I64(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I64_Minus_I128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 )","tags":"","loc":"interface\\operator(-).html"},{"title":"OPERATOR(*) – FortCharConv","text":"public interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two signed integers (at least one of which is a 128-bit signed integer) Usage : --->    OUTPUT = FIRST_IN * SECOND_IN Module Procedures private  function I128_Multiply_I128(LhsVal, RhsVal) result(OutVal) To perform multiplication of two SInt128 objects (Lhs * Rhs) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Multiply_I32(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I32_Multiply_I128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Multiply_I64(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I64_Multiply_I128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 )","tags":"","loc":"interface\\operator(ASTERISK).html"},{"title":"OPERATOR(/) – FortCharConv","text":"public interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To return the quotient of a division of two signed integers,\n  where the dividend (numerator) is a 128-bit signed integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit signed integer Usage : --->    QUOT = NUMER / DENOM Module Procedures private  function I128_Divide_I32(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Divide_I64(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Divide_I128(Dividend, Divisor) result(Quotient) To perform division of two SInt128 objects (Dividend / Divisor) and\nand return the quotient Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend type( SInt128 ), intent(in) :: Divisor Return Value type( SInt128 )","tags":"","loc":"interface\\operator(SLASH).html"},{"title":"MOD – FortCharConv","text":"public interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two signed integers,\n  where the dividend (numerator) is a 128-bit signed integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit signed integer Usage : --->    REM = MOD(NUMER, DENOM) Module Procedures private  function I128_Mod_I32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Mod_I64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Mod_I128(Dividend, Divisor) result(Remainder) To perform division of two SInt128 objects (Dividend / Divisor)\nand return the remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend type( SInt128 ), intent(in) :: Divisor Return Value type( SInt128 )","tags":"","loc":"interface\\mod.html"},{"title":"DivMod – FortCharConv","text":"public interface DivMod Subroutine Interface : DivMod Purpose :  To perform a division of two signed integers (where the\n  dividend (numerator) is a 128-bit signed integer and the divisor\n  (denominator) can be 32-, 64- or 128-bit signed integer) and\n  to return both the quotient and the remainder Usage : --->    CALL DivMod(NUMER, DENOM, QUOT, REM) Module Procedures private  subroutine I128_DivMod_I32(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor and\nreturn both quotient and remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor type( SInt128 ), intent(out) :: Quotient type( SInt128 ), intent(out) :: Remainder private  subroutine I128_DivMod_I64(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor and\nreturn both quotient and remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor type( SInt128 ), intent(out) :: Quotient type( SInt128 ), intent(out) :: Remainder private  subroutine I128_DivMod_I128(Dividend, Divisor, Quotient, Remainder) To perform division of two SInt128 objects (Dividend / Divisor) and\nand return both the quotient and the remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend type( SInt128 ), intent(in) :: Divisor type( SInt128 ), intent(out) :: Quotient type( SInt128 ), intent(out) :: Remainder","tags":"","loc":"interface\\divmod.html"},{"title":"Increment – FortCharConv","text":"public interface Increment Subroutine Interface : Increment Purpose :  To increase value of a 128-bit signed integer by one Usage : --->    CALL Increment(I128) Module Procedures private  subroutine I128_Increment(Val) To increase value of the input by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: Val","tags":"","loc":"interface\\increment.html"},{"title":"Decrement – FortCharConv","text":"public interface Decrement Subroutine Interface : Decrement Purpose :  To decrease value of a 128-bit signed integer by one Usage : --->    CALL Decrement(I128) Module Procedures private  subroutine I128_Decrement(Val) To decrease value of the input by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: Val","tags":"","loc":"interface\\decrement.html"},{"title":"Add – FortCharConv","text":"public interface Add Subroutine Interface : Add Purpose :  To add a signed integer to a 128-bit signed integer Usage : --->    CALL Add(This, Other) Module Procedures private  subroutine I128_Add_I32(This, Other) To perform addition:  This = This + Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine I128_Add_I64(This, Other) To perform addition:  This = This + Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine I128_Add_I128(This, Other) To perform addition:  This = This + Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other","tags":"","loc":"interface\\add.html"},{"title":"Subtract – FortCharConv","text":"public interface Subtract Subroutine Interface : Subtract Purpose :  To subtract a signed integer from a 128-bit signed integer Usage : --->    CALL Subtract(This, Other) Important Note :  For subtraction of signed integers (unlike unsigned one),\n  value of This can be less than Other. Module Procedures private  subroutine I128_Subtract_I32(This, Other) To perform subtraction:  This = This - Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine I128_Subtract_I64(This, Other) To perform subtraction:  This = This - Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine I128_Subtract_I128(This, Other) To perform subtraction:  This = This - Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other","tags":"","loc":"interface\\subtract.html"},{"title":"Multiply – FortCharConv","text":"public interface Multiply Subroutine Interface : Multiply Purpose :  To multiply a 128-bit signed integer by a signed integer Usage : --->    CALL Multiply(This, Other) Module Procedures private  subroutine I128_Times_I32(This, Other) To perform multiplication:  This = This * Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine I128_Times_I64(This, Other) To perform multiplication:  This = This * Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine I128_Times_I128(This, Other) To perform multiplication:  This = This * Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other","tags":"","loc":"interface\\multiply.html"},{"title":"Divide – FortCharConv","text":"public interface Divide Subroutine Interface : Divide Purpose :  To divide a 128-bit signed integer by a signed integer Usage : --->    CALL Divide(This, Other) Module Procedures private  subroutine I128_Over_I32(This, Other, Remainder) To perform division:  This = This / Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other integer(kind=I4B), intent(out), optional :: Remainder private  subroutine I128_Over_I64(This, Other, Remainder) To perform division:  This = This / Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other integer(kind=I8B), intent(out), optional :: Remainder private  subroutine I128_Over_I128(This, Other, Remainder) To perform division:  This = This / Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other type( SInt128 ), intent(out), optional :: Remainder","tags":"","loc":"interface\\divide.html"},{"title":"ShiftLOnce – FortCharConv","text":"public interface ShiftLOnce Function Interface : ShiftLOnce Purpose :  To perform logical left shift by 1 Usage : --->    OUT = ShiftLOnce(IN) Module Procedures private  function I128_SHIFTL_Once(InVal) result(OutVal) To perform logical left shift by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\shiftlonce.html"},{"title":"ShiftROnce – FortCharConv","text":"public interface ShiftROnce Function Interface : ShiftROnce Purpose :  To perform logical right shift by 1 Usage : --->    OUT = ShiftROnce(IN) Module Procedures private  function I128_SHIFTR_Once(InVal) result(OutVal) To perform logical right shift by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\shiftronce.html"},{"title":"ShiftAOnce – FortCharConv","text":"public interface ShiftAOnce Function Interface : ShiftAOnce Purpose :  To perform arithmetic right shift by 1 Usage : --->    OUT = ShiftAOnce(IN) Module Procedures private  function I128_SHIFTA_Once(InVal) result(OutVal) To perform arithmetic right shift by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\shiftaonce.html"},{"title":"ShiftL64 – FortCharConv","text":"public interface ShiftL64 Function Interface : ShiftL64 Purpose :  To perform logical left shift by 64 Usage : --->    OUT = ShiftL64(IN) Module Procedures private  function I128_SHIFTL_64(InVal) result(OutVal) To perform logical left shift by 64 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\shiftl64.html"},{"title":"ShiftR64 – FortCharConv","text":"public interface ShiftR64 Function Interface : ShiftR64 Purpose :  To perform logical right shift by 64 Usage : --->    OUT = ShiftR64(IN) Module Procedures private  function I128_SHIFTR_64(InVal) result(OutVal) To perform logical right shift by 64 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\shiftr64.html"},{"title":"ShiftA64 – FortCharConv","text":"public interface ShiftA64 Function Interface : ShiftA64 Purpose :  To perform arithmetic right shift by 64 Usage : --->    OUT = ShiftA64(IN) Module Procedures private  function I128_SHIFTA_64(InVal) result(OutVal) To perform arithmetic right shift by 64 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\shifta64.html"},{"title":"ShiftL63Down – FortCharConv","text":"public interface ShiftL63Down Function Interface : ShiftL63Down Purpose :  To perform logical left shift by 63 or less Usage : --->    OUT = ShiftL63Down(IN, 11) Module Procedures private  function I128_SHIFTL_63Down(InVal, ShiftPos) result(OutVal) To perform logical left shift by 63 or less Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 )","tags":"","loc":"interface\\shiftl63down.html"},{"title":"ShiftR63Down – FortCharConv","text":"public interface ShiftR63Down Function Interface : ShiftR63Down Purpose :  To perform logical right shift by 63 or less Usage : --->    OUT = ShiftR63Down(IN, 53) Module Procedures private  function I128_SHIFTR_63Down(InVal, ShiftPos) result(OutVal) To perform logical right shift by 63 or less Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 )","tags":"","loc":"interface\\shiftr63down.html"},{"title":"ShiftA63Down – FortCharConv","text":"public interface ShiftA63Down Function Interface : ShiftA63Down Purpose :  To perform arithmetic right shift by 63 or less Usage : --->    OUT = ShiftA63Down(IN, 53) Module Procedures private  function I128_SHIFTA_63Down(InVal, ShiftPos) result(OutVal) To perform arithmetic right shift by 63 or less Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 )","tags":"","loc":"interface\\shifta63down.html"},{"title":"ShiftL64Up – FortCharConv","text":"public interface ShiftL64Up Function Interface : ShiftL64Up Purpose :  To perform logical left shift by 64 or more (<= 128) Usage : --->    OUT = ShiftL64Up(IN, 111) Module Procedures private  function I128_SHIFTL_64Up(InVal, ShiftPos) result(OutVal) To perform logical left shift by 64 or more Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 )","tags":"","loc":"interface\\shiftl64up.html"},{"title":"ShiftR64Up – FortCharConv","text":"public interface ShiftR64Up Function Interface : ShiftR64Up Purpose :  To perform logical right shift by 64 or more (<= 128) Usage : --->    OUT = ShiftR64Up(IN, 84) Module Procedures private  function I128_SHIFTR_64Up(InVal, ShiftPos) result(OutVal) To perform logical right shift by 64 or more Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 )","tags":"","loc":"interface\\shiftr64up.html"},{"title":"ShiftA64Up – FortCharConv","text":"public interface ShiftA64Up Function Interface : ShiftA64Up Purpose :  To perform arithmetic right shift by 64 or more (<= 128) Usage : --->    OUT = ShiftA64Up(IN, 84) Module Procedures private  function I128_SHIFTA_64Up(InVal, ShiftPos) result(OutVal) To perform arithmetic right shift by 64 or more Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 )","tags":"","loc":"interface\\shifta64up.html"},{"title":"SHIFTL – FortCharConv","text":"public interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTL(IN, 127) Module Procedures private  function I128_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical/arithmetic left shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos must be nonnegative and <= 128 Return Value type( SInt128 )","tags":"","loc":"interface\\shiftl.html"},{"title":"SHIFTA – FortCharConv","text":"public interface SHIFTA Function Interface : SHIFTA Purpose :  To perform arithmetic right shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTA(IN, 33) Module Procedures private  function I128_ShiftRightArithmetic(InVal, ShiftPos) result(OutVal) To perform arithmetic right shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos must be nonnegative and <= 128 Return Value type( SInt128 )","tags":"","loc":"interface\\shifta.html"},{"title":"SHIFTR – FortCharConv","text":"public interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTR(IN, 33) Module Procedures private  function I128_ShiftRightLogical(InVal, ShiftPos) result(OutVal) To perform logical right shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos must be nonnegative and <= 128 Return Value type( SInt128 )","tags":"","loc":"interface\\shiftr.html"},{"title":"ISHFT – FortCharConv","text":"public interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 --->    OUT = ISHFT(IN, -24)   ! a logical right shift by 24 Module Procedures private  function I128_ShiftLogical(InVal, ShiftPos) result(OutVal) To perform logical (left or rigth) shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( SInt128 )","tags":"","loc":"interface\\ishft.html"},{"title":"ISHFTC – FortCharConv","text":"public interface ISHFTC Function Interface : ISHFTC Purpose :  To perform circular shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 --->    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24 Module Procedures private  function I128_Rotate(InVal, ShiftPos) result(OutVal) To perform a circular shift of the rightmost bits Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( SInt128 )","tags":"","loc":"interface\\ishftc.html"},{"title":"NOT – FortCharConv","text":"public interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = NOT(IN) Module Procedures private  function I128_Not(InVal) result(OutVal) To return the bitwise logical complement of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 )","tags":"","loc":"interface\\not.html"},{"title":"IOR – FortCharConv","text":"public interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IOR(LHSIN, RHSIN) Module Procedures private  function I128_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of the SInt128 objects Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 )","tags":"","loc":"interface\\ior.html"},{"title":"IEOR – FortCharConv","text":"public interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IEOR(LHSIN, RHSIN) Module Procedures private  function I128_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of the SInt128 objects Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 )","tags":"","loc":"interface\\ieor.html"},{"title":"IAND – FortCharConv","text":"public interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IAND(LHSIN, RHSIN) Module Procedures private  function I128_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of the SInt128 objects Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 )","tags":"","loc":"interface\\iand.html"},{"title":"LEADZ – FortCharConv","text":"public interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumLZ = LEADZ(INPUT) Module Procedures private  function I128_LeadingZeros(I128) result(NumLZ) To count the number of leading zero bits Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\leadz.html"},{"title":"TRAILZ – FortCharConv","text":"public interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumTZ = TRAILZ(INPUT) Module Procedures private  function I128_TrailingZeros(I128) result(NumTZ) To count the number of trailing zero bits Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\trailz.html"},{"title":"POPCNT – FortCharConv","text":"public interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumBits = POPCNT(INPUT) Module Procedures private  function I128_Count1Bits(I128) result(NumBits) To count the number of 1 bits in the specified input Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\popcnt.html"},{"title":"POPPAR – FortCharConv","text":"public interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumPar = POPPAR(INPUT) Module Procedures private  function I128_Parity(I128) result(ParNum) To determine the parity of the specified input Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\poppar.html"},{"title":"IBSET – FortCharConv","text":"public interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBSET(IN, Pos) Module Procedures private  function I128_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1 For more detail, see explanation of elemental intrinsic function 'IBSET' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( SInt128 )","tags":"","loc":"interface\\ibset.html"},{"title":"IBCLR – FortCharConv","text":"public interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCLR(IN, Pos) Module Procedures private  function I128_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0 For more detail, see explanation of elemental intrinsic function 'IBCLR' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( SInt128 )","tags":"","loc":"interface\\ibclr.html"},{"title":"IBCHNG – FortCharConv","text":"public interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCHNG(IN, Pos) Module Procedures private  function I128_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( SInt128 )","tags":"","loc":"interface\\ibchng.html"},{"title":"BTEST – FortCharConv","text":"public interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position is 0 (False) or 1 (True) (For more information, see detailed explanation of the intrinsic function) Usage : --->    Flag = BTEST(IN, Pos) Module Procedures private  function I128_TestBit(I128, Pos) result(Flag) To check whether the bit at the specifed position is 0 (False) or 1 (True) For more detail, see explanation of elemental intrinsic function 'BTEST' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 integer(kind=I4B), intent(in) :: Pos Return Value logical","tags":"","loc":"interface\\btest.html"},{"title":"IBITS – FortCharConv","text":"public interface IBITS Function Interface : IBITS Purpose :  To extract a sequence of bits according to the specified input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBITS(IN, Pos, Len) Module Procedures private  function I128_ExtractBits(InVal, Pos, Len) result(OutVal) To extract a sequence of bits according to the specified input For more detail, see explanation of elemental intrinsic function 'IBITS' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos integer(kind=I4B), intent(in) :: Len Return Value type( SInt128 )","tags":"","loc":"interface\\ibits.html"},{"title":"MoveBits – FortCharConv","text":"public interface MoveBits Subroutine Interface : MoveBits Purpose :  To copy a sequence of bits (a bit field) from one location to another (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS') Usage : --->    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos) Module Procedures private  subroutine I128_MoveBits(InVal, InPos, Len, OutVal, OutPos) To copy a sequence of bits (a bit field) from one location to another For more detail, see explanation of elemental intrinsic subroutine\n'MVBITS' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: InPos integer(kind=I4B), intent(in) :: Len type( SInt128 ), intent(inout) :: OutVal integer(kind=I4B), intent(in) :: OutPos","tags":"","loc":"interface\\movebits.html"},{"title":"IsPositive – FortCharConv","text":"public interface IsPositive Function Interface : IsPositive Purpose :  To check whether the input value is positive or not Usage : --->    Flag = IsPositive(INPUT) --->    IF (IsPositive(INPUT)) DoSomeThing Module Procedures private  function I128_Is_Positive(I128) result(Flag) To check whether the number is positive or not Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value logical","tags":"","loc":"interface\\ispositive.html"},{"title":"IsNegative – FortCharConv","text":"public interface IsNegative Function Interface : IsNegative Purpose :  To check whether the input value is negative or not Usage : --->    Flag = IsNegative(INPUT) --->    IF (IsNegative(INPUT)) DoSomeThing Module Procedures private  function I128_Is_Negative(I128) result(Flag) To check whether the number is negative or not Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value logical","tags":"","loc":"interface\\isnegative.html"},{"title":"IsZero – FortCharConv","text":"public interface IsZero Function Interface : IsZero Purpose :  To check whether the input value is zero or not Usage : --->    Flag = IsZero(INPUT) --->    IF (IsZero(INPUT)) DoSomeThing Module Procedures private  function I128_Is_Zero(I128) result(Flag) To check whether the number is zero or not Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value logical","tags":"","loc":"interface\\iszero.html"},{"title":"ABS – FortCharConv","text":"public interface ABS Function Interface : ABS Purpose :  To return the absolute value of the input Usage : --->    OUTPUT = ABS(INPUT) Module Procedures private  function I128_Absolute(I128) result(ABS) To return the absolute value Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value type( SInt128 )","tags":"","loc":"interface\\abs.html"},{"title":"Display – FortCharConv","text":"public interface Display Subroutine Interface : Display Purpose :  To write/display the 'SInt128' object to the screen (or the specified unit) Usage : To display (signed) value of I128 as a decimal string to the screen --->    CALL Display(I128) To display (signed) value of I128 as a decimal string to the output logical unit --->    CALL Display(I128, 11) To display (signed) value of I128 as a decimal string to the output logical unit with input/output status and message --->    CALL Display(I128, 11, IOStat, IOMsg) To display (signed) values of components of U128 as a decimal string to the screen --->    CALL Display(I128, ShowComponent=.TRUE.) To display (signed) value of I128 as a decimal string to the screen with a prefix string --->    CALL Display(I128, Prefix='Unsigned value of U128') Module Procedures private  subroutine I128_Write(I128, Unit, IOStat, IOMsg, ShowComponent, Prefix) To write 'SInt128' object to the screen (or the specified unit) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 SInt128 object integer(kind=I4B), intent(in), optional :: Unit output logical unit integer(kind=I4B), intent(out), optional :: IOStat io stat character(len=*), intent(out), optional :: IOMsg io message logical, intent(in), optional :: ShowComponent flag indicating whether to show components or not if flag is present and true, write compoents of the object otherwise, write the object as a decimal string character(len=*), intent(in), optional :: Prefix prefix string","tags":"","loc":"interface\\display.html"},{"title":"RealSP_ToString_DragonBox – FortCharConv","text":"public  function RealSP_ToString_DragonBox(Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character (decimal) string\nusing the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string Source Code FUNCTION RealSP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a single-precision floating-point value to a character (decimal) string ! using the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I4B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = SP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I4B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I4B )) THEN ! zero SigDec = 0_I4B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + WRITE_RealSP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealSP_ToString_DragonBox","tags":"","loc":"proc\\realsp_tostring_dragonbox.html"},{"title":"RealSP_ToString_Ryu – FortCharConv","text":"public  function RealSP_ToString_Ryu(Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character (decimal) string\nusing the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string Source Code FUNCTION RealSP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a single-precision floating-point value to a character (decimal) string ! using the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I4B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = SP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I4B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I4B )) THEN ! zero SigDec = 0_I4B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + WRITE_RealSP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealSP_ToString_Ryu","tags":"","loc":"proc\\realsp_tostring_ryu.html"},{"title":"RealSP_ToString_Schubfach – FortCharConv","text":"public  function RealSP_ToString_Schubfach(Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character (decimal) string\nusing the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string Source Code FUNCTION RealSP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a single-precision floating-point value to a character (decimal) string ! using the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I4B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = SP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I4B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I4B )) THEN ! zero SigDec = 0_I4B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + WRITE_RealSP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealSP_ToString_Schubfach","tags":"","loc":"proc\\realsp_tostring_schubfach.html"},{"title":"RealSP_FromString_FastFloat – FortCharConv","text":"public  function RealSP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number Source Code FUNCTION RealSP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the FastFloat algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin64 ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using FastFloat algorithm if SlowPath is true ! IF (SlowPath) CALL Dec2Bin_FastFloat(SigDec, ExpDec, cStr, Aux%Truncated, Aux%Indices, SigBin, ExpBin) IF ( SlowPath ) THEN CALL Dec2Bin_FastFloat ( INT ( SigDec , KIND = I8B ), ExpDec , cStr , Aux % Truncated , Aux % Indices , SigBin64 , ExpBin ) SigBin = INT ( SigBin64 , KIND = I4B ) END IF ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_FastFloat","tags":"","loc":"proc\\realsp_fromstring_fastfloat.html"},{"title":"RealSP_FromString_LibC – FortCharConv","text":"public  function RealSP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the LibC algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number Source Code FUNCTION RealSP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the LibC algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using LibC algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_LibC ( SigDec , ExpDec , cStr , Aux % Start , Aux % Truncated , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_LibC","tags":"","loc":"proc\\realsp_fromstring_libc.html"},{"title":"RealSP_FromString_YY – FortCharConv","text":"public  function RealSP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the YY algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number Source Code FUNCTION RealSP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the YY algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using YY's algorithm +++ RawVal = Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_YY","tags":"","loc":"proc\\realsp_fromstring_yy.html"},{"title":"RealSP_FromString_Lemire – FortCharConv","text":"public  function RealSP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number Source Code FUNCTION RealSP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the Lemire algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using Lemire's algorithm +++ RawVal = Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_Lemire","tags":"","loc":"proc\\realsp_fromstring_lemire.html"},{"title":"UMul128_Upper64 – FortCharConv","text":"public pure function UMul128_Upper64(X, Y) result(U128Hi) To compute upper 64 bits of multiplication of two 64-bit unsigned integers Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: Y Return Value integer(kind=I8B) Source Code PURE FUNCTION UMul128_Upper64 ( X , Y ) RESULT ( U128Hi ) !DIR$ ATTRIBUTES INLINE :: UMul128_Upper64 !** PURPOSE OF THIS SUBROUTINE: !! To compute upper 64 bits of multiplication of two 64-bit unsigned integers IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ) :: U128Hi !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , X_Hi , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Hi_Lo , Cross !** FLOW X_Lo = IAND ( X , MaskU32 ) X_Hi = SHIFTR ( X , 32 ) Y_Lo = IAND ( Y , MaskU32 ) Y_Hi = SHIFTR ( Y , 32 ) Hi_Lo = X_Hi * Y_Lo Cross = SHIFTR ( X_Lo * Y_Lo , 32 ) + IAND ( Hi_Lo , MaskU32 ) + X_Lo * Y_Hi U128Hi = SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + X_Hi * Y_Hi RETURN END FUNCTION UMul128_Upper64","tags":"","loc":"proc\\umul128_upper64.html"},{"title":"UMul96_Upper64 – FortCharConv","text":"public pure function UMul96_Upper64(X, Y) result(U128Hi) To compute upper 64 bits of multiplication of a 32-bit unsigned integer and\na 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: X integer(kind=I8B), intent(in) :: Y Return Value integer(kind=I8B) Source Code PURE FUNCTION UMul96_Upper64 ( X , Y ) RESULT ( U128Hi ) !DIR$ ATTRIBUTES INLINE :: UMul96_Upper64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute upper 64 bits of multiplication of a 32-bit unsigned integer and ! a 64-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y INTEGER ( KIND = I8B ) :: U128Hi !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128Hi = UMul128_Upper64 ( SHIFTL ( ToUnsignedLong ( X ), 32 ), Y ) RETURN END FUNCTION UMul96_Upper64","tags":"","loc":"proc\\umul96_upper64.html"},{"title":"UMul96_Lower64 – FortCharConv","text":"public pure function UMul96_Lower64(X, Y) result(U128Lo) To compute lower 64 bits of multiplication of a 32-bit unsigned integer and\na 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: X integer(kind=I8B), intent(in) :: Y Return Value integer(kind=I8B) Source Code PURE FUNCTION UMul96_Lower64 ( X , Y ) RESULT ( U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul96_Lower64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute lower 64 bits of multiplication of a 32-bit unsigned integer and ! a 64-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y INTEGER ( KIND = I8B ) :: U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128Lo = X * Y RETURN END FUNCTION UMul96_Lower64","tags":"","loc":"proc\\umul96_lower64.html"},{"title":"UMul128_N_Shift – FortCharConv","text":"public pure function UMul128_N_Shift(A, B_Hi, B_Lo, ShrPos) result(ResVal) To multiply two 64-bit unsigned integers, and then shift\nthe 128-bit result by ShrPos => SHIFTR(A*B, ShrPos). Note: ShrPos should be in the range [64, 128]. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: A integer(kind=I8B), intent(in) :: B_Hi integer(kind=I8B), intent(in) :: B_Lo integer(kind=I4B), intent(in) :: ShrPos Return Value integer(kind=I8B) Source Code PURE FUNCTION UMul128_N_Shift ( A , B_Hi , B_Lo , ShrPos ) RESULT ( ResVal ) !DIR$ ATTRIBUTES INLINE :: UMul128_N_Shift !** PURPOSE OF THIS SUBROUTINE: !&#94; To multiply two 64-bit unsigned integers, and then shift ! the 128-bit result by ShrPos => SHIFTR(A*B, ShrPos). ! Note: ShrPos should be in the range [64, 128]. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: A , B_Hi , B_Lo INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShrPos INTEGER ( KIND = I8B ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: R0_Hi , R1_Lo , R1_Hi !** FLOW ! multiply A and B_Lo and return the high bit R0_Hi R0_Hi = UMul128_Upper64 ( A , B_Lo ) ! multiply A and B_Hi and add R0_Hi to the result CALL UMul128_N_Add ( A , B_Hi , R0_Hi , R1_Hi , R1_Lo ) ! shift the result by ShrPos position => SHIFTR(A*B, ShrPos) ResVal = IOR ( SHIFTL ( R1_Hi , ( 128 - ShrPos )), SHIFTR ( R1_Lo , ( ShrPos - 64 ))) RETURN END FUNCTION UMul128_N_Shift","tags":"","loc":"proc\\umul128_n_shift.html"},{"title":"UMul128 – FortCharConv","text":"public pure subroutine UMul128(X, Y, U128Hi, U128Lo) To compute 128-bit result of multiplication of two 64-bit unsigned integers. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: Y integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo Source Code PURE SUBROUTINE UMul128 ( X , Y , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul128 !** PURPOSE OF THIS SUBROUTINE: !! To compute 128-bit result of multiplication of two 64-bit unsigned integers. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , X_Hi , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Hi_Lo , Cross !** FLOW X_Lo = IAND ( X , MaskU32 ) X_Hi = SHIFTR ( X , 32 ) Y_Lo = IAND ( Y , MaskU32 ) Y_Hi = SHIFTR ( Y , 32 ) Lo_Lo = X_Lo * Y_Lo Hi_Lo = X_Hi * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaskU32 ) + X_Lo * Y_Hi U128Hi = SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + X_Hi * Y_Hi U128Lo = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaskU32 )) RETURN END SUBROUTINE UMul128","tags":"","loc":"proc\\umul128.html"},{"title":"UMul192_Upper128 – FortCharConv","text":"public pure subroutine UMul192_Upper128(X, YHi, YLo, U128Hi, U128Lo) To compute upper 128 bits of multiplication of a 64-bit unsigned integer and\na 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: YHi integer(kind=I8B), intent(in) :: YLo integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo Source Code PURE SUBROUTINE UMul192_Upper128 ( X , YHi , YLo , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul192_Upper128 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute upper 128 bits of multiplication of a 64-bit unsigned integer and ! a 128-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , YHi , YLo INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Add !** FLOW CALL UMul128 ( X , YHi , U128Hi , U128Lo ) Add = UMul128_Upper64 ( X , YLo ) U128Lo = U128Lo + Add IF ( U128Lo . ULT . Add ) U128Hi = U128Hi + 1_I8B RETURN END SUBROUTINE UMul192_Upper128","tags":"","loc":"proc\\umul192_upper128.html"},{"title":"UMul192_Lower128 – FortCharConv","text":"public pure subroutine UMul192_Lower128(X, YHi, YLo, U128Hi, U128Lo) To compute lower 128 bits of multiplication of a 64-bit unsigned integer and\na 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: YHi integer(kind=I8B), intent(in) :: YLo integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo Source Code PURE SUBROUTINE UMul192_Lower128 ( X , YHi , YLo , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul192_Lower128 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute lower 128 bits of multiplication of a 64-bit unsigned integer and ! a 128-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , YHi , YLo INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL UMul128 ( X , YLo , U128Hi , U128Lo ) U128Hi = U128Hi + X * YHi RETURN END SUBROUTINE UMul192_Lower128","tags":"","loc":"proc\\umul192_lower128.html"},{"title":"UMul128_N_Add – FortCharConv","text":"public pure subroutine UMul128_N_Add(A, B, C, U128Hi, U128Lo) To multiply two 64-bit unsigned integers and add a value (A*B + C), and\nreturn the 128-bit result as U128Hi, U128Lo. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: A integer(kind=I8B), intent(in) :: B integer(kind=I8B), intent(in) :: C integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo Source Code PURE SUBROUTINE UMul128_N_Add ( A , B , C , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul128_N_Add !** PURPOSE OF THIS SUBROUTINE: !&#94; To multiply two 64-bit unsigned integers and add a value (A*B + C), and ! return the 128-bit result as U128Hi, U128Lo. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: A , B , C INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: H , L , T !** FLOW ! multiply A and B CALL UMul128 ( A , B , H , L ) ! add carry T = L + C ! check whether to add 1 to high bit IF ( T . ULT . L ) THEN H = H + 1_I8B ELSE IF ( T . ULT . C ) H = H + 1_I8B END IF U128Hi = H U128Lo = T RETURN END SUBROUTINE UMul128_N_Add","tags":"","loc":"proc\\umul128_n_add.html"},{"title":"OPERATOR (.ULT.) – FortCharConv","text":"public interface OPERATOR (.ULT.) Operator Overload : OPERATOR(.ULT.) Purpose :  To check if the LHS value is less than the RHS value return .TRUE. if LHS < RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULT. RHS --->    IF (LHS .ULT. RHS) DoSomething Module Procedures private pure function UInt8_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator (.ult.).html"},{"title":"OPERATOR (.ULE.) – FortCharConv","text":"public interface OPERATOR (.ULE.) Operator Overload : OPERATOR(.ULE.) Purpose :  To check if the LHS value is less than or equal to the RHS value return .TRUE. if LHS <= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULE. RHS --->    IF (LHS .ULE. RHS) DoSomething Module Procedures private pure function UInt8_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator (.ule.).html"},{"title":"OPERATOR (.UGT.) – FortCharConv","text":"public interface OPERATOR (.UGT.) Operator Overload : OPERATOR(.UGT.) Purpose :  To check if the LHS value is greater than the RHS value return .TRUE. if LHS > RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGT. RHS --->    IF (LHS .UGT. RHS) DoSomething Module Procedures private pure function UInt8_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator (.ugt.).html"},{"title":"OPERATOR (.UGE.) – FortCharConv","text":"public interface OPERATOR (.UGE.) Operator Overload : OPERATOR(.UGE.) Purpose :  To check if the LHS value is greater than or equal to the RHS value return .TRUE. if LHS >= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGE. RHS --->    IF (LHS .UGE. RHS) DoSomething Module Procedures private pure function UInt8_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator (.uge.).html"},{"title":"OPERATOR (.UDIV.) – FortCharConv","text":"public interface OPERATOR (.UDIV.) Operator Overload : OPERATOR(.UDIV.) Purpose :  To return the quotient of a division of two unsigned integers,\n  where both input and an output have the same kind Usage : --->    QUOT = NUMER .UDIV. DENOM Module Procedures private pure function UInt8_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: Dividend integer(kind=I1B), intent(in) :: Divisor Return Value integer(kind=I1B) private pure function UInt16_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: Dividend integer(kind=I2B), intent(in) :: Divisor Return Value integer(kind=I2B) private pure function UInt32_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing ResVal   - the unsigned quotient of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value integer(kind=I4B) private pure function UInt64_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing ResVal   - the unsigned quotient of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value integer(kind=I8B)","tags":"","loc":"interface\\operator (.udiv.).html"},{"title":"UMOD – FortCharConv","text":"public interface UMOD Function Interface : UMOD Purpose :  To return the remainder of a division of two unsigned integers,\n  where both input and an output have the same kind Usage : --->    REM = UMOD(NUMER, DENOM) Module Procedures private pure function UInt8_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: Dividend integer(kind=I1B), intent(in) :: Divisor Return Value integer(kind=I1B) private pure function UInt16_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: Dividend integer(kind=I2B), intent(in) :: Divisor Return Value integer(kind=I2B) private pure function UInt32_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing Rem      - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value integer(kind=I4B) private pure function UInt64_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing Rem      - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value integer(kind=I8B)","tags":"","loc":"interface\\umod.html"},{"title":"UDivMod – FortCharConv","text":"public interface UDivMod Subroutine Interface : UDivMod Purpose :  To perform a division of two unsigned integers and then return both\n  the quotient and the remainder where both input and output have the same kind Usage : --->    CALL UDivMod(NUMER, DENOM, QUOT, REM) Module Procedures private pure subroutine UInt32_DivMod(Dividend, Divisor, Quotient, Remainder) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend  - the value to be divided Divisor   - the value doing the dividing Quotient  - the unsigned quotient of the first argument divided by the second argument Remainder - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor integer(kind=I4B), intent(out) :: Quotient integer(kind=I4B), intent(out) :: Remainder private pure subroutine UInt64_DivMod(Dividend, Divisor, Quotient, Remainder) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend  - the value to be divided Divisor   - the value doing the dividing Quotient  - the unsigned quotient of the first argument divided by the second argument Remainder - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor integer(kind=I8B), intent(out) :: Quotient integer(kind=I8B), intent(out) :: Remainder","tags":"","loc":"interface\\udivmod.html"},{"title":"CompareUnsigned – FortCharConv","text":"public interface CompareUnsigned Function Interface : CompareUnsigned Purpose :  To compare two unsigned integers (of the same kind) and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = CompareUnsigned(LHS, RHS) --->    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething Module Procedures private pure function Compare_UInt8(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function Compare_UInt16(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function Compare_UInt32(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function Compare_UInt64(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value integer(kind=I4B)","tags":"","loc":"interface\\compareunsigned.html"},{"title":"ToUnsignedInteger – FortCharConv","text":"public interface ToUnsignedInteger Function Interface : ToUnsignedInteger Purpose :  To perform unsigned conversion from lower-precision unsigned integer\n  to 32-bit unsigned integer Usage : --->    U32 = ToUnsignedInteger(U8) Module Procedures private pure function ByteToUnsignedInteger(InVal) result(OutVal) To convert the argument to an integer by an unsigned\nconversion.  In an unsigned conversion to an integer, the\nhigh-order 24 bits of the integer are zero and the low-order\n8 bits are equal to the bits of the byte argument.\nConsequently, zero and positive byte values are mapped\nto a numerically equal integer value and negative byte values\nare mapped to a integer value equal to the input plus 2**8. InVal  - the value to convert to an unsigned integer OutVal - the result converted to integer by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function ShortToUnsignedInteger(InVal) result(OutVal) To convert the argument to an integer by an unsigned\nconversion.  In an unsigned conversion to an integer, the\nhigh-order 16 bits of the integer are zero and the low-order\n16 bits are equal to the bits of the short argument.\nConsequently, zero and positive short values are mapped\nto a numerically equal integer value and negative short values\nare mapped to a integer value equal to the input plus 2**16. InVal  - the value to convert to an unsigned integer OutVal - the result converted to integer by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: InVal Return Value integer(kind=I4B)","tags":"","loc":"interface\\tounsignedinteger.html"},{"title":"ToUnsignedLong – FortCharConv","text":"public interface ToUnsignedLong Function Interface : ToUnsignedLong Purpose :  To perform unsigned conversion from lower-precision unsigned integer\n  to 64-bit unsigned integer Usage : --->    U64 = ToUnsignedLong(U32) Module Procedures private pure function ByteToUnsignedLong(InVal) result(OutVal) To convert the argument to a long integer by an unsigned\nconversion.  In an unsigned conversion to a long, the\nhigh-order 56 bits of the long are zero and the low-order\n8 bits are equal to the bits of the byte argument.\nConsequently, zero and positive byte values are mapped\nto a numerically equal long value and negative byte values\nare mapped to a long value equal to the input plus 2**8. InVal  - the value to convert to an unsigned long OutVal - the result converted to long by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: InVal Return Value integer(kind=I8B) private pure function ShortToUnsignedLong(InVal) result(OutVal) To convert the argument to a long integer by an unsigned\nconversion.  In an unsigned conversion to a long, the\nhigh-order 48 bits of the long are zero and the low-order\n16 bits are equal to the bits of the short argument.\nConsequently, zero and positive short values are mapped\nto a numerically equal long value and negative short values\nare mapped to a long value equal to the input plus 2**16. InVal  - the value to convert to an unsigned long OutVal - the result converted to long by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: InVal Return Value integer(kind=I8B) private pure function IntegerToUnsignedLong(InVal) result(OutVal) To convert the argument to a long integer by an unsigned\nconversion.  In an unsigned conversion to a long, the\nhigh-order 32 bits of the long are zero and the low-order\n32 bits are equal to the bits of the integer argument.\nConsequently, zero and positive integer values are mapped\nto a numerically equal long value and negative integer values\nare mapped to a long value equal to the input plus 2**32. InVal  - the value to convert to an unsigned long OutVal - the result converted to long by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I8B)","tags":"","loc":"interface\\tounsignedlong.html"},{"title":"ToDecStrUnsigned – FortCharConv","text":"public interface ToDecStrUnsigned Function Interface : ToDecStrUnsigned Purpose :  To convert an unsigned integer to a decimal string Usage : --->    Str = ToDecStrUnsigned(U32) Module Procedures private  function U32_ToDecString(Val) result(RetStr) To convert a 32-bit integer treated as an unsigned number into a string. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val Return Value character(len=:), ALLOCATABLE private  function U64_ToDecString(Val) result(RetStr) To convert a 64-bit integer treated as an unsigned number into a string. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Val Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\todecstrunsigned.html"},{"title":"ToHexStrUnsigned – FortCharConv","text":"public interface ToHexStrUnsigned Function Interface : ToHexStrUnsigned Purpose :  To convert an unsigned integer to a hexadecimal string Usage : --->    Str = ToHexStrUnsigned(U32) Module Procedures private  function U32_ToHexString(Number) result(cStr) To convert an usigned 32-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE private  function U64_ToHexString(Number) result(cStr) To convert an usigned 64-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\tohexstrunsigned.html"},{"title":"ASSIGNMENT(=) – FortCharConv","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a 128-bit unsigned integer and\n  other unsigned integers (32- and 64-bit integers) Usage : --->    U128 = OtherType Module Procedures private  subroutine U128_From_U32(U128, U32) To convert an unsigned 32-bit integer number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(out) :: U128 integer(kind=I4B), intent(in) :: U32 number treated as unsigned private  subroutine U128_From_U64(U128, U64) To convert an unsigned 64-bit integer number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(out) :: U128 integer(kind=I8B), intent(in) :: U64 number treated as unsigned private  subroutine U128_To_U32(U32, U128) To convert an unsigned 128-bit integer number to an unsigned 32-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(out) :: U32 number treated as unsigned type( UInt128 ), intent(in) :: U128 private  subroutine U128_To_U64(U64, U128) To convert an unsigned 128-bit integer number to an unsigned 64-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(out) :: U64 number treated as unsigned type( UInt128 ), intent(in) :: U128","tags":"","loc":"interface\\assignment(=)~2.html"},{"title":"UInt128 – FortCharConv","text":"public interface UInt128 Constructor Interface : UInt128 Purpose :  To construct a 128-bit unsigned integer from\n  other Fortran intrinsic types Usage : --->    U128 = UInt128(OtherType) Module Procedures private  function I32_To_U128(I32, AsUnsigned) result(U128) To convert a signed 32-bit integer number to an unsigned 128-bit integer number\n or to convert an unsigned 32-bit integer number to an unsigned 128-bit integer\n number if the specified flag is present and true. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I32 number treated as signed (default) logical, intent(in), optional :: AsUnsigned if present and true, number treated as unsigned Return Value type( UInt128 ) private  function I64_To_U128(I64, AsUnsigned) result(U128) To convert a signed 64-bit integer number to an unsigned 128-bit integer number\nor to convert an unsigned 64-bit integer number to an unsigned 128-bit integer\nnumber if the specified flag is present and true. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: I64 number treated as signed (default) logical, intent(in), optional :: AsUnsigned if present and true, number treated as unsigned Return Value type( UInt128 ) private  function R32_To_U128(R32) result(U128) To convert a 32-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: R32 Return Value type( UInt128 ) private  function R64_To_U128(R64) result(U128) To convert a 64-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: R64 Return Value type( UInt128 ) private  function R128_To_U128(R128) result(U128) To convert a 128-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: R128 Return Value type( UInt128 ) private  function DecString_To_U128(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an unsigned 128-bit integer value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( UInt128 ) number","tags":"","loc":"interface\\uint128.html"},{"title":"ToI32 – FortCharConv","text":"public interface ToI32 Function Interface : ToI32 Purpose :  To convert a 128-bit unsigned integer to a \n  32-bit signed integer Usage : --->    I32 = ToI32(U128) Module Procedures private  function I32_From_U128(U128) result(I32) To convert an unsigned 128-bit integer number to a signed 32-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B) number treated as signed","tags":"","loc":"interface\\toi32.html"},{"title":"ToI64 – FortCharConv","text":"public interface ToI64 Function Interface : ToI64 Purpose :  To convert a 128-bit unsigned integer to\n  a 64-bit signed integer Usage : --->    I64 = ToI64(U128) Module Procedures private  function I64_From_U128(U128) result(I64) To convert an unsigned 128-bit integer number to a signed 64-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I8B) number treated as signed","tags":"","loc":"interface\\toi64.html"},{"title":"ToR32 – FortCharConv","text":"public interface ToR32 Function Interface : ToR32 Purpose :  To convert a 128-bit unsigned integer to\n  a 32-bit floating point (real) number Usage : --->    R32 = ToR32(U128) Module Procedures private  function R32_From_U128(U128) result(R32) To convert an unsigned 128-bit integer number to a 32-bit floating point number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value real(kind=SP)","tags":"","loc":"interface\\tor32~2.html"},{"title":"ToR64 – FortCharConv","text":"public interface ToR64 Function Interface : ToR64 Purpose :  To convert a 128-bit unsigned integer to\n  a 64-bit floating point (real) number Usage : --->    R64 = ToR64(U128) Module Procedures private  function R64_From_U128(U128) result(R64) To convert an unsigned 128-bit integer number to a 64-bit floating point number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value real(kind=DP)","tags":"","loc":"interface\\tor64~2.html"},{"title":"ToR128 – FortCharConv","text":"public interface ToR128 Function Interface : ToR128 Purpose :  To convert a 128-bit unsigned integer to\n  a 128-bit floating point (real) number Usage : --->    R128 = ToR128(U128) Module Procedures private  function R128_From_U128(U128) result(R128) To convert an unsigned 128-bit integer number to a 128-bit floating point number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value real(kind=QP)","tags":"","loc":"interface\\tor128~2.html"},{"title":"ToDecString – FortCharConv","text":"public interface ToDecString Function Interface : ToDecString Purpose :  To convert a 128-bit unsigned integer to\n  a decimal string Usage : --->    Str = ToDecString(U128) Module Procedures private  function DecString_From_U128(U128) result(Str) To convert an unsigned 128-bit integer number to a decimal string. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\todecstring~2.html"},{"title":"ToHexString – FortCharConv","text":"public interface ToHexString Function Interface : ToHexString Purpose :  To convert a 128-bit unsigned integer to\n  a hexadecimal string Usage : --->    Str = ToHexString(U128) Module Procedures private  function HexString_From_U128(U128) result(Str) To convert an unsigned 128-bit integer number to a hexadecimal string. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value character(len=:), ALLOCATABLE","tags":"","loc":"interface\\tohexstring~2.html"},{"title":"OPERATOR(==) – FortCharConv","text":"public interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two 128-bit unsigned integers are equal return .TRUE. if both values are equal; otherwise return .FALSE. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething Module Procedures private  function U128_Equal(LHS, RHS) result(Flag) To check whether two Uint128 objects are equal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(==)~2.html"},{"title":"OPERATOR(/=) – FortCharConv","text":"public interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two 128-bit unsigned integers are not equal return .TRUE. if both values are NOT equal; otherwise return .FALSE. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething Module Procedures private  function U128_NotEqual(LHS, RHS) result(Flag) To check whether two Uint128 objects are NOT equal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(SLASH=)~2.html"},{"title":"OPERATOR(.ULT.) – FortCharConv","text":"public interface OPERATOR(.ULT.) Operator Overload : OPERATOR(.ULT.) Purpose :  To check if the LHS value is less than the RHS value return .TRUE. if LHS < RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULT. RHS --->    IF (LHS .ULT. RHS) DoSomething Module Procedures private  function U128_LessThan(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is less than the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(.ult.).html"},{"title":"OPERATOR(.ULE.) – FortCharConv","text":"public interface OPERATOR(.ULE.) Operator Overload : OPERATOR(.ULE.) Purpose :  To check if the LHS value is less than or equal to the RHS value return .TRUE. if LHS <= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULE. RHS --->    IF (LHS .ULE. RHS) DoSomething Module Procedures private  function U128_LessEqual(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is less than or equal to the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(.ule.).html"},{"title":"OPERATOR(.UGT.) – FortCharConv","text":"public interface OPERATOR(.UGT.) Operator Overload : OPERATOR(.UGT.) Purpose :  To check if the LHS value is greater than the RHS value return .TRUE. if LHS > RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGT. RHS --->    IF (LHS .UGT. RHS) DoSomething Module Procedures private  function U128_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is greater than the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(.ugt.).html"},{"title":"OPERATOR(.UGE.) – FortCharConv","text":"public interface OPERATOR(.UGE.) Operator Overload : OPERATOR(.UGE.) Purpose :  To check if the LHS value is greater than or equal to the RHS value return .TRUE. if LHS >= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGE. RHS --->    IF (LHS .UGE. RHS) DoSomething Module Procedures private  function U128_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is greater than or equal to the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(.uge.).html"},{"title":"CompareUnsigned – FortCharConv","text":"public interface CompareUnsigned Function Interface : CompareUnsigned Purpose :  To compare two 128-bit unsigned integers and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = CompareUnsigned(LHS, RHS) --->    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething Module Procedures private  function U128_Compare(LHS, RHS) result(Flag) To compare LHS and RHS objects. -> return -1 if LHS < RHS -> return  0 if LHS == RHS -> return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value integer(kind=I4B)","tags":"","loc":"interface\\compareunsigned~2.html"},{"title":"OPERATOR(+) – FortCharConv","text":"public interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two unsigned integers\n  (at least one of which is a 128-bit unsigned integer) or\n  to add a unary plus sign to a 128-bit unsigned integer\n  (which has no effect on the unsigned integer) Usage : --->    OUTPUT = +INPUT --->    OUTPUT = FIRST_IN + SECOND_IN Module Procedures private  function U128_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) private  function U128_Plus_U128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Plus_U32(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U32_Plus_U128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Plus_U64(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U64_Plus_U128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 )","tags":"","loc":"interface\\operator(+)~2.html"},{"title":"OPERATOR(-) – FortCharConv","text":"public interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two unsigned integers\n  (at least one of which is a 128-bit unsigned integer) or\n  to perform a negation of a 128-bit unsigned integer Usage : --->    OUTPUT = -INPUT --->    OUTPUT = FIRST_IN - SECOND_IN Important Note :  For subtraction of unsigned integers, value of FIRST_IN\n  must always be greater than SECOND_IN.  Otherwise, value of OUTPUT\n  is NOT valid. Module Procedures private  function U128_Negate(InVal) result(OutVal) To negate the Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) private  function U128_Minus_U128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Minus_U32(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U32_Minus_U128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Minus_U64(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U64_Minus_U128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 )","tags":"","loc":"interface\\operator(-)~2.html"},{"title":"OPERATOR(*) – FortCharConv","text":"public interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two unsigned integers (at least one of which is a 128-bit unsigned integer) Usage : --->    OUTPUT = FIRST_IN * SECOND_IN Module Procedures private  function U128_Multiply_U128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Multiply_U32(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U32_Multiply_U128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Multiply_U64(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U64_Multiply_U128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 )","tags":"","loc":"interface\\operator(ASTERISK)~2.html"},{"title":"OPERATOR(.UDIV.) – FortCharConv","text":"public interface OPERATOR(.UDIV.) Operator Overload : OPERATOR(.UDIV.) Purpose :  To return the quotient of a division of two unsigned integers,\n  where the dividend (numerator) is a 128-bit unsigned integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit unsigned integer Usage : --->    QUOT = NUMER .UDIV. DENOM Module Procedures private  function U128_Divide_U32(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Divide_U64(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Divide_U128(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend type( UInt128 ), intent(in) :: Divisor Return Value type( UInt128 )","tags":"","loc":"interface\\operator(.udiv.).html"},{"title":"UMOD – FortCharConv","text":"public interface UMOD Function Interface : UMOD Purpose :  To return the remainder of a division of two unsigned integers,\n  where the dividend (numerator) is a 128-bit unsigned integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit unsigned integer Usage : --->    REM = UMOD(NUMER, DENOM) Module Procedures private  function U128_Mod_U32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Mod_U64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Mod_U128(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend type( UInt128 ), intent(in) :: Divisor Return Value type( UInt128 )","tags":"","loc":"interface\\umod~2.html"},{"title":"UDivMod – FortCharConv","text":"public interface UDivMod Subroutine Interface : UDivMod Purpose :  To perform a division of two unsigned integers (where the\n  dividend (numerator) is a 128-bit unsigned integer and the divisor\n  (denominator) can be 32-, 64- or 128-bit unsigned integer) and\n  to return both the quotient and the remainder Usage : --->    CALL UDivMod(NUMER, DENOM, QUOT, REM) Module Procedures private  subroutine U128_DivMod_U32(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor. And, to return both quotient and remainder. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor type( UInt128 ), intent(out) :: Quotient type( UInt128 ), intent(out) :: Remainder private  subroutine U128_DivMod_U64(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor. And, to return both quotient and remainder. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor type( UInt128 ), intent(out) :: Quotient type( UInt128 ), intent(out) :: Remainder private  subroutine U128_DivMod_U128(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor. And, to return both quotient and remainder. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend type( UInt128 ), intent(in) :: Divisor type( UInt128 ), intent(out) :: Quotient type( UInt128 ), intent(out) :: Remainder","tags":"","loc":"interface\\udivmod~2.html"},{"title":"Increment – FortCharConv","text":"public interface Increment Subroutine Interface : Increment Purpose :  To increase value of a 128-bit unsigned integer by one Usage : --->    CALL Increment(U128) Module Procedures private  subroutine U128_Increment(Val) To increase value of the input by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: Val","tags":"","loc":"interface\\increment~2.html"},{"title":"Decrement – FortCharConv","text":"public interface Decrement Subroutine Interface : Decrement Purpose :  To decrease value of a 128-bit unsigned integer by one Usage : --->    CALL Decrement(U128) Module Procedures private  subroutine U128_Decrement(Val) To decrease value of the input by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: Val","tags":"","loc":"interface\\decrement~2.html"},{"title":"Add – FortCharConv","text":"public interface Add Subroutine Interface : Add Purpose :  To add an unsigned integer to a 128-bit unsigned integer Usage : --->    CALL Add(This, Other) Module Procedures private  subroutine U128_Add_U32(This, Other) To perform addition:  This = This + Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Add_U64(This, Other) To perform addition:  This = This + Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Add_U128(This, Other) To perform addition:  This = This + Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other","tags":"","loc":"interface\\add~2.html"},{"title":"Subtract – FortCharConv","text":"public interface Subtract Subroutine Interface : Subtract Purpose :  To subtract an unsigned integer from a 128-bit unsigned integer Usage : --->    CALL Subtract(This, Other) Important Note :  For subtraction of unsigned integers, value of This\n  must always be greater than Other.  Otherwise, value of the returned\n  This is NOT valid. Module Procedures private  subroutine U128_Subtract_U32(This, Other) To perform subtraction:  This = This - Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Subtract_U64(This, Other) To perform subtraction:  This = This - Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Subtract_U128(This, Other) To perform subtraction:  This = This - Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other","tags":"","loc":"interface\\subtract~2.html"},{"title":"Multiply – FortCharConv","text":"public interface Multiply Subroutine Interface : Multiply Purpose :  To multiply a 128-bit unsigned integer by an unsigned integer Usage : --->    CALL Multiply(This, Other) Module Procedures private  subroutine U128_Times_U32(This, Other) To perform multiplication:  This = This * Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine U128_Times_U64(This, Other) To perform multiplication:  This = This * Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine U128_Times_U128(This, Other) To perform multiplication:  This = This * Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other","tags":"","loc":"interface\\multiply~2.html"},{"title":"Divide – FortCharConv","text":"public interface Divide Subroutine Interface : Divide Purpose :  To divide a 128-bit unsigned integer by an unsigned integer Usage : --->    CALL Divide(This, Other) Module Procedures private  subroutine U128_Over_U32(This, Other, Remainder) To perform division:  This = This / Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other integer(kind=I4B), intent(out), optional :: Remainder private  subroutine U128_Over_U64(This, Other, Remainder) To perform division:  This = This / Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other integer(kind=I8B), intent(out), optional :: Remainder private  subroutine U128_Over_U128(This, Other, Remainder) To perform division:  This = This / Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other type( UInt128 ), intent(out), optional :: Remainder","tags":"","loc":"interface\\divide~2.html"},{"title":"ShiftLOnce – FortCharConv","text":"public interface ShiftLOnce Function Interface : ShiftLOnce Purpose :  To perform logical left shift by 1 Usage : --->    OUT = ShiftLOnce(IN) Module Procedures private  function U128_ShiftLeftOnce(InVal) result(OutVal) To perform logical left shift by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 )","tags":"","loc":"interface\\shiftlonce~2.html"},{"title":"ShiftROnce – FortCharConv","text":"public interface ShiftROnce Function Interface : ShiftROnce Purpose :  To perform logical right shift by 1 Usage : --->    OUT = ShiftROnce(IN) Module Procedures private  function U128_ShiftRightOnce(InVal) result(OutVal) To perform logical right shift by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 )","tags":"","loc":"interface\\shiftronce~2.html"},{"title":"ShiftL64 – FortCharConv","text":"public interface ShiftL64 Function Interface : ShiftL64 Purpose :  To perform logical left shift by 64 Usage : --->    OUT = ShiftL64(IN) Module Procedures private  function U128_ShiftLeft64(InVal) result(OutVal) To perform logical left shift by 64. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 )","tags":"","loc":"interface\\shiftl64~2.html"},{"title":"ShiftR64 – FortCharConv","text":"public interface ShiftR64 Function Interface : ShiftR64 Purpose :  To perform logical right shift by 64 Usage : --->    OUT = ShiftR64(IN) Module Procedures private  function U128_ShiftRight64(InVal) result(OutVal) To perform logical right shift by 64 Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 )","tags":"","loc":"interface\\shiftr64~2.html"},{"title":"ShiftL63Down – FortCharConv","text":"public interface ShiftL63Down Function Interface : ShiftL63Down Purpose :  To perform logical left shift by 63 or less Usage : --->    OUT = ShiftL63Down(IN, 11) Module Procedures private  function U128_ShiftLeft63Down(InVal, ShiftPos) result(OutVal) To perform logical left shift by 63 or less. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos < 64 Return Value type( UInt128 )","tags":"","loc":"interface\\shiftl63down~2.html"},{"title":"ShiftR63Down – FortCharConv","text":"public interface ShiftR63Down Function Interface : ShiftR63Down Purpose :  To perform logical right shift by 63 or less Usage : --->    OUT = ShiftR63Down(IN, 53) Module Procedures private  function U128_ShiftRight63Down(InVal, ShiftPos) result(OutVal) To perform logical right shift by 63 or less. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos < 64 Return Value type( UInt128 )","tags":"","loc":"interface\\shiftr63down~2.html"},{"title":"ShiftL64Up – FortCharConv","text":"public interface ShiftL64Up Function Interface : ShiftL64Up Purpose :  To perform logical left shift by 64 or more (<= 128) Usage : --->    OUT = ShiftL64Up(IN, 111) Module Procedures private  function U128_ShiftLeft64Up(InVal, ShiftPos) result(OutVal) To perform logical left shift by 64 or more. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 64 < ShiftPos <= 128 Return Value type( UInt128 )","tags":"","loc":"interface\\shiftl64up~2.html"},{"title":"ShiftR64Up – FortCharConv","text":"public interface ShiftR64Up Function Interface : ShiftR64Up Purpose :  To perform logical right shift by 64 or more (<= 128) Usage : --->    OUT = ShiftR64Up(IN, 84) Module Procedures private  function U128_ShiftRight64Up(InVal, ShiftPos) result(OutVal) To perform logical right shift by 64 or more. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 64 < ShiftPos <= 128 Return Value type( UInt128 )","tags":"","loc":"interface\\shiftr64up~2.html"},{"title":"SHIFTL – FortCharConv","text":"public interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTL(IN, 127) Module Procedures private  function U128_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical left shift of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos <= 128 Return Value type( UInt128 )","tags":"","loc":"interface\\shiftl~2.html"},{"title":"SHIFTR – FortCharConv","text":"public interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTR(IN, 33) Module Procedures private  function U128_ShiftRight(InVal, ShiftPos) result(OutVal) To perform logical right shift of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos <= 128 Return Value type( UInt128 )","tags":"","loc":"interface\\shiftr~2.html"},{"title":"ISHFT – FortCharConv","text":"public interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 --->    OUT = ISHFT(IN, -24)   ! a logical right shift by 24 Module Procedures private  function U128_ShiftLogical(InVal, ShiftPos) result(OutVal) To perform logical (left or right) shift of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( UInt128 )","tags":"","loc":"interface\\ishft~2.html"},{"title":"ISHFTC – FortCharConv","text":"public interface ISHFTC Function Interface : ISHFTC Purpose :  To perform circular shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 --->    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24 Module Procedures private  function U128_Rotate(InVal, ShiftPos) result(OutVal) To perform a circular shift of the rightmost bits. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( UInt128 )","tags":"","loc":"interface\\ishftc~2.html"},{"title":"NOT – FortCharConv","text":"public interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = NOT(IN) Module Procedures private  function U128_Not(InVal) result(OutVal) To return the bitwise logical complement of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 )","tags":"","loc":"interface\\not~2.html"},{"title":"IOR – FortCharConv","text":"public interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IOR(LHSIN, RHSIN) Module Procedures private  function U128_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of the UInt128 objects. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 )","tags":"","loc":"interface\\ior~2.html"},{"title":"IEOR – FortCharConv","text":"public interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IEOR(LHSIN, RHSIN) Module Procedures private  function U128_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of the UInt128 objects. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 )","tags":"","loc":"interface\\ieor~2.html"},{"title":"IAND – FortCharConv","text":"public interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IAND(LHSIN, RHSIN) Module Procedures private  function U128_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of the UInt128 objects. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 )","tags":"","loc":"interface\\iand~2.html"},{"title":"LEADZ – FortCharConv","text":"public interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumLZ = LEADZ(INPUT) Module Procedures private  function U128_LeadingZeros(U128) result(NumLZ) To count the number of leading zero bits. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\leadz~2.html"},{"title":"TRAILZ – FortCharConv","text":"public interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumTZ = TRAILZ(INPUT) Module Procedures private  function U128_TrailingZeros(U128) result(NumTZ) To count the number of trailing zero bits. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\trailz~2.html"},{"title":"POPCNT – FortCharConv","text":"public interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumBits = POPCNT(INPUT) Module Procedures private  function U128_Count1Bits(U128) result(NumBits) To count the number of 1 bits in the specified input. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\popcnt~2.html"},{"title":"POPPAR – FortCharConv","text":"public interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumPar = POPPAR(INPUT) Module Procedures private  function U128_Parity(U128) result(ParNum) To determine the parity of the specified input. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B)","tags":"","loc":"interface\\poppar~2.html"},{"title":"IBSET – FortCharConv","text":"public interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBSET(IN, Pos) Module Procedures private  function U128_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1. For more detail, see explanation of elemental intrinsic function 'IBSET'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( UInt128 )","tags":"","loc":"interface\\ibset~2.html"},{"title":"IBCLR – FortCharConv","text":"public interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCLR(IN, Pos) Module Procedures private  function U128_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0. For more detail, see explanation of elemental intrinsic function 'IBCLR'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( UInt128 )","tags":"","loc":"interface\\ibclr~2.html"},{"title":"IBCHNG – FortCharConv","text":"public interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCHNG(IN, Pos) Module Procedures private  function U128_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( UInt128 )","tags":"","loc":"interface\\ibchng~2.html"},{"title":"BTEST – FortCharConv","text":"public interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position is 0 (False) or 1 (True) (For more information, see detailed explanation of the intrinsic function) Usage : --->    Flag = BTEST(IN, Pos) Module Procedures private  function U128_TestBit(U128, Pos) result(Flag) To check whether the bit at the specified position is 0 (False) or 1 (True). For more detail, see explanation of elemental intrinsic function 'BTEST'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 integer(kind=I4B), intent(in) :: Pos Return Value logical","tags":"","loc":"interface\\btest~2.html"},{"title":"IBITS – FortCharConv","text":"public interface IBITS Function Interface : IBITS Purpose :  To extract a sequence of bits according to the specified input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBITS(IN, Pos, Len) Module Procedures private  function U128_ExtractBits(InVal, Pos, Len) result(OutVal) To extract a sequence of bits according to the specified input. For more detail, see explanation of elemental intrinsic function 'IBITS'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos integer(kind=I4B), intent(in) :: Len Return Value type( UInt128 )","tags":"","loc":"interface\\ibits~2.html"},{"title":"MoveBits – FortCharConv","text":"public interface MoveBits Subroutine Interface : MoveBits Purpose :  To copy a sequence of bits (a bit field) from one location to another (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS') Usage : --->    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos) Module Procedures private  subroutine U128_MoveBits(InVal, InPos, Len, OutVal, OutPos) To copy a sequence of bits (a bit field) from one location to another. For more detail, see explanation of elemental intrinsic subroutine 'MVBITS'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: InPos integer(kind=I4B), intent(in) :: Len type( UInt128 ), intent(inout) :: OutVal integer(kind=I4B), intent(in) :: OutPos","tags":"","loc":"interface\\movebits~2.html"},{"title":"Display – FortCharConv","text":"public interface Display Subroutine Interface : Display Purpose :  To write/display the 'UInt128' object to the screen (or the specified unit) Usage : To display (unsigned) value of U128 as a decimal string to the screen --->    CALL Display(U128) To display (unsigned) value of U128 as a decimal string to the output logical unit --->    CALL Display(U128, 11) To display (unsigned) value of U128 as a decimal string to the output logical unit with input/output status and message --->    CALL Display(U128, 11, IOStat, IOMsg) To display (signed) values of components of U128 as a decimal string to the screen --->    CALL Display(U128, ShowComponent=.TRUE.) To display (unsigned) value of U128 as a decimal string to the screen with a prefix string --->    CALL Display(U128, Prefix='Unsigned value of U128') Module Procedures private  subroutine U128_Write(U128, Unit, IOStat, IOMsg, ShowComponent, Prefix) To write 'UInt128' object to the screen (or the specified unit). Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 UInt128 object integer(kind=I4B), intent(in), optional :: Unit output logical unit integer(kind=I4B), intent(out), optional :: IOStat io stat character(len=*), intent(out), optional :: IOMsg io message logical, intent(in), optional :: ShowComponent flag indicating whether to show components or not if flag is present and true, write compoents of the object otherwise, write the object as a decimal string character(len=*), intent(in), optional :: Prefix prefix string","tags":"","loc":"interface\\display~2.html"},{"title":"DisplayWarningError – FortCharConv","text":"public  subroutine DisplayWarningError(ErrorMessage, OutUnit) To display a 'Warning Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit Source Code SUBROUTINE DisplayWarningError ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a 'Warning Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DisplayErrorMessage ( ' ++ WARNING ++ : ' // ErrorMessage , OutUnit ) RETURN END SUBROUTINE DisplayWarningError","tags":"","loc":"proc\\displaywarningerror.html"},{"title":"DisplayFatalError – FortCharConv","text":"public  subroutine DisplayFatalError(ErrorMessage, OutUnit) To display a 'Fatal Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit Source Code SUBROUTINE DisplayFatalError ( ErrorMessage , OutUnit ) !** URPOSE OF THIS SUBROUTINE: !&#94; To display a 'Fatal Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ! display message CALL DisplayErrorMessage ( ' ++ FATAL ++ : ' // ErrorMessage , OutUnit ) ! set flag FatalError = TrueVal RETURN END SUBROUTINE DisplayFatalError","tags":"","loc":"proc\\displayfatalerror.html"},{"title":"DisplaySevereError – FortCharConv","text":"public  subroutine DisplaySevereError(ErrorMessage, OutUnit) To display a 'Severe Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit Source Code SUBROUTINE DisplaySevereError ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a 'Severe Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DisplayErrorMessage ( ' ++ SEVERE ++ : ' // ErrorMessage , OutUnit ) RETURN END SUBROUTINE DisplaySevereError","tags":"","loc":"proc\\displaysevereerror.html"},{"title":"DisplayContinueError – FortCharConv","text":"public  subroutine DisplayContinueError(ErrorMessage, OutUnit) To display a 'Continued Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit Source Code SUBROUTINE DisplayContinueError ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a 'Continued Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ! display message CALL DisplayErrorMessage ( ' +++++ : ' // ErrorMessage , OutUnit ) ! check error flags IF ( StopOnError . AND . FatalError ) THEN CALL AbortProgram ( OutUnit ) ELSE ! reset flag FatalError = FalseVal END IF RETURN END SUBROUTINE DisplayContinueError","tags":"","loc":"proc\\displaycontinueerror.html"},{"title":"DisplayMessage – FortCharConv","text":"public  subroutine DisplayMessage(Message, OutUnit) To display a (informative) message on designated output Files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Message integer(kind=I4B), intent(inout), optional :: OutUnit Source Code SUBROUTINE DisplayMessage ( Message , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a (informative) message on designated output Files. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: Message INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DisplayErrorMessage ( Message , OutUnit ) RETURN END SUBROUTINE DisplayMessage","tags":"","loc":"proc\\displaymessage.html"},{"title":"CloseErrorFile – FortCharConv","text":"public  subroutine CloseErrorFile() This subroutine closes the general error file. Arguments None Source Code SUBROUTINE CloseErrorFile !** PURPOSE OF THIS SUBROUTINE: !&#94; This subroutine closes the general error file. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: ! na !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: LOGICAL :: FileOpened INTEGER ( KIND = I4B ) :: IOS INTEGER ( KIND = I4B ) :: ErrorUnit !** FLOW INQUIRE ( FILE = ErrFilename , OPENED = FileOpened , IOStat = IOS ) IF ( FileOpened . AND .( IOS == 0 )) THEN ! get existing unit number for the opened file INQUIRE ( FILE = ErrFilename , NUMBER = ErrorUnit ) ! then close the General Error Report file CLOSE ( ErrorUnit ) END IF RETURN END SUBROUTINE CloseErrorFile","tags":"","loc":"proc\\closeerrorfile.html"},{"title":"AbortProgram – FortCharConv","text":"public  subroutine AbortProgram(OutUnit) This subroutine causes the program to halt due to a fatal error. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), optional :: OutUnit Source Code SUBROUTINE AbortProgram ( OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This subroutine causes the program to halt due to a fatal error. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: CHARACTER ( LEN = :), ALLOCATABLE :: StopMessage !** FLOW StopMessage = 'XPFC Terminated -- Fatal Error(s) Detected.' CALL DisplayMessage ( StopMessage , OutUnit ) CALL CloseMiscOpenFiles () STOP 'Program Terminated -- Error(s) Detected.' RETURN END SUBROUTINE AbortProgram","tags":"","loc":"proc\\abortprogram.html"},{"title":"SetStopOnError – FortCharConv","text":"public  subroutine SetStopOnError(Flag) To set StopOnError flag (module variable). Arguments Type Intent Optional Attributes Name logical, intent(in) :: Flag Source Code SUBROUTINE SetStopOnError ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set StopOnError flag (module variable). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: LOGICAL , INTENT ( IN ) :: Flag ! true if requesting termination of the program due to fatal error(s) !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW StopOnError = Flag RETURN END SUBROUTINE SetStopOnError","tags":"","loc":"proc\\setstoponerror.html"},{"title":"CloseMiscOpenFiles – FortCharConv","text":"public  subroutine CloseMiscOpenFiles() This subroutine scans potential Unit numbers and closes\n  any that are still open. Arguments None Source Code SUBROUTINE CloseMiscOpenFiles !** PURPOSE OF THIS SUBROUTINE: !&#94; This subroutine scans potential Unit numbers and closes !   any that are still open. !** METHODOLOGY EMPLOYED: ! Use INQUIRE to determine if file is open. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: ! na !** SUBROUTINE PARAMETER DEFINITIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxUnitNumber = 1000 !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: LOGICAL :: EXIST , OPENED INTEGER ( KIND = I4B ) :: UnitNumber INTEGER ( KIND = I4B ) :: IOS !** FLOW DO UnitNumber = 1 , MaxUnitNumber INQUIRE ( Unit = UnitNumber , EXIST = EXIST , OPENED = OPENED , IOStat = IOS ) IF ( EXIST . AND . OPENED . AND .( IOS == 0 )) CLOSE ( UnitNumber ) END DO RETURN END SUBROUTINE CloseMiscOpenFiles","tags":"","loc":"proc\\closemiscopenfiles.html"},{"title":"I32_FromChar_CC_FortNum – FortCharConv","text":"public  function I32_FromChar_CC_FortNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a Fortran number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number Source Code FUNCTION I32_FromChar_CC_FortNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a Fortran number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for leading zero(s) Number = 0 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_CC_FortNum","tags":"","loc":"proc\\i32_fromchar_cc_fortnum.html"},{"title":"I32_FromChar_CC_FortPlus – FortCharConv","text":"public  function I32_FromChar_CC_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number Source Code FUNCTION I32_FromChar_CC_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for leading zero(s) Number = 0 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_CC_FortPlus","tags":"","loc":"proc\\i32_fromchar_cc_fortplus.html"},{"title":"I32_FromChar_CC_JsonNum – FortCharConv","text":"public  function I32_FromChar_CC_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number Source Code FUNCTION I32_FromChar_CC_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN IF ( Indx == StrLen ) THEN Number = 0 ELSE CurChr => cStr ( Indx + 1 : Indx + 1 ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 ELSE Number = 0 END IF END IF RETURN END IF ! compute value of the input string Number = 0 IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_CC_JsonNum","tags":"","loc":"proc\\i32_fromchar_cc_jsonnum.html"},{"title":"I32_FromChar_Lemire_FortPlus – FortCharConv","text":"public  function I32_FromChar_Lemire_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number Source Code FUNCTION I32_FromChar_Lemire_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IndxP7 INTEGER ( KIND = I4B ) :: Sign , StrLen INTEGER ( KIND = I4B ) :: IStart , NumDigit CHARACTER ( LEN = 1 ), POINTER :: CurChr CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! initialize Number = 0 IStart = 0 NumDigit = 0 ! process 8 digits immediately if possible IndxP7 = Indx + 7 IF ( IndxP7 <= StrLen ) THEN wStr = cStr ( Indx : IndxP7 ) IF ( Is_Made_Of_Eight_Digits ( WVal )) THEN ! process 8 digits at once Number = INT ( Parse_Eight_Digits_Unrolled ( wVal ), KIND = I4B ) IStart = Indx NumDigit = 8 Indx = Indx + 8 END IF END IF ! process the remaining digits IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( IStart == 0 ) IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_Lemire_FortPlus","tags":"","loc":"proc\\i32_fromchar_lemire_fortplus.html"},{"title":"I32_FromChar_YY_JsonNum – FortCharConv","text":"public  function I32_FromChar_YY_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number Source Code FUNCTION I32_FromChar_YY_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: ! Digit: '0' INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_ZERO = SHIFTL ( 1 , 0 ) ! 1 = Z'01' ! Digit: [1-9] INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_NONZERO = SHIFTL ( 1 , 1 ) ! 2 = Z'02' ! Digit type table (generate with misc/make_tables.c) INTEGER ( KIND = I1B ), PARAMETER :: DigitTable ( 0 : 127 ) = [ & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '04' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '08' , KIND = I1B ), INT ( Z '10' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '01' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IVal , Add INTEGER ( KIND = I4B ) :: Indx , StrLen , I INTEGER ( KIND = I4B ) :: Sign , SignBit INTEGER ( KIND = I4B ) :: CurCode ! ASCII code of current character LOGICAL ( KIND = 4 ) :: Digit_End , Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether first digit is zero ! < for JSON number, the first digit being zero is not allowed. > CurCode = IACHAR ( cStr ( Indx : Indx )) IF (. NOT .( IAND ( DigitTable ( CurCode ), DIGI_TYPE_NONZERO ) /= 0 )) THEN IF ( CurCode == A0 ) THEN IF ( Indx + 1 > StrLen ) THEN Number = 0 ELSE IF (. NOT .( IAND ( DigitTable ( IACHAR ( cStr ( Indx + 1 : Indx + 1 ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Number = 0 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 END IF END IF ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 END IF RETURN END IF ! compute IVal for the next 8 characters (digits) IVal = CurCode - A0 I = 1 !DIR$ UNROLL = 8 DO IF ( Indx + I <= StrLen ) THEN CurCode = IACHAR ( cStr ( Indx + I : Indx + I )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN IVal = IVal * LBase + ( CurCode - A0 ) ELSE Digit_End = TrueVal EXIT END IF ELSE Digit_End = TrueVal EXIT END IF I = I + 1 IF ( I > 8 ) THEN Digit_End = FalseVal EXIT END IF END DO IF (( Digit_End ). OR .( Indx + I > StrLen )) THEN Number = INT ( IVal * Sign , KIND = I4B ) RETURN END IF ! deal with more digit(s) Indx = Indx + I CurCode = IACHAR ( cStr ( Indx : Indx )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN ! must check overflow Add = CurCode - A0 ! check overflow IF ( IVal < MaxI32Div10 ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN IF (( IAND ( DigitTable ( IACHAR ( cStr ( Indx : Indx ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF ELSE Overflow = FalseVal END IF ELSEIF ( IVal > MaxI32Div10 ) THEN Overflow = TrueVal ELSE ! IVal is equal to MaxI32Div10 SignBit = 0 IF ( Sign == - 1 ) SignBit = 1 IF ( Add > MaxI32Mod10 + SignBit ) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF END IF IF ( Overflow ) THEN ! overflow IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE ! not overflow IVal = IVal * LBase + Add Number = INT ( IVal * Sign , KIND = I4B ) END IF ELSE ! not overflow Number = INT ( IVal * Sign , KIND = I4B ) END IF RETURN END FUNCTION I32_FromChar_YY_JsonNum","tags":"","loc":"proc\\i32_fromchar_yy_jsonnum.html"},{"title":"I64_FromChar_CC_FortNum – FortCharConv","text":"public  function I64_FromChar_CC_FortNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a Fortran number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number Source Code FUNCTION I64_FromChar_CC_FortNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a Fortran number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_CC_FortNum","tags":"","loc":"proc\\i64_fromchar_cc_fortnum.html"},{"title":"I64_FromChar_CC_FortPlus – FortCharConv","text":"public  function I64_FromChar_CC_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number Source Code FUNCTION I64_FromChar_CC_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_CC_FortPlus","tags":"","loc":"proc\\i64_fromchar_cc_fortplus.html"},{"title":"I64_FromChar_CC_JsonNum – FortCharConv","text":"public  function I64_FromChar_CC_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number Source Code FUNCTION I64_FromChar_CC_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN IF ( Indx == StrLen ) THEN Number = 0_I8B ELSE CurChr => cStr ( Indx + 1 : Indx + 1 ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 ELSE Number = 0_I8B END IF END IF RETURN END IF ! compute value of the input string Number = 0_I8B IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_CC_JsonNum","tags":"","loc":"proc\\i64_fromchar_cc_jsonnum.html"},{"title":"I64_FromChar_Lemire_FortPlus – FortCharConv","text":"public  function I64_FromChar_Lemire_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number Source Code FUNCTION I64_FromChar_Lemire_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IndxP7 , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: IStart , NumDigit CHARACTER ( LEN = 1 ), POINTER :: CurChr CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! initialize Number = 0_I8B IStart = 0 NumDigit = 0 ! process 8 digits immediately if possible IndxP7 = Indx + 7 IF ( IndxP7 <= StrLen ) THEN wStr = cStr ( Indx : IndxP7 ) IF ( Is_Made_Of_Eight_Digits ( WVal )) THEN ! process 8 digits at once Number = Parse_Eight_Digits_Unrolled ( wVal ) IStart = Indx NumDigit = 8 Indx = Indx + 8 ! process another 8 digits immediately if possible IndxP7 = Indx + 7 IF ( IndxP7 <= StrLen ) THEN wStr = cStr ( Indx : IndxP7 ) IF ( Is_Made_Of_Eight_Digits ( WVal )) THEN ! process 8 digits at once Number = Number * 100000000_I8B + Parse_Eight_Digits_Unrolled ( wVal ) NumDigit = 16 Indx = Indx + 8 END IF END IF END IF END IF ! process the remaining digits IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( IStart == 0 ) IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_Lemire_FortPlus","tags":"","loc":"proc\\i64_fromchar_lemire_fortplus.html"},{"title":"I64_FromChar_YY_JsonNum – FortCharConv","text":"public  function I64_FromChar_YY_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number Source Code FUNCTION I64_FromChar_YY_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: ! Digit: '0' INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_ZERO = SHIFTL ( 1 , 0 ) ! 1 = Z'01' ! Digit: [1-9] INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_NONZERO = SHIFTL ( 1 , 1 ) ! 2 = Z'02' ! Digit type table (generate with misc/make_tables.c) INTEGER ( KIND = I1B ), PARAMETER :: DigitTable ( 0 : 127 ) = [ & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '04' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '08' , KIND = I1B ), INT ( Z '10' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '01' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IVal , Add INTEGER ( KIND = I4B ) :: Indx , StrLen , I INTEGER ( KIND = I8B ) :: Sign , SignBit INTEGER ( KIND = I4B ) :: CurCode ! ASCII code of current character LOGICAL :: Digit_End , Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether first digit is zero ! < for JSON number, the first digit being zero is not allowed. > CurCode = IACHAR ( cStr ( Indx : Indx )) IF (. NOT .( IAND ( DigitTable ( CurCode ), DIGI_TYPE_NONZERO ) /= 0 )) THEN IF ( CurCode == A0 ) THEN IF ( Indx + 1 > StrLen ) THEN Number = 0_I8B ELSE IF (. NOT .( IAND ( DigitTable ( IACHAR ( cStr ( Indx + 1 : Indx + 1 ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Number = 0_I8B ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 END IF END IF ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 END IF RETURN END IF ! compute IVal for the next 17 characters (digits) IVal = INT ( CurCode - A0 , KIND = I8B ) I = 1 !DIR$ UNROLL = 17 DO IF ( Indx + I <= StrLen ) THEN CurCode = IACHAR ( cStr ( Indx + I : Indx + I )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN IVal = IVal * LBase + INT ( CurCode - A0 , KIND = I8B ) ELSE Digit_End = TrueVal EXIT END IF ELSE Digit_End = TrueVal EXIT END IF I = I + 1 IF ( I > 17 ) THEN Digit_End = FalseVal EXIT END IF END DO IF (( Digit_End ). OR .( Indx + I > StrLen )) THEN Number = IVal * Sign RETURN END IF ! deal with more digit(s) Indx = Indx + I CurCode = IACHAR ( cStr ( Indx : Indx )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN ! must check overflow Add = INT ( CurCode - A0 , KIND = I8B ) ! check overflow IF ( IVal < MaxI64Div10 ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN IF (( IAND ( DigitTable ( IACHAR ( cStr ( Indx : Indx ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF ELSE Overflow = FalseVal END IF ELSEIF ( IVal > MaxI64Div10 ) THEN Overflow = TrueVal ELSE ! IVal is equal to MaxI64Div10 SignBit = 0_I8B IF ( Sign == - 1_I8B ) SignBit = 1_I8B IF ( Add > MaxI64Mod10 + SignBit ) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF END IF IF ( Overflow ) THEN ! overflow IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE ! not overflow IVal = IVal * LBase + Add Number = IVal * Sign END IF ELSE ! no overflow Number = IVal * Sign END IF RETURN END FUNCTION I64_FromChar_YY_JsonNum","tags":"","loc":"proc\\i64_fromchar_yy_jsonnum.html"},{"title":"RealQP_ToString_DragonBox – FortCharConv","text":"public  function RealQP_ToString_DragonBox(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: Number logical, intent(in), optional :: IsScientific Return Value character(len=:), ALLOCATABLE Source Code FUNCTION RealQP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a quadruple-precision floating-point value to a character (decimal) string ! using the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Number ! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawBin ! raw IEEE binary floating point representation TYPE ( UInt128 ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) INTEGER ( KIND = I8B ) :: IntVal ( 2 ) ! working integers (for conversion to binary representation) REAL ( KIND = QP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( IntVal , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 60 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number RawBin = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= ZeroU128 SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = ToI32 ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits )) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == ZeroU128 )) THEN ! zero SigDec = ZeroU128 ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealQP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealQP_ToString_DragonBox","tags":"","loc":"proc\\realqp_tostring_dragonbox.html"},{"title":"RealQP_ToString_Ryu – FortCharConv","text":"public  function RealQP_ToString_Ryu(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: Number logical, intent(in), optional :: IsScientific Return Value character(len=:), ALLOCATABLE Source Code FUNCTION RealQP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a quadruple-precision floating-point value to a character (decimal) string ! using the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Number ! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawBin ! raw IEEE binary floating point representation TYPE ( UInt128 ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) INTEGER ( KIND = I8B ) :: IntVal ( 2 ) ! working integers (for conversion to binary representation) REAL ( KIND = QP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( IntVal , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 60 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number RawBin = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= ZeroU128 SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = ToI32 ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits )) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == ZeroU128 )) THEN ! zero SigDec = ZeroU128 ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealQP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealQP_ToString_Ryu","tags":"","loc":"proc\\realqp_tostring_ryu.html"},{"title":"RealQP_ToString_Schubfach – FortCharConv","text":"public  function RealQP_ToString_Schubfach(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: Number logical, intent(in), optional :: IsScientific Return Value character(len=:), ALLOCATABLE Source Code FUNCTION RealQP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a quadruple-precision floating-point value to a character (decimal) string ! using the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Number ! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawBin ! raw IEEE binary floating point representation TYPE ( UInt128 ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) INTEGER ( KIND = I8B ) :: IntVal ( 2 ) ! working integers (for conversion to binary representation) REAL ( KIND = QP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( IntVal , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 60 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number RawBin = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= ZeroU128 SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = ToI32 ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits )) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == ZeroU128 )) THEN ! zero SigDec = ZeroU128 ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealQP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealQP_ToString_Schubfach","tags":"","loc":"proc\\realqp_tostring_schubfach.html"},{"title":"RealQP_FromString_FastFloat – FortCharConv","text":"public  function RealQP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) Source Code FUNCTION RealQP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the FastFloat algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using FastFloat algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , Aux % Truncated , Aux % Indices , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_FastFloat","tags":"","loc":"proc\\realqp_fromstring_fastfloat.html"},{"title":"RealQP_FromString_LibC – FortCharConv","text":"public  function RealQP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) Source Code FUNCTION RealQP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the LibC algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using LibC algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_LibC ( SigDec , ExpDec , cStr , Aux % Start , Aux % Truncated , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_LibC","tags":"","loc":"proc\\realqp_fromstring_libc.html"},{"title":"RealQP_FromString_YY – FortCharConv","text":"public  function RealQP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) Source Code FUNCTION RealQP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the YY algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using YY's algorithm +++ RawVal = Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_YY","tags":"","loc":"proc\\realqp_fromstring_yy.html"},{"title":"RealQP_FromString_Lemire – FortCharConv","text":"public  function RealQP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) Source Code FUNCTION RealQP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the Lemire algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using Lemire's algorithm +++ RawVal = Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_Lemire","tags":"","loc":"proc\\realqp_fromstring_lemire.html"},{"title":"ModBase_Integer_ToChar – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains routines that convert an integer value into a decimal string. REFERENCES : [1] Number Conversion Benchmark in C [2] itoa - Fast integer to ascii / integer to string conversion Uses ModBase_Common ModBase_UIntUtil ModBase_Tables_CharConv Functions public  function I32_ToChar_Basic (Number) result(cStr) To convert a 32-bit integer to a decimal string using basic (naive) algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I32_ToChar_CC (Number) result(cStr) To convert a 32-bit integer to a decimal string using CC algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I32_ToChar_YY (Number) result(cStr) To convert a 32-bit integer to a decimal string using YY algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I32_ToChar_YYLL (Number) result(cStr) To convert a 32-bit integer to a decimal string using YY algorithm with large table Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I32_ToChar_JEA (Number) result(cStr) To convert a 32-bit integer to a decimal string using JEA algorithm Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I64_ToChar_Basic (Number) result(cStr) To convert a 64-bit integer to a decimal string using basic (naive) algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I64_ToChar_CC (Number) result(cStr) To convert a 64-bit integer to a decimal string using CC algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I64_ToChar_YY (Number) result(cStr) To convert a 64-bit integer to a decimal string using YY algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I64_ToChar_YYLL (Number) result(cStr) To convert a 64-bit integer to a decimal string using YY algorithm with large table Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public  function I64_ToChar_JEA (Number) result(cStr) To convert a 64-bit integer to a decimal string using JEA algorithm Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE","tags":"","loc":"module\\modbase_integer_tochar.html"},{"title":"ModBase_Common – FortCharConv","text":"PURPOSE OF THIS MODULE : contains parameters and derived types commonly used Uses iso_fortran_env iso_c_binding Variables Type Visibility Attributes Name Initial integer, public, parameter :: I8B = INT64 kind for 64-bit or 8-byte integer integer, public, parameter :: I4B = INT32 kind for 32-bit or 4-byte integer integer, public, parameter :: I2B = INT16 kind for 16-bit or 2-byte integer integer, public, parameter :: I1B = INT8 kind for  8-bit or 1-byte integer integer, public, parameter :: QP = REAL128 kind for 128-bit floating point (real) number integer, public, parameter :: DP = REAL64 kind for  64-bit floating point (real) number integer, public, parameter :: SP = REAL32 kind for  32-bit floating point (real) number logical, public, parameter :: TrueVal = .TRUE. logical, public, parameter :: FalseVal = .FALSE. integer, public, parameter :: IP = I4B kind of indices integer, public, parameter :: FP = DP kind of default floating point (real) number integer, public, parameter :: Degree = 1 integer, public, parameter :: Radian = 2 real(kind=FP), public, parameter :: Zero = 0.0_FP real(kind=FP), public, parameter :: One = 1.0_FP real(kind=FP), public, parameter :: Two = 2.0_FP real(kind=FP), public, parameter :: Three = 3.0_FP real(kind=FP), public, parameter :: Four = 4.0_FP real(kind=FP), public, parameter :: Five = 5.0_FP real(kind=FP), public, parameter :: Six = 6.0_FP real(kind=FP), public, parameter :: Seven = 7.0_FP real(kind=FP), public, parameter :: Eight = 8.0_FP real(kind=FP), public, parameter :: Nine = 9.0_FP real(kind=FP), public, parameter :: Ten = 10.0_FP real(kind=FP), public, parameter :: Hundred = 100.0_FP real(kind=FP), public, parameter :: Thousand = 1000.0_FP real(kind=FP), public, parameter :: Million = 1000000.0_FP real(kind=FP), public, parameter :: Billion = 1000000000.0_FP real(kind=FP), public, parameter :: Quater = 0.25_FP real(kind=FP), public, parameter :: Half = 0.5_FP real(kind=FP), public, parameter :: ThreeQuater = 0.75_FP real(kind=FP), public, parameter :: OneThird = One/Three real(kind=FP), public, parameter :: TwoThird = Two/Three real(kind=FP), public, parameter :: Pi = 3.141592653589793238462643383279502884197169399375105820974944592307_FP real(kind=FP), public, parameter :: PiOvr2 = Half*Pi real(kind=FP), public, parameter :: Pi3Ovr2 = 1.5_FP*Pi real(kind=FP), public, parameter :: TwoPi = Two*Pi real(kind=FP), public, parameter :: Zero01 = 1.0E-1_FP real(kind=FP), public, parameter :: Zero02 = 1.0E-2_FP real(kind=FP), public, parameter :: Zero03 = 1.0E-3_FP real(kind=FP), public, parameter :: Zero04 = 1.0E-4_FP real(kind=FP), public, parameter :: Zero05 = 1.0E-5_FP real(kind=FP), public, parameter :: Zero06 = 1.0E-6_FP real(kind=FP), public, parameter :: Zero07 = 1.0E-7_FP real(kind=FP), public, parameter :: Zero08 = 1.0E-8_FP real(kind=FP), public, parameter :: Zero09 = 1.0E-9_FP real(kind=FP), public, parameter :: Zero10 = 1.0E-10_FP real(kind=FP), public, parameter :: Zero11 = 1.0E-11_FP real(kind=FP), public, parameter :: Zero12 = 1.0E-12_FP real(kind=FP), public, parameter :: Zero13 = 1.0E-13_FP real(kind=FP), public, parameter :: Zero14 = 1.0E-14_FP real(kind=FP), public, parameter :: Zero15 = 1.0E-15_FP real(kind=FP), public, parameter :: Zero16 = 1.0E-16_FP real(kind=FP), public, parameter :: Zero17 = 1.0E-17_FP real(kind=FP), public, parameter :: MachineEps = EPSILON(One) machine epsilon real(kind=FP), public, parameter :: Small = TINY(One) the smallest positive number real(kind=FP), public, parameter :: Large = HUGE(One) the largest positive number real(kind=FP), public, parameter :: SqrtEps = SQRT(MachineEps) square root of MachineEps integer(kind=I1B), public, parameter :: Huge_I1B = HUGE(1_I1B) = 127 integer(kind=I2B), public, parameter :: Huge_I2B = HUGE(1_I2B) = 32767 integer(kind=I4B), public, parameter :: Huge_I4B = HUGE(1_I4B) = 2147483647 integer(kind=I8B), public, parameter :: Huge_I8B = HUGE(1_I8B) = 9223372036854775807 real(kind=SP), public, parameter :: Huge_RSP = HUGE(1.0_SP) = 3.4028235E+38 real(kind=DP), public, parameter :: Huge_RDP = HUGE(1.0_DP) = 1.797693134862316E+308 real(kind=QP), public, parameter :: Huge_RQP = HUGE(1.0_QP) = 1.189731495357231765085759326628007E+4932 real(kind=SP), public, parameter :: Tiny_RSP = TINY(1.0_SP) = 1.1754944E-38 real(kind=DP), public, parameter :: Tiny_RDP = TINY(1.0_DP) = 2.225073858507201E-308 real(kind=QP), public, parameter :: Tiny_RQP = TINY(1.0_QP) = 3.362103143112093506262677817321753E-4932 real(kind=SP), public, parameter :: Eps_RSP = EPSILON(1.0_SP) = 1.1920929E-07 real(kind=DP), public, parameter :: Eps_RDP = EPSILON(1.0_DP) = 2.220446049250313E-016 real(kind=QP), public, parameter :: Eps_RQP = EPSILON(1.0_QP) = 1.925929944387235853055977942584927E-0034 character(len=*), public, parameter :: LibName = \"XPFLib\" library name Derived Types type, public :: Equation an equation type that can be used to parse strings/texts expressing\n  mathematical expressions to 'FunctionParser' so that a system of\n  equations can be evaluated at runtime. Components Type Visibility Attributes Name Initial integer(kind=IP), public :: NEQ number of equations integer(kind=IP), public :: NVR number of variables character(len=256), public, ALLOCATABLE :: EQText (:) texts expressing equations character(len=30), public, ALLOCATABLE :: VarText (:) texts expressing variable names real(kind=FP), public, ALLOCATABLE :: Values (:) values of variables type, public :: UserParam a user parameter type used to modernize legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public :: NR number of real parameters integer(kind=IP), public :: NI number of integer parameters real(kind=FP), public, ALLOCATABLE :: RPar (:) real parameters integer(kind=IP), public, ALLOCATABLE :: IPar (:) integer parameters type, public :: WorkSpace a workspace type used to modernize legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public :: LRW number of real workspace variables integer(kind=IP), public :: LIW number of integer workspace variables real(kind=FP), public, ALLOCATABLE :: RVar (:) real workspace variables integer(kind=IP), public, ALLOCATABLE :: IVar (:) integer workspace variables type, public :: SharePar a share parameter type used to modernize common block of legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public, LEN :: NR number of real and integer parameters integer(kind=IP), public, LEN :: NI number of real and integer parameters real(kind=FP), public :: RPar (NR) real parameters integer(kind=IP), public :: IPar (NI) integer parameters type, public :: SaveVar a saved variable type used to modernize legacy code Components Type Visibility Attributes Name Initial integer(kind=IP), public, LEN :: NR number of real, integer and logical parameters integer(kind=IP), public, LEN :: NL number of real, integer and logical parameters real(kind=FP), public :: RVar (NR) number of real parameters integer(kind=IP), public :: IVar (NI) number of integer parameters logical, public :: LVar (NL) number of logical parameters type, public :: Container container type that utilize 'c' pointer (C_PTR) type Components Type Visibility Attributes Name Initial type(C_PTR), public :: Store = C_NULL_PTR","tags":"","loc":"module\\modbase_common.html"},{"title":"ModBase_RealDP_CharConv – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains routines that perform a conversion between a 64-bit\n  floating point number and a string. REFERENCE TECHNICAL ARTICLES : [1]  Junekey Jeon. Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm [2]  Ulf Adams. Ryu: Fast Float-to-String Conversion [3]  Raffaello Giulietti. The Schubfach way to render doubles [4]  Clinger WD. How to Read Floating Point Numbers Accurately ,\n  SIGPLAN Not 2004 Apr;39(4):360–371. [5]  Daniel Lemire. Number Parsing at a Gigabyte per Second ,\n  Software: Practice and Experience 51 (8), 2021. [6]  Noble Mushtak and Daniel Lemire. Fast Number Parsing Without Fallback ,\n  Software: Practice and Experience 53 (7), 2023. [7]  Bouvier & Zimmermann. Division-Free Binary-to-Decimal Conversion [8]  Hacker's Delight, 2nd Edition. [9]  Nigel Tao. The Eisel-Lemire ParseNumberF64 Algorithm [10] Nigel Tao. ParseNumberF64 by Simple Decimal Conversion REFERENCE CODE IMPLEMENTATION : [11] DragonBox: C++ reference implementation [12] Ryu: C reference implementation [13] Schubfach: Java reference implementation [14] Drachennest: Different algorithms for converting binary to decimal floating-point numbers [15] Number Conversion Benchmark in C [16] fast_float number parsing library: 4x faster than strtod [17] fast_double_parser: 4x faster than strtod [18] The LLVM Project: LibC Support [19] Double Conversion: Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles [20] fmt: A modern formatting library TECHNICAL AND IMPLEMENTATION NOTES : On the output to string : 1) Three routines are available to convert a real (floating-point) number into a string. - \"RealToString_DragonBox\" is based on the Dragonbox binary-to-decimal conversion algorithm [1]\n     and the reference implementation [11, 14, 20] - \"RealToString_Ryu\" is based on the Ryu binary-to-decimal conversion algorithm [2]\n     and the reference implementation [12, 14] - \"RealToString_Schubfach\" is based on the Schubfach binary-to-decimal conversion algorithm [3]\n     and the reference implementation [13, 14, 15] 2) All three binary-to-decimal conversion algorithms employed here produce the so-called shortest\n   output representation that provide an error-free write-read cycle.  This means that any correct\n   parsers (e.g. RealFromString routines) will read in the output string and return the original\n   real (floating-poing) number. 3) Although the DragonBox reference implementation provides several modes of rounding, only the\n   round-to-nearest mode is implemented here (the other two algorithms also use this mode). 4) Although the Ryu reference implementation provides several conversion output formats (Shortest,\n   Scientific, Fixed), only the shortest representation (as mentioned above) is implemented.\n   Therefore, all three routines will produces the output string in a format similar to \"G0\" format\n   specification in Fortran. 5) Actually, the RealToString routines have an optional \"format\" argument that we can use to specify\n   whether to output the string in \"General (G)\" or \"Scientific (ES)\" format.  However, because they\n   always produce the shortest output, no input argument to the routines is provided to specify\n   the desired number of significant digits as typically done in Fortran format specifications. On the input from string : 1) Four routines are available to convert a string into a real (floating-point) number.  All four\n   routines utilize the so-call Clinger's fast-path algorithm [4].  Three of them (except \"YY\") employ\n   the so-call Eisel-Lemire decimal-to-binary conversion algorithm [5, 9] but are based on different\n   reference implementation.  When the Eisel-Lemire (or YY's fast-path) algorithm is NOT valid, three\n   of the routines (except \"LibC\") use multi-precision (unsigned) integer arithmetic (i.e. BigUInt)\n   whereas \"LibC\" employs the so-call Simple Decimal Conversion algorithm [10]. - \"RealFromString_FastFloat\" is based on the reference implementation [16] - \"RealFromString_LibC\" is based on the reference implementation [18] - \"RealFromString_YY\" is based on the reference implementation [15, 19] - \"RealFromString_Lemire\" is based on the reference implementation [17, 19] 2) The RealFromString routines have an optional \"parsing\" argument that we can use to specify how\n   the routines interpret the input string. 3) The \"Parse_Fortran_String\" routine is called when the optional \"parsing\" argument is not specified\n   (i.e. the default option) or \"FortNum (or 1)\" value is supplied as the parsing argument.  The routine\n   will interpret the input string as a valid Fortran real (floating point) number if it has one of\n   the two following forms: <1> A number without exponent part -> [S]N[N...] <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] where [ ] indicates an optional field S is a sign indicator (required if negative '-', optional if positive '+'). N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere\n          after the sign (but before the exponent). E is an exponent indicator (either 'e' or 'E') The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. - The optional kind parameter (e.g. 10.0_DP) is not allowed here. Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered\n   valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\"\n   is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement\n   where spaces inside the valid number are allowed. However, this can easily be done by adding an\n   optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or 'ignored'.\n   Then, the input will be pre-processed according to the flag.  Nonetheless, this routine neglects\n   this optional input because it will make the routine much less efficient due to the fact that\n   we will need to scan the whole string twice and we will also need to copy the input string into\n   a buffer string and working with the buffer instead of directly handling the input string. 4) The \"Parse_FPlus_String\" routine is called when \"FPlusNum (or 2)\" value is supplied as the parsing\n   argument.  The routine will parse a valid Fortran real (floating point) number with more relaxed\n   rules than those used in \"Parse_Fortran_Number\" routine. The relaxed rules consider the following\n   numbers as valid: - a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q'\n     in place of 'e' or 'E'. - a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to\n     be expressed in a valid number expressed in the scientific format. - digits before any invalid character encountered are treated as a valid number\n     and any characters after the first encounter (including the first invalid one)\n     are neglected.  therefore, for example, a '12.56ax-300' is considered to be\n     a valid number with a value of 12.56. 5) The \"Parse_JSON_String\" routine is called when \"JsonNum (or 3)\" value is supplied as the parsing\n   argument.  The routine will parse a valid JSON floating point number where its differences from\n   from Fortran number are as follows: - leading and trailing spaces are not allowed. - a plus sign as the first character is not allowed. - leading zero(s) is not allowed (if 0 is the first character, the second one\n     must either be a period or an exponent indicator.) - a period must be followed by at least one digit. USAGE : On the output to string : => cStr = RealXP_ToString_DragonBox(Number, IsScientific) => cStr = RealXP_ToString_Ryu(Number, IsScientific) => cStr = RealXP_ToString_Schubfach(Number, IsScientific) where \"cStr\" is an \"allocatable\" character string representing the output string \"Number\" is a real number representing the floating point value \"IsScientific\" is a logical flag (optional argument) indicating whether\n      the output string is in \"General\" or \"Scientific\" format. If present and true, the output string is in \"Scientific\" format. Otherwise, the output string is in \"General\" format. On the input from string : => Number = RealXP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) where \"Number\" is a real number representing the floating point value if the input string is valid \"cStr\" is a character string representing the floating-point number string \"ParseOpt\" is an integer input flag (optional) indicating how to interpret the input string.\n      The valid value is FortNum (1), FPlusNum (2) or JsonNum (3).\n      If not specified and invalid, the routines will interpret the input string as a Fortran number. \"ErrFlag\" is a logical output flag (optional) indicating whether there is an error in parsing\n      the input string.  True if the string represents a valid number.  False, otherwise. \"ErrMsg\" is an allocatable output character string (optional) that returns a message that describe\n      the result of parsing the input string. NOTE : \"XP\" in the routine names shown above indicate the precision of the real number.\n  The actual name will either be \"RealSP_...\", \"RealDP_...\" or \"RealQP_...\" for single-precision,\n  double-precision and quadruple-precision number, respectively. Uses ModBase_UIntUtil ieee_arithmetic ModBase_Common ModBase_UInt128 ModBase_Tables_CharConv ModBase_SIntUtil Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: FortNum = 1 strict fortran number integer(kind=I4B), public, parameter :: FPlusNum = 2 relaxed fortran number integer(kind=I4B), public, parameter :: JsonNum = 3 json number integer(kind=I8B), public, parameter :: MinSubnormal = 1_I8B minimum value of subnormal floating point number integer(kind=I8B), public, parameter :: MaxSubnormal = SHIFTL(1_I8B, SignificandBits)-1_I8B maximum value of subnormal floating point number integer(kind=I8B), public, parameter :: MinNormal = SHIFTL(1_I8B, SignificandBits) minimum value of normal floating point number integer(kind=I8B), public, parameter :: MaxNormal = IOR(SHIFTL(INT(MaxExponent-1, KIND=I8B), SignificandBits), MaxSubnormal) maximum value of normal floating point number Functions public  function RealDP_ToString_DragonBox (Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character (decimal) string\nusing the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string public  function RealDP_ToString_Ryu (Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character (decimal) string\nusing the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string public  function RealDP_ToString_Schubfach (Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character (decimal) string\nusing the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string public  function RealDP_FromString_FastFloat (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number public  function RealDP_FromString_LibC (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the LibC algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number public  function RealDP_FromString_YY (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the YY algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number public  function RealDP_FromString_Lemire (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision floating-point value\nusing the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=DP) floating point number","tags":"","loc":"module\\modbase_realdp_charconv.html"},{"title":"ModBase_SIntUtil – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains various utility routines relating to (signed) integers. Uses ModBase_Common Variables Type Visibility Attributes Name Initial integer(kind=I1B), public, parameter :: MAX_I8 = INT(Z'7F', KIND=I1B) 127 integer(kind=I2B), public, parameter :: MAX_I16 = INT(Z'7FFF', KIND=I2B) 32767 integer(kind=I4B), public, parameter :: MAX_I32 = INT(Z'7FFFFFFF', KIND=I4B) 2147483647 integer(kind=I8B), public, parameter :: MAX_I64 = INT(Z'7FFFFFFFFFFFFFFF', KIND=I8B) 9223372036854775807 integer(kind=I1B), public, parameter :: MIN_I8 = INT(Z'80', KIND=I1B) -128 integer(kind=I2B), public, parameter :: MIN_I16 = INT(Z'8000', KIND=I2B) -32768 integer(kind=I4B), public, parameter :: MIN_I32 = INT(Z'80000000', KIND=I4B) -2147483648 integer(kind=I8B), public, parameter :: MIN_I64 = INT(Z'8000000000000000', KIND=I8B) -9223372036854775808 Interfaces public        interface Compare Function Interface : Compare Purpose :  To compare two signed integers of the same kind and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething private pure function I8_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function I16_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function I32_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function I64_Compare(LHS, RHS) result(Flag) To compare LHS and RHS. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value integer(kind=I4B) public        interface HighestOneBit Function Interface : HighestOneBit Purpose :  To return an integer value (same kind as the specified integer value) with at most a single one-bit, in the position of the highest-order (leftmost) one-bit in the input. Usage : --->    OUTPUT = HighestOneBit(INPUT) private pure function I32_HighestOneBit(InVal) result(OutVal) To return an 32-bit integer value with at most a single one-bit, in the\nposition of the highest-order (leftmost) one-bit in the specified\n32-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_HighestOneBit(InVal) result(OutVal) To return an 64-bit integer value with at most a single one-bit, in the\nposition of the highest-order (leftmost) one-bit in the specified\n64-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B) public        interface LowestOneBit Function Interface : LowestOneBit Purpose :  To return an integer value (same kind as the specified integer value) with at most a single one-bit, in the position of the lowest-order (rightmost) one-bit in the input. Usage : --->    OUTPUT = LowestOneBit(INPUT) private pure function I32_LowestOneBit(InVal) result(OutVal) To return an 32-bit integer value with at most a single one-bit, in the\nposition of the lowest-order (rightmost) one-bit in the specified\n32-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_LowestOneBit(InVal) result(OutVal) To return an 64-bit integer value with at most a single one-bit, in the\nposition of the lowest-order (rightmost) one-bit in the specified\n64-bit integer value.  To return zero if the specified value has no\none-bits in its two's complement binary representation, that is, if it\nis equal to zero. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B) public        interface ReverseBits Function Interface : ReverseBits Purpose :  To return an integer value (same kind as the specified integer value) obtained by reversing the order of the bits in the two's complement binary representation of the input. Usage : --->    OUTPUT = ReverseBits(INPUT) private pure function I32_ReverseBits(InVal) result(OutVal) To return an 32-bit integer value obtained by reversing the order of the\nbits in the two's complement binary representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_ReverseBits(InVal) result(OutVal) To return an 64-bit integer value obtained by reversing the order of the\nbits in the two's complement binary representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B) public        interface ReverseBytes Function Interface : ReverseBits Purpose :  To return an integer value (same kind as the specified integer value) obtained by reversing the order of the bytes in the two's complement binary representation of the input. Usage : --->    OUTPUT = ReverseBytes(INPUT) private pure function I32_ReverseBytes(InVal) result(OutVal) To return an 32-bit integer value obtained by reversing the order of the\nbytes in the two's complement representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function I64_ReverseBytes(InVal) result(OutVal) To return an 64-bit integer value obtained by reversing the order of the\nbytes in the two's complement representation of the specified value. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: InVal Return Value integer(kind=I8B) public        interface SigNum Function Interface : SigNum Purpose :  To return the sign of the specified input where the return value is -1 if the specified value is negative 0 if the specified value is zero 1 if the specified value is positive Usage : --->    SignFlag = SigNum(INPUT) private pure function I32_SigNum(Val) result(Sign) To return the sign of the specified input where the return value is -1 if the specified value is negative 0 if the specified value is zero 1 if the specified value is positive. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val Return Value integer(kind=I4B) private pure function I64_SigNum(Val) result(Sign) To return the sign of the specified input where the return value is -1 if the specified value is negative 0 if the specified value is zero 1 if the specified value is positive. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Val Return Value integer(kind=I4B) public        interface ToHexStrSigned Function Interface : ToHexStrSigned Purpose :  To convert a signed integer to a hexadecimal string Usage : --->    Str = ToHexStrSigned(I32) private pure function I32_ToHexString(Number) result(cStr) To convert a signed 32-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE private pure function I64_ToHexString(Number) result(cStr) To convert a signed 64-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE public        interface ToDecStrSigned Function Interface : ToDecStrSigned Purpose :  To convert a signed integer to a decimal string Usage : --->    Str = ToDecStrSigned(I64) private  function I32_ToDecString(Number) result(cStr) To convert an integer number to decimal string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE private  function I64_ToDecString(Number) result(cStr) To convert an integer number to decimal string Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Functions public  function I32_FromChar (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number public  function I64_FromChar (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number","tags":"","loc":"module\\modbase_sintutil.html"},{"title":"ModBase_SInt128 – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains a derived type and basic operations for a 128-bit signed integer. The application interface (API) for the 128-bit signed integer follows Fortran intrinsic\n  integer types as close as practical.  Also, the implementation should provide behavior\n  closely similar to the behavior of Fortran intrinsic integer types. Important Note : (1) For arithmetic operations, various types of signed integer types (32-, 64- and 128-bit)\n   are allowed.  However, the use of signed and unsigned integers in the same operation is NOT\n   allowed.  Unsigned integer types must be explicitly converted to signed types before using\n   in the arithmetic operations. (2) For comparison and bitwise operations that require two input arguments, both arguments must\n   only be the 128-bit signed integer type.  All other types must be explicitly converted to\n   this type before using in the comparison and bitwise operations. REFERENCES : [1] Absl's Numeric Library [2] Fast 128-bit math library for Java [3] Extended precision integer C++ library Uses ModBase_UIntUtil ModBase_Error_Handlers ieee_arithmetic ModBase_Common iso_fortran_env ModBase_UInt128 ModBase_SIntUtil Variables Type Visibility Attributes Name Initial type( SInt128 ), public, parameter :: MaxI128 = SInt128(MaxI64, MaxU64) 128-bit signed parameter with maximum value type( SInt128 ), public, parameter :: MinI128 = SInt128(MinI64, MinU64) 128-bit signed parameter with minimum value type( SInt128 ), public, parameter :: OneI128 = SInt128(0_I8B, 1_I8B) 128-bit signed parameter with value of one type( SInt128 ), public, parameter :: ZeroI128 = SInt128(0_I8B, 0_I8B) 128-bit signed parameter with value of zero Interfaces public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a 128-bit signed integer and\n  other signed integers (32- and 64-bit integers) Usage : --->    I128 = OtherType private  subroutine I128_From_I32(I128, I32) To convert a signed 32-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(out) :: I128 integer(kind=I4B), intent(in) :: I32 number treated as signed private  subroutine I128_From_I64(I128, I64) To convert a signed 64-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(out) :: I128 integer(kind=I8B), intent(in) :: I64 number treated as signed private  subroutine I128_To_I32(I32, I128) To convert a signed 128-bit integer number to a signed 32-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(out) :: I32 number treated as signed type( SInt128 ), intent(in) :: I128 private  subroutine I128_To_I64(I64, I128) To convert a signed 128-bit integer number to a signed 64-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(out) :: I64 number treated as signed type( SInt128 ), intent(in) :: I128 public        interface SInt128 Constructor Interface : SInt128 Purpose :  To construct a 128-bit signed integer from\n  other Fortran intrinsic types or 32- and 64-bit unsigned integers Usage : --->    I128 = SInt128(IntrinsicType)   ! constructor for Fortran intrinsic types --->    I128 = SInt128(UType, Negative) ! 32- and 64-bit unsigned integers where I128 has negative value if 'Negative' is true Note :  The different between 32-bit signed (I32) and unsigned (U32) integer types\n            is that I32 is treated as signed while U32 is treated as unsigned although\n            both are actually the 32-bit Fortran intrinsic integer type. private  function I32_To_I128(I32) result(I128) To convert a signed 32-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I32 number treated as signed Return Value type( SInt128 ) private  function I64_To_I128(I64) result(I128) To convert a signed 64-bit integer number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: I64 number treated as signed Return Value type( SInt128 ) private  function U32_To_I128(U32, Negative) result(I128) To convert an unsigned 32-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: U32 number treated as unsigned logical, intent(in) :: Negative true if the 128-bit integer value is negative otherwise, the 128-bit integer value is positive Return Value type( SInt128 ) private  function U64_To_I128(U64, Negative) result(I128) To convert an unsigned 64-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: U64 number treated as unsigned logical, intent(in) :: Negative true if the 128-bit integer value is negative otherwise, the 128-bit integer value is positive Return Value type( SInt128 ) private  function R32_To_I128(R32) result(I128) To convert a 32-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: R32 Return Value type( SInt128 ) private  function R64_To_I128(R64) result(I128) To convert a 64-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: R64 Return Value type( SInt128 ) private  function R128_To_I128(R128) result(I128) To convert a 128-bit floating point number to a signed 128-bit integer number Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: R128 Return Value type( SInt128 ) private  function DecString_To_I128(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a signed 128-bit integer value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( SInt128 ) number public        interface ToU32 Function Interface : ToU32 Purpose :  To convert a 128-bit signed integer to a \n  32-bit unsigned integer Usage : --->    U32 = ToU32(I128) private  function U32_From_I128(I128) result(U32) To convert a signed 128-bit integer number to an unsigned 32-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B) number treated as unsigned public        interface ToU64 Function Interface : ToU64 Purpose :  To convert a 128-bit signed integer to a \n  64-bit unsigned integer Usage : --->    U64 = ToU64(I128) private  function U64_From_I128(I128) result(U64) To convert a signed 128-bit integer number to an unsigned 64-bit integer number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I8B) number treated as unsigned public        interface ToU128 Function Interface : ToU128 Purpose :  To convert a 128-bit signed integer to a \n  128-bit unsigned integer Usage : --->    U128 = ToU128(I128) private  function U128_From_I128(I128) result(U128) To convert a signed 128-bit integer to an unsigned 128-bit integer Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value type( UInt128 ) public        interface ToR32 Function Interface : ToR32 Purpose :  To convert a 128-bit signed integer to\n  a 32-bit floating point (real) number Usage : --->    R32 = ToR32(I128) private  function R32_From_I128(I128) result(R32) To convert a signed 128-bit integer number to a 32-bit floating point number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value real(kind=SP) public        interface ToR64 Function Interface : ToR64 Purpose :  To convert a 128-bit signed integer to\n  a 64-bit floating point (real) number Usage : --->    R64 = ToR64(I128) private  function R64_From_I128(I128) result(R64) To convert a signed 128-bit integer number to a 64-bit floating point number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value real(kind=DP) public        interface ToR128 Function Interface : ToR128 Purpose :  To convert a 128-bit signed integer to\n  a 128-bit floating point (real) number Usage : --->    R128 = ToR128(I128) private  function R128_From_I128(I128) result(R128) To convert a signed 128-bit integer number to a 128-bit floating point number Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value real(kind=QP) public        interface ToDecString Function Interface : ToDecString Purpose :  To convert a 128-bit signed integer to\n  a decimal string Usage : --->    Str = ToDecString(I128) private  function DecString_From_I128(I128) result(Str) To convert a signed 128-bit integer number to a decimal string Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value character(len=:), ALLOCATABLE public        interface ToHexString Function Interface : ToHexString Purpose :  To convert a 128-bit signed integer to\n  a hexadecimal string Usage : --->    Str = ToHexString(I128) private  function HexString_From_I128(I128) result(Str) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value character(len=:), ALLOCATABLE public        interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two 128-bit signed integers are equal return .TRUE. if both values are equal; otherwise return .FALSE. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething private  function I128_Equal(LHS, RHS) result(Flag) To check whether two SInt128 objects are equal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two 128-bit signed integers are not equal return .TRUE. if both values are NOT equal; otherwise return .FALSE. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething private  function I128_NotEqual(LHS, RHS) result(Flag) To check whether two SInt128 objects are NOT equal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value return .TRUE. if LHS < RHS; otherwise return .FALSE. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething private  function I128_LessThan(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is less than the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value return .TRUE. if LHS <= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething private  function I128_LessEqual(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is less than or equal to the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value return .TRUE. if LHS > RHS; otherwise return .FALSE. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething private  function I128_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is greater than the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value return .TRUE. if LHS >= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething private  function I128_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS SInt128 object is greater than or equal to the RHS SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value logical public        interface Compare Function Interface : Compare Purpose :  To compare two 128-bit signed integers and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething private  function I128_Compare(LHS, RHS) result(Flag) To compare LHS and RHS objects. -> return -1 if LHS < RHS -> return  0 if LHS == RHS -> return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LHS type( SInt128 ), intent(in) :: RHS Return Value integer(kind=I4B) public        interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two signed integers\n  (at least one of which is a 128-bit signed integer) or\n  to add a unary plus sign to a 128-bit signed integer\n  (which has no effect on the signed integer) Usage : --->    OUTPUT = +INPUT --->    OUTPUT = FIRST_IN + SECOND_IN private  function I128_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the Sint128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) private  function I128_Plus_I128(LhsVal, RhsVal) result(OutVal) To perform addition of two SInt128 objects (Lhs + Rhs) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Plus_I32(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I32_Plus_I128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Plus_I64(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I64_Plus_I128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) public        interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two signed integers\n  (at least one of which is a 128-bit signed integer) or\n  to perform a negation of a 128-bit signed integer Usage : --->    OUTPUT = -INPUT --->    OUTPUT = FIRST_IN - SECOND_IN Important Note :  For subtraction of signed integers (unlike unsigned one),\n  value of FIRST_IN can be less than SECOND_IN. private  function I128_Negate(InVal) result(OutVal) To negate the Uint128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) private  function I128_Minus_I128(LhsVal, RhsVal) result(OutVal) To perform subtraction of two SInt128 objects (Lhs - Rhs) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Minus_I32(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I32_Minus_I128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Minus_I64(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I64_Minus_I128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) public        interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two signed integers (at least one of which is a 128-bit signed integer) Usage : --->    OUTPUT = FIRST_IN * SECOND_IN private  function I128_Multiply_I128(LhsVal, RhsVal) result(OutVal) To perform multiplication of two SInt128 objects (Lhs * Rhs) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Multiply_I32(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I32_Multiply_I128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I128_Multiply_I64(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( SInt128 ) private  function I64_Multiply_I128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) public        interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To return the quotient of a division of two signed integers,\n  where the dividend (numerator) is a 128-bit signed integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit signed integer Usage : --->    QUOT = NUMER / DENOM private  function I128_Divide_I32(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Divide_I64(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Divide_I128(Dividend, Divisor) result(Quotient) To perform division of two SInt128 objects (Dividend / Divisor) and\nand return the quotient Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend type( SInt128 ), intent(in) :: Divisor Return Value type( SInt128 ) public        interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two signed integers,\n  where the dividend (numerator) is a 128-bit signed integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit signed integer Usage : --->    REM = MOD(NUMER, DENOM) private  function I128_Mod_I32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Mod_I64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( SInt128 ) private  function I128_Mod_I128(Dividend, Divisor) result(Remainder) To perform division of two SInt128 objects (Dividend / Divisor)\nand return the remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend type( SInt128 ), intent(in) :: Divisor Return Value type( SInt128 ) public        interface DivMod Subroutine Interface : DivMod Purpose :  To perform a division of two signed integers (where the\n  dividend (numerator) is a 128-bit signed integer and the divisor\n  (denominator) can be 32-, 64- or 128-bit signed integer) and\n  to return both the quotient and the remainder Usage : --->    CALL DivMod(NUMER, DENOM, QUOT, REM) private  subroutine I128_DivMod_I32(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor and\nreturn both quotient and remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor type( SInt128 ), intent(out) :: Quotient type( SInt128 ), intent(out) :: Remainder private  subroutine I128_DivMod_I64(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor and\nreturn both quotient and remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor type( SInt128 ), intent(out) :: Quotient type( SInt128 ), intent(out) :: Remainder private  subroutine I128_DivMod_I128(Dividend, Divisor, Quotient, Remainder) To perform division of two SInt128 objects (Dividend / Divisor) and\nand return both the quotient and the remainder Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: Dividend type( SInt128 ), intent(in) :: Divisor type( SInt128 ), intent(out) :: Quotient type( SInt128 ), intent(out) :: Remainder public        interface Increment Subroutine Interface : Increment Purpose :  To increase value of a 128-bit signed integer by one Usage : --->    CALL Increment(I128) private  subroutine I128_Increment(Val) To increase value of the input by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: Val public        interface Decrement Subroutine Interface : Decrement Purpose :  To decrease value of a 128-bit signed integer by one Usage : --->    CALL Decrement(I128) private  subroutine I128_Decrement(Val) To decrease value of the input by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: Val public        interface Add Subroutine Interface : Add Purpose :  To add a signed integer to a 128-bit signed integer Usage : --->    CALL Add(This, Other) private  subroutine I128_Add_I32(This, Other) To perform addition:  This = This + Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine I128_Add_I64(This, Other) To perform addition:  This = This + Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine I128_Add_I128(This, Other) To perform addition:  This = This + Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other public        interface Subtract Subroutine Interface : Subtract Purpose :  To subtract a signed integer from a 128-bit signed integer Usage : --->    CALL Subtract(This, Other) Important Note :  For subtraction of signed integers (unlike unsigned one),\n  value of This can be less than Other. private  subroutine I128_Subtract_I32(This, Other) To perform subtraction:  This = This - Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine I128_Subtract_I64(This, Other) To perform subtraction:  This = This - Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine I128_Subtract_I128(This, Other) To perform subtraction:  This = This - Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other public        interface Multiply Subroutine Interface : Multiply Purpose :  To multiply a 128-bit signed integer by a signed integer Usage : --->    CALL Multiply(This, Other) private  subroutine I128_Times_I32(This, Other) To perform multiplication:  This = This * Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine I128_Times_I64(This, Other) To perform multiplication:  This = This * Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine I128_Times_I128(This, Other) To perform multiplication:  This = This * Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other public        interface Divide Subroutine Interface : Divide Purpose :  To divide a 128-bit signed integer by a signed integer Usage : --->    CALL Divide(This, Other) private  subroutine I128_Over_I32(This, Other, Remainder) To perform division:  This = This / Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other integer(kind=I4B), intent(out), optional :: Remainder private  subroutine I128_Over_I64(This, Other, Remainder) To perform division:  This = This / Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other integer(kind=I8B), intent(out), optional :: Remainder private  subroutine I128_Over_I128(This, Other, Remainder) To perform division:  This = This / Other Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(inout) :: This type( SInt128 ), intent(in) :: Other type( SInt128 ), intent(out), optional :: Remainder public        interface ShiftLOnce Function Interface : ShiftLOnce Purpose :  To perform logical left shift by 1 Usage : --->    OUT = ShiftLOnce(IN) private  function I128_SHIFTL_Once(InVal) result(OutVal) To perform logical left shift by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface ShiftROnce Function Interface : ShiftROnce Purpose :  To perform logical right shift by 1 Usage : --->    OUT = ShiftROnce(IN) private  function I128_SHIFTR_Once(InVal) result(OutVal) To perform logical right shift by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface ShiftAOnce Function Interface : ShiftAOnce Purpose :  To perform arithmetic right shift by 1 Usage : --->    OUT = ShiftAOnce(IN) private  function I128_SHIFTA_Once(InVal) result(OutVal) To perform arithmetic right shift by 1 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface ShiftL64 Function Interface : ShiftL64 Purpose :  To perform logical left shift by 64 Usage : --->    OUT = ShiftL64(IN) private  function I128_SHIFTL_64(InVal) result(OutVal) To perform logical left shift by 64 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface ShiftR64 Function Interface : ShiftR64 Purpose :  To perform logical right shift by 64 Usage : --->    OUT = ShiftR64(IN) private  function I128_SHIFTR_64(InVal) result(OutVal) To perform logical right shift by 64 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface ShiftA64 Function Interface : ShiftA64 Purpose :  To perform arithmetic right shift by 64 Usage : --->    OUT = ShiftA64(IN) private  function I128_SHIFTA_64(InVal) result(OutVal) To perform arithmetic right shift by 64 Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface ShiftL63Down Function Interface : ShiftL63Down Purpose :  To perform logical left shift by 63 or less Usage : --->    OUT = ShiftL63Down(IN, 11) private  function I128_SHIFTL_63Down(InVal, ShiftPos) result(OutVal) To perform logical left shift by 63 or less Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 ) public        interface ShiftR63Down Function Interface : ShiftR63Down Purpose :  To perform logical right shift by 63 or less Usage : --->    OUT = ShiftR63Down(IN, 53) private  function I128_SHIFTR_63Down(InVal, ShiftPos) result(OutVal) To perform logical right shift by 63 or less Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 ) public        interface ShiftA63Down Function Interface : ShiftA63Down Purpose :  To perform arithmetic right shift by 63 or less Usage : --->    OUT = ShiftA63Down(IN, 53) private  function I128_SHIFTA_63Down(InVal, ShiftPos) result(OutVal) To perform arithmetic right shift by 63 or less Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 ) public        interface ShiftL64Up Function Interface : ShiftL64Up Purpose :  To perform logical left shift by 64 or more (<= 128) Usage : --->    OUT = ShiftL64Up(IN, 111) private  function I128_SHIFTL_64Up(InVal, ShiftPos) result(OutVal) To perform logical left shift by 64 or more Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 ) public        interface ShiftR64Up Function Interface : ShiftR64Up Purpose :  To perform logical right shift by 64 or more (<= 128) Usage : --->    OUT = ShiftR64Up(IN, 84) private  function I128_SHIFTR_64Up(InVal, ShiftPos) result(OutVal) To perform logical right shift by 64 or more Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 ) public        interface ShiftA64Up Function Interface : ShiftA64Up Purpose :  To perform arithmetic right shift by 64 or more (<= 128) Usage : --->    OUT = ShiftA64Up(IN, 84) private  function I128_SHIFTA_64Up(InVal, ShiftPos) result(OutVal) To perform arithmetic right shift by 64 or more Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos Return Value type( SInt128 ) public        interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTL(IN, 127) private  function I128_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical/arithmetic left shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos must be nonnegative and <= 128 Return Value type( SInt128 ) public        interface SHIFTA Function Interface : SHIFTA Purpose :  To perform arithmetic right shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTA(IN, 33) private  function I128_ShiftRightArithmetic(InVal, ShiftPos) result(OutVal) To perform arithmetic right shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos must be nonnegative and <= 128 Return Value type( SInt128 ) public        interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTR(IN, 33) private  function I128_ShiftRightLogical(InVal, ShiftPos) result(OutVal) To perform logical right shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos must be nonnegative and <= 128 Return Value type( SInt128 ) public        interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 --->    OUT = ISHFT(IN, -24)   ! a logical right shift by 24 private  function I128_ShiftLogical(InVal, ShiftPos) result(OutVal) To perform logical (left or rigth) shift of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( SInt128 ) public        interface ISHFTC Function Interface : ISHFTC Purpose :  To perform circular shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 --->    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24 private  function I128_Rotate(InVal, ShiftPos) result(OutVal) To perform a circular shift of the rightmost bits Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( SInt128 ) public        interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = NOT(IN) private  function I128_Not(InVal) result(OutVal) To return the bitwise logical complement of the SInt128 object Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal Return Value type( SInt128 ) public        interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IOR(LHSIN, RHSIN) private  function I128_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of the SInt128 objects Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) public        interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IEOR(LHSIN, RHSIN) private  function I128_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of the SInt128 objects Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) public        interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IAND(LHSIN, RHSIN) private  function I128_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of the SInt128 objects Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: LhsVal type( SInt128 ), intent(in) :: RhsVal Return Value type( SInt128 ) public        interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumLZ = LEADZ(INPUT) private  function I128_LeadingZeros(I128) result(NumLZ) To count the number of leading zero bits Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B) public        interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumTZ = TRAILZ(INPUT) private  function I128_TrailingZeros(I128) result(NumTZ) To count the number of trailing zero bits Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B) public        interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumBits = POPCNT(INPUT) private  function I128_Count1Bits(I128) result(NumBits) To count the number of 1 bits in the specified input Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B) public        interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumPar = POPPAR(INPUT) private  function I128_Parity(I128) result(ParNum) To determine the parity of the specified input Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value integer(kind=I4B) public        interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBSET(IN, Pos) private  function I128_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1 For more detail, see explanation of elemental intrinsic function 'IBSET' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( SInt128 ) public        interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCLR(IN, Pos) private  function I128_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0 For more detail, see explanation of elemental intrinsic function 'IBCLR' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( SInt128 ) public        interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCHNG(IN, Pos) private  function I128_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( SInt128 ) public        interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position is 0 (False) or 1 (True) (For more information, see detailed explanation of the intrinsic function) Usage : --->    Flag = BTEST(IN, Pos) private  function I128_TestBit(I128, Pos) result(Flag) To check whether the bit at the specifed position is 0 (False) or 1 (True) For more detail, see explanation of elemental intrinsic function 'BTEST' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 integer(kind=I4B), intent(in) :: Pos Return Value logical public        interface IBITS Function Interface : IBITS Purpose :  To extract a sequence of bits according to the specified input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBITS(IN, Pos, Len) private  function I128_ExtractBits(InVal, Pos, Len) result(OutVal) To extract a sequence of bits according to the specified input For more detail, see explanation of elemental intrinsic function 'IBITS' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos integer(kind=I4B), intent(in) :: Len Return Value type( SInt128 ) public        interface MoveBits Subroutine Interface : MoveBits Purpose :  To copy a sequence of bits (a bit field) from one location to another (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS') Usage : --->    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos) private  subroutine I128_MoveBits(InVal, InPos, Len, OutVal, OutPos) To copy a sequence of bits (a bit field) from one location to another For more detail, see explanation of elemental intrinsic subroutine\n'MVBITS' Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: InPos integer(kind=I4B), intent(in) :: Len type( SInt128 ), intent(inout) :: OutVal integer(kind=I4B), intent(in) :: OutPos public        interface IsPositive Function Interface : IsPositive Purpose :  To check whether the input value is positive or not Usage : --->    Flag = IsPositive(INPUT) --->    IF (IsPositive(INPUT)) DoSomeThing private  function I128_Is_Positive(I128) result(Flag) To check whether the number is positive or not Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value logical public        interface IsNegative Function Interface : IsNegative Purpose :  To check whether the input value is negative or not Usage : --->    Flag = IsNegative(INPUT) --->    IF (IsNegative(INPUT)) DoSomeThing private  function I128_Is_Negative(I128) result(Flag) To check whether the number is negative or not Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value logical public        interface IsZero Function Interface : IsZero Purpose :  To check whether the input value is zero or not Usage : --->    Flag = IsZero(INPUT) --->    IF (IsZero(INPUT)) DoSomeThing private  function I128_Is_Zero(I128) result(Flag) To check whether the number is zero or not Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value logical public        interface ABS Function Interface : ABS Purpose :  To return the absolute value of the input Usage : --->    OUTPUT = ABS(INPUT) private  function I128_Absolute(I128) result(ABS) To return the absolute value Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 Return Value type( SInt128 ) public        interface Display Subroutine Interface : Display Purpose :  To write/display the 'SInt128' object to the screen (or the specified unit) Usage : To display (signed) value of I128 as a decimal string to the screen --->    CALL Display(I128) To display (signed) value of I128 as a decimal string to the output logical unit --->    CALL Display(I128, 11) To display (signed) value of I128 as a decimal string to the output logical unit with input/output status and message --->    CALL Display(I128, 11, IOStat, IOMsg) To display (signed) values of components of U128 as a decimal string to the screen --->    CALL Display(I128, ShowComponent=.TRUE.) To display (signed) value of I128 as a decimal string to the screen with a prefix string --->    CALL Display(I128, Prefix='Unsigned value of U128') private  subroutine I128_Write(I128, Unit, IOStat, IOMsg, ShowComponent, Prefix) To write 'SInt128' object to the screen (or the specified unit) Arguments Type Intent Optional Attributes Name type( SInt128 ), intent(in) :: I128 SInt128 object integer(kind=I4B), intent(in), optional :: Unit output logical unit integer(kind=I4B), intent(out), optional :: IOStat io stat character(len=*), intent(out), optional :: IOMsg io message logical, intent(in), optional :: ShowComponent flag indicating whether to show components or not if flag is present and true, write compoents of the object otherwise, write the object as a decimal string character(len=*), intent(in), optional :: Prefix prefix string Derived Types type, public :: SInt128 a 128-bit signed integer type where the base of its components is 2**64. Components Type Visibility Attributes Name Initial integer(kind=I8B), public :: High upper 64 bits treated as signed integer integer(kind=I8B), public :: Low lower 64 bits treated as unsigned integer Constructor Constructor Interface : SInt128 Purpose :  To construct a 128-bit signed integer from\n  other Fortran intrinsic types or 32- and 64-bit unsigned integers Usage : --->    I128 = SInt128(IntrinsicType)   ! constructor for Fortran intrinsic types --->    I128 = SInt128(UType, Negative) ! 32- and 64-bit unsigned integers where I128 has negative value if 'Negative' is true Note :  The different between 32-bit signed (I32) and unsigned (U32) integer types\n            is that I32 is treated as signed while U32 is treated as unsigned although\n            both are actually the 32-bit Fortran intrinsic integer type. private\n\n                    \n                    function I32_To_I128 (I32) To convert a signed 32-bit integer number to a signed 128-bit integer number private\n\n                    \n                    function I64_To_I128 (I64) To convert a signed 64-bit integer number to a signed 128-bit integer number private\n\n                    \n                    function U32_To_I128 (U32, Negative) To convert an unsigned 32-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative private\n\n                    \n                    function U64_To_I128 (U64, Negative) To convert an unsigned 64-bit integer number to a signed 128-bit integer number\nwhere the sign flag is used to indicate whether the 128-bit integer value is\npositive or negative private\n\n                    \n                    function R32_To_I128 (R32) To convert a 32-bit floating point number to a signed 128-bit integer number private\n\n                    \n                    function R64_To_I128 (R64) To convert a 64-bit floating point number to a signed 128-bit integer number private\n\n                    \n                    function R128_To_I128 (R128) To convert a 128-bit floating point number to a signed 128-bit integer number private\n\n                    \n                    function DecString_To_I128 (cStr, ErrFlag, ErrMsg) To convert a decimal string to a signed 128-bit integer value","tags":"","loc":"module\\modbase_sint128.html"},{"title":"ModBase_RealSP_CharConv – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains routines that perform a conversion between a 32-bit\n  floating point number and a string. REFERENCE TECHNICAL ARTICLES : [1]  Junekey Jeon. Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm [2]  Ulf Adams. Ryu: Fast Float-to-String Conversion [3]  Raffaello Giulietti. The Schubfach way to render doubles [4]  Clinger WD. How to Read Floating Point Numbers Accurately ,\n  SIGPLAN Not 2004 Apr;39(4):360–371. [5]  Daniel Lemire. Number Parsing at a Gigabyte per Second ,\n  Software: Practice and Experience 51 (8), 2021. [6]  Noble Mushtak and Daniel Lemire. Fast Number Parsing Without Fallback ,\n  Software: Practice and Experience 53 (7), 2023. [7]  Bouvier & Zimmermann. Division-Free Binary-to-Decimal Conversion [8]  Hacker's Delight, 2nd Edition. [9]  Nigel Tao. The Eisel-Lemire ParseNumberF64 Algorithm [10] Nigel Tao. ParseNumberF64 by Simple Decimal Conversion REFERENCE CODE IMPLEMENTATION : [11] DragonBox: C++ reference implementation [12] Ryu: C reference implementation [13] Schubfach: Java reference implementation [14] Drachennest: Different algorithms for converting binary to decimal floating-point numbers [15] Number Conversion Benchmark in C [16] fast_float number parsing library: 4x faster than strtod [17] fast_double_parser: 4x faster than strtod [18] The LLVM Project: LibC Support [19] Double Conversion: Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles [20] fmt: A modern formatting library TECHNICAL AND IMPLEMENTATION NOTES : On the output to string : 1) Three routines are available to convert a real (floating-point) number into a string. - \"RealToString_DragonBox\" is based on the Dragonbox binary-to-decimal conversion algorithm [1]\n     and the reference implementation [11, 14, 20] - \"RealToString_Ryu\" is based on the Ryu binary-to-decimal conversion algorithm [2]\n     and the reference implementation [12, 14] - \"RealToString_Schubfach\" is based on the Schubfach binary-to-decimal conversion algorithm [3]\n     and the reference implementation [13, 14, 15] 2) All three binary-to-decimal conversion algorithms employed here produce the so-called shortest\n   output representation that provide an error-free write-read cycle.  This means that any correct\n   parsers (e.g. RealFromString routines) will read in the output string and return the original\n   real (floating-poing) number. 3) Although the DragonBox reference implementation provides several modes of rounding, only the\n   round-to-nearest mode is implemented here (the other two algorithms also use this mode). 4) Although the Ryu reference implementation provides several conversion output formats (Shortest,\n   Scientific, Fixed), only the shortest representation (as mentioned above) is implemented.\n   Therefore, all three routines will produces the output string in a format similar to \"G0\" format\n   specification in Fortran. 5) Actually, the RealToString routines have an optional \"format\" argument that we can use to specify\n   whether to output the string in \"General (G)\" or \"Scientific (ES)\" format.  However, because they\n   always produce the shortest output, no input argument to the routines is provided to specify\n   the desired number of significant digits as typically done in Fortran format specifications. On the input from string : 1) Four routines are available to convert a string into a real (floating-point) number.  All four\n   routines utilize the so-call Clinger's fast-path algorithm [4].  Three of them (except \"YY\") employ\n   the so-call Eisel-Lemire decimal-to-binary conversion algorithm [5, 9] but are based on different\n   reference implementation.  When the Eisel-Lemire (or YY's fast-path) algorithm is NOT valid, three\n   of the routines (except \"LibC\") use multi-precision (unsigned) integer arithmetic (i.e. BigUInt)\n   whereas \"LibC\" employs the so-call Simple Decimal Conversion algorithm [10]. - \"RealFromString_FastFloat\" is based on the reference implementation [16] - \"RealFromString_LibC\" is based on the reference implementation [18] - \"RealFromString_YY\" is based on the reference implementation [15, 19] - \"RealFromString_Lemire\" is based on the reference implementation [17, 19] 2) The RealFromString routines have an optional \"parsing\" argument that we can use to specify how\n   the routines interpret the input string. 3) The \"Parse_Fortran_String\" routine is called when the optional \"parsing\" argument is not specified\n   (i.e. the default option) or \"FortNum (or 1)\" value is supplied as the parsing argument.  The routine\n   will interpret the input string as a valid Fortran real (floating point) number if it has one of\n   the two following forms: <1> A number without exponent part -> [S]N[N...] <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] where [ ] indicates an optional field S is a sign indicator (required if negative '-', optional if positive '+'). N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere\n          after the sign (but before the exponent). E is an exponent indicator (either 'e' or 'E') The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. - The optional kind parameter (e.g. 10.0_DP) is not allowed here. Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered\n   valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\"\n   is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement\n   where spaces inside the valid number are allowed. However, this can easily be done by adding an\n   optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or 'ignored'.\n   Then, the input will be pre-processed according to the flag.  Nonetheless, this routine neglects\n   this optional input because it will make the routine much less efficient due to the fact that\n   we will need to scan the whole string twice and we will also need to copy the input string into\n   a buffer string and working with the buffer instead of directly handling the input string. 4) The \"Parse_FPlus_String\" routine is called when \"FPlusNum (or 2)\" value is supplied as the parsing\n   argument.  The routine will parse a valid Fortran real (floating point) number with more relaxed\n   rules than those used in \"Parse_Fortran_Number\" routine. The relaxed rules consider the following\n   numbers as valid: - a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q'\n     in place of 'e' or 'E'. - a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to\n     be expressed in a valid number expressed in the scientific format. - digits before any invalid character encountered are treated as a valid number\n     and any characters after the first encounter (including the first invalid one)\n     are neglected.  therefore, for example, a '12.56ax-300' is considered to be\n     a valid number with a value of 12.56. 5) The \"Parse_JSON_String\" routine is called when \"JsonNum (or 3)\" value is supplied as the parsing\n   argument.  The routine will parse a valid JSON floating point number where its differences from\n   from Fortran number are as follows: - leading and trailing spaces are not allowed. - a plus sign as the first character is not allowed. - leading zero(s) is not allowed (if 0 is the first character, the second one\n     must either be a period or an exponent indicator.) - a period must be followed by at least one digit. USAGE : On the output to string : => cStr = RealXP_ToString_DragonBox(Number, IsScientific) => cStr = RealXP_ToString_Ryu(Number, IsScientific) => cStr = RealXP_ToString_Schubfach(Number, IsScientific) where \"cStr\" is an \"allocatable\" character string representing the output string \"Number\" is a real number representing the floating point value \"IsScientific\" is a logical flag (optional argument) indicating whether\n      the output string is in \"General\" or \"Scientific\" format. If present and true, the output string is in \"Scientific\" format. Otherwise, the output string is in \"General\" format. On the input from string : => Number = RealXP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) where \"Number\" is a real number representing the floating point value if the input string is valid \"cStr\" is a character string representing the floating-point number string \"ParseOpt\" is an integer input flag (optional) indicating how to interpret the input string.\n      The valid value is FortNum (1), FPlusNum (2) or JsonNum (3).\n      If not specified and invalid, the routines will interpret the input string as a Fortran number. \"ErrFlag\" is a logical output flag (optional) indicating whether there is an error in parsing\n      the input string.  True if the string represents a valid number.  False, otherwise. \"ErrMsg\" is an allocatable output character string (optional) that returns a message that describe\n      the result of parsing the input string. NOTE : \"XP\" in the routine names shown above indicate the precision of the real number.\n  The actual name will either be \"RealSP_...\", \"RealDP_...\" or \"RealQP_...\" for single-precision,\n  double-precision and quadruple-precision number, respectively. Uses ModBase_UIntUtil ieee_arithmetic ModBase_Common ModBase_UInt128 ModBase_Tables_CharConv ModBase_SIntUtil Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: FortNum = 1 integer(kind=I4B), public, parameter :: FPlusNum = 2 integer(kind=I4B), public, parameter :: JsonNum = 3 integer(kind=I4B), public, parameter :: MinSubnormal = 1 minimum value of subnormal floating point number integer(kind=I4B), public, parameter :: MaxSubnormal = SHIFTL(1, SignificandBits)-1 maximum value of subnormal floating point number integer(kind=I4B), public, parameter :: MinNormal = SHIFTL(1, SignificandBits) minimum value of normal floating point number integer(kind=I4B), public, parameter :: MaxNormal = IOR(SHIFTL((MaxExponent-1), SignificandBits), MaxSubnormal) maximum value of normal floating point number Functions public  function RealSP_ToString_DragonBox (Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character (decimal) string\nusing the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string public  function RealSP_ToString_Ryu (Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character (decimal) string\nusing the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string public  function RealSP_ToString_Schubfach (Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character (decimal) string\nusing the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag true  if to write the given number in scientific format false if to write the given number in general format default is false Return Value character(len=:), ALLOCATABLE character string public  function RealSP_FromString_FastFloat (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number public  function RealSP_FromString_LibC (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the LibC algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number public  function RealSP_FromString_YY (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the YY algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number public  function RealSP_FromString_Lemire (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision floating-point value\nusing the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr input string integer(kind=I4B), intent(in), optional :: ParseOpt parsing option logical, intent(out), optional :: ErrFlag error flag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=SP) floating point number","tags":"","loc":"module\\modbase_realsp_charconv.html"},{"title":"ModBase_UIntUtil – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains routines that perform comparisons and arithmetic\n operations for unsigned integers.  The module also provide various\n utility routines including conversions from an unsigned integer to\n a string as well as unsigned multiplications (to higher precision). REFERENCES : [1] Guava: Google Core Libraries for Java [2] Java's OpenJDK [3] FLIBS - A collection of Fortran modules TECHNICAL NOTES : According to [3], Fortran does not natively support unsigned integers but\n   intrinsic (signed) integer types in Fortran behave the same as unsigned\n   one for positive values.  For negative values, however, they behave differently\n   for the following operations: - conversion :   to and from string - comparision :  less than (<), less than or equal to(<=),\n                      greater than (>), greater than or equal to (>=) - arithmetic :   division (/) and modulation (MOD) (note that in two's complement arithmetic, the three other basic\n    arithmetic operations of add, subtract, and multiply are bit-wise\n    identical if the two operands are regarded as both being signed\n    or both being unsigned.) Therefore, the module only provides routines for those operations that differ.\n   For those operations (the one that not yet mentioned including bitwise one)\n   that have the same behaviors, normal Fortran expressions can be used. It is important to note that routines in this module cannot differentiate between\n   signed and unsigned integers (i.e. they assume all integers (input and/or output)\n   to be unsigned with the exception of output of 'CompareUnsigned' routines); thus,\n   users of this module must be extremely careful not to mix up signed and unsigned\n   integers in the same expressions. The application interface (API) used in this module follows closely that used in\n   reference [3].  However, the implementations used here are mostly based on those\n   in references [1] and [2] because it appears that algorithms used in [1] and [2]\n   are more efficient than those used in [3]. Uses ModBase_SIntUtil ModBase_Common Variables Type Visibility Attributes Name Initial integer(kind=I1B), public, parameter :: MAX_U8 = INT(Z'FF', KIND=I1B) 255 integer(kind=I2B), public, parameter :: MAX_U16 = INT(Z'FFFF', KIND=I2B) 65535 integer(kind=I4B), public, parameter :: MAX_U32 = INT(Z'FFFFFFFF', KIND=I4B) 4294967295 integer(kind=I8B), public, parameter :: MAX_U64 = INT(Z'FFFFFFFFFFFFFFFF', KIND=I8B) 18446744073709551615 integer(kind=I1B), public, parameter :: MIN_U8 = 0_I1B integer(kind=I2B), public, parameter :: MIN_U16 = 0_I2B integer(kind=I4B), public, parameter :: MIN_U32 = 0_I4B integer(kind=I8B), public, parameter :: MIN_U64 = 0_I8B Interfaces public        interface OPERATOR (.ULT.) Operator Overload : OPERATOR(.ULT.) Purpose :  To check if the LHS value is less than the RHS value return .TRUE. if LHS < RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULT. RHS --->    IF (LHS .ULT. RHS) DoSomething private pure function UInt8_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_LT(LHS, RHS) result(Flag) To compare whether LHS < RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical public        interface OPERATOR (.ULE.) Operator Overload : OPERATOR(.ULE.) Purpose :  To check if the LHS value is less than or equal to the RHS value return .TRUE. if LHS <= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULE. RHS --->    IF (LHS .ULE. RHS) DoSomething private pure function UInt8_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_LE(LHS, RHS) result(Flag) To compare whether LHS <= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical public        interface OPERATOR (.UGT.) Operator Overload : OPERATOR(.UGT.) Purpose :  To check if the LHS value is greater than the RHS value return .TRUE. if LHS > RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGT. RHS --->    IF (LHS .UGT. RHS) DoSomething private pure function UInt8_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_GT(LHS, RHS) result(Flag) To compare whether LHS > RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical public        interface OPERATOR (.UGE.) Operator Overload : OPERATOR(.UGE.) Purpose :  To check if the LHS value is greater than or equal to the RHS value return .TRUE. if LHS >= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGE. RHS --->    IF (LHS .UGE. RHS) DoSomething private pure function UInt8_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value logical private pure function UInt16_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value logical private pure function UInt32_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value logical private pure function UInt64_GE(LHS, RHS) result(Flag) To compare whether LHS >= RHS where both numbers are treated as unsigned. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value logical public        interface OPERATOR (.UDIV.) Operator Overload : OPERATOR(.UDIV.) Purpose :  To return the quotient of a division of two unsigned integers,\n  where both input and an output have the same kind Usage : --->    QUOT = NUMER .UDIV. DENOM private pure function UInt8_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: Dividend integer(kind=I1B), intent(in) :: Divisor Return Value integer(kind=I1B) private pure function UInt16_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: Dividend integer(kind=I2B), intent(in) :: Divisor Return Value integer(kind=I2B) private pure function UInt32_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing ResVal   - the unsigned quotient of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value integer(kind=I4B) private pure function UInt64_Divide(Dividend, Divisor) result(ResVal) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing ResVal   - the unsigned quotient of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value integer(kind=I8B) public        interface UMOD Function Interface : UMOD Purpose :  To return the remainder of a division of two unsigned integers,\n  where both input and an output have the same kind Usage : --->    REM = UMOD(NUMER, DENOM) private pure function UInt8_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: Dividend integer(kind=I1B), intent(in) :: Divisor Return Value integer(kind=I1B) private pure function UInt16_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: Dividend integer(kind=I2B), intent(in) :: Divisor Return Value integer(kind=I2B) private pure function UInt32_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing Rem      - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value integer(kind=I4B) private pure function UInt64_Remainder(Dividend, Divisor) result(Rem) To return the unsigned remainder from dividing the first argument\nby the second where each argument and the result is interpreted\nas an unsigned value. Dividend - the value to be divided Divisor  - the value doing the dividing Rem      - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value integer(kind=I8B) public        interface UDivMod Subroutine Interface : UDivMod Purpose :  To perform a division of two unsigned integers and then return both\n  the quotient and the remainder where both input and output have the same kind Usage : --->    CALL UDivMod(NUMER, DENOM, QUOT, REM) private pure subroutine UInt32_DivMod(Dividend, Divisor, Quotient, Remainder) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend  - the value to be divided Divisor   - the value doing the dividing Quotient  - the unsigned quotient of the first argument divided by the second argument Remainder - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor integer(kind=I4B), intent(out) :: Quotient integer(kind=I4B), intent(out) :: Remainder private pure subroutine UInt64_DivMod(Dividend, Divisor, Quotient, Remainder) To return the unsigned quotient of dividing the first argument by\nthe second where each argument and the result is interpreted as\nan unsigned value. Dividend  - the value to be divided Divisor   - the value doing the dividing Quotient  - the unsigned quotient of the first argument divided by the second argument Remainder - the unsigned remainder of the first argument divided by the second argument Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor integer(kind=I8B), intent(out) :: Quotient integer(kind=I8B), intent(out) :: Remainder public        interface CompareUnsigned Function Interface : CompareUnsigned Purpose :  To compare two unsigned integers (of the same kind) and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = CompareUnsigned(LHS, RHS) --->    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething private pure function Compare_UInt8(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: LHS integer(kind=I1B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function Compare_UInt16(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: LHS integer(kind=I2B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function Compare_UInt32(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LHS integer(kind=I4B), intent(in) :: RHS Return Value integer(kind=I4B) private pure function Compare_UInt64(LHS, RHS) result(Flag) To compare LHS and RHS where both numbers are treated as unsigned. - return -1 if LHS < RHS - return  0 if LHS == RHS - return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LHS integer(kind=I8B), intent(in) :: RHS Return Value integer(kind=I4B) public        interface ToUnsignedInteger Function Interface : ToUnsignedInteger Purpose :  To perform unsigned conversion from lower-precision unsigned integer\n  to 32-bit unsigned integer Usage : --->    U32 = ToUnsignedInteger(U8) private pure function ByteToUnsignedInteger(InVal) result(OutVal) To convert the argument to an integer by an unsigned\nconversion.  In an unsigned conversion to an integer, the\nhigh-order 24 bits of the integer are zero and the low-order\n8 bits are equal to the bits of the byte argument.\nConsequently, zero and positive byte values are mapped\nto a numerically equal integer value and negative byte values\nare mapped to a integer value equal to the input plus 2**8. InVal  - the value to convert to an unsigned integer OutVal - the result converted to integer by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: InVal Return Value integer(kind=I4B) private pure function ShortToUnsignedInteger(InVal) result(OutVal) To convert the argument to an integer by an unsigned\nconversion.  In an unsigned conversion to an integer, the\nhigh-order 16 bits of the integer are zero and the low-order\n16 bits are equal to the bits of the short argument.\nConsequently, zero and positive short values are mapped\nto a numerically equal integer value and negative short values\nare mapped to a integer value equal to the input plus 2**16. InVal  - the value to convert to an unsigned integer OutVal - the result converted to integer by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: InVal Return Value integer(kind=I4B) public        interface ToUnsignedLong Function Interface : ToUnsignedLong Purpose :  To perform unsigned conversion from lower-precision unsigned integer\n  to 64-bit unsigned integer Usage : --->    U64 = ToUnsignedLong(U32) private pure function ByteToUnsignedLong(InVal) result(OutVal) To convert the argument to a long integer by an unsigned\nconversion.  In an unsigned conversion to a long, the\nhigh-order 56 bits of the long are zero and the low-order\n8 bits are equal to the bits of the byte argument.\nConsequently, zero and positive byte values are mapped\nto a numerically equal long value and negative byte values\nare mapped to a long value equal to the input plus 2**8. InVal  - the value to convert to an unsigned long OutVal - the result converted to long by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in) :: InVal Return Value integer(kind=I8B) private pure function ShortToUnsignedLong(InVal) result(OutVal) To convert the argument to a long integer by an unsigned\nconversion.  In an unsigned conversion to a long, the\nhigh-order 48 bits of the long are zero and the low-order\n16 bits are equal to the bits of the short argument.\nConsequently, zero and positive short values are mapped\nto a numerically equal long value and negative short values\nare mapped to a long value equal to the input plus 2**16. InVal  - the value to convert to an unsigned long OutVal - the result converted to long by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: InVal Return Value integer(kind=I8B) private pure function IntegerToUnsignedLong(InVal) result(OutVal) To convert the argument to a long integer by an unsigned\nconversion.  In an unsigned conversion to a long, the\nhigh-order 32 bits of the long are zero and the low-order\n32 bits are equal to the bits of the integer argument.\nConsequently, zero and positive integer values are mapped\nto a numerically equal long value and negative integer values\nare mapped to a long value equal to the input plus 2**32. InVal  - the value to convert to an unsigned long OutVal - the result converted to long by an unsigned conversion Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: InVal Return Value integer(kind=I8B) public        interface ToDecStrUnsigned Function Interface : ToDecStrUnsigned Purpose :  To convert an unsigned integer to a decimal string Usage : --->    Str = ToDecStrUnsigned(U32) private  function U32_ToDecString(Val) result(RetStr) To convert a 32-bit integer treated as an unsigned number into a string. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val Return Value character(len=:), ALLOCATABLE private  function U64_ToDecString(Val) result(RetStr) To convert a 64-bit integer treated as an unsigned number into a string. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Val Return Value character(len=:), ALLOCATABLE public        interface ToHexStrUnsigned Function Interface : ToHexStrUnsigned Purpose :  To convert an unsigned integer to a hexadecimal string Usage : --->    Str = ToHexStrUnsigned(U32) private  function U32_ToHexString(Number) result(cStr) To convert an usigned 32-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE private  function U64_ToHexString(Number) result(cStr) To convert an usigned 64-bit integer number to a hexadecimal string Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: Number Return Value character(len=:), ALLOCATABLE Functions public pure function UMul128_Upper64 (X, Y) result(U128Hi) To compute upper 64 bits of multiplication of two 64-bit unsigned integers Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: Y Return Value integer(kind=I8B) public pure function UMul96_Upper64 (X, Y) result(U128Hi) To compute upper 64 bits of multiplication of a 32-bit unsigned integer and\na 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: X integer(kind=I8B), intent(in) :: Y Return Value integer(kind=I8B) public pure function UMul96_Lower64 (X, Y) result(U128Lo) To compute lower 64 bits of multiplication of a 32-bit unsigned integer and\na 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: X integer(kind=I8B), intent(in) :: Y Return Value integer(kind=I8B) public pure function UMul128_N_Shift (A, B_Hi, B_Lo, ShrPos) result(ResVal) To multiply two 64-bit unsigned integers, and then shift\nthe 128-bit result by ShrPos => SHIFTR(A*B, ShrPos). Note: ShrPos should be in the range [64, 128]. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: A integer(kind=I8B), intent(in) :: B_Hi integer(kind=I8B), intent(in) :: B_Lo integer(kind=I4B), intent(in) :: ShrPos Return Value integer(kind=I8B) Subroutines public pure subroutine UMul128 (X, Y, U128Hi, U128Lo) To compute 128-bit result of multiplication of two 64-bit unsigned integers. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: Y integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo public pure subroutine UMul192_Upper128 (X, YHi, YLo, U128Hi, U128Lo) To compute upper 128 bits of multiplication of a 64-bit unsigned integer and\na 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: YHi integer(kind=I8B), intent(in) :: YLo integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo public pure subroutine UMul192_Lower128 (X, YHi, YLo, U128Hi, U128Lo) To compute lower 128 bits of multiplication of a 64-bit unsigned integer and\na 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: X integer(kind=I8B), intent(in) :: YHi integer(kind=I8B), intent(in) :: YLo integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo public pure subroutine UMul128_N_Add (A, B, C, U128Hi, U128Lo) To multiply two 64-bit unsigned integers and add a value (A*B + C), and\nreturn the 128-bit result as U128Hi, U128Lo. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: A integer(kind=I8B), intent(in) :: B integer(kind=I8B), intent(in) :: C integer(kind=I8B), intent(out) :: U128Hi integer(kind=I8B), intent(out) :: U128Lo","tags":"","loc":"module\\modbase_uintutil.html"},{"title":"ModBase_UInt128 – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains a derived type and basic operations for a 128-bit unsigned integer. The application interface (API) follows Fortran intrinsic integer types as close as practical.\n  However, since Fortran does not have an unsigned integer type, those operations that differ\n  between unsigned and signed integers use API similar to those used in 'ModBase_UIntUtil' module. Important Note : (1) For arithmetic operations, various types of unsigned integer types (32-, 64- and 128-bit)\n   are allowed.  However, the use of signed and unsigned integers in the same operation is NOT\n   allowed.  Signed integer types must be explicitly converted to unsigned types before using\n   in the arithmetic operations. (2) For comparison and bitwise operations that require two input arguments, both arguments must\n   only be the 128-bit unsigned integer type.  All other types must be explicitly converted to\n   this type before using in the comparison and bitwise operations. REFERENCES : [1] Absl's Numeric Library [2] Fast 128-bit math library for Java [3] Extended precision integer C++ library Uses ModBase_UIntUtil ModBase_Error_Handlers ieee_arithmetic ModBase_Common iso_fortran_env ModBase_SIntUtil Variables Type Visibility Attributes Name Initial type( UInt128 ), public, parameter :: MaxU128 = UInt128(MaxU64, MaxU64) 128-bit unsigned parameter with maximum value type( UInt128 ), public, parameter :: MinU128 = UInt128(MinU64, MinU64) 128-bit unsigned parameter with minimum value type( UInt128 ), public, parameter :: OneU128 = UInt128(MinU64, 1_I8B) 128-bit unsigned parameter with value of one type( UInt128 ), public, parameter :: ZeroU128 = MinU128 128-bit unsigned parameter with value of zero type( UInt128 ), public, parameter :: MASKI64 = UInt128(MinU64, MaxU64) Used to cast a 64-bit integer to a 128bit integer without getting unwanted sign extension Interfaces public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a 128-bit unsigned integer and\n  other unsigned integers (32- and 64-bit integers) Usage : --->    U128 = OtherType private  subroutine U128_From_U32(U128, U32) To convert an unsigned 32-bit integer number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(out) :: U128 integer(kind=I4B), intent(in) :: U32 number treated as unsigned private  subroutine U128_From_U64(U128, U64) To convert an unsigned 64-bit integer number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(out) :: U128 integer(kind=I8B), intent(in) :: U64 number treated as unsigned private  subroutine U128_To_U32(U32, U128) To convert an unsigned 128-bit integer number to an unsigned 32-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(out) :: U32 number treated as unsigned type( UInt128 ), intent(in) :: U128 private  subroutine U128_To_U64(U64, U128) To convert an unsigned 128-bit integer number to an unsigned 64-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(out) :: U64 number treated as unsigned type( UInt128 ), intent(in) :: U128 public        interface UInt128 Constructor Interface : UInt128 Purpose :  To construct a 128-bit unsigned integer from\n  other Fortran intrinsic types Usage : --->    U128 = UInt128(OtherType) private  function I32_To_U128(I32, AsUnsigned) result(U128) To convert a signed 32-bit integer number to an unsigned 128-bit integer number\n or to convert an unsigned 32-bit integer number to an unsigned 128-bit integer\n number if the specified flag is present and true. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I32 number treated as signed (default) logical, intent(in), optional :: AsUnsigned if present and true, number treated as unsigned Return Value type( UInt128 ) private  function I64_To_U128(I64, AsUnsigned) result(U128) To convert a signed 64-bit integer number to an unsigned 128-bit integer number\nor to convert an unsigned 64-bit integer number to an unsigned 128-bit integer\nnumber if the specified flag is present and true. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: I64 number treated as signed (default) logical, intent(in), optional :: AsUnsigned if present and true, number treated as unsigned Return Value type( UInt128 ) private  function R32_To_U128(R32) result(U128) To convert a 32-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: R32 Return Value type( UInt128 ) private  function R64_To_U128(R64) result(U128) To convert a 64-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: R64 Return Value type( UInt128 ) private  function R128_To_U128(R128) result(U128) To convert a 128-bit floating point number to an unsigned 128-bit integer number. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: R128 Return Value type( UInt128 ) private  function DecString_To_U128(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to an unsigned 128-bit integer value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( UInt128 ) number public        interface ToI32 Function Interface : ToI32 Purpose :  To convert a 128-bit unsigned integer to a \n  32-bit signed integer Usage : --->    I32 = ToI32(U128) private  function I32_From_U128(U128) result(I32) To convert an unsigned 128-bit integer number to a signed 32-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B) number treated as signed public        interface ToI64 Function Interface : ToI64 Purpose :  To convert a 128-bit unsigned integer to\n  a 64-bit signed integer Usage : --->    I64 = ToI64(U128) private  function I64_From_U128(U128) result(I64) To convert an unsigned 128-bit integer number to a signed 64-bit integer number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I8B) number treated as signed public        interface ToR32 Function Interface : ToR32 Purpose :  To convert a 128-bit unsigned integer to\n  a 32-bit floating point (real) number Usage : --->    R32 = ToR32(U128) private  function R32_From_U128(U128) result(R32) To convert an unsigned 128-bit integer number to a 32-bit floating point number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value real(kind=SP) public        interface ToR64 Function Interface : ToR64 Purpose :  To convert a 128-bit unsigned integer to\n  a 64-bit floating point (real) number Usage : --->    R64 = ToR64(U128) private  function R64_From_U128(U128) result(R64) To convert an unsigned 128-bit integer number to a 64-bit floating point number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value real(kind=DP) public        interface ToR128 Function Interface : ToR128 Purpose :  To convert a 128-bit unsigned integer to\n  a 128-bit floating point (real) number Usage : --->    R128 = ToR128(U128) private  function R128_From_U128(U128) result(R128) To convert an unsigned 128-bit integer number to a 128-bit floating point number. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value real(kind=QP) public        interface ToDecString Function Interface : ToDecString Purpose :  To convert a 128-bit unsigned integer to\n  a decimal string Usage : --->    Str = ToDecString(U128) private  function DecString_From_U128(U128) result(Str) To convert an unsigned 128-bit integer number to a decimal string. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value character(len=:), ALLOCATABLE public        interface ToHexString Function Interface : ToHexString Purpose :  To convert a 128-bit unsigned integer to\n  a hexadecimal string Usage : --->    Str = ToHexString(U128) private  function HexString_From_U128(U128) result(Str) To convert an unsigned 128-bit integer number to a hexadecimal string. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value character(len=:), ALLOCATABLE public        interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two 128-bit unsigned integers are equal return .TRUE. if both values are equal; otherwise return .FALSE. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething private  function U128_Equal(LHS, RHS) result(Flag) To check whether two Uint128 objects are equal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two 128-bit unsigned integers are not equal return .TRUE. if both values are NOT equal; otherwise return .FALSE. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething private  function U128_NotEqual(LHS, RHS) result(Flag) To check whether two Uint128 objects are NOT equal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(.ULT.) Operator Overload : OPERATOR(.ULT.) Purpose :  To check if the LHS value is less than the RHS value return .TRUE. if LHS < RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULT. RHS --->    IF (LHS .ULT. RHS) DoSomething private  function U128_LessThan(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is less than the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(.ULE.) Operator Overload : OPERATOR(.ULE.) Purpose :  To check if the LHS value is less than or equal to the RHS value return .TRUE. if LHS <= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .ULE. RHS --->    IF (LHS .ULE. RHS) DoSomething private  function U128_LessEqual(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is less than or equal to the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(.UGT.) Operator Overload : OPERATOR(.UGT.) Purpose :  To check if the LHS value is greater than the RHS value return .TRUE. if LHS > RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGT. RHS --->    IF (LHS .UGT. RHS) DoSomething private  function U128_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is greater than the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(.UGE.) Operator Overload : OPERATOR(.UGE.) Purpose :  To check if the LHS value is greater than or equal to the RHS value return .TRUE. if LHS >= RHS; otherwise return .FALSE. Usage : --->    Flag = LHS .UGE. RHS --->    IF (LHS .UGE. RHS) DoSomething private  function U128_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS Uint128 object is greater than or equal to the RHS Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value logical public        interface CompareUnsigned Function Interface : CompareUnsigned Purpose :  To compare two 128-bit unsigned integers and return -1 if LHS < RHS 0 if LHS == RHS 1 if LHS > RHS Usage : --->    Flag = CompareUnsigned(LHS, RHS) --->    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething private  function U128_Compare(LHS, RHS) result(Flag) To compare LHS and RHS objects. -> return -1 if LHS < RHS -> return  0 if LHS == RHS -> return +1 if LHS > RHS Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LHS type( UInt128 ), intent(in) :: RHS Return Value integer(kind=I4B) public        interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two unsigned integers\n  (at least one of which is a 128-bit unsigned integer) or\n  to add a unary plus sign to a 128-bit unsigned integer\n  (which has no effect on the unsigned integer) Usage : --->    OUTPUT = +INPUT --->    OUTPUT = FIRST_IN + SECOND_IN private  function U128_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) private  function U128_Plus_U128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Plus_U32(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U32_Plus_U128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Plus_U64(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U64_Plus_U128(LhsVal, RhsVal) result(OutVal) To perform addition:  OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) public        interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two unsigned integers\n  (at least one of which is a 128-bit unsigned integer) or\n  to perform a negation of a 128-bit unsigned integer Usage : --->    OUTPUT = -INPUT --->    OUTPUT = FIRST_IN - SECOND_IN Important Note :  For subtraction of unsigned integers, value of FIRST_IN\n  must always be greater than SECOND_IN.  Otherwise, value of OUTPUT\n  is NOT valid. private  function U128_Negate(InVal) result(OutVal) To negate the Uint128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) private  function U128_Minus_U128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Minus_U32(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U32_Minus_U128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Minus_U64(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal value treated as unsigned integer Return Value type( UInt128 ) private  function U64_Minus_U128(LhsVal, RhsVal) result(OutVal) To perform subtraction:  OutVal = LhsVal - RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal value treated as unsigned integer type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) public        interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two unsigned integers (at least one of which is a 128-bit unsigned integer) Usage : --->    OUTPUT = FIRST_IN * SECOND_IN private  function U128_Multiply_U128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Multiply_U32(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I4B), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U32_Multiply_U128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U128_Multiply_U64(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal integer(kind=I8B), intent(in) :: RhsVal Return Value type( UInt128 ) private  function U64_Multiply_U128(LhsVal, RhsVal) result(OutVal) To perform multiplication:  OutVal = LhsVal * RhsVal. Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) public        interface OPERATOR(.UDIV.) Operator Overload : OPERATOR(.UDIV.) Purpose :  To return the quotient of a division of two unsigned integers,\n  where the dividend (numerator) is a 128-bit unsigned integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit unsigned integer Usage : --->    QUOT = NUMER .UDIV. DENOM private  function U128_Divide_U32(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Divide_U64(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Divide_U128(Dividend, Divisor) result(Quotient) To perform division:  Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend type( UInt128 ), intent(in) :: Divisor Return Value type( UInt128 ) public        interface UMOD Function Interface : UMOD Purpose :  To return the remainder of a division of two unsigned integers,\n  where the dividend (numerator) is a 128-bit unsigned integer and the\n  divisor (denominator) can be 32-, 64- or 128-bit unsigned integer Usage : --->    REM = UMOD(NUMER, DENOM) private  function U128_Mod_U32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Mod_U64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor Return Value type( UInt128 ) private  function U128_Mod_U128(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend MOD Divisor. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend type( UInt128 ), intent(in) :: Divisor Return Value type( UInt128 ) public        interface UDivMod Subroutine Interface : UDivMod Purpose :  To perform a division of two unsigned integers (where the\n  dividend (numerator) is a 128-bit unsigned integer and the divisor\n  (denominator) can be 32-, 64- or 128-bit unsigned integer) and\n  to return both the quotient and the remainder Usage : --->    CALL UDivMod(NUMER, DENOM, QUOT, REM) private  subroutine U128_DivMod_U32(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor. And, to return both quotient and remainder. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I4B), intent(in) :: Divisor type( UInt128 ), intent(out) :: Quotient type( UInt128 ), intent(out) :: Remainder private  subroutine U128_DivMod_U64(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor. And, to return both quotient and remainder. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend integer(kind=I8B), intent(in) :: Divisor type( UInt128 ), intent(out) :: Quotient type( UInt128 ), intent(out) :: Remainder private  subroutine U128_DivMod_U128(Dividend, Divisor, Quotient, Remainder) To perform division:  Quotient = Dividend / Divisor. And, to return both quotient and remainder. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: Dividend type( UInt128 ), intent(in) :: Divisor type( UInt128 ), intent(out) :: Quotient type( UInt128 ), intent(out) :: Remainder public        interface Increment Subroutine Interface : Increment Purpose :  To increase value of a 128-bit unsigned integer by one Usage : --->    CALL Increment(U128) private  subroutine U128_Increment(Val) To increase value of the input by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: Val public        interface Decrement Subroutine Interface : Decrement Purpose :  To decrease value of a 128-bit unsigned integer by one Usage : --->    CALL Decrement(U128) private  subroutine U128_Decrement(Val) To decrease value of the input by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: Val public        interface Add Subroutine Interface : Add Purpose :  To add an unsigned integer to a 128-bit unsigned integer Usage : --->    CALL Add(This, Other) private  subroutine U128_Add_U32(This, Other) To perform addition:  This = This + Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Add_U64(This, Other) To perform addition:  This = This + Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Add_U128(This, Other) To perform addition:  This = This + Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other public        interface Subtract Subroutine Interface : Subtract Purpose :  To subtract an unsigned integer from a 128-bit unsigned integer Usage : --->    CALL Subtract(This, Other) Important Note :  For subtraction of unsigned integers, value of This\n  must always be greater than Other.  Otherwise, value of the returned\n  This is NOT valid. private  subroutine U128_Subtract_U32(This, Other) To perform subtraction:  This = This - Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Subtract_U64(This, Other) To perform subtraction:  This = This - Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other value treated as unsigned integer private  subroutine U128_Subtract_U128(This, Other) To perform subtraction:  This = This - Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other public        interface Multiply Subroutine Interface : Multiply Purpose :  To multiply a 128-bit unsigned integer by an unsigned integer Usage : --->    CALL Multiply(This, Other) private  subroutine U128_Times_U32(This, Other) To perform multiplication:  This = This * Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other private  subroutine U128_Times_U64(This, Other) To perform multiplication:  This = This * Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other private  subroutine U128_Times_U128(This, Other) To perform multiplication:  This = This * Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other public        interface Divide Subroutine Interface : Divide Purpose :  To divide a 128-bit unsigned integer by an unsigned integer Usage : --->    CALL Divide(This, Other) private  subroutine U128_Over_U32(This, Other, Remainder) To perform division:  This = This / Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I4B), intent(in) :: Other integer(kind=I4B), intent(out), optional :: Remainder private  subroutine U128_Over_U64(This, Other, Remainder) To perform division:  This = This / Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This integer(kind=I8B), intent(in) :: Other integer(kind=I8B), intent(out), optional :: Remainder private  subroutine U128_Over_U128(This, Other, Remainder) To perform division:  This = This / Other. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(inout) :: This type( UInt128 ), intent(in) :: Other type( UInt128 ), intent(out), optional :: Remainder public        interface ShiftLOnce Function Interface : ShiftLOnce Purpose :  To perform logical left shift by 1 Usage : --->    OUT = ShiftLOnce(IN) private  function U128_ShiftLeftOnce(InVal) result(OutVal) To perform logical left shift by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) public        interface ShiftROnce Function Interface : ShiftROnce Purpose :  To perform logical right shift by 1 Usage : --->    OUT = ShiftROnce(IN) private  function U128_ShiftRightOnce(InVal) result(OutVal) To perform logical right shift by 1. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) public        interface ShiftL64 Function Interface : ShiftL64 Purpose :  To perform logical left shift by 64 Usage : --->    OUT = ShiftL64(IN) private  function U128_ShiftLeft64(InVal) result(OutVal) To perform logical left shift by 64. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) public        interface ShiftR64 Function Interface : ShiftR64 Purpose :  To perform logical right shift by 64 Usage : --->    OUT = ShiftR64(IN) private  function U128_ShiftRight64(InVal) result(OutVal) To perform logical right shift by 64 Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) public        interface ShiftL63Down Function Interface : ShiftL63Down Purpose :  To perform logical left shift by 63 or less Usage : --->    OUT = ShiftL63Down(IN, 11) private  function U128_ShiftLeft63Down(InVal, ShiftPos) result(OutVal) To perform logical left shift by 63 or less. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos < 64 Return Value type( UInt128 ) public        interface ShiftR63Down Function Interface : ShiftR63Down Purpose :  To perform logical right shift by 63 or less Usage : --->    OUT = ShiftR63Down(IN, 53) private  function U128_ShiftRight63Down(InVal, ShiftPos) result(OutVal) To perform logical right shift by 63 or less. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos < 64 Return Value type( UInt128 ) public        interface ShiftL64Up Function Interface : ShiftL64Up Purpose :  To perform logical left shift by 64 or more (<= 128) Usage : --->    OUT = ShiftL64Up(IN, 111) private  function U128_ShiftLeft64Up(InVal, ShiftPos) result(OutVal) To perform logical left shift by 64 or more. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 64 < ShiftPos <= 128 Return Value type( UInt128 ) public        interface ShiftR64Up Function Interface : ShiftR64Up Purpose :  To perform logical right shift by 64 or more (<= 128) Usage : --->    OUT = ShiftR64Up(IN, 84) private  function U128_ShiftRight64Up(InVal, ShiftPos) result(OutVal) To perform logical right shift by 64 or more. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 64 < ShiftPos <= 128 Return Value type( UInt128 ) public        interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTL(IN, 127) private  function U128_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical left shift of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos <= 128 Return Value type( UInt128 ) public        interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift with 0 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = SHIFTR(IN, 33) private  function U128_ShiftRight(InVal, ShiftPos) result(OutVal) To perform logical right shift of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos 0 <= ShiftPos <= 128 Return Value type( UInt128 ) public        interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 --->    OUT = ISHFT(IN, -24)   ! a logical right shift by 24 private  function U128_ShiftLogical(InVal, ShiftPos) result(OutVal) To perform logical (left or right) shift of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( UInt128 ) public        interface ISHFTC Function Interface : ISHFTC Purpose :  To perform circular shift with -128 <= ShiftPos <= 128 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 --->    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24 private  function U128_Rotate(InVal, ShiftPos) result(OutVal) To perform a circular shift of the rightmost bits. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: ShiftPos -128 <= ShiftPos <= 128; -> positive, the shift is to the left; -> negative, the shift is to the right Return Value type( UInt128 ) public        interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = NOT(IN) private  function U128_Not(InVal) result(OutVal) To return the bitwise logical complement of the UInt128 object. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal Return Value type( UInt128 ) public        interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IOR(LHSIN, RHSIN) private  function U128_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of the UInt128 objects. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) public        interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IEOR(LHSIN, RHSIN) private  function U128_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of the UInt128 objects. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) public        interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IAND(LHSIN, RHSIN) private  function U128_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of the UInt128 objects. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: LhsVal type( UInt128 ), intent(in) :: RhsVal Return Value type( UInt128 ) public        interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumLZ = LEADZ(INPUT) private  function U128_LeadingZeros(U128) result(NumLZ) To count the number of leading zero bits. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B) public        interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumTZ = TRAILZ(INPUT) private  function U128_TrailingZeros(U128) result(NumTZ) To count the number of trailing zero bits. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B) public        interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumBits = POPCNT(INPUT) private  function U128_Count1Bits(U128) result(NumBits) To count the number of 1 bits in the specified input. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B) public        interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the input (For more information, see detailed explanation of the intrinsic function) Usage : --->    NumPar = POPPAR(INPUT) private  function U128_Parity(U128) result(ParNum) To determine the parity of the specified input. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 Return Value integer(kind=I4B) public        interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBSET(IN, Pos) private  function U128_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1. For more detail, see explanation of elemental intrinsic function 'IBSET'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( UInt128 ) public        interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0 (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCLR(IN, Pos) private  function U128_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0. For more detail, see explanation of elemental intrinsic function 'IBCLR'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( UInt128 ) public        interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBCHNG(IN, Pos) private  function U128_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos Return Value type( UInt128 ) public        interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position is 0 (False) or 1 (True) (For more information, see detailed explanation of the intrinsic function) Usage : --->    Flag = BTEST(IN, Pos) private  function U128_TestBit(U128, Pos) result(Flag) To check whether the bit at the specified position is 0 (False) or 1 (True). For more detail, see explanation of elemental intrinsic function 'BTEST'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 integer(kind=I4B), intent(in) :: Pos Return Value logical public        interface IBITS Function Interface : IBITS Purpose :  To extract a sequence of bits according to the specified input (For more information, see detailed explanation of the intrinsic function) Usage : --->    OUT = IBITS(IN, Pos, Len) private  function U128_ExtractBits(InVal, Pos, Len) result(OutVal) To extract a sequence of bits according to the specified input. For more detail, see explanation of elemental intrinsic function 'IBITS'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: Pos integer(kind=I4B), intent(in) :: Len Return Value type( UInt128 ) public        interface MoveBits Subroutine Interface : MoveBits Purpose :  To copy a sequence of bits (a bit field) from one location to another (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS') Usage : --->    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos) private  subroutine U128_MoveBits(InVal, InPos, Len, OutVal, OutPos) To copy a sequence of bits (a bit field) from one location to another. For more detail, see explanation of elemental intrinsic subroutine 'MVBITS'. Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: InVal integer(kind=I4B), intent(in) :: InPos integer(kind=I4B), intent(in) :: Len type( UInt128 ), intent(inout) :: OutVal integer(kind=I4B), intent(in) :: OutPos public        interface Display Subroutine Interface : Display Purpose :  To write/display the 'UInt128' object to the screen (or the specified unit) Usage : To display (unsigned) value of U128 as a decimal string to the screen --->    CALL Display(U128) To display (unsigned) value of U128 as a decimal string to the output logical unit --->    CALL Display(U128, 11) To display (unsigned) value of U128 as a decimal string to the output logical unit with input/output status and message --->    CALL Display(U128, 11, IOStat, IOMsg) To display (signed) values of components of U128 as a decimal string to the screen --->    CALL Display(U128, ShowComponent=.TRUE.) To display (unsigned) value of U128 as a decimal string to the screen with a prefix string --->    CALL Display(U128, Prefix='Unsigned value of U128') private  subroutine U128_Write(U128, Unit, IOStat, IOMsg, ShowComponent, Prefix) To write 'UInt128' object to the screen (or the specified unit). Arguments Type Intent Optional Attributes Name type( UInt128 ), intent(in) :: U128 UInt128 object integer(kind=I4B), intent(in), optional :: Unit output logical unit integer(kind=I4B), intent(out), optional :: IOStat io stat character(len=*), intent(out), optional :: IOMsg io message logical, intent(in), optional :: ShowComponent flag indicating whether to show components or not if flag is present and true, write compoents of the object otherwise, write the object as a decimal string character(len=*), intent(in), optional :: Prefix prefix string Derived Types type, public :: UInt128 a 128-bit unsigned integer type where the base of its components is 2**64. Components Type Visibility Attributes Name Initial integer(kind=I8B), public :: High upper 64 bits treated as unsigned integer integer(kind=I8B), public :: Low lower 64 bits treated as unsigned integer Constructor Constructor Interface : UInt128 Purpose :  To construct a 128-bit unsigned integer from\n  other Fortran intrinsic types Usage : --->    U128 = UInt128(OtherType) private\n\n                    \n                    function I32_To_U128 (I32, AsUnsigned) To convert a signed 32-bit integer number to an unsigned 128-bit integer number\n or to convert an unsigned 32-bit integer number to an unsigned 128-bit integer\n number if the specified flag is present and true. private\n\n                    \n                    function I64_To_U128 (I64, AsUnsigned) To convert a signed 64-bit integer number to an unsigned 128-bit integer number\nor to convert an unsigned 64-bit integer number to an unsigned 128-bit integer\nnumber if the specified flag is present and true. private\n\n                    \n                    function R32_To_U128 (R32) To convert a 32-bit floating point number to an unsigned 128-bit integer number. private\n\n                    \n                    function R64_To_U128 (R64) To convert a 64-bit floating point number to an unsigned 128-bit integer number. private\n\n                    \n                    function R128_To_U128 (R128) To convert a 128-bit floating point number to an unsigned 128-bit integer number. private\n\n                    \n                    function DecString_To_U128 (cStr, ErrFlag, ErrMsg) To convert a decimal string to an unsigned 128-bit integer value.","tags":"","loc":"module\\modbase_uint128.html"},{"title":"ModBase_Error_Handlers – FortCharConv","text":"PURPOSE OF THIS MODULE : contains routines and parameters for error handling tasks Uses ModBase_Common Variables Type Visibility Attributes Name Initial integer(kind=I1B), public, parameter :: ErrNone = 0 no error level integer(kind=I1B), public, parameter :: ErrWarning = 1 warning error level integer(kind=I1B), public, parameter :: ErrSevere = 2 severe error level integer(kind=I1B), public, parameter :: ErrFatal = 3 fatal error level character(len=*), public, parameter :: ErrFilename = 'ErrorLog.txt' Subroutines public  subroutine DisplayWarningError (ErrorMessage, OutUnit) To display a 'Warning Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit public  subroutine DisplayFatalError (ErrorMessage, OutUnit) To display a 'Fatal Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit public  subroutine DisplaySevereError (ErrorMessage, OutUnit) To display a 'Severe Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit public  subroutine DisplayContinueError (ErrorMessage, OutUnit) To display a 'Continued Error' message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ErrorMessage integer(kind=I4B), intent(inout), optional :: OutUnit public  subroutine DisplayMessage (Message, OutUnit) To display a (informative) message on designated output Files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Message integer(kind=I4B), intent(inout), optional :: OutUnit public  subroutine CloseErrorFile () This subroutine closes the general error file. Arguments None public  subroutine AbortProgram (OutUnit) This subroutine causes the program to halt due to a fatal error. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), optional :: OutUnit public  subroutine SetStopOnError (Flag) To set StopOnError flag (module variable). Arguments Type Intent Optional Attributes Name logical, intent(in) :: Flag public  subroutine CloseMiscOpenFiles () This subroutine scans potential Unit numbers and closes\n  any that are still open. Arguments None","tags":"","loc":"module\\modbase_error_handlers.html"},{"title":"ModBase_Tables_CharConv – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains look-up tables used by \"CharConv\" routines. Uses ModBase_Common Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: Pow10_256_Small_MinExp = -350 minimum exponent value of the 'Pow10_256_Small_Table' table integer(kind=I4B), public, parameter :: Pow10_256_Small_MaxExp = 350 maximum exponent value of the Power_of_Ten table integer(kind=I8B), public, parameter :: Pow10_256_Small_Table (0:3,Pow10_256_Small_MinExp:Pow10_256_Small_MaxExp) = RESHAPE([INT(Z'4AAC6E5A51197B81', KIND=I8B), INT(Z'D72FA647259193CE', KIND=I8B), INT(Z'A8726BC8D55CBB16', KIND=I8B), INT(Z'A05C0DD70F6E1619', KIND=I8B), INT(Z'DD5789F0E55FDA62', KIND=I8B), INT(Z'8CFB8FD8EEF5F8C1', KIND=I8B), INT(Z'128F06BB0AB3E9DC', KIND=I8B), INT(Z'C873114CD3499BA0', KIND=I8B), INT(Z'54AD6C6D1EB7D0FA', KIND=I8B), INT(Z'B03A73CF2AB376F2', KIND=I8B), INT(Z'1732C869CD60E453', KIND=I8B), INT(Z'FA8FD5A0081C0288', KIND=I8B), INT(Z'74EC63C43332E29C', KIND=I8B), INT(Z'4E2488617AB02A57', KIND=I8B), INT(Z'0E7FBD42205C8EB4', KIND=I8B), INT(Z'9C99E58405118195', KIND=I8B), INT(Z'52277CB53FFF9B43', KIND=I8B), INT(Z'61ADAA79D95C34ED', KIND=I8B), INT(Z'521FAC92A873B261', KIND=I8B), INT(Z'C3C05EE50655E1FA', KIND=I8B), INT(Z'A6B15BE28FFF8214', KIND=I8B), INT(Z'BA1915184FB34228', KIND=I8B), INT(Z'E6A797B752909EF9', KIND=I8B), INT(Z'F4B0769E47EB5A78', KIND=I8B), INT(Z'682ED96D99FFB14D', KIND=I8B), INT(Z'144FAD2F31D00959', KIND=I8B), INT(Z'9028BED2939A635C', KIND=I8B), INT(Z'98EE4A22ECF3188B', KIND=I8B), INT(Z'C23A8FC9007F9DA0', KIND=I8B), INT(Z'1963987AFE440BAF', KIND=I8B), INT(Z'7432EE873880FC33', KIND=I8B), INT(Z'BF29DCABA82FDEAE', KIND=I8B), INT(Z'B2C933BB409F8508', KIND=I8B), INT(Z'DFBC7E99BDD50E9B', KIND=I8B), INT(Z'113FAA2906A13B3F', KIND=I8B), INT(Z'EEF453D6923BD65A', KIND=I8B), INT(Z'4FBDC0550863B325', KIND=I8B), INT(Z'EBD5CF2016A52921', KIND=I8B), INT(Z'4AC7CA59A424C507', KIND=I8B), INT(Z'9558B4661B6565F8', KIND=I8B), INT(Z'A3AD306A4A7C9FEE', KIND=I8B), INT(Z'E6CB42E81C4E7369', KIND=I8B), INT(Z'5D79BCF00D2DF649', KIND=I8B), INT(Z'BAAEE17FA23EBF76', KIND=I8B), INT(Z'0C987C84DD1BC7EA', KIND=I8B), INT(Z'607E13A223621044', KIND=I8B), INT(Z'F4D82C2C107973DC', KIND=I8B), INT(Z'E95A99DF8ACE6F53', KIND=I8B), INT(Z'87DF4DD30A315CF2', KIND=I8B), INT(Z'BC4ECC45561D4A2A', KIND=I8B), INT(Z'79071B9B8A4BE869', KIND=I8B), INT(Z'91D8A02BB6C10594', KIND=I8B), INT(Z'29D72147CCBDB42E', KIND=I8B), INT(Z'2B627F56ABA49CB5', KIND=I8B), INT(Z'9748E2826CDEE284', KIND=I8B), INT(Z'B64EC836A47146F9', KIND=I8B), INT(Z'744CE999BFED213A', KIND=I8B), INT(Z'363B1F2C568DC3E2', KIND=I8B), INT(Z'FD1B1B2308169B25', KIND=I8B), INT(Z'E3E27A444D8D98B7', KIND=I8B), INT(Z'88B0120017F434C4', KIND=I8B), INT(Z'41E4F37BB6189A6D', KIND=I8B), INT(Z'FE30F0F5E50E20F7', KIND=I8B), INT(Z'8E6D8C6AB0787F72', KIND=I8B), INT(Z'EADC16801DF141F5', KIND=I8B), INT(Z'125E305AA39EC108', KIND=I8B), INT(Z'BDBD2D335E51A935', KIND=I8B), INT(Z'B208EF855C969F4F', KIND=I8B), INT(Z'25931C20256D9273', KIND=I8B), INT(Z'56F5BC714C86714B', KIND=I8B), INT(Z'AD2C788035E61382', KIND=I8B), INT(Z'DE8B2B66B3BC4723', KIND=I8B), INT(Z'F77BF19417647B88', KIND=I8B), INT(Z'765995C6CFD406CE', KIND=I8B), INT(Z'4C3BCB5021AFCC31', KIND=I8B), INT(Z'8B16FB203055AC76', KIND=I8B), INT(Z'B55AEDF91D3D9A6A', KIND=I8B), INT(Z'D3EFFB3883C90882', KIND=I8B), INT(Z'DF4ABE242A1BBF3D', KIND=I8B), INT(Z'ADDCB9E83C6B1793', KIND=I8B), INT(Z'62B1A977648D0104', KIND=I8B), INT(Z'48EBFA06A4BB4AA3', KIND=I8B), INT(Z'D71D6DAD34A2AF0D', KIND=I8B), INT(Z'D953E8624B85DD78', KIND=I8B), INT(Z'1DAF09EA9ED820A2', KIND=I8B), INT(Z'4D937C4426F50EA6', KIND=I8B), INT(Z'8672648C40E5AD68', KIND=I8B), INT(Z'87D4713D6F33AA6B', KIND=I8B), INT(Z'A51ACC65468E28CB', KIND=I8B), INT(Z'60F85B5530B2524F', KIND=I8B), INT(Z'680EFDAF511F18C2', KIND=I8B), INT(Z'A9C98D8CCB009506', KIND=I8B), INT(Z'8E617F7E9831B2FE', KIND=I8B), INT(Z'F936722A7CDEE6E3', KIND=I8B), INT(Z'0212BD1B2566DEF2', KIND=I8B), INT(Z'D43BF0EFFDC0BA48', KIND=I8B), INT(Z'38FCEFAF1F1F0FDF', KIND=I8B), INT(Z'DBC2075A8E0B504E', KIND=I8B), INT(Z'014BB630F7604B57', KIND=I8B), INT(Z'84A57695FE98746D', KIND=I8B), INT(Z'C73C2B9AE6E6D3D6', KIND=I8B), INT(Z'D2B28931318E2461', KIND=I8B), INT(Z'419EA3BD35385E2D', KIND=I8B), INT(Z'A5CED43B7E3E9188', KIND=I8B), INT(Z'390B3681A0A088CC', KIND=I8B), INT(Z'475F2B7D7DF1AD7A', KIND=I8B), INT(Z'52064CAC828675B9', KIND=I8B), INT(Z'CF42894A5DCE35EA', KIND=I8B), INT(Z'63A702110464557F', KIND=I8B), INT(Z'CC9B7B2E6EB70C6C', KIND=I8B), INT(Z'7343EFEBD1940993', KIND=I8B), INT(Z'818995CE7AA0E1B2', KIND=I8B), INT(Z'7C90C295457D6ADF', KIND=I8B), INT(Z'BFC259FA0A64CF87', KIND=I8B), INT(Z'1014EBE6C5F90BF8', KIND=I8B), INT(Z'A1EBFB4219491A1F', KIND=I8B), INT(Z'5BB4F33A96DCC597', KIND=I8B), INT(Z'EFB2F0788CFE0369', KIND=I8B), INT(Z'D41A26E077774EF6', KIND=I8B), INT(Z'CA66FA129F9B60A6', KIND=I8B), INT(Z'B2A230093C93F6FD', KIND=I8B), INT(Z'AB9FAC96B03D8443', KIND=I8B), INT(Z'8920B098955522B4', KIND=I8B), INT(Z'FD00B897478238D0', KIND=I8B), INT(Z'4FA55E05C5DC7A5E', KIND=I8B), INT(Z'EB43CBDE2E2672AA', KIND=I8B), INT(Z'55B46E5F5D5535B0', KIND=I8B), INT(Z'9E20735E8CB16382', KIND=I8B), INT(Z'E38EB587375398F6', KIND=I8B), INT(Z'2614BED5B9B00F54', KIND=I8B), INT(Z'EB2189F734AA831D', KIND=I8B), INT(Z'C5A890362FDDBC62', KIND=I8B), INT(Z'1C7262E905287F33', KIND=I8B), INT(Z'6F99EE8B281C132A', KIND=I8B), INT(Z'A5E9EC7501D523E4', KIND=I8B), INT(Z'F712B443BBD52B7B', KIND=I8B), INT(Z'51C77DD1A3394F80', KIND=I8B), INT(Z'C5C03516F9118BFA', KIND=I8B), INT(Z'47B233C92125366E', KIND=I8B), INT(Z'9A6BB0AA55653B2D', KIND=I8B), INT(Z'E6395D460C07A360', KIND=I8B), INT(Z'7730425CB755EEF8', KIND=I8B), INT(Z'999EC0BB696E840A', KIND=I8B), INT(Z'C1069CD4EABE89F8', KIND=I8B), INT(Z'1FC7B4978F098C38', KIND=I8B), INT(Z'14FC52F3E52B6AB7', KIND=I8B), INT(Z'C00670EA43CA250D', KIND=I8B), INT(Z'F148440A256E2C76', KIND=I8B), INT(Z'73DCD0DEB965F7A3', KIND=I8B), INT(Z'2D1DB3D86F3B22B2', KIND=I8B), INT(Z'380406926A5E5728', KIND=I8B), INT(Z'96CD2A865764DBCA', KIND=I8B), INT(Z'10D4051667BF758C', KIND=I8B), INT(Z'386520CE8B09EB5F', KIND=I8B), INT(Z'C605083704F5ECF2', KIND=I8B), INT(Z'BC807527ED3E12BC', KIND=I8B), INT(Z'D509065C01AF52EF', KIND=I8B), INT(Z'C67E69022DCC6636', KIND=I8B), INT(Z'F7864A44C633682E', KIND=I8B), INT(Z'EBA09271E88D976B', KIND=I8B), INT(Z'4525A3F9810D93D5', KIND=I8B), INT(Z'3C0F01A15C9FBFE2', KIND=I8B), INT(Z'7AB3EE6AFBE0211D', KIND=I8B), INT(Z'93445B8731587EA3', KIND=I8B), INT(Z'D66F0CF7E150F8CA', KIND=I8B), INT(Z'8B12C209B3C7AFDA', KIND=I8B), INT(Z'5960EA05BAD82964', KIND=I8B), INT(Z'B8157268FDAE9E4C', KIND=I8B), INT(Z'8C0AD035D9A536FD', KIND=I8B), INT(Z'ADD7728C20B99BD1', KIND=I8B), INT(Z'6FB92487298E33BD', KIND=I8B), INT(Z'E61ACF033D1A45DF', KIND=I8B), INT(Z'F786C221A807425E', KIND=I8B), INT(Z'8CA6A79794740162', KIND=I8B), INT(Z'A5D3B6D479F8E056', KIND=I8B), INT(Z'8FD0C16206306BAB', KIND=I8B), INT(Z'B56872AA120912F6', KIND=I8B), INT(Z'2FD0517D799101BB', KIND=I8B), INT(Z'8F48A4899877186C', KIND=I8B), INT(Z'B3C4F1BA87BC8696', KIND=I8B), INT(Z'A2C28F54968B57B3', KIND=I8B), INT(Z'3BC465DCD7F5422A', KIND=I8B), INT(Z'331ACDABFE94DE87', KIND=I8B), INT(Z'E0B62E2929ABA83C', KIND=I8B), INT(Z'A5B99994DE1716D0', KIND=I8B), INT(Z'855ABFAA06F9495A', KIND=I8B), INT(Z'9FF0C08B7F1D0B14', KIND=I8B), INT(Z'8C71DCD9BA0B4925', KIND=I8B), INT(Z'4F27FFFA159CDC84', KIND=I8B), INT(Z'A6B16F9488B79BB1', KIND=I8B), INT(Z'07ECF0AE5EE44DD9', KIND=I8B), INT(Z'AF8E5410288E1B6F', KIND=I8B), INT(Z'A2F1FFF89B0413A5', KIND=I8B), INT(Z'105DCB79AAE5829D', KIND=I8B), INT(Z'C9E82CD9F69D6150', KIND=I8B), INT(Z'DB71E91432B1A24A', KIND=I8B), INT(Z'85D73FFB60E28C47', KIND=I8B), INT(Z'0A3A9F2C0ACF71A2', KIND=I8B), INT(Z'BE311C083A225CD2', KIND=I8B), INT(Z'892731AC9FAF056E', KIND=I8B), INT(Z'274D0FFA391B2F59', KIND=I8B), INT(Z'8CC946F70D834E0B', KIND=I8B), INT(Z'6DBD630A48AAF406', KIND=I8B), INT(Z'AB70FE17C79AC6CA', KIND=I8B), INT(Z'F12053F8C761FB2F', KIND=I8B), INT(Z'2FFB98B4D0E4218D', KIND=I8B), INT(Z'092CBBCCDAD5B108', KIND=I8B), INT(Z'D64D3D9DB981787D', KIND=I8B), INT(Z'B6B4347B7C9D3CFD', KIND=I8B), INT(Z'1DFD3F71028E94F8', KIND=I8B), INT(Z'25BBF56008C58EA5', KIND=I8B), INT(Z'85F0468293F0EB4E', KIND=I8B), INT(Z'E461419A5BC48C3D', KIND=I8B), INT(Z'657C8F4D43323A36', KIND=I8B), INT(Z'AF2AF2B80AF6F24E', KIND=I8B), INT(Z'A76C582338ED2621', KIND=I8B), INT(Z'9D799200F2B5AF4C', KIND=I8B), INT(Z'FEDBB32093FEC8C4', KIND=I8B), INT(Z'1AF5AF660DB4AEE1', KIND=I8B), INT(Z'D1476E2C07286FAA', KIND=I8B), INT(Z'E26BFB4097B18D8F', KIND=I8B), INT(Z'3F494FF45C7F3D7A', KIND=I8B), INT(Z'50D98D9FC890ED4D', KIND=I8B), INT(Z'82CCA4DB847945CA', KIND=I8B), INT(Z'9B06FA10BD9DF0F3', KIND=I8B), INT(Z'8F1BA3F1739F0CD9', KIND=I8B), INT(Z'E50FF107BAB528A0', KIND=I8B), INT(Z'A37FCE126597973C', KIND=I8B), INT(Z'01C8B894ED056D30', KIND=I8B), INT(Z'B2E28CEDD086D010', KIND=I8B), INT(Z'1E53ED49A96272C8', KIND=I8B), INT(Z'CC5FC196FEFD7D0C', KIND=I8B), INT(Z'023AE6BA2846C87C', KIND=I8B), INT(Z'DF9B302944A88414', KIND=I8B), INT(Z'25E8E89C13BB0F7A', KIND=I8B), INT(Z'FF77B1FCBEBCDC4F', KIND=I8B), INT(Z'8164D034592C3D4E', KIND=I8B), INT(Z'CBC0FE19CAE9528C', KIND=I8B), INT(Z'77B191618C54E9AC', KIND=I8B), INT(Z'9FAACF3DF73609B1', KIND=I8B), INT(Z'A1BE04416F774CA1', KIND=I8B), INT(Z'FEB13DA03DA3A72F', KIND=I8B), INT(Z'D59DF5B9EF6A2417', KIND=I8B), INT(Z'C795830D75038C1D', KIND=I8B), INT(Z'8A2D8551CB551FC9', KIND=I8B), INT(Z'FE5D8D084D0C90FB', KIND=I8B), INT(Z'4B0573286B44AD1D', KIND=I8B), INT(Z'F97AE3D0D2446F25', KIND=I8B), INT(Z'365C73531F1533DE', KIND=I8B), INT(Z'BEFA78253027DA9D', KIND=I8B), INT(Z'4EE367F9430AEC32', KIND=I8B), INT(Z'9BECCE62836AC577', KIND=I8B), INT(Z'83F39027E6DA80D5', KIND=I8B), INT(Z'6EB9162E7C31D144', KIND=I8B), INT(Z'229C41F793CDA73F', KIND=I8B), INT(Z'C2E801FB244576D5', KIND=I8B), INT(Z'A4F07431E091210B', KIND=I8B), INT(Z'4A675BBA1B3E4595', KIND=I8B), INT(Z'6B43527578C1110F', KIND=I8B), INT(Z'F3A20279ED56D48A', KIND=I8B), INT(Z'8716489F2C5AB4A6', KIND=I8B), INT(Z'8E8099545106EB7D', KIND=I8B), INT(Z'830A13896B78AAA9', KIND=I8B), INT(Z'9845418C345644D6', KIND=I8B), INT(Z'E8DBDAC6F77161D0', KIND=I8B), INT(Z'F220BFA96548A65C', KIND=I8B), INT(Z'23CC986BC656D553', KIND=I8B), INT(Z'BE5691EF416BD60C', KIND=I8B), INT(Z'2312D178B54DBA44', KIND=I8B), INT(Z'EEA8EF93BE9ACFF4', KIND=I8B), INT(Z'2CBFBE86B7EC8AA8', KIND=I8B), INT(Z'EDEC366B11C6CB8F', KIND=I8B), INT(Z'95EBC2EB7150946B', KIND=I8B), INT(Z'952995BC5720C1F8', KIND=I8B), INT(Z'7BF7D71432F3D6A9', KIND=I8B), INT(Z'94B3A202EB1C3F39', KIND=I8B), INT(Z'BB66B3A64DA4B985', KIND=I8B), INT(Z'FA73FB2B6CE8F276', KIND=I8B), INT(Z'DAF5CCD93FB0CC53', KIND=I8B), INT(Z'B9E08A83A5E34F07', KIND=I8B), INT(Z'6A40608FE10DE7E7', KIND=I8B), INT(Z'F910F9F648232F14', KIND=I8B), INT(Z'D1B3400F8F9CFF68', KIND=I8B), INT(Z'E858AD248F5C22C9', KIND=I8B), INT(Z'C2683C59ECA8B0F0', KIND=I8B), INT(Z'9BAA9C39ED15FD6C', KIND=I8B), INT(Z'23100809B9C21FA1', KIND=I8B), INT(Z'91376C36D99995BE', KIND=I8B), INT(Z'F3024B7067D2DD2C', KIND=I8B), INT(Z'02954348685B7CC7', KIND=I8B), INT(Z'ABD40A0C2832A78A', KIND=I8B), INT(Z'B58547448FFFFB2D', KIND=I8B), INT(Z'EFC2DE4C81C79477', KIND=I8B), INT(Z'833A941A82725BF9', KIND=I8B), INT(Z'16C90C8F323F516C', KIND=I8B), INT(Z'E2E69915B3FFF9F9', KIND=I8B), INT(Z'35D9CAEFD11CBCCA', KIND=I8B), INT(Z'D2049C909187797C', KIND=I8B), INT(Z'AE3DA7D97F6792E3', KIND=I8B), INT(Z'8DD01FAD907FFC3B', KIND=I8B), INT(Z'43503DABC563EBFD', KIND=I8B), INT(Z'C685C3B4B5E957DB', KIND=I8B), INT(Z'99CD11CFDF41779C', KIND=I8B), INT(Z'B1442798F49FFB4A', KIND=I8B), INT(Z'14244D16B6BCE6FD', KIND=I8B), INT(Z'F82734A1E363ADD2', KIND=I8B), INT(Z'40405643D711D583', KIND=I8B), INT(Z'DD95317F31C7FA1D', KIND=I8B), INT(Z'4C96B02E3236105E', KIND=I8B), INT(Z'7B1880E52E1E4CA3', KIND=I8B), INT(Z'482835EA666B2572', KIND=I8B), INT(Z'8A7D3EEF7F1CFC52', KIND=I8B), INT(Z'1FBC5C39BEC39475', KIND=I8B), INT(Z'19DEA11E79A5DFCC', KIND=I8B), INT(Z'DA3243650005EECF', KIND=I8B), INT(Z'AD1C8EAB5EE43B66', KIND=I8B), INT(Z'27AB73482E747993', KIND=I8B), INT(Z'E0564966180F57BF', KIND=I8B), INT(Z'90BED43E40076A82', KIND=I8B), INT(Z'D863B256369D4A40', KIND=I8B), INT(Z'78CB280D1D08CBFB', KIND=I8B), INT(Z'CC35EDDFCF0996D7', KIND=I8B), INT(Z'5A7744A6E804A291', KIND=I8B), INT(Z'873E4F75E2224E68', KIND=I8B), INT(Z'56FDF210644AFEFA', KIND=I8B), INT(Z'3F436957C2CBFC8D', KIND=I8B), INT(Z'711515D0A205CB36', KIND=I8B), INT(Z'A90DE3535AAAE202', KIND=I8B), INT(Z'ACBD6E947D5DBEB9', KIND=I8B), INT(Z'CF1443ADB37EFBB0', KIND=I8B), INT(Z'0D5A5B44CA873E03', KIND=I8B), INT(Z'D3515C2831559A83', KIND=I8B), INT(Z'6BF6651CCE5A9734', KIND=I8B), INT(Z'616CAA4C902F5D4E', KIND=I8B), INT(Z'E858790AFE9486C2', KIND=I8B), INT(Z'8412D9991ED58091', KIND=I8B), INT(Z'06F3FE6401F13D01', KIND=I8B), INT(Z'F9C7D4DFB43B34A2', KIND=I8B), INT(Z'626E974DBE39A872', KIND=I8B), INT(Z'A5178FFF668AE0B6', KIND=I8B), INT(Z'88B0FDFD026D8C41', KIND=I8B), INT(Z'B839CA17A14A01CA', KIND=I8B), INT(Z'FB0A3D212DC8128F', KIND=I8B), INT(Z'CE5D73FF402D98E3', KIND=I8B), INT(Z'956E9EBE218477A8', KIND=I8B), INT(Z'D3241E4EC4CE411E', KIND=I8B), INT(Z'7CE66634BC9D0B99', KIND=I8B), INT(Z'80FA687F881C7F8E', KIND=I8B), INT(Z'3ACA466DA9E59593', KIND=I8B), INT(Z'47ED25E27601D166', KIND=I8B), INT(Z'1C1FFFC1EBC44E80', KIND=I8B), INT(Z'A139029F6A239F72', KIND=I8B), INT(Z'C97CD809145EFAF7', KIND=I8B), INT(Z'59E86F5B138245BF', KIND=I8B), INT(Z'A327FFB266B56220', KIND=I8B), INT(Z'C987434744AC874E', KIND=I8B), INT(Z'BBDC0E0B5976B9B5', KIND=I8B), INT(Z'70628B31D862D72F', KIND=I8B), INT(Z'4BF1FF9F0062BAA8', KIND=I8B), INT(Z'FBE9141915D7A922', KIND=I8B), INT(Z'D56988C717EA3411', KIND=I8B), INT(Z'463D96FF273DC67D', KIND=I8B), INT(Z'6F773FC3603DB4A9', KIND=I8B), INT(Z'9D71AC8FADA6C9B5', KIND=I8B), INT(Z'4AC3EAF8DDE4C115', KIND=I8B), INT(Z'97CCFCBEF10D381D', KIND=I8B), INT(Z'CB550FB4384D21D3', KIND=I8B), INT(Z'C4CE17B399107C22', KIND=I8B), INT(Z'9D74E5B7155DF15B', KIND=I8B), INT(Z'7DC03BEEAD508624', KIND=I8B), INT(Z'7E2A53A146606A48', KIND=I8B), INT(Z'F6019DA07F549B2B', KIND=I8B), INT(Z'E2690F926D5AB6D9', KIND=I8B), INT(Z'4E9825752C5253D6', KIND=I8B), INT(Z'2EDA7444CBFC426D', KIND=I8B), INT(Z'99C102844F94E0FB', KIND=I8B), INT(Z'9B03537708B1648F', KIND=I8B), INT(Z'A23E2ED27766E8CC', KIND=I8B), INT(Z'FA911155FEFB5308', KIND=I8B), INT(Z'C0314325637A1939', KIND=I8B), INT(Z'C1C42854CADDBDB3', KIND=I8B), INT(Z'CACDBA871540A2FF', KIND=I8B), INT(Z'793555AB7EBA27CA', KIND=I8B), INT(Z'F03D93EEBC589F88', KIND=I8B), INT(Z'D91A9934FECA9690', KIND=I8B), INT(Z'BEC094946D4865DF', KIND=I8B), INT(Z'4BC1558B2F3458DE', KIND=I8B), INT(Z'96267C7535B763B5', KIND=I8B), INT(Z'CF613F823E7D3C34', KIND=I8B), INT(Z'6E70B9B9889A7F57', KIND=I8B), INT(Z'9EB1AAEDFB016F16', KIND=I8B), INT(Z'BBB01B9283253CA2', KIND=I8B), INT(Z'C3398F62CE1C8B41', KIND=I8B), INT(Z'0A0CE827EAC11F2D', KIND=I8B), INT(Z'465E15A979C1CADC', KIND=I8B), INT(Z'EA9C227723EE8BCB', KIND=I8B), INT(Z'9A03F99DC0D1D708', KIND=I8B), INT(Z'86481118F2B8B37C', KIND=I8B), INT(Z'0BFACD89EC191EC9', KIND=I8B), INT(Z'92A1958A7675175F', KIND=I8B), INT(Z'C084F80531064CCA', KIND=I8B), INT(Z'E7DA155F2F66E05B', KIND=I8B), INT(Z'CEF980EC671F667B', KIND=I8B), INT(Z'B749FAED14125D36', KIND=I8B), INT(Z'B0A636067D47DFFD', KIND=I8B), INT(Z'E1D09AB6FB409872', KIND=I8B), INT(Z'82B7E12780E7401A', KIND=I8B), INT(Z'E51C79A85916F484', KIND=I8B), INT(Z'AE67E1C40E4CEBFE', KIND=I8B), INT(Z'CD2260B25D085F47', KIND=I8B), INT(Z'D1B2ECB8B0908810', KIND=I8B), INT(Z'8F31CC0937AE58D2', KIND=I8B), INT(Z'9A01DA3511E026FE', KIND=I8B), INT(Z'006AF8DEF44A7719', KIND=I8B), INT(Z'861FA7E6DCB4AA15', KIND=I8B), INT(Z'B2FE3F0B8599EF07', KIND=I8B), INT(Z'008250C2565830BD', KIND=I8B), INT(Z'4085B716B15D14E0', KIND=I8B), INT(Z'67A791E093E1D49A', KIND=I8B), INT(Z'DFBDCECE67006AC9', KIND=I8B), INT(Z'0051727975F71E76', KIND=I8B), INT(Z'6853926E2EDA2D0C', KIND=I8B), INT(Z'E0C8BB2C5C6D24E0', KIND=I8B), INT(Z'8BD6A141006042BD', KIND=I8B), INT(Z'0065CF17D374E614', KIND=I8B), INT(Z'82687709BA90B84F', KIND=I8B), INT(Z'58FAE9F773886E18', KIND=I8B), INT(Z'AECC49914078536D', KIND=I8B), INT(Z'C07F42DDC8521F99', KIND=I8B), INT(Z'A30294CC2934E662', KIND=I8B), INT(Z'AF39A475506A899E', KIND=I8B), INT(Z'DA7F5BF590966848', KIND=I8B), INT(Z'B84F89CA9D3353BF', KIND=I8B), INT(Z'25E19CFF99C10FFD', KIND=I8B), INT(Z'6D8406C952429603', KIND=I8B), INT(Z'888F99797A5E012D', KIND=I8B), INT(Z'26636C3D448028AF', KIND=I8B), INT(Z'EF5A043F803153FD', KIND=I8B), INT(Z'C8E5087BA6D33B83', KIND=I8B), INT(Z'AAB37FD7D8F58178', KIND=I8B), INT(Z'6FFC474C95A032DB', KIND=I8B), INT(Z'EB30854F603DA8FC', KIND=I8B), INT(Z'FB1E4A9A90880A64', KIND=I8B), INT(Z'D5605FCDCF32E1D6', KIND=I8B), INT(Z'C5FDAC8FDD841FC9', KIND=I8B), INT(Z'12FE53519C26899D', KIND=I8B), INT(Z'5CF2EEA09A55067F', KIND=I8B), INT(Z'855C3BE0A17FCD26', KIND=I8B), INT(Z'377D17B3D4E527BB', KIND=I8B), INT(Z'D7BDE82603302C05', KIND=I8B), INT(Z'F42FAA48C0EA481E', KIND=I8B), INT(Z'A6B34AD8C9DFC06F', KIND=I8B), INT(Z'855C5DA0CA1E71AA', KIND=I8B), INT(Z'8DAD622F83FC3706', KIND=I8B), INT(Z'F13B94DAF124DA26', KIND=I8B), INT(Z'D0601D8EFC57B08B', KIND=I8B), INT(Z'1359BA847E53070A', KIND=I8B), INT(Z'188C5D5DB27DA264', KIND=I8B), INT(Z'76C53D08D6B70858', KIND=I8B), INT(Z'823C12795DB6CE57', KIND=I8B), INT(Z'183029259DE7C8CD', KIND=I8B), INT(Z'1EAF74B51F1D0AFD', KIND=I8B), INT(Z'54768C4B0C64CA6E', KIND=I8B), INT(Z'A2CB1717B52481ED', KIND=I8B), INT(Z'5E3C336F0561BB00', KIND=I8B), INT(Z'A65B51E266E44DBC', KIND=I8B), INT(Z'A9942F5DCF7DFD09', KIND=I8B), INT(Z'CB7DDCDDA26DA268', KIND=I8B), INT(Z'75CB404AC6BA29C0', KIND=I8B), INT(Z'0FF2265B009D612B', KIND=I8B), INT(Z'D3F93B35435D7C4C', KIND=I8B), INT(Z'FE5D54150B090B02', KIND=I8B), INT(Z'299F082EBC345A18', KIND=I8B), INT(Z'89F757F8E0625CBB', KIND=I8B), INT(Z'C47BC5014A1A6DAF', KIND=I8B), INT(Z'9EFA548D26E5A6E1', KIND=I8B), INT(Z'F406CA3A6B41709E', KIND=I8B), INT(Z'6C752DF7187AF3E9', KIND=I8B), INT(Z'359AB6419CA1091B', KIND=I8B), INT(Z'C6B8E9B0709F109A', KIND=I8B), INT(Z'71087CC90611CCC6', KIND=I8B), INT(Z'47927974DE99B0E4', KIND=I8B), INT(Z'C30163D203C94B62', KIND=I8B), INT(Z'F867241C8CC6D4C0', KIND=I8B), INT(Z'C6A54DFDA3CB1FFB', KIND=I8B), INT(Z'6CBB8BE90B200E8E', KIND=I8B), INT(Z'79E0DE63425DCF1D', KIND=I8B), INT(Z'9B407691D7FC44F8', KIND=I8B), INT(Z'784EA17D0CBDE7FA', KIND=I8B), INT(Z'C7EA6EE34DE81232', KIND=I8B), INT(Z'985915FC12F542E4', KIND=I8B), INT(Z'C21094364DFB5636', KIND=I8B), INT(Z'166249DC4FED61F9', KIND=I8B), INT(Z'F9E50A9C216216BF', KIND=I8B), INT(Z'3E6F5B7B17B2939D', KIND=I8B), INT(Z'F294B943E17A2BC4', KIND=I8B), INT(Z'6DFD6E29B1F45D3B', KIND=I8B), INT(Z'BC2F26A194DD4E37', KIND=I8B), INT(Z'A705992CEECF9C42', KIND=I8B), INT(Z'979CF3CA6CEC5B5A', KIND=I8B), INT(Z'497CC9B41E71748A', KIND=I8B), INT(Z'6B3AF049FA14A1C5', KIND=I8B), INT(Z'50C6FF782A838353', KIND=I8B), INT(Z'BD8430BD08277231', KIND=I8B), INT(Z'9BDBFC21260DD1AD', KIND=I8B), INT(Z'4609AC5C7899CA36', KIND=I8B), INT(Z'A4F8BF5635246428', KIND=I8B), INT(Z'ECE53CEC4A314EBD', KIND=I8B), INT(Z'21697D94B7C8A30C', KIND=I8B), INT(Z'2BC60BB9CB601E62', KIND=I8B), INT(Z'871B7795E136BE99', KIND=I8B), INT(Z'940F4613AE5ED136', KIND=I8B), INT(Z'A9C3DCF9E5BACBCF', KIND=I8B), INT(Z'76B78EA83E3825FA', KIND=I8B), INT(Z'28E2557B59846E3F', KIND=I8B), INT(Z'B913179899F68584', KIND=I8B), INT(Z'5434D4385F297EC3', KIND=I8B), INT(Z'546572524DC62F79', KIND=I8B), INT(Z'331AEADA2FE589CF', KIND=I8B), INT(Z'E757DD7EC07426E5', KIND=I8B), INT(Z'D4A104A33B79EF3A', KIND=I8B), INT(Z'94BF6773709BDDAB', KIND=I8B), INT(Z'3FF0D2C85DEF7621', KIND=I8B), INT(Z'9096EA6F3848984F', KIND=I8B), INT(Z'C9C945CC0A586B08', KIND=I8B), INT(Z'F9EF41504CC2D516', KIND=I8B), INT(Z'0FED077A756B53A9', KIND=I8B), INT(Z'B4BCA50B065ABE63', KIND=I8B), INT(Z'7C3B973F0CEE85CA', KIND=I8B), INT(Z'786B11A45FF38A5C', KIND=I8B), INT(Z'D3E8495912C62894', KIND=I8B), INT(Z'E1EBCE4DC7F16DFB', KIND=I8B), INT(Z'CDA53E876815139E', KIND=I8B), INT(Z'CB42EB06BBF83679', KIND=I8B), INT(Z'64712DD7ABBBD95C', KIND=I8B), INT(Z'8D3360F09CF6E4BD', KIND=I8B), INT(Z'410E8E29421A5886', KIND=I8B), INT(Z'FE13A5C86AF64418', KIND=I8B), INT(Z'BD8D794D96AACFB3', KIND=I8B), INT(Z'B080392CC4349DEC', KIND=I8B), INT(Z'515231B392A0EEA8', KIND=I8B), INT(Z'FD988F3A85B3D51E', KIND=I8B), INT(Z'ECF0D7A0FC5583A0', KIND=I8B), INT(Z'DCA04777F541C567', KIND=I8B), INT(Z'F2D35F103BA49529', KIND=I8B), INT(Z'9E7F598493906532', KIND=I8B), INT(Z'F41686C49DB57244', KIND=I8B), INT(Z'89E42CAAF9491B60', KIND=I8B), INT(Z'AF8836D44A8DBA73', KIND=I8B), INT(Z'C61F2FE5B8747E7F', KIND=I8B), INT(Z'311C2875C522CED5', KIND=I8B), INT(Z'AC5D37D5B79B6239', KIND=I8B), INT(Z'9B6A44895D312910', KIND=I8B), INT(Z'37A6FBDF26919E1F', KIND=I8B), INT(Z'7D633293366B828B', KIND=I8B), INT(Z'D77485CB25823AC7', KIND=I8B), INT(Z'C1226AD5DA3EB9AA', KIND=I8B), INT(Z'02C85D6B781B02D3', KIND=I8B), INT(Z'AE5DFF9C02033197', KIND=I8B), INT(Z'86A8D39EF77164BC', KIND=I8B), INT(Z'B16B058B50CE6814', KIND=I8B), INT(Z'C37A74C65621C388', KIND=I8B), INT(Z'D9F57F830283FDFC', KIND=I8B), INT(Z'A8530886B54DBDEB', KIND=I8B), INT(Z'DDC5C6EE25020219', KIND=I8B), INT(Z'F45911F7EBAA346A', KIND=I8B), INT(Z'D072DF63C324FD7B', KIND=I8B), INT(Z'D267CAA862A12D66', KIND=I8B), INT(Z'CA9B9C54D7214150', KIND=I8B), INT(Z'78B7AB3AF34A60C2', KIND=I8B), INT(Z'4247CB9E59F71E6D', KIND=I8B), INT(Z'8380DEA93DA4BC60', KIND=I8B), INT(Z'7D42836A0CE991A4', KIND=I8B), INT(Z'D6E59609B01CF8F3', KIND=I8B), INT(Z'52D9BE85F074E608', KIND=I8B), INT(Z'A46116538D0DEB78', KIND=I8B), INT(Z'5C9324449023F60D', KIND=I8B), INT(Z'0C9EFB8C1C243730', KIND=I8B), INT(Z'67902E276C921F8B', KIND=I8B), INT(Z'CD795BE870516656', KIND=I8B), INT(Z'39DBF6AADA1679C8', KIND=I8B), INT(Z'E7E35D379196A27E', KIND=I8B), INT(Z'00BA1CD8A3DB53B6', KIND=I8B), INT(Z'806BD9714632DFF6', KIND=I8B), INT(Z'C852F455909C183A', KIND=I8B), INT(Z'A1DC348575FC4B1D', KIND=I8B), INT(Z'80E8A40ECCD228A4', KIND=I8B), INT(Z'A086CFCD97BF97F3', KIND=I8B), INT(Z'3A67B16AF4C31E48', KIND=I8B), INT(Z'CA5341A6D37B5DE5', KIND=I8B), INT(Z'6122CD128006B2CD', KIND=I8B), INT(Z'C8A883C0FDAF7DF0', KIND=I8B), INT(Z'89019DC5B1F3E5DB', KIND=I8B), INT(Z'3CE81210885A355E', KIND=I8B), INT(Z'796B805720085F81', KIND=I8B), INT(Z'FAD2A4B13D1B5D6C', KIND=I8B), INT(Z'15A1029B8F386FA9', KIND=I8B), INT(Z'C6110B4A5538615B', KIND=I8B), INT(Z'CBE3303674053BB0', KIND=I8B), INT(Z'9CC3A6EEC6311A63', KIND=I8B), INT(Z'DB09434273068B93', KIND=I8B), INT(Z'F7954E1CEA8679B1', KIND=I8B), INT(Z'BEDBFC4411068A9C', KIND=I8B), INT(Z'C3F490AA77BD60FC', KIND=I8B), INT(Z'51CB94130FC82E78', KIND=I8B), INT(Z'357AA1A42528181E', KIND=I8B), INT(Z'EE92FB5515482D44', KIND=I8B), INT(Z'F4F1B4D515ACB93B', KIND=I8B), INT(Z'F31F3C8BE9DD1D0B', KIND=I8B), INT(Z'A16CA50697390F12', KIND=I8B), INT(Z'751BDD152D4D1C4A', KIND=I8B), INT(Z'991711052D8BF3C5', KIND=I8B), INT(Z'AFE70BAEE454644D', KIND=I8B), INT(Z'49C7CE483D0752D7', KIND=I8B), INT(Z'D262D45A78A0635D', KIND=I8B), INT(Z'BF5CD54678EEF0B6', KIND=I8B), INT(Z'9BE0CE9A9D697D61', KIND=I8B), INT(Z'9C39C1DA4C49278D', KIND=I8B), INT(Z'86FB897116C87C34', KIND=I8B), INT(Z'EF340A98172AACE4', KIND=I8B), INT(Z'816C8120A261EE5C', KIND=I8B), INT(Z'E1A419286FADB8B8', KIND=I8B), INT(Z'D45D35E6AE3D4DA0', KIND=I8B), INT(Z'9580869F0E7AAC0E', KIND=I8B), INT(Z'A1C7A168CAFA69F3', KIND=I8B), INT(Z'1A0D1F728B9926E6', KIND=I8B), INT(Z'8974836059CCA109', KIND=I8B), INT(Z'BAE0A846D2195712', KIND=I8B), INT(Z'4A3989C2FDB90470', KIND=I8B), INT(Z'6090674F2E7F70A0', KIND=I8B), INT(Z'2BD1A438703FC94B', KIND=I8B), INT(Z'E998D258869FACD7', KIND=I8B), INT(Z'2E63F619DE93A2C6', KIND=I8B), INT(Z'1C5A40917D0FA664', KIND=I8B), INT(Z'7B6306A34627DDCF', KIND=I8B), INT(Z'91FF83775423CC06', KIND=I8B), INT(Z'39FCF3A056388B78', KIND=I8B), INT(Z'E370D0B5DC538FFD', KIND=I8B), INT(Z'1A3BC84C17B1D542', KIND=I8B), INT(Z'B67F6455292CBF08', KIND=I8B), INT(Z'887C30886BC6AE56', KIND=I8B), INT(Z'9C4D04E3536873FC', KIND=I8B), INT(Z'20CABA5F1D9E4A93', KIND=I8B), INT(Z'E41F3D6A7377EECA', KIND=I8B), INT(Z'D54D9E55435C2CF5', KIND=I8B), INT(Z'41B0230E1421487D', KIND=I8B), INT(Z'547EB47B7282EE9C', KIND=I8B), INT(Z'8E938662882AF53E', KIND=I8B), INT(Z'4AA105EA94333833', KIND=I8B), INT(Z'521C2BD199299A9D', KIND=I8B), INT(Z'E99E619A4F23AA43', KIND=I8B), INT(Z'B23867FB2A35B28D', KIND=I8B), INT(Z'9D49476539400640', KIND=I8B), INT(Z'26A336C5FF740144', KIND=I8B), INT(Z'6405FA00E2EC94D4', KIND=I8B), INT(Z'DEC681F9F4C31F31', KIND=I8B), INT(Z'E24DCC9F43C803E8', KIND=I8B), INT(Z'9826023BBFA880CA', KIND=I8B), INT(Z'DE83BC408DD3DD04', KIND=I8B), INT(Z'8B3C113C38F9F37E', KIND=I8B), INT(Z'9AE13FC714BA04E2', KIND=I8B), INT(Z'BE2F82CAAF92A0FD', KIND=I8B), INT(Z'9624AB50B148D445', KIND=I8B), INT(Z'AE0B158B4738705E', KIND=I8B), INT(Z'01998FB8D9E8861A', KIND=I8B), INT(Z'2DBB637D5B77493D', KIND=I8B), INT(Z'3BADD624DD9B0957', KIND=I8B), INT(Z'D98DDAEE19068C76', KIND=I8B), INT(Z'20FFF9D3883153D0', KIND=I8B), INT(Z'7C951E2E592A8DC6', KIND=I8B), INT(Z'E54CA5D70A80E5D6', KIND=I8B), INT(Z'87F8A8D4CFA417C9', KIND=I8B), INT(Z'A93FF8486A3DA8C4', KIND=I8B), INT(Z'1BBA65B9EF753137', KIND=I8B), INT(Z'5E9FCF4CCD211F4C', KIND=I8B), INT(Z'A9F6D30A038D1DBC', KIND=I8B), INT(Z'938FF65A84CD12F6', KIND=I8B), INT(Z'22A8FF286B527D85', KIND=I8B), INT(Z'7647C3200069671F', KIND=I8B), INT(Z'D47487CC8470652B', KIND=I8B), INT(Z'7C39F9F893002BD9', KIND=I8B), INT(Z'75A99F7943138E73', KIND=I8B), INT(Z'29ECD9F40041E073', KIND=I8B), INT(Z'84C8D4DFD2C63F3B', KIND=I8B), INT(Z'5B487876B7C036D0', KIND=I8B), INT(Z'5314075793D87210', KIND=I8B), INT(Z'F468107100525890', KIND=I8B), INT(Z'A5FB0A17C777CF09', KIND=I8B), INT(Z'721A969465B04484', KIND=I8B), INT(Z'67D9092D78CE8E94', KIND=I8B), INT(Z'7182148D4066EEB4', KIND=I8B), INT(Z'CF79CC9DB955C2CC', KIND=I8B), INT(Z'C7509E1CBF8E2AD2', KIND=I8B), INT(Z'C0E7A5BC6B81191C', KIND=I8B), INT(Z'C6F14CD848405530', KIND=I8B), INT(Z'81AC1FE293D599BF', KIND=I8B), INT(Z'F924C5A3EF71B587', KIND=I8B), INT(Z'F1218F2B86615F63', KIND=I8B), INT(Z'B8ADA00E5A506A7C', KIND=I8B), INT(Z'A21727DB38CB002F', KIND=I8B), INT(Z'F76DF70CEB4E22E9', KIND=I8B), INT(Z'2D69F2F667F9B73C', KIND=I8B), INT(Z'A6D90811F0E4851C', KIND=I8B), INT(Z'CA9CF1D206FDC03B', KIND=I8B), INT(Z'354974D02621ABA3', KIND=I8B), INT(Z'38C46FB401F8250C', KIND=I8B), INT(Z'908F4A166D1DA663', KIND=I8B), INT(Z'FD442E4688BD304A', KIND=I8B), INT(Z'A14DE90217D50B46', KIND=I8B), INT(Z'037AC5D0813B1727', KIND=I8B), INT(Z'9A598E4E043287FE', KIND=I8B), INT(Z'9E4A9CEC15763E2E', KIND=I8B), INT(Z'89A163429DCA4E17', KIND=I8B), INT(Z'84597744A189DCF1', KIND=I8B), INT(Z'40EFF1E1853F29FD', KIND=I8B), INT(Z'C5DD44271AD3CDBA', KIND=I8B), INT(Z'EC09BC13453CE19D', KIND=I8B), INT(Z'E56FD515C9EC542D', KIND=I8B), INT(Z'D12BEE59E68EF47C', KIND=I8B), INT(Z'F7549530E188C128', KIND=I8B), INT(Z'B386158C0B460D02', KIND=I8B), INT(Z'0F65E52D9E33B49C', KIND=I8B), INT(Z'82BB74F8301958CE', KIND=I8B), INT(Z'9A94DD3E8CF578B9', KIND=I8B), INT(Z'E0679AEF0E179043', KIND=I8B), INT(Z'933F5E7905C0A1C3', KIND=I8B), INT(Z'E36A52363C1FAF01', KIND=I8B), INT(Z'C13A148E3032D6E7', KIND=I8B), INT(Z'D88181AAD19D7454', KIND=I8B), INT(Z'F80F36174730CA34', KIND=I8B), INT(Z'DC44E6C3CB279AC1', KIND=I8B), INT(Z'F18899B1BC3F8CA1', KIND=I8B), INT(Z'0750F10AC30268B4', KIND=I8B), INT(Z'3B0981CE8C7E7E61', KIND=I8B), INT(Z'29AB103A5EF8C0B9', KIND=I8B), INT(Z'96F5600F15A7B7E5', KIND=I8B), INT(Z'49252D4D73C302E1', KIND=I8B), INT(Z'89CBE2422F9E1DF9', KIND=I8B), INT(Z'7415D448F6B6F0E7', KIND=I8B), INT(Z'BCB2B812DB11A5DE', KIND=I8B), INT(Z'9B6E78A0D0B3C39A', KIND=I8B), INT(Z'6C3EDAD2BB85A577', KIND=I8B), INT(Z'111B495B3464AD21', KIND=I8B), INT(Z'EBDF661791D60F56', KIND=I8B), INT(Z'C1250B6482705A40', KIND=I8B), INT(Z'E3A748C3B533876A', KIND=I8B), INT(Z'CAB10DD900BEEC34', KIND=I8B), INT(Z'936B9FCEBB25C995', KIND=I8B), INT(Z'716E4E3DA30C70D0', KIND=I8B), INT(Z'1C911AF4A2806945', KIND=I8B), INT(Z'3D5D514F40EEA742', KIND=I8B), INT(Z'B84687C269EF3BFB', KIND=I8B), INT(Z'CDC9E1CD0BCF8D04', KIND=I8B), INT(Z'A3B561B1CB208396', KIND=I8B), INT(Z'0CB4A5A3112A5112', KIND=I8B), INT(Z'E65829B3046B0AFA', KIND=I8B), INT(Z'409E2D202761B822', KIND=I8B), INT(Z'A6515D0F1EF4523E', KIND=I8B), INT(Z'47F0E785EABA72AB', KIND=I8B), INT(Z'8FF71A0FE2C2E6DC', KIND=I8B), INT(Z'D0C5B868313A262B', KIND=I8B), INT(Z'8FE5B452E6B166CD', KIND=I8B), INT(Z'59ED216765690F56', KIND=I8B), INT(Z'B3F4E093DB73A093', KIND=I8B), INT(Z'44F726823D88AFB6', KIND=I8B), INT(Z'33DF2167A05DC081', KIND=I8B), INT(Z'306869C13EC3532C', KIND=I8B), INT(Z'E0F218B8D25088B8', KIND=I8B), INT(Z'CB1A781166756DD1', KIND=I8B), INT(Z'A06B74E0C43A9850', KIND=I8B), INT(Z'1E414218C73A13FB', KIND=I8B), INT(Z'8C974F7383725573', KIND=I8B), INT(Z'FDE11615C012C946', KIND=I8B), INT(Z'88865218F5493E64', KIND=I8B), INT(Z'E5D1929EF90898FA', KIND=I8B), INT(Z'AFBD2350644EEACF', KIND=I8B), INT(Z'3D595B9B30177B98', KIND=I8B), INT(Z'2AA7E69F329B8DFE', KIND=I8B), INT(Z'DF45F746B74ABF39', KIND=I8B), INT(Z'DBAC6C247D62A583', KIND=I8B), INT(Z'E657D940FE0EAD3F', KIND=I8B), INT(Z'BAA8F0237FA138BE', KIND=I8B), INT(Z'6B8BBA8C328EB783', KIND=I8B), INT(Z'894BC396CE5DA772', KIND=I8B), INT(Z'9FEDCF913D92588E', KIND=I8B), INT(Z'A9532C2C5F8986EE', KIND=I8B), INT(Z'066EA92F3F326564', KIND=I8B), INT(Z'AB9EB47C81F5114F', KIND=I8B), INT(Z'47E943758CF6EEB2', KIND=I8B), INT(Z'D3A7F737776BE8AA', KIND=I8B), INT(Z'C80A537B0EFEFEBD', KIND=I8B), INT(Z'D686619BA27255A2', KIND=I8B), INT(Z'6CF1CA29781A552F', KIND=I8B), INT(Z'A448FA82AAA3716A', KIND=I8B), INT(Z'BD06742CE95F5F36', KIND=I8B), INT(Z'8613FD0145877585', KIND=I8B), INT(Z'082E3CB3D620EA7B', KIND=I8B), INT(Z'4D5B3923554C4DC5', KIND=I8B), INT(Z'2C48113823B73704', KIND=I8B), INT(Z'A798FC4196E952E7', KIND=I8B), INT(Z'4A39CBE0CBA9251A', KIND=I8B), INT(Z'60B2076C2A9F6136', KIND=I8B), INT(Z'F75A15862CA504C5', KIND=I8B), INT(Z'D17F3B51FCA3A7A0', KIND=I8B), INT(Z'EE641F6C7F49B730', KIND=I8B), INT(Z'5C6F44A39AA39CC1', KIND=I8B), INT(Z'9A984D73DBE722FB', KIND=I8B), INT(Z'82EF85133DE648C4', KIND=I8B), INT(Z'69FD27479F1C24FC', KIND=I8B), INT(Z'338B15CC814C83F2', KIND=I8B), INT(Z'C13E60D0D2E0EBBA', KIND=I8B), INT(Z'A3AB66580D5FDAF5', KIND=I8B), INT(Z'047C711986E32E3B', KIND=I8B), INT(Z'C06DDB3FA19FA4EF', KIND=I8B), INT(Z'318DF905079926A8', KIND=I8B), INT(Z'CC963FEE10B7D1B3', KIND=I8B), INT(Z'C59B8D5FE89BF9CA', KIND=I8B), INT(Z'F089520F8A078E2A', KIND=I8B), INT(Z'FDF17746497F7052', KIND=I8B), INT(Z'FFBBCFE994E5C61F', KIND=I8B), INT(Z'BB81385BF1617C1E', KIND=I8B), INT(Z'D655D349B644B8DA', KIND=I8B), INT(Z'FEB6EA8BEDEFA633', KIND=I8B), INT(Z'9FD561F1FD0F9BD3', KIND=I8B), INT(Z'6A618672EDB9DB26', KIND=I8B), INT(Z'CBEB481C23D5E711', KIND=I8B), INT(Z'FE64A52EE96B8FC0', KIND=I8B), INT(Z'C7CABA6E7C5382C8', KIND=I8B), INT(Z'C4F9E80FA92851EF', KIND=I8B), INT(Z'FEE61A232CCB60D5', KIND=I8B), INT(Z'3DFDCE7AA3C673B0', KIND=I8B), INT(Z'F9BD690A1B68637B', KIND=I8B), INT(Z'9B1C3109C9B93335', KIND=I8B), INT(Z'9F4FD055FBFF1C85', KIND=I8B), INT(Z'06BEA10CA65C084E', KIND=I8B), INT(Z'9C1661A651213E2D', KIND=I8B), INT(Z'01E33D4C3C278003', KIND=I8B), INT(Z'4723C46B7AFEE3A7', KIND=I8B), INT(Z'486E494FCFF30A62', KIND=I8B), INT(Z'C31BFA0FE5698DB8', KIND=I8B), INT(Z'C25C0C9F4B316004', KIND=I8B), INT(Z'D8ECB58659BE9C90', KIND=I8B), INT(Z'5A89DBA3C3EFCCFA', KIND=I8B), INT(Z'F3E2F893DEC3F126', KIND=I8B), INT(Z'797987E38EFEDC02', KIND=I8B), INT(Z'C793F173F81721DA', KIND=I8B), INT(Z'F89629465A75E01C', KIND=I8B), INT(Z'986DDB5C6B3A76B7', KIND=I8B), INT(Z'17D7E9DC72BE9303', KIND=I8B), INT(Z'F978EDD0F61CEA51', KIND=I8B), INT(Z'F6BBB397F1135823', KIND=I8B), INT(Z'BE89523386091465', KIND=I8B), INT(Z'5DCDE4538F6E37C4', KIND=I8B), INT(Z'F7D7294533A424E5', KIND=I8B), INT(Z'746AA07DED582E2C', KIND=I8B), INT(Z'EE2BA6C0678B597F', KIND=I8B), INT(Z'5AA0AEB439A4E2DA', KIND=I8B), INT(Z'1AE679CB4046970F', KIND=I8B), INT(Z'A8C2A44EB4571CDC', KIND=I8B), INT(Z'94DB483840B717EF', KIND=I8B), INT(Z'3148DA61480E1B91', KIND=I8B), INT(Z'21A0183E10583CD3', KIND=I8B), INT(Z'92F34D62616CE413', KIND=I8B), INT(Z'BA121A4650E4DDEB', KIND=I8B), INT(Z'FD9B10F99A11A275', KIND=I8B), INT(Z'EA081E4D946E4C07', KIND=I8B), INT(Z'77B020BAF9C81D17', KIND=I8B), INT(Z'E896A0D7E51E1566', KIND=I8B), INT(Z'FE80EA9C004B0589', KIND=I8B), INT(Z'F24512F07CC4EF84', KIND=I8B), INT(Z'0ACE1474DC1D122E', KIND=I8B), INT(Z'915E2486EF32CD60', KIND=I8B), INT(Z'3E212543005DC6EB', KIND=I8B), INT(Z'AED657AC9BF62B66', KIND=I8B), INT(Z'0D819992132456BA', KIND=I8B), INT(Z'B5B5ADA8AAFF80B8', KIND=I8B), INT(Z'CDA96E93C07538A6', KIND=I8B), INT(Z'5A8BED97C2F3B63F', KIND=I8B), INT(Z'10E1FFF697ED6C69', KIND=I8B), INT(Z'E3231912D5BF60E6', KIND=I8B), INT(Z'E089E51C58494368', KIND=I8B), INT(Z'D897747ED9D851E7', KIND=I8B), INT(Z'CA8D3FFA1EF463C1', KIND=I8B), INT(Z'8DF5EFABC5979C8F', KIND=I8B), INT(Z'D8AC5E636E5B9442', KIND=I8B), INT(Z'4EBD519E904E6661', KIND=I8B), INT(Z'BD308FF8A6B17CB2', KIND=I8B), INT(Z'B1736B96B6FD83B3', KIND=I8B), INT(Z'4ED775FC49F27952', KIND=I8B), INT(Z'E26CA6063461FFFA', KIND=I8B), INT(Z'AC7CB3F6D05DDBDE', KIND=I8B), INT(Z'DDD0467C64BCE4A0', KIND=I8B), INT(Z'7146A9BDAE378BD3', KIND=I8B), INT(Z'4D83E7C3E0BD3FFC', KIND=I8B), INT(Z'6BCDF07A423AA96B', KIND=I8B), INT(Z'8AA22C0DBEF60EE4', KIND=I8B), INT(Z'8D98542D19C56EC8', KIND=I8B), INT(Z'20E4E1B4D8EC8FFB', KIND=I8B), INT(Z'86C16C98D2C953C6', KIND=I8B), INT(Z'AD4AB7112EB3929D', KIND=I8B), INT(Z'70FE69386036CA7B', KIND=I8B), INT(Z'A91E1A220F27B3FA', KIND=I8B), INT(Z'E871C7BF077BA8B7', KIND=I8B), INT(Z'D89D64D57A607744', KIND=I8B), INT(Z'869F01C33C223E8C', KIND=I8B), INT(Z'C9B2D0554978D07C', KIND=I8B), INT(Z'11471CD764AD4972', KIND=I8B), INT(Z'87625F056C7C4A8B', KIND=I8B), INT(Z'A846C2340B2ACE30', KIND=I8B), INT(Z'7C1F846A9BD7049B', KIND=I8B), INT(Z'D598E40D3DD89BCF', KIND=I8B), INT(Z'A93AF6C6C79B5D2D', KIND=I8B), INT(Z'925872C10DF581BC', KIND=I8B), INT(Z'5B27658542CCC5C2', KIND=I8B), INT(Z'4AFF1D108D4EC2C3', KIND=I8B), INT(Z'D389B47879823479', KIND=I8B), INT(Z'9B7747B8A8B97115', KIND=I8B), INT(Z'18F89F7349BFFB99', KIND=I8B), INT(Z'CEDF722A585139BA', KIND=I8B), INT(Z'843610CB4BF160CB', KIND=I8B), INT(Z'025519A6D2E7CD5A', KIND=I8B), INT(Z'9F36C7501C2FFA80', KIND=I8B), INT(Z'C2974EB4EE658828', KIND=I8B), INT(Z'A54394FE1EEDB8FE', KIND=I8B), INT(Z'02EA601087A1C0B1', KIND=I8B), INT(Z'C7047924233BF920', KIND=I8B), INT(Z'733D226229FEEA32', KIND=I8B), INT(Z'CE947A3DA6A9273E', KIND=I8B), INT(Z'01D27C0A54C5186F', KIND=I8B), INT(Z'BC62CBB696057BB4', KIND=I8B), INT(Z'0806357D5A3F525F', KIND=I8B), INT(Z'811CCC668829B887', KIND=I8B), INT(Z'02471B0CE9F65E8A', KIND=I8B), INT(Z'AB7B7EA43B86DAA1', KIND=I8B), INT(Z'CA07C2DCB0CF26F7', KIND=I8B), INT(Z'A163FF802A3426A8', KIND=I8B), INT(Z'42D8E1D02473F62D', KIND=I8B), INT(Z'965A5E4D4A689149', KIND=I8B), INT(Z'FC89B393DD02F0B5', KIND=I8B), INT(Z'C9BCFF6034C13052', KIND=I8B), INT(Z'938F1A442D90F3B8', KIND=I8B), INT(Z'FBF0F5E09D02B59B', KIND=I8B), INT(Z'BBAC2078D443ACE2', KIND=I8B), INT(Z'FC2C3F3841F17C67', KIND=I8B), INT(Z'3C39706A9C7A9853', KIND=I8B), INT(Z'DD7699AC6221B181', KIND=I8B), INT(Z'D54B944B84AA4C0D', KIND=I8B), INT(Z'9D9BA7832936EDC0', KIND=I8B), INT(Z'8B47CC8543993E68', KIND=I8B), INT(Z'54D440177AAA1DE1', KIND=I8B), INT(Z'0A9E795E65D4DF11', KIND=I8B), INT(Z'C5029163F384A931', KIND=I8B), INT(Z'EE19BFA6947F8E02', KIND=I8B), INT(Z'AA09501D5954A559', KIND=I8B), INT(Z'4D4617B5FF4A16D5', KIND=I8B), INT(Z'F64335BCF065D37D', KIND=I8B), INT(Z'34D017C81CCFB8C1', KIND=I8B), INT(Z'8A45D21257D4E758', KIND=I8B), INT(Z'504BCED1BF8E4E45', KIND=I8B), INT(Z'99EA0196163FA42E', KIND=I8B), INT(Z'42041DBA2403A6F2', KIND=I8B), INT(Z'ECD74696EDCA212E', KIND=I8B), INT(Z'E45EC2862F71E1D6', KIND=I8B), INT(Z'C06481FB9BCF8D39', KIND=I8B), INT(Z'D2852528AD0490AE', KIND=I8B), INT(Z'A80D183CA93CA979', KIND=I8B), INT(Z'5D767327BB4E5A4C', KIND=I8B), INT(Z'F07DA27A82C37088', KIND=I8B), INT(Z'239337396C22DA6D', KIND=I8B), INT(Z'E9082F25E9C5E9EC', KIND=I8B), INT(Z'3A6A07F8D510F86F', KIND=I8B), INT(Z'964E858C91BA2655', KIND=I8B), INT(Z'2C780507C72B9108', KIND=I8B), INT(Z'E34A3AEF64376467', KIND=I8B), INT(Z'890489F70A55368B', KIND=I8B), INT(Z'BBE226EFB628AFEA', KIND=I8B), INT(Z'F7960649B8F6754A', KIND=I8B), INT(Z'DC1CC9AB3D453D80', KIND=I8B), INT(Z'2B45AC74CCEA842E', KIND=I8B), INT(Z'EADAB0ABA3B2DBE5', KIND=I8B), INT(Z'9ABDC3EE139A094E', KIND=I8B), INT(Z'4991FE0B064B4670', KIND=I8B), INT(Z'3B0B8BC90012929D', KIND=I8B), INT(Z'92C8AE6B464FC96F', KIND=I8B), INT(Z'C16D34E998808BA2', KIND=I8B), INT(Z'9BF67D8DC7DE180C', KIND=I8B), INT(Z'09CE6EBB40173744', KIND=I8B), INT(Z'B77ADA0617E3BBCB', KIND=I8B), INT(Z'F1C88223FEA0AE8A', KIND=I8B), INT(Z'C2F41CF139D59E0F', KIND=I8B), INT(Z'CC420A6A101D0515', KIND=I8B), INT(Z'E55990879DDCAABD', KIND=I8B), INT(Z'F71D51567F246D16', KIND=I8B), INT(Z'99D89216C42582C9', KIND=I8B), INT(Z'9FA946824A12232D', KIND=I8B), INT(Z'8F57FA54C2A9EAB6', KIND=I8B), INT(Z'74E4A5AC1EED885C', KIND=I8B), INT(Z'004EB69C752EE37C', KIND=I8B), INT(Z'47939822DC96ABF9', KIND=I8B), INT(Z'B32DF8E9F3546564', KIND=I8B), INT(Z'921DCF1726A8EA73', KIND=I8B), INT(Z'40626443927A9C5B', KIND=I8B), INT(Z'59787E2B93BC56F7', KIND=I8B), INT(Z'DFF9772470297EBD', KIND=I8B), INT(Z'3B52A16E78299288', KIND=I8B), INT(Z'883D7EAA3B8CA1B9', KIND=I8B), INT(Z'57EB4EDB3C55B65A', KIND=I8B), INT(Z'8BFBEA76C619EF36', KIND=I8B), INT(Z'8A2749CA1633F72A', KIND=I8B), INT(Z'2A4CDE54CA6FCA27', KIND=I8B), INT(Z'EDE622920B6B23F1', KIND=I8B), INT(Z'AEFAE51477A06B03', KIND=I8B), INT(Z'6CB11C3C9BC0F4F4', KIND=I8B), INT(Z'74E015E9FD0BBCB1', KIND=I8B), INT(Z'E95FAB368E45ECED', KIND=I8B), INT(Z'DAB99E59958885C4', KIND=I8B), INT(Z'E3EEB1A5E1589918', KIND=I8B), INT(Z'690C0DB23E2755EE', KIND=I8B), INT(Z'11DBCB0218EBB414', KIND=I8B), INT(Z'88B402F7FD75539B', KIND=I8B), INT(Z'9CEA5E0F59AEBF5F', KIND=I8B), INT(Z'834F111ECDB12B6A', KIND=I8B), INT(Z'D652BDC29F26A119', KIND=I8B), INT(Z'AAE103B5FCD2A881', KIND=I8B), INT(Z'4424F593301A6F37', KIND=I8B), INT(Z'E422D566811D7645', KIND=I8B), INT(Z'4BE76D3346F0495F', KIND=I8B), INT(Z'D59944A37C0752A2', KIND=I8B), INT(Z'4A97197BFE108582', KIND=I8B), INT(Z'EE95C56010B269EB', KIND=I8B), INT(Z'6F70A4400C562DDB', KIND=I8B), INT(Z'857FCAE62D8493A5', KIND=I8B), INT(Z'1D3CDFDAFD94A6E2', KIND=I8B), INT(Z'EA3B36B814DF0466', KIND=I8B), INT(Z'CB4CCD500F6BB952', KIND=I8B), INT(Z'A6DFBD9FB8E5B88E', KIND=I8B), INT(Z'A48C17D1BCF9D09B', KIND=I8B), INT(Z'A4CA04661A16C57F', KIND=I8B), INT(Z'7E2000A41346A7A7', KIND=I8B), INT(Z'D097AD07A71F26B2', KIND=I8B), INT(Z'C6D78EE3161C2261', KIND=I8B), INT(Z'C6FE42BFD04E3B6F', KIND=I8B), INT(Z'8ED400668C0C28C8', KIND=I8B), INT(Z'825ECC24C873782F', KIND=I8B), INT(Z'B88D729BDBA32AF9', KIND=I8B), INT(Z'F8BDD36FC461CA4B', KIND=I8B), INT(Z'728900802F0F32FA', KIND=I8B), INT(Z'A2F67F2DFA90563B', KIND=I8B), INT(Z'A6B0CF42D28BF5B8', KIND=I8B), INT(Z'B6ED484BB57A3CDE', KIND=I8B), INT(Z'4F2B40A03AD2FFB9', KIND=I8B), INT(Z'CBB41EF979346BCA', KIND=I8B), INT(Z'505D0313872EF326', KIND=I8B), INT(Z'24A89A5EA2D8CC16', KIND=I8B), INT(Z'E2F610C84987BFA8', KIND=I8B), INT(Z'FEA126B7D78186BC', KIND=I8B), INT(Z'F23A21EC347D57F7', KIND=I8B), INT(Z'16E9607B25C77F8D', KIND=I8B), INT(Z'0DD9CA7D2DF4D7C9', KIND=I8B), INT(Z'9F24B832E6B0F436', KIND=I8B), INT(Z'6EC8AA67419CADF5', KIND=I8B), INT(Z'5CA3B899EF395F71', KIND=I8B), INT(Z'91503D1C79720DBB', KIND=I8B), INT(Z'C6EDE63FA05D3143', KIND=I8B), INT(Z'CA7AD5011203D973', KIND=I8B), INT(Z'33CCA6C06B07B74D', KIND=I8B), INT(Z'75A44C6397CE912A', KIND=I8B), INT(Z'F8A95FCF88747D94', KIND=I8B), INT(Z'9E8CC520AB4267E7', KIND=I8B), INT(Z'605FE83842E4D290', KIND=I8B), INT(Z'C986AFBE3EE11ABA', KIND=I8B), INT(Z'9B69DBE1B548CE7C', KIND=I8B), INT(Z'C62FF668D61301E1', KIND=I8B), INT(Z'F877E246539E0734', KIND=I8B), INT(Z'FBE85BADCE996168', KIND=I8B), INT(Z'C24452DA229B021B', KIND=I8B), INT(Z'F7BBF4030B97C25A', KIND=I8B), INT(Z'3695DAD7E8858901', KIND=I8B), INT(Z'FAE27299423FB9C3', KIND=I8B), INT(Z'F2D56790AB41C2A2', KIND=I8B), INT(Z'3AD57881E73ED978', KIND=I8B), INT(Z'021DA8C6F15375A1', KIND=I8B), INT(Z'DCCD879FC967D41A', KIND=I8B), INT(Z'97C560BA6B0919A5', KIND=I8B), INT(Z'898AD6A2610E8FD6', KIND=I8B), INT(Z'82A512F8ADA85309', KIND=I8B), INT(Z'5400E987BBC1C920', KIND=I8B), INT(Z'BDB6B8E905CB600F', KIND=I8B), INT(Z'EBED8C4AF95233CC', KIND=I8B), INT(Z'A34E57B6D91267CB', KIND=I8B), INT(Z'290123E9AAB23B68', KIND=I8B), INT(Z'ED246723473E3813', KIND=I8B), INT(Z'737477AEDBD3605F', KIND=I8B), INT(Z'6610F6D247AB80DF', KIND=I8B), INT(Z'F9A0B6720AAF6521', KIND=I8B), INT(Z'9436C0760C86E30B', KIND=I8B), INT(Z'5051959A92C83877', KIND=I8B), INT(Z'BF953486D9966117', KIND=I8B), INT(Z'F808E40E8D5B3E69', KIND=I8B), INT(Z'B94470938FA89BCE', KIND=I8B), INT(Z'2465FB01377A4695', KIND=I8B), INT(Z'2F7A81A88FFBF95D', KIND=I8B), INT(Z'B60B1D1230B20E04', KIND=I8B), INT(Z'E7958CB87392C2C2', KIND=I8B), INT(Z'36BFBCE0C2AC6C1D', KIND=I8B), INT(Z'9DAC910959FD7BDA', KIND=I8B), INT(Z'B1C6F22B5E6F48C2', KIND=I8B), INT(Z'90BD77F3483BB9B9', KIND=I8B), INT(Z'C46FAC18F3578724', KIND=I8B), INT(Z'4517B54BB07CDAD0', KIND=I8B), INT(Z'1E38AEB6360B1AF3', KIND=I8B), INT(Z'B4ECD5F01A4AA828', KIND=I8B), INT(Z'F58B971F302D68EE', KIND=I8B), INT(Z'165DA29E9C9C1184', KIND=I8B), INT(Z'25C6DA63C38DE1B0', KIND=I8B), INT(Z'E2280B6C20DD5232', KIND=I8B), INT(Z'19773E737E1C6194', KIND=I8B), INT(Z'0DFA85A321E18AF3', KIND=I8B), INT(Z'579C487E5A38AD0E', KIND=I8B), INT(Z'8D590723948A535F', KIND=I8B), INT(Z'DFD50E105DA379F9', KIND=I8B), INT(Z'9179270BEA59EDAF', KIND=I8B), INT(Z'2D835A9DF0C6D851', KIND=I8B), INT(Z'B0AF48EC79ACE837', KIND=I8B), INT(Z'D7CA5194750C5878', KIND=I8B), INT(Z'F5D770CEE4F0691B', KIND=I8B), INT(Z'F8E431456CF88E65', KIND=I8B), INT(Z'DCDB1B2798182244', KIND=I8B), INT(Z'66DE72FCC927B74B', KIND=I8B), INT(Z'B9A6A6814F1641B1', KIND=I8B), INT(Z'1B8E9ECB641B58FF', KIND=I8B), INT(Z'8A08F0F8BF0F156B', KIND=I8B), INT(Z'C0960FBBFB71A51E', KIND=I8B), INT(Z'A8105021A2DBD21D', KIND=I8B), INT(Z'E272467E3D222F3F', KIND=I8B), INT(Z'AC8B2D36EED2DAC5', KIND=I8B), INT(Z'30BB93AAFA4E0E65', KIND=I8B), INT(Z'9214642A0B92C6A5', KIND=I8B), INT(Z'5B0ED81DCC6ABB0F', KIND=I8B), INT(Z'D7ADF884AA879177', KIND=I8B), INT(Z'3E753C4ADC70C8FF', KIND=I8B), INT(Z'BB4CBE9A473BBC27', KIND=I8B), INT(Z'98E947129FC2B4E9', KIND=I8B), INT(Z'86CCBB52EA94BAEA', KIND=I8B), INT(Z'0E128B5D938CFB3F', KIND=I8B), INT(Z'2A1FEE40D90AAB31', KIND=I8B), INT(Z'3F2398D747B36224', KIND=I8B), INT(Z'A87FEA27A539E9A5', KIND=I8B), INT(Z'51972E34F8703A0F', KIND=I8B), INT(Z'34A7E9D10F4D55FD', KIND=I8B), INT(Z'8EEC7F0D19A03AAD', KIND=I8B), INT(Z'D29FE4B18E88640E', KIND=I8B), INT(Z'52FE7CE11B462449', KIND=I8B), INT(Z'40E8F222A99055BE', KIND=I8B), INT(Z'1953CF68300424AC', KIND=I8B), INT(Z'83A3EEEEF9153E89', KIND=I8B), INT(Z'E7BE1C196217AD5B', KIND=I8B), INT(Z'51232EAB53F46B2D', KIND=I8B), INT(Z'5FA8C3423C052DD7', KIND=I8B), INT(Z'A48CEAAAB75A8E2B', KIND=I8B), INT(Z'61ADA31FBA9D98B2', KIND=I8B), INT(Z'256BFA5628F185F9', KIND=I8B), INT(Z'3792F412CB06794D', KIND=I8B), INT(Z'CDB02555653131B6', KIND=I8B), INT(Z'DD0C85F3D4A27F6F', KIND=I8B), INT(Z'37637C75D996F3BB', KIND=I8B), INT(Z'E2BBD88BBEE40BD0', KIND=I8B), INT(Z'808E17555F3EBF11', KIND=I8B), INT(Z'D44FA770C9CB1F4B', KIND=I8B), INT(Z'453C5B934FFCB0AA', KIND=I8B), INT(Z'5B6ACEAEAE9D0EC4', KIND=I8B), INT(Z'A0B19D2AB70E6ED6', KIND=I8B), INT(Z'8963914CFC3DE71E', KIND=I8B), INT(Z'568B727823FBDCD5', KIND=I8B), INT(Z'F245825A5A445275', KIND=I8B), INT(Z'C8DE047564D20A8B', KIND=I8B), INT(Z'EBBC75A03B4D60E6', KIND=I8B), INT(Z'AC2E4F162CFAD40A', KIND=I8B), INT(Z'EED6E2F0F0D56712', KIND=I8B), INT(Z'FB158592BE068D2E', KIND=I8B), INT(Z'D355C98425105C90', KIND=I8B), INT(Z'AB9CF16DDC1CC486', KIND=I8B), INT(Z'55464DD69685606B', KIND=I8B), INT(Z'9CED737BB6C4183D', KIND=I8B), INT(Z'882B3BE52E5473B4', KIND=I8B), INT(Z'96842DC95323F5A8', KIND=I8B), INT(Z'AA97E14C3C26B886', KIND=I8B), INT(Z'C428D05AA4751E4C', KIND=I8B), INT(Z'AA360ADE79E990A1', KIND=I8B), INT(Z'3C25393BA7ECF312', KIND=I8B), INT(Z'D53DD99F4B3066A8', KIND=I8B), INT(Z'F53304714D9265DF', KIND=I8B), INT(Z'AA61C6CB0C31FA64', KIND=I8B), INT(Z'259743C548F417EB', KIND=I8B), INT(Z'E546A8038EFE4029', KIND=I8B), INT(Z'993FE2C6D07B7FAB', KIND=I8B), INT(Z'94FA387DCF3E78FD', KIND=I8B), INT(Z'6EFD14B69B311DE6', KIND=I8B), INT(Z'DE98520472BDD033', KIND=I8B), INT(Z'BF8FDB78849A5F96', KIND=I8B), INT(Z'3A38C69D430E173D', KIND=I8B), INT(Z'4ABC59E441FD6560', KIND=I8B), INT(Z'963E66858F6D4440', KIND=I8B), INT(Z'EF73D256A5C0F77C', KIND=I8B), INT(Z'24637C2249E8CE86', KIND=I8B), INT(Z'2EB5B82EA93E5F5C', KIND=I8B), INT(Z'DDE7001379A44AA8', KIND=I8B), INT(Z'95A8637627989AAD', KIND=I8B), INT(Z'2D7C5B2ADC630227', KIND=I8B), INT(Z'3A63263A538DF733', KIND=I8B), INT(Z'5560C018580D5D52', KIND=I8B), INT(Z'BB127C53B17EC159', KIND=I8B), INT(Z'F8DB71F5937BC2B1', KIND=I8B), INT(Z'C8FBEFC8E87174FF', KIND=I8B), INT(Z'AAB8F01E6E10B4A6', KIND=I8B), INT(Z'E9D71B689DDE71AF', KIND=I8B), INT(Z'FB8927397C2D59AF', KIND=I8B), INT(Z'3D9D75DD9146E91F', KIND=I8B), INT(Z'CAB3961304CA70E8', KIND=I8B), INT(Z'9226712162AB070D', KIND=I8B), INT(Z'FA6B7107DB38B01A', KIND=I8B), INT(Z'4D04D354F598A367', KIND=I8B), INT(Z'3D607B97C5FD0D22', KIND=I8B), INT(Z'B6B00D69BB55C8D1', KIND=I8B), INT(Z'F9064D49D206DC21', KIND=I8B), INT(Z'E046082A32FECC41', KIND=I8B), INT(Z'8CB89A7DB77C506A', KIND=I8B), INT(Z'E45C10C42A2B3B05', KIND=I8B), INT(Z'3BA3F04E23444995', KIND=I8B), INT(Z'CC2BC51A5FDF3FA9', KIND=I8B), INT(Z'77F3608E92ADB242', KIND=I8B), INT(Z'8EB98A7A9A5B04E3', KIND=I8B), INT(Z'8A8CEC61AC155BFA', KIND=I8B), INT(Z'7F36B660F7D70F93', KIND=I8B), INT(Z'55F038B237591ED3', KIND=I8B), INT(Z'B267ED1940F1C61C', KIND=I8B), INT(Z'6D30277A171AB2F8', KIND=I8B), INT(Z'5F0463F935CCD378', KIND=I8B), INT(Z'6B6C46DEC52F6688', KIND=I8B), INT(Z'DF01E85F912E37A3', KIND=I8B), INT(Z'443E18AC4E70AFDB', KIND=I8B), INT(Z'3B62BE7BC1A0042B', KIND=I8B), INT(Z'2323AC4B3B3DA015', KIND=I8B), INT(Z'8B61313BBABCE2C6', KIND=I8B), INT(Z'154D9ED7620CDBD2', KIND=I8B), INT(Z'8A3B6E1AB2080536', KIND=I8B), INT(Z'ABEC975E0A0D081A', KIND=I8B), INT(Z'AE397D8AA96C1B77', KIND=I8B), INT(Z'9AA1068D3A9012C7', KIND=I8B), INT(Z'2CCA49A15E8A0683', KIND=I8B), INT(Z'96E7BD358C904A21', KIND=I8B), INT(Z'D9C7DCED53C72255', KIND=I8B), INT(Z'40A4A418449A0BBC', KIND=I8B), INT(Z'BBFE6E04DB164412', KIND=I8B), INT(Z'7E50D64177DA2E54', KIND=I8B), INT(Z'881CEA14545C7575', KIND=I8B), INT(Z'D0CDCD1E55C08EAB', KIND=I8B), INT(Z'EAFE098611DBD516', KIND=I8B), INT(Z'DDE50BD1D5D0B9E9', KIND=I8B), INT(Z'AA242499697392D2', KIND=I8B), INT(Z'85014065EB30B256', KIND=I8B), INT(Z'65BD8BE79652CA5C', KIND=I8B), INT(Z'955E4EC64B44E864', KIND=I8B), INT(Z'D4AD2DBFC3D07787', KIND=I8B), INT(Z'D320C83FB2FE6F75', KIND=I8B), INT(Z'BF967770BDF3BE79', KIND=I8B), INT(Z'BD5AF13BEF0B113E', KIND=I8B), INT(Z'84EC3C97DA624AB4', KIND=I8B), INT(Z'47E8FA4F9FBE0B53', KIND=I8B), INT(Z'6F7C154CED70AE18', KIND=I8B), INT(Z'ECB1AD8AEACDD58E', KIND=I8B), INT(Z'A6274BBDD0FADD61', KIND=I8B), INT(Z'59E338E387AD8E28', KIND=I8B), INT(Z'0B5B1AA028CCD99E', KIND=I8B), INT(Z'67DE18EDA5814AF2', KIND=I8B), INT(Z'CFB11EAD453994BA', KIND=I8B), INT(Z'F82E038E34CC78D9', KIND=I8B), INT(Z'4718F0A419800802', KIND=I8B), INT(Z'80EACF948770CED7', KIND=I8B), INT(Z'81CEB32C4B43FCF4', KIND=I8B), INT(Z'B6398471C1FF970F', KIND=I8B), INT(Z'18DF2CCD1FE00A03', KIND=I8B), INT(Z'A1258379A94D028D', KIND=I8B), INT(Z'A2425FF75E14FC31', KIND=I8B), INT(Z'A3C7E58E327F7CD3', KIND=I8B), INT(Z'5F16F80067D80C84', KIND=I8B), INT(Z'096EE45813A04330', KIND=I8B), INT(Z'CAD2F7F5359A3B3E', KIND=I8B), INT(Z'CCB9DEF1BF1F5C08', KIND=I8B), INT(Z'76DCB60081CE0FA5', KIND=I8B), INT(Z'8BCA9D6E188853FC', KIND=I8B), INT(Z'FD87B5F28300CA0D', KIND=I8B), INT(Z'9FF42B5717739985', KIND=I8B), INT(Z'CA49F1C05120C9C7', KIND=I8B), INT(Z'775EA264CF55347D', KIND=I8B), INT(Z'9E74D1B791E07E48', KIND=I8B), INT(Z'87F1362CDD507FE6', KIND=I8B), INT(Z'3CDC6E306568FC39', KIND=I8B), INT(Z'95364AFE032A819D', KIND=I8B), INT(Z'C612062576589DDA', KIND=I8B), INT(Z'E9ED83B814A49FE0', KIND=I8B), INT(Z'8C1389BC7EC33B47', KIND=I8B), INT(Z'3A83DDBD83F52204', KIND=I8B), INT(Z'F79687AED3EEC551', KIND=I8B), INT(Z'F23472530CE6E3EC', KIND=I8B), INT(Z'D78C3615CF3A050C', KIND=I8B), INT(Z'C4926A9672793542', KIND=I8B), INT(Z'9ABE14CD44753B52', KIND=I8B), INT(Z'2EC18EE7D0209CE7', KIND=I8B), INT(Z'8D6F439B43088650', KIND=I8B), INT(Z'75B7053C0F178293', KIND=I8B), INT(Z'C16D9A0095928A27', KIND=I8B), INT(Z'3A71F2A1C428C420', KIND=I8B), INT(Z'70CB148213CAA7E4', KIND=I8B), INT(Z'5324C68B12DD6338', KIND=I8B), INT(Z'F1C90080BAF72CB1', KIND=I8B), INT(Z'A48737A51A997A94', KIND=I8B), INT(Z'467EECD14C5EA8EE', KIND=I8B), INT(Z'D3F6FC16EBCA5E03', KIND=I8B), INT(Z'971DA05074DA7BEE', KIND=I8B), INT(Z'4DA9058E613FD939', KIND=I8B), INT(Z'181EA8059F76532A', KIND=I8B), INT(Z'88F4BB1CA6BCF584', KIND=I8B), INT(Z'BCE5086492111AEA', KIND=I8B), INT(Z'E11346F1F98FCF88', KIND=I8B), INT(Z'1E2652070753E7F4', KIND=I8B), INT(Z'2B31E9E3D06C32E5', KIND=I8B), INT(Z'EC1E4A7DB69561A5', KIND=I8B), INT(Z'0CAC0C573BF9E1B5', KIND=I8B), INT(Z'32D7F344649470F9', KIND=I8B), INT(Z'3AFF322E62439FCF', KIND=I8B), INT(Z'9392EE8E921D5D07', KIND=I8B), INT(Z'4FD70F6D0AF85A22', KIND=I8B), INT(Z'FF8DF0157DB98D37', KIND=I8B), INT(Z'09BEFEB9FAD487C2', KIND=I8B), INT(Z'B877AA3236A4B449', KIND=I8B), INT(Z'23CCD3484DB670AA', KIND=I8B), INT(Z'BF716C1ADD27F085', KIND=I8B), INT(Z'4C2EBE687989A9B3', KIND=I8B), INT(Z'E69594BEC44DE15B', KIND=I8B), INT(Z'3660040D3092066A', KIND=I8B), INT(Z'57A6E390CA38F653', KIND=I8B), INT(Z'0F9D37014BF60A10', KIND=I8B), INT(Z'901D7CF73AB0ACD9', KIND=I8B), INT(Z'03F805107CB68805', KIND=I8B), INT(Z'6D909C74FCC733E8', KIND=I8B), INT(Z'538484C19EF38C94', KIND=I8B), INT(Z'B424DC35095CD80F', KIND=I8B), INT(Z'04F606549BE42A06', KIND=I8B), INT(Z'88F4C3923BF900E2', KIND=I8B), INT(Z'2865A5F206B06FB9', KIND=I8B), INT(Z'E12E13424BB40E13', KIND=I8B), INT(Z'4319C3F4E16E9A44', KIND=I8B), INT(Z'F598FA3B657BA08D', KIND=I8B), INT(Z'F93F87B7442E45D3', KIND=I8B), INT(Z'8CBCCC096F5088CB', KIND=I8B), INT(Z'93E034F219CA40D5', KIND=I8B), INT(Z'F2FF38CA3EDA88B0', KIND=I8B), INT(Z'F78F69A51539D748', KIND=I8B), INT(Z'AFEBFF0BCB24AAFE', KIND=I8B), INT(Z'B8D8422EA03CD10A', KIND=I8B), INT(Z'2FBF06FCCE912ADC', KIND=I8B), INT(Z'B573440E5A884D1B', KIND=I8B), INT(Z'DBE6FECEBDEDD5BE', KIND=I8B), INT(Z'F387295D242602A6', KIND=I8B), INT(Z'FDD7645E011ABAC9', KIND=I8B), INT(Z'31680A88F8953030', KIND=I8B), INT(Z'89705F4136B4A597', KIND=I8B), INT(Z'7068F3B46D2F8350', KIND=I8B), INT(Z'3D4D3D758161697C', KIND=I8B), INT(Z'FDC20D2B36BA7C3D', KIND=I8B), INT(Z'ABCC77118461CEFC', KIND=I8B), INT(Z'8C8330A1887B6424', KIND=I8B), INT(Z'8CA08CD2E1B9C3DB', KIND=I8B), INT(Z'3D32907604691B4C', KIND=I8B), INT(Z'D6BF94D5E57A42BC', KIND=I8B), INT(Z'37D1FE64F54D1E96', KIND=I8B), INT(Z'D7E45803CD141A69', KIND=I8B), INT(Z'A63F9A49C2C1B10F', KIND=I8B), INT(Z'8637BD05AF6C69B5', KIND=I8B), INT(Z'85C67DFE32A0663C', KIND=I8B), INT(Z'CDDD6E04C0592103', KIND=I8B), INT(Z'0FCF80DC33721D53', KIND=I8B), INT(Z'A7C5AC471B478423', KIND=I8B), INT(Z'67381D7DBF487FCB', KIND=I8B), INT(Z'C154C985F06F6944', KIND=I8B), INT(Z'D3C36113404EA4A8', KIND=I8B), INT(Z'D1B71758E219652B', KIND=I8B), INT(Z'C083126E978D4FDF', KIND=I8B), INT(Z'78D4FDF3B645A1CA', KIND=I8B), INT(Z'645A1CAC083126E9', KIND=I8B), INT(Z'83126E978D4FDF3B', KIND=I8B), INT(Z'70A3D70A3D70A3D7', KIND=I8B), INT(Z'D70A3D70A3D70A3D', KIND=I8B), INT(Z'3D70A3D70A3D70A3', KIND=I8B), INT(Z'A3D70A3D70A3D70A', KIND=I8B), INT(Z'CCCCCCCCCCCCCCCC', KIND=I8B), INT(Z'CCCCCCCCCCCCCCCC', KIND=I8B), INT(Z'CCCCCCCCCCCCCCCC', KIND=I8B), INT(Z'CCCCCCCCCCCCCCCC', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'8000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'A000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'C800000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'FA00000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'9C40000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'C350000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'F424000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'9896800000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'BEBC200000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'EE6B280000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'9502F90000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'BA43B74000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'E8D4A51000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'9184E72A00000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'B5E620F480000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'E35FA931A0000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'8E1BC9BF04000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'B1A2BC2EC5000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'DE0B6B3A76400000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'8AC7230489E80000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'AD78EBC5AC620000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'D8D726B7177A8000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'878678326EAC9000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'A968163F0A57B400', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'D3C21BCECCEDA100', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'84595161401484A0', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'A56FA5B99019A5C8', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'CECB8F27F4200F3A', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4000000000000000', KIND=I8B), INT(Z'813F3978F8940984', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'5000000000000000', KIND=I8B), INT(Z'A18F07D736B90BE5', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'A400000000000000', KIND=I8B), INT(Z'C9F2C9CD04674EDE', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4D00000000000000', KIND=I8B), INT(Z'FC6F7C4045812296', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'F020000000000000', KIND=I8B), INT(Z'9DC5ADA82B70B59D', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'6C28000000000000', KIND=I8B), INT(Z'C5371912364CE305', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'C732000000000000', KIND=I8B), INT(Z'F684DF56C3E01BC6', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'3C7F400000000000', KIND=I8B), INT(Z'9A130B963A6C115C', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4B9F100000000000', KIND=I8B), INT(Z'C097CE7BC90715B3', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'1E86D40000000000', KIND=I8B), INT(Z'F0BDC21ABB48DB20', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'1314448000000000', KIND=I8B), INT(Z'96769950B50D88F4', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'17D955A000000000', KIND=I8B), INT(Z'BC143FA4E250EB31', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'5DCFAB0800000000', KIND=I8B), INT(Z'EB194F8E1AE525FD', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'5AA1CAE500000000', KIND=I8B), INT(Z'92EFD1B8D0CF37BE', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'F14A3D9E40000000', KIND=I8B), INT(Z'B7ABC627050305AD', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'6D9CCD05D0000000', KIND=I8B), INT(Z'E596B7B0C643C719', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'E4820023A2000000', KIND=I8B), INT(Z'8F7E32CE7BEA5C6F', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'DDA2802C8A800000', KIND=I8B), INT(Z'B35DBF821AE4F38B', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'D50B2037AD200000', KIND=I8B), INT(Z'E0352F62A19E306E', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4526F422CC340000', KIND=I8B), INT(Z'8C213D9DA502DE45', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'9670B12B7F410000', KIND=I8B), INT(Z'AF298D050E4395D6', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'3C0CDD765F114000', KIND=I8B), INT(Z'DAF3F04651D47B4C', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'A5880A69FB6AC800', KIND=I8B), INT(Z'88D8762BF324CD0F', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'8EEA0D047A457A00', KIND=I8B), INT(Z'AB0E93B6EFEE0053', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'72A4904598D6D880', KIND=I8B), INT(Z'D5D238A4ABE98068', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'47A6DA2B7F864750', KIND=I8B), INT(Z'85A36366EB71F041', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'999090B65F67D924', KIND=I8B), INT(Z'A70C3C40A64E6C51', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'FFF4B4E3F741CF6D', KIND=I8B), INT(Z'D0CF4B50CFE20765', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'2000000000000000', KIND=I8B), INT(Z'BFF8F10E7A8921A4', KIND=I8B), INT(Z'82818F1281ED449F', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'2800000000000000', KIND=I8B), INT(Z'AFF72D52192B6A0D', KIND=I8B), INT(Z'A321F2D7226895C7', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'7200000000000000', KIND=I8B), INT(Z'9BF4F8A69F764490', KIND=I8B), INT(Z'CBEA6F8CEB02BB39', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'8E80000000000000', KIND=I8B), INT(Z'02F236D04753D5B4', KIND=I8B), INT(Z'FEE50B7025C36A08', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'D910000000000000', KIND=I8B), INT(Z'01D762422C946590', KIND=I8B), INT(Z'9F4F2726179A2245', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0F54000000000000', KIND=I8B), INT(Z'424D3AD2B7B97EF5', KIND=I8B), INT(Z'C722F0EF9D80AAD6', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'5329000000000000', KIND=I8B), INT(Z'D2E0898765A7DEB2', KIND=I8B), INT(Z'F8EBAD2B84E0D58B', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'73F9A00000000000', KIND=I8B), INT(Z'63CC55F49F88EB2F', KIND=I8B), INT(Z'9B934C3B330C8577', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'50F8080000000000', KIND=I8B), INT(Z'3CBF6B71C76B25FB', KIND=I8B), INT(Z'C2781F49FFCFA6D5', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'25360A0000000000', KIND=I8B), INT(Z'8BEF464E3945EF7A', KIND=I8B), INT(Z'F316271C7FC3908A', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'5741C64000000000', KIND=I8B), INT(Z'97758BF0E3CBB5AC', KIND=I8B), INT(Z'97EDD871CFDA3A56', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'6D1237D000000000', KIND=I8B), INT(Z'3D52EEED1CBEA317', KIND=I8B), INT(Z'BDE94E8E43D0C8EC', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4856C5C400000000', KIND=I8B), INT(Z'4CA7AAA863EE4BDD', KIND=I8B), INT(Z'ED63A231D4C4FB27', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4D363B9A80000000', KIND=I8B), INT(Z'8FE8CAA93E74EF6A', KIND=I8B), INT(Z'945E455F24FB1CF8', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'E083CA8120000000', KIND=I8B), INT(Z'B3E2FD538E122B44', KIND=I8B), INT(Z'B975D6B6EE39E436', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'18A4BD2168000000', KIND=I8B), INT(Z'60DBBCA87196B616', KIND=I8B), INT(Z'E7D34C64A9C85D44', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'CF66F634E1000000', KIND=I8B), INT(Z'BC8955E946FE31CD', KIND=I8B), INT(Z'90E40FBEEA1D3A4A', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'4340B3C219400000', KIND=I8B), INT(Z'6BABAB6398BDBE41', KIND=I8B), INT(Z'B51D13AEA4A488DD', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'9410E0B29F900000', KIND=I8B), INT(Z'C696963C7EED2DD1', KIND=I8B), INT(Z'E264589A4DCDAB14', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'FC8A8C6FA3BA0000', KIND=I8B), INT(Z'FC1E1DE5CF543CA2', KIND=I8B), INT(Z'8D7EB76070A08AEC', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'BBAD2F8B8CA88000', KIND=I8B), INT(Z'3B25A55F43294BCB', KIND=I8B), INT(Z'B0DE65388CC8ADA8', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'AA987B6E6FD2A000', KIND=I8B), INT(Z'49EF0EB713F39EBE', KIND=I8B), INT(Z'DD15FE86AFFAD912', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'2A9F4D2505E3A400', KIND=I8B), INT(Z'6E3569326C784337', KIND=I8B), INT(Z'8A2DBF142DFCC7AB', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'F547206E475C8D00', KIND=I8B), INT(Z'49C2C37F07965404', KIND=I8B), INT(Z'ACB92ED9397BF996', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'3298E889D933B040', KIND=I8B), INT(Z'DC33745EC97BE906', KIND=I8B), INT(Z'D7E77A8F87DAF7FB', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'DF9F915627C04E28', KIND=I8B), INT(Z'69A028BB3DED71A3', KIND=I8B), INT(Z'86F0AC99B4E8DAFD', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'D78775ABB1B061B2', KIND=I8B), INT(Z'C40832EA0D68CE0C', KIND=I8B), INT(Z'A8ACD7C0222311BC', KIND=I8B), INT(Z'8000000000000000', KIND=I8B), INT(Z'0D6953169E1C7A1E', KIND=I8B), INT(Z'F50A3FA490C30190', KIND=I8B), INT(Z'D2D80DB02AABD62B', KIND=I8B), INT(Z'1000000000000000', KIND=I8B), INT(Z'0861D3EE22D1CC53', KIND=I8B), INT(Z'792667C6DA79E0FA', KIND=I8B), INT(Z'83C7088E1AAB65DB', KIND=I8B), INT(Z'D400000000000000', KIND=I8B), INT(Z'8A7A48E9AB863F67', KIND=I8B), INT(Z'577001B891185938', KIND=I8B), INT(Z'A4B8CAB1A1563F52', KIND=I8B), INT(Z'C900000000000000', KIND=I8B), INT(Z'AD18DB241667CF41', KIND=I8B), INT(Z'ED4C0226B55E6F86', KIND=I8B), INT(Z'CDE6FD5E09ABCF26', KIND=I8B), INT(Z'1DA0000000000000', KIND=I8B), INT(Z'2C2F88F68E00E189', KIND=I8B), INT(Z'544F8158315B05B4', KIND=I8B), INT(Z'80B05E5AC60B6178', KIND=I8B), INT(Z'6508000000000000', KIND=I8B), INT(Z'373B6B34318119EB', KIND=I8B), INT(Z'696361AE3DB1C721', KIND=I8B), INT(Z'A0DC75F1778E39D6', KIND=I8B), INT(Z'3E4A000000000000', KIND=I8B), INT(Z'850A46013DE16066', KIND=I8B), INT(Z'03BC3A19CD1E38E9', KIND=I8B), INT(Z'C913936DD571C84C', KIND=I8B), INT(Z'CDDC800000000000', KIND=I8B), INT(Z'E64CD7818D59B87F', KIND=I8B), INT(Z'04AB48A04065C723', KIND=I8B), INT(Z'FB5878494ACE3A5F', KIND=I8B), INT(Z'E0A9D00000000000', KIND=I8B), INT(Z'6FF006B0F858134F', KIND=I8B), INT(Z'62EB0D64283F9C76', KIND=I8B), INT(Z'9D174B2DCEC0E47B', KIND=I8B), INT(Z'D8D4440000000000', KIND=I8B), INT(Z'0BEC085D366E1823', KIND=I8B), INT(Z'3BA5D0BD324F8394', KIND=I8B), INT(Z'C45D1DF942711D9A', KIND=I8B), INT(Z'CF09550000000000', KIND=I8B), INT(Z'0EE70A7484099E2C', KIND=I8B), INT(Z'CA8F44EC7EE36479', KIND=I8B), INT(Z'F5746577930D6500', KIND=I8B), INT(Z'0165D52000000000', KIND=I8B), INT(Z'A9506688D28602DC', KIND=I8B), INT(Z'7E998B13CF4E1ECB', KIND=I8B), INT(Z'9968BF6ABBE85F20', KIND=I8B), INT(Z'01BF4A6800000000', KIND=I8B), INT(Z'93A4802B07278393', KIND=I8B), INT(Z'9E3FEDD8C321A67E', KIND=I8B), INT(Z'BFC2EF456AE276E8', KIND=I8B), INT(Z'C22F1D0200000000', KIND=I8B), INT(Z'388DA035C8F16477', KIND=I8B), INT(Z'C5CFE94EF3EA101E', KIND=I8B), INT(Z'EFB3AB16C59B14A2', KIND=I8B), INT(Z'D95D722140000000', KIND=I8B), INT(Z'E35884219D96DECA', KIND=I8B), INT(Z'BBA1F1D158724A12', KIND=I8B), INT(Z'95D04AEE3B80ECE5', KIND=I8B), INT(Z'8FB4CEA990000000', KIND=I8B), INT(Z'9C2EA52A04FC967D', KIND=I8B), INT(Z'2A8A6E45AE8EDC97', KIND=I8B), INT(Z'BB445DA9CA61281F', KIND=I8B), INT(Z'F3A20253F4000000', KIND=I8B), INT(Z'833A4E74863BBC1C', KIND=I8B), INT(Z'F52D09D71A3293BD', KIND=I8B), INT(Z'EA1575143CF97226', KIND=I8B), INT(Z'1845417478800000', KIND=I8B), INT(Z'72047108D3E55592', KIND=I8B), INT(Z'593C2626705F9C56', KIND=I8B), INT(Z'924D692CA61BE758', KIND=I8B), INT(Z'9E5691D196A00000', KIND=I8B), INT(Z'0E858D4B08DEAAF6', KIND=I8B), INT(Z'6F8B2FB00C77836C', KIND=I8B), INT(Z'B6E0C377CFA2E12E', KIND=I8B), INT(Z'45EC3645FC480000', KIND=I8B), INT(Z'1226F09DCB1655B4', KIND=I8B), INT(Z'0B6DFB9C0F956447', KIND=I8B), INT(Z'E498F455C38B997A', KIND=I8B), INT(Z'ABB3A1EBBDAD0000', KIND=I8B), INT(Z'6B5856629EEDF590', KIND=I8B), INT(Z'4724BD4189BD5EAC', KIND=I8B), INT(Z'8EDF98B59A373FEC', KIND=I8B), INT(Z'D6A08A66AD184000', KIND=I8B), INT(Z'862E6BFB46A972F4', KIND=I8B), INT(Z'58EDEC91EC2CB657', KIND=I8B), INT(Z'B2977EE300C50FE7', KIND=I8B), INT(Z'0C48AD00585E5000', KIND=I8B), INT(Z'67BA06FA1853CFB2', KIND=I8B), INT(Z'2F2967B66737E3ED', KIND=I8B), INT(Z'DF3D5E9BC0F653E1', KIND=I8B), INT(Z'47AD6C20373AF200', KIND=I8B), INT(Z'60D4445C4F3461CF', KIND=I8B), INT(Z'BD79E0D20082EE74', KIND=I8B), INT(Z'8B865B215899F46C', KIND=I8B), INT(Z'1998C7284509AE80', KIND=I8B), INT(Z'7909557363017A43', KIND=I8B), INT(Z'ECD8590680A3AA11', KIND=I8B), INT(Z'AE67F1E9AEC07187', KIND=I8B), INT(Z'DFFEF8F2564C1A20', KIND=I8B), INT(Z'D74BAAD03BC1D8D3', KIND=I8B), INT(Z'E80E6F4820CC9495', KIND=I8B), INT(Z'DA01EE641A708DE9', KIND=I8B), INT(Z'6BFF5B9775EF9054', KIND=I8B), INT(Z'A68F4AC225592784', KIND=I8B), INT(Z'3109058D147FDCDD', KIND=I8B), INT(Z'884134FE908658B2', KIND=I8B), INT(Z'86FF327D536B7469', KIND=I8B), INT(Z'10331D72AEAF7165', KIND=I8B), INT(Z'BD4B46F0599FD415', KIND=I8B), INT(Z'AA51823E34A7EEDE', KIND=I8B), INT(Z'E8BEFF1CA8465183', KIND=I8B), INT(Z'543FE4CF5A5B4DBE', KIND=I8B), INT(Z'6C9E18AC7007C91A', KIND=I8B), INT(Z'D4E5E2CDC1D1EA96', KIND=I8B), INT(Z'51775F71E92BF2F2', KIND=I8B), INT(Z'74A7EF0198791097', KIND=I8B), INT(Z'03E2CF6BC604DDB0', KIND=I8B), INT(Z'850FADC09923329E', KIND=I8B), INT(Z'25D5374E6376EFAE', KIND=I8B), INT(Z'91D1EAC1FE9754BD', KIND=I8B), INT(Z'84DB8346B786151C', KIND=I8B), INT(Z'A6539930BF6BFF45', KIND=I8B), INT(Z'6F4A8521FC54AB9A', KIND=I8B), INT(Z'B64665727E3D29EC', KIND=I8B), INT(Z'E612641865679A63', KIND=I8B), INT(Z'CFE87F7CEF46FF16', KIND=I8B), INT(Z'C58E93353DB4EB40', KIND=I8B), INT(Z'51EBFF678EE63A33', KIND=I8B), INT(Z'4FCB7E8F3F60C07E', KIND=I8B), INT(Z'81F14FAE158C5F6E', KIND=I8B), INT(Z'B6F238028D222610', KIND=I8B), INT(Z'E666FF41729FC8C0', KIND=I8B), INT(Z'E3BE5E330F38F09D', KIND=I8B), INT(Z'A26DA3999AEF7749', KIND=I8B), INT(Z'E4AEC603306AAF94', KIND=I8B), INT(Z'6000BF11CF47BAF0', KIND=I8B), INT(Z'5CADF5BFD3072CC5', KIND=I8B), INT(Z'CB090C8001AB551C', KIND=I8B), INT(Z'1DDA7783FC855B79', KIND=I8B), INT(Z'B800EED64319A9AD', KIND=I8B), INT(Z'73D9732FC7C8F7F6', KIND=I8B), INT(Z'FDCB4FA002162A63', KIND=I8B), INT(Z'32A88AB27DD3592C', KIND=I8B), INT(Z'33009545E9F00A0C', KIND=I8B), INT(Z'2867E7FDDCDD9AFA', KIND=I8B), INT(Z'9E9F11C4014DDA7E', KIND=I8B), INT(Z'3F52AD5F1D482F77', KIND=I8B), INT(Z'BFC0BA97646C0C8F', KIND=I8B), INT(Z'B281E1FD541501B8', KIND=I8B), INT(Z'C646D63501A1511D', KIND=I8B), INT(Z'0F2758B6E49A3B54', KIND=I8B), INT(Z'EFB0E93D3D870FB3', KIND=I8B), INT(Z'1F225A7CA91A4226', KIND=I8B), INT(Z'F7D88BC24209A565', KIND=I8B), INT(Z'E97897724EE06515', KIND=I8B), INT(Z'55CE91C6467469CF', KIND=I8B), INT(Z'3375788DE9B06958', KIND=I8B), INT(Z'9AE757596946075F', KIND=I8B), INT(Z'E3D6BD4EE2987E5A', KIND=I8B), INT(Z'6B423637D8118443', KIND=I8B), INT(Z'0052D6B1641C83AE', KIND=I8B), INT(Z'C1A12D2FC3978937', KIND=I8B), INT(Z'DCCC6CA29B3E9DF0', KIND=I8B), INT(Z'0612C3C5CE15E554', KIND=I8B), INT(Z'C0678C5DBD23A49A', KIND=I8B), INT(Z'F209787BB47D6B84', KIND=I8B), INT(Z'09FFC3E5A10722B6', KIND=I8B), INT(Z'43CBBA5BA0CDAF55', KIND=I8B), INT(Z'F840B7BA963646E0', KIND=I8B), INT(Z'9745EB4D50CE6332', KIND=I8B), INT(Z'4C7FB4DF0948EB64', KIND=I8B), INT(Z'54BEA8F289011B2A', KIND=I8B), INT(Z'B650E5A93BC3D898', KIND=I8B), INT(Z'BD176620A501FBFF', KIND=I8B), INT(Z'DF9FA216CB9B263D', KIND=I8B), INT(Z'69EE532F2B4161F4', KIND=I8B), INT(Z'A3E51F138AB4CEBE', KIND=I8B), INT(Z'EC5D3FA8CE427AFF', KIND=I8B), INT(Z'0BC3C54E3F40F7E6', KIND=I8B), INT(Z'0234F3FD7B08DD39', KIND=I8B), INT(Z'C66F336C36B10137', KIND=I8B), INT(Z'93BA47C980E98CDF', KIND=I8B), INT(Z'4EB4B6A1CF1135DF', KIND=I8B), INT(Z'C2C230FCD9CB1487', KIND=I8B), INT(Z'B80B0047445D4184', KIND=I8B), INT(Z'B8A8D9BBE123F017', KIND=I8B), INT(Z'2261E44A42D58357', KIND=I8B), INT(Z'F372BD3C103DD9A9', KIND=I8B), INT(Z'A60DC059157491E5', KIND=I8B), INT(Z'E6D3102AD96CEC1D', KIND=I8B), INT(Z'B57D2EAE69C57216', KIND=I8B), INT(Z'B827B6458A26A809', KIND=I8B), INT(Z'87C89837AD68DB2F', KIND=I8B), INT(Z'9043EA1AC7E41392', KIND=I8B), INT(Z'22DC7A5A0436CE9C', KIND=I8B), INT(Z'A631A3D6ECB0520C', KIND=I8B), INT(Z'29BABE4598C311FB', KIND=I8B), INT(Z'B454E4A179DD1877', KIND=I8B), INT(Z'2B9398F085448243', KIND=I8B), INT(Z'8FBE0CCCA7DC668F', KIND=I8B), INT(Z'F4296DD6FEF3D67A', KIND=I8B), INT(Z'E16A1DC9D8545E94', KIND=I8B), INT(Z'7B3C3F96534AD16A', KIND=I8B), INT(Z'99D6C7FFE8E9C019', KIND=I8B), INT(Z'1899E4A65F58660C', KIND=I8B), INT(Z'8CE2529E2734BB1D', KIND=I8B), INT(Z'DA0B4F7BE81D85C4', KIND=I8B), INT(Z'C04C79FFE324301F', KIND=I8B), INT(Z'5EC05DCFF72E7F8F', KIND=I8B), INT(Z'B01AE745B101E9E4', KIND=I8B), INT(Z'D08E235AE224E736', KIND=I8B), INT(Z'B05F987FDBED3C27', KIND=I8B), INT(Z'76707543F4FA1F73', KIND=I8B), INT(Z'DC21A1171D42645D', KIND=I8B), INT(Z'E258D618CD571081', KIND=I8B), INT(Z'4E3BBF4FE9744598', KIND=I8B), INT(Z'6A06494A791C53A8', KIND=I8B), INT(Z'899504AE72497EBA', KIND=I8B), INT(Z'1AEF0B9F00ACD4A2', KIND=I8B), INT(Z'61CAAF23E3D156FF', KIND=I8B), INT(Z'0487DB9D17636892', KIND=I8B), INT(Z'ABFA45DA0EDBDE69', KIND=I8B), INT(Z'E1AACE86C0D809CA', KIND=I8B), INT(Z'FA3D5AECDCC5ACBE', KIND=I8B), INT(Z'45A9D2845D3C42B6', KIND=I8B), INT(Z'D6F8D7509292D603', KIND=I8B), INT(Z'4D0AC1143887061E', KIND=I8B), INT(Z'5C6658D409FB8BF7', KIND=I8B), INT(Z'0B8A2392BA45A9B2', KIND=I8B), INT(Z'865B86925B9BC5C2', KIND=I8B), INT(Z'204D715946A8C7A6', KIND=I8B), INT(Z'F37FEF090C7A6EF5', KIND=I8B), INT(Z'8E6CAC7768D7141E', KIND=I8B), INT(Z'A7F26836F282B732', KIND=I8B), INT(Z'6860CDAF9852F990', KIND=I8B), INT(Z'B05FEACB4F990AB2', KIND=I8B), INT(Z'3207D795430CD926', KIND=I8B), INT(Z'D1EF0244AF2364FF', KIND=I8B), INT(Z'813C808DBF33DBFA', KIND=I8B), INT(Z'2E3BF2BF11BFA6AF', KIND=I8B), INT(Z'7F44E6BD49E807B8', KIND=I8B), INT(Z'8335616AED761F1F', KIND=I8B), INT(Z'618BA0B12F00D2F8', KIND=I8B), INT(Z'39CAEF6ED62F905B', KIND=I8B), INT(Z'5F16206C9C6209A6', KIND=I8B), INT(Z'A402B9C5A8D3A6E7', KIND=I8B), INT(Z'39EE88DD7AC107B6', KIND=I8B), INT(Z'C83DAB4A8BBB7472', KIND=I8B), INT(Z'36DBA887C37A8C0F', KIND=I8B), INT(Z'CD036837130890A1', KIND=I8B), INT(Z'6435158A6CB8A4D2', KIND=I8B), INT(Z'DD268B0E975528C7', KIND=I8B), INT(Z'C2494954DA2C9789', KIND=I8B), INT(Z'802221226BE55A64', KIND=I8B), INT(Z'3D425AED07E6CE06', KIND=I8B), INT(Z'54702DD23D2A72F9', KIND=I8B), INT(Z'F2DB9BAA10B7BD6C', KIND=I8B), INT(Z'A02AA96B06DEB0FD', KIND=I8B), INT(Z'8C92F1A849E08188', KIND=I8B), INT(Z'698C3946CC750FB7', KIND=I8B), INT(Z'6F92829494E5ACC7', KIND=I8B), INT(Z'C83553C5C8965D3D', KIND=I8B), INT(Z'6FB7AE125C58A1EA', KIND=I8B), INT(Z'43EF47987F9253A5', KIND=I8B), INT(Z'CB772339BA1F17F9', KIND=I8B), INT(Z'FA42A8B73ABBF48C', KIND=I8B), INT(Z'65D2CCCB79B76532', KIND=I8B), INT(Z'CA758CBF4FBB7447', KIND=I8B), INT(Z'FF2A760414536EFB', KIND=I8B), INT(Z'9C69A97284B578D7', KIND=I8B), INT(Z'3F477FFE58253E7F', KIND=I8B), INT(Z'BD12EFEF23AA5159', KIND=I8B), INT(Z'FEF5138519684ABA', KIND=I8B), INT(Z'C38413CF25E2D70D', KIND=I8B), INT(Z'8F195FFDEE2E8E1F', KIND=I8B), INT(Z'6C57ABEAEC94E5AF', KIND=I8B), INT(Z'7EB258665FC25D69', KIND=I8B), INT(Z'F46518C2EF5B8CD1', KIND=I8B), INT(Z'B96FDBFEB4DD18D3', KIND=I8B), INT(Z'E3B6CB72D3DD0F8D', KIND=I8B), INT(Z'EF2F773FFBD97A61', KIND=I8B), INT(Z'98BF2F79D5993802', KIND=I8B), INT(Z'27CBD2FE62145F08', KIND=I8B), INT(Z'5CA47E4F88D45371', KIND=I8B), INT(Z'AAFB550FFACFD8FA', KIND=I8B), INT(Z'BEEEFB584AFF8603', KIND=I8B), INT(Z'71BEC7BDFA9976CA', KIND=I8B), INT(Z'F3CD9DE36B09684D', KIND=I8B), INT(Z'95BA2A53F983CF38', KIND=I8B), INT(Z'EEAABA2E5DBF6784', KIND=I8B), INT(Z'67173CD6BC9FEA3E', KIND=I8B), INT(Z'986082AE22E5E130', KIND=I8B), INT(Z'DD945A747BF26183', KIND=I8B), INT(Z'952AB45CFA97A0B2', KIND=I8B), INT(Z'80DD0C0C6BC7E4CE', KIND=I8B), INT(Z'7E78A359AB9F597C', KIND=I8B), INT(Z'94F971119AEEF9E4', KIND=I8B), INT(Z'BA756174393D88DF', KIND=I8B), INT(Z'A1144F0F86B9DE01', KIND=I8B), INT(Z'9E16CC3016872FDB', KIND=I8B), INT(Z'7A37CD5601AAB85D', KIND=I8B), INT(Z'E912B9D1478CEB17', KIND=I8B), INT(Z'44ACB169B4342AC0', KIND=I8B), INT(Z'82CE3F9E0E147DE9', KIND=I8B), INT(Z'AC62E055C10AB33A', KIND=I8B), INT(Z'91ABB422CCB812EE', KIND=I8B), INT(Z'95D7DDC421413571', KIND=I8B), INT(Z'2381CF8591999D63', KIND=I8B), INT(Z'577B986B314D6009', KIND=I8B), INT(Z'B616A12B7FE617AA', KIND=I8B), INT(Z'7B4DD535299182CD', KIND=I8B), INT(Z'6C624366F60004BC', KIND=I8B), INT(Z'ED5A7E85FDA0B80B', KIND=I8B), INT(Z'E39C49765FDF9D94', KIND=I8B), INT(Z'CD10A54139FAF1C0', KIND=I8B), INT(Z'23BD6A2059C002F5', KIND=I8B), INT(Z'14588F13BE847307', KIND=I8B), INT(Z'8E41ADE9FBEBC27D', KIND=I8B), INT(Z'4054CE918879AE30', KIND=I8B), INT(Z'ECACC4A8703003B3', KIND=I8B), INT(Z'596EB2D8AE258FC8', KIND=I8B), INT(Z'B1D219647AE6B31C', KIND=I8B), INT(Z'106A0235EA9819BC', KIND=I8B), INT(Z'27D7F5D28C3C04A0', KIND=I8B), INT(Z'6FCA5F8ED9AEF3BB', KIND=I8B), INT(Z'DE469FBD99A05FE3', KIND=I8B), INT(Z'0A424161B29F1015', KIND=I8B), INT(Z'F8E6F9A397A582E4', KIND=I8B), INT(Z'25DE7BB9480D5854', KIND=I8B), INT(Z'8AEC23D680043BEE', KIND=I8B), INT(Z'0CD2D1BA1F46D41B', KIND=I8B), INT(Z'3720B80C7D8EE39D', KIND=I8B), INT(Z'AF561AA79A10AE6A', KIND=I8B), INT(Z'ADA72CCC20054AE9', KIND=I8B), INT(Z'50078628A7188922', KIND=I8B), INT(Z'C4E8E60F9CF29C84', KIND=I8B), INT(Z'1B2BA1518094DA04', KIND=I8B), INT(Z'D910F7FF28069DA4', KIND=I8B), INT(Z'B204B3D9686F55B5', KIND=I8B), INT(Z'FB118FC9C217A1D2', KIND=I8B), INT(Z'90FB44D2F05D0842', KIND=I8B), INT(Z'87AA9AFF79042286', KIND=I8B), INT(Z'5E85E0CFC28B2B22', KIND=I8B), INT(Z'B9D5F3BC329D8A47', KIND=I8B), INT(Z'353A1607AC744A53', KIND=I8B), INT(Z'A99541BF57452B28', KIND=I8B), INT(Z'36275903B32DF5EB', KIND=I8B), INT(Z'A84B70AB3F44ECD9', KIND=I8B), INT(Z'42889B8997915CE8', KIND=I8B), INT(Z'D3FA922F2D1675F2', KIND=I8B), INT(Z'C1D897A24FFCB9B3', KIND=I8B), INT(Z'692F266B078B1407', KIND=I8B), INT(Z'69956135FEBADA11', KIND=I8B), INT(Z'847C9B5D7C2E09B7', KIND=I8B), INT(Z'B24EBD8AE3FBE81F', KIND=I8B), INT(Z'C37AF005C96DD909', KIND=I8B), INT(Z'43FAB9837E699095', KIND=I8B), INT(Z'A59BC234DB398C25', KIND=I8B), INT(Z'1EE26CED9CFAE227', KIND=I8B), INT(Z'3459AC073BC94F4C', KIND=I8B), INT(Z'94F967E45E03F4BB', KIND=I8B), INT(Z'CF02B2C21207EF2E', KIND=I8B), INT(Z'934D8414821CCD58', KIND=I8B), INT(Z'00B80B84855DD18F', KIND=I8B), INT(Z'1D1BE0EEBAC278F5', KIND=I8B), INT(Z'8161AFB94B44F57D', KIND=I8B), INT(Z'7820E519A2A400AF', KIND=I8B), INT(Z'40E60E65A6B545F3', KIND=I8B), INT(Z'6462D92A69731732', KIND=I8B), INT(Z'A1BA1BA79E1632DC', KIND=I8B), INT(Z'56291E600B4D00DB', KIND=I8B), INT(Z'D11F91FF10629770', KIND=I8B), INT(Z'7D7B8F7503CFDCFE', KIND=I8B), INT(Z'CA28A291859BBF93', KIND=I8B), INT(Z'6BB365F80E204111', KIND=I8B), INT(Z'8567767ED47B3D4C', KIND=I8B), INT(Z'5CDA735244C3D43E', KIND=I8B), INT(Z'FCB2CB35E702AF78', KIND=I8B), INT(Z'C3501FBB08D428AB', KIND=I8B), INT(Z'1360AA0F44CD064F', KIND=I8B), INT(Z'3A0888136AFA64A7', KIND=I8B), INT(Z'9DEFBF01B061ADAB', KIND=I8B), INT(Z'B42427A9CB0932D5', KIND=I8B), INT(Z'D838D493160047E3', KIND=I8B), INT(Z'088AAA1845B8FDD0', KIND=I8B), INT(Z'C56BAEC21C7A1916', KIND=I8B), INT(Z'A12D31943DCB7F8B', KIND=I8B), INT(Z'0E4709B7DB8059DC', KIND=I8B), INT(Z'8AAD549E57273D45', KIND=I8B), INT(Z'F6C69A72A3989F5B', KIND=I8B), INT(Z'E4BC3EFCA69F2FB7', KIND=I8B), INT(Z'28EC6612E9303829', KIND=I8B), INT(Z'36AC54E2F678864B', KIND=I8B), INT(Z'9A3C2087A63F6399', KIND=I8B), INT(Z'5DEB4EBBD046FBA4', KIND=I8B), INT(Z'F3277F97A37C4634', KIND=I8B), INT(Z'84576A1BB416A7DD', KIND=I8B), INT(Z'C0CB28A98FCF3C7F', KIND=I8B), INT(Z'7566226AC458BA8E', KIND=I8B), INT(Z'6FF15F7D8C5B57C1', KIND=I8B), INT(Z'656D44A2A11C51D5', KIND=I8B), INT(Z'F0FDF2D3F3C30B9F', KIND=I8B), INT(Z'E95FD582BAB77498', KIND=I8B), INT(Z'65F6DBAE77B916D8', KIND=I8B), INT(Z'9F644AE5A4B1B325', KIND=I8B), INT(Z'969EB7C47859E743', KIND=I8B), INT(Z'23B7CAE3696551BF', KIND=I8B), INT(Z'BF74929A15A75C8F', KIND=I8B), INT(Z'873D5D9F0DDE1FEE', KIND=I8B), INT(Z'BC4665B596706114', KIND=I8B), INT(Z'ECA5BD9C43BEA62E', KIND=I8B), INT(Z'6F51B7409B1133B2', KIND=I8B), INT(Z'A90CB506D155A7EA', KIND=I8B), INT(Z'EB57FF22FC0C7959', KIND=I8B), INT(Z'D3E79681AA5727DD', KIND=I8B), INT(Z'8593128860EAC04F', KIND=I8B), INT(Z'09A7F12442D588F2', KIND=I8B), INT(Z'9316FF75DD87CBD8', KIND=I8B), INT(Z'C8E17C2214ECF1D4', KIND=I8B), INT(Z'26F7D72A79257063', KIND=I8B), INT(Z'0C11ED6D538AEB2F', KIND=I8B), INT(Z'B7DCBF5354E9BECE', KIND=I8B), INT(Z'BB19DB2A9A282E49', KIND=I8B), INT(Z'F0B5CCF5176ECC7C', KIND=I8B), INT(Z'8F1668C8A86DA5FA', KIND=I8B), INT(Z'E5D3EF282A242E81', KIND=I8B), INT(Z'F4F028FAA0591CEE', KIND=I8B), INT(Z'D671A0192EA53FCD', KIND=I8B), INT(Z'F96E017D694487BC', KIND=I8B), INT(Z'8FA475791A569D10', KIND=I8B), INT(Z'722C3339486F6429', KIND=I8B), INT(Z'0C0E081F7A4E8FC1', KIND=I8B), INT(Z'37C981DCC395A9AC', KIND=I8B), INT(Z'B38D92D760EC4455', KIND=I8B), INT(Z'CEB740079A8B3D33', KIND=I8B), INT(Z'0F118A2758E233B1', KIND=I8B), INT(Z'85BBE253F47B1417', KIND=I8B), INT(Z'E070F78D3927556A', KIND=I8B), INT(Z'21328804C0970640', KIND=I8B), INT(Z'696AF658978D604F', KIND=I8B), INT(Z'93956D7478CCEC8E', KIND=I8B), INT(Z'8C469AB843B89562', KIND=I8B), INT(Z'E97F2A05F0BCC7D0', KIND=I8B), INT(Z'03C5B3EEBD70B862', KIND=I8B), INT(Z'387AC8D1970027B2', KIND=I8B), INT(Z'AF58416654A6BABB', KIND=I8B), INT(Z'A3DEF4876CEBF9C4', KIND=I8B), INT(Z'84B720EA6CCCE67B', KIND=I8B), INT(Z'06997B05FCC0319E', KIND=I8B), INT(Z'DB2E51BFE9D0696A', KIND=I8B), INT(Z'466B58D4A4137C1A', KIND=I8B), INT(Z'12F274928400100D', KIND=I8B), INT(Z'441FECE3BDF81F03', KIND=I8B), INT(Z'88FCF317F22241E2', KIND=I8B), INT(Z'98062F09CD185B21', KIND=I8B), INT(Z'D7AF11B725001410', KIND=I8B), INT(Z'D527E81CAD7626C3', KIND=I8B), INT(Z'AB3C2FDDEEAAD25A', KIND=I8B), INT(Z'BE07BACC405E71EA', KIND=I8B), INT(Z'CD9AD624EE401914', KIND=I8B), INT(Z'8A71E223D8D3B074', KIND=I8B), INT(Z'D60B3BD56A5586F1', KIND=I8B), INT(Z'F6C4D4BFA83B0732', KIND=I8B), INT(Z'0080C5D714E80FAC', KIND=I8B), INT(Z'F6872D5667844E49', KIND=I8B), INT(Z'85C7056562757456', KIND=I8B), INT(Z'347609EF9249C8FE', KIND=I8B), INT(Z'40A0F74CDA221398', KIND=I8B), INT(Z'B428F8AC016561DB', KIND=I8B), INT(Z'A738C6BEBB12D16C', KIND=I8B), INT(Z'41938C6B76DC3B3E', KIND=I8B), INT(Z'10C9352010AA987E', KIND=I8B), INT(Z'E13336D701BEBA52', KIND=I8B), INT(Z'D106F86E69D785C7', KIND=I8B), INT(Z'E8FC37C32A49A507', KIND=I8B), INT(Z'4A7DC1340A6A9F4E', KIND=I8B), INT(Z'ECC0024661173473', KIND=I8B), INT(Z'82A45B450226B39C', KIND=I8B), INT(Z'A33B45B3F4DC0E48', KIND=I8B), INT(Z'1D1D31810D054722', KIND=I8B), INT(Z'27F002D7F95D0190', KIND=I8B), INT(Z'A34D721642B06084', KIND=I8B), INT(Z'4C0A1720F21311DB', KIND=I8B), INT(Z'24647DE1504698EB', KIND=I8B), INT(Z'31EC038DF7B441F4', KIND=I8B), INT(Z'CC20CE9BD35C78A5', KIND=I8B), INT(Z'1F0C9CE92E97D651', KIND=I8B), INT(Z'2D7D9D59A4583F26', KIND=I8B), INT(Z'7E67047175A15271', KIND=I8B), INT(Z'FF290242C83396CE', KIND=I8B), INT(Z'D367E211BD1EE5F3', KIND=I8B), INT(Z'BC6E825806B72777', KIND=I8B), INT(Z'0F0062C6E984D386', KIND=I8B), INT(Z'9F79A169BD203E41', KIND=I8B), INT(Z'C841DA962C669F70', KIND=I8B), INT(Z'6B8A22EE0864F155', KIND=I8B), INT(Z'52C07B78A3E60868', KIND=I8B), INT(Z'C75809C42C684DD1', KIND=I8B), INT(Z'3A52513BB780474C', KIND=I8B), INT(Z'866CABA98A7E2DAB', KIND=I8B), INT(Z'A7709A56CCDF8A82', KIND=I8B), INT(Z'F92E0C3537826145', KIND=I8B), INT(Z'047372C552B02C8F', KIND=I8B), INT(Z'9403EB49F68EDC8B', KIND=I8B), INT(Z'88A66076400BB691', KIND=I8B), INT(Z'9BBCC7A142B17CCB', KIND=I8B), INT(Z'C5904F76A75C37B3', KIND=I8B), INT(Z'F904E61C743293AD', KIND=I8B), INT(Z'6ACFF893D00EA435', KIND=I8B), INT(Z'C2ABF989935DDBFE', KIND=I8B), INT(Z'36F46354513345A0', KIND=I8B), INT(Z'77461FA3913F3899', KIND=I8B), INT(Z'0583F6B8C4124D43', KIND=I8B), INT(Z'F356F7EBF83552FE', KIND=I8B), INT(Z'C258BE14B2C00B84', KIND=I8B), INT(Z'2A8BD3C63AC7835F', KIND=I8B), INT(Z'C3727A337A8B704A', KIND=I8B), INT(Z'98165AF37B2153DE', KIND=I8B), INT(Z'B2EEED99DF700E65', KIND=I8B), INT(Z'B52EC8B7C9796437', KIND=I8B), INT(Z'744F18C0592E4C5C', KIND=I8B), INT(Z'BE1BF1B059E9A8D6', KIND=I8B), INT(Z'9FAAA900574C11FE', KIND=I8B), INT(Z'E27A7AE5BBD7BD45', KIND=I8B), INT(Z'1162DEF06F79DF73', KIND=I8B), INT(Z'EDA2EE1C7064130C', KIND=I8B), INT(Z'83CAA9A0368F8B3F', KIND=I8B), INT(Z'6D8C8CCF9566D64B', KIND=I8B), INT(Z'8ADDCB5645AC2BA8', KIND=I8B), INT(Z'9485D4D1C63E8BE7', KIND=I8B), INT(Z'64BD540844336E0E', KIND=I8B), INT(Z'88EFB0037AC08BDE', KIND=I8B), INT(Z'6D953E2BD7173692', KIND=I8B), INT(Z'B9A74A0637CE2EE1', KIND=I8B), INT(Z'FDECA90A55404992', KIND=I8B), INT(Z'2B2B9C045970AED5', KIND=I8B), INT(Z'C8FA8DB6CCDD0437', KIND=I8B), INT(Z'E8111C87C5C1BA99', KIND=I8B), INT(Z'BEB3E9A675482DFB', KIND=I8B), INT(Z'7AFB4182B7E66D45', KIND=I8B), INT(Z'1D9C9892400A22A2', KIND=I8B), INT(Z'910AB1D4DB9914A0', KIND=I8B), INT(Z'2E60E410129A397A', KIND=I8B), INT(Z'19BA11E365E00897', KIND=I8B), INT(Z'2503BEB6D00CAB4B', KIND=I8B), INT(Z'B54D5E4A127F59C8', KIND=I8B), INT(Z'F9F91D141740C7D9', KIND=I8B), INT(Z'E028965C3F580ABC', KIND=I8B), INT(Z'2E44AE64840FD61D', KIND=I8B), INT(Z'E2A0B5DC971F303A', KIND=I8B), INT(Z'1C3BB22C8E887CE7', KIND=I8B), INT(Z'AC195DF9A79706B6', KIND=I8B), INT(Z'5CEAECFED289E5D2', KIND=I8B), INT(Z'8DA471A9DE737E24', KIND=I8B), INT(Z'A34A9EB7B22A9C21', KIND=I8B), INT(Z'571FB578117CC863', KIND=I8B), INT(Z'7425A83E872C5F47', KIND=I8B), INT(Z'B10D8E1456105DAD', KIND=I8B), INT(Z'8C1D46659EB5432A', KIND=I8B), INT(Z'2CE7A2D615DBFA7C', KIND=I8B), INT(Z'D12F124E28F77719', KIND=I8B), INT(Z'DD50F1996B947518', KIND=I8B), INT(Z'D7924BFF833149FA', KIND=I8B), INT(Z'BC10C5C5CDA97C8D', KIND=I8B), INT(Z'82BD6B70D99AAA6F', KIND=I8B), INT(Z'8A5296FFE33CC92F', KIND=I8B), INT(Z'4D76DEFF63FD9C78', KIND=I8B), INT(Z'AB14F7374113DBB1', KIND=I8B), INT(Z'636CC64D1001550B', KIND=I8B), INT(Z'ACE73CBFDC0BFB7B', KIND=I8B), INT(Z'A0D496BF3CFD0397', KIND=I8B), INT(Z'95DA35051158D29D', KIND=I8B), INT(Z'3C47F7E05401AA4E', KIND=I8B), INT(Z'D8210BEFD30EFA5A', KIND=I8B), INT(Z'8484DE37861E223E', KIND=I8B), INT(Z'1DA861232AD783A2', KIND=I8B), INT(Z'65ACFAEC34810A71', KIND=I8B), INT(Z'8714A775E3E95C78', KIND=I8B), INT(Z'25A615C567A5AACE', KIND=I8B), INT(Z'6512796BF58D648B', KIND=I8B), INT(Z'7F1839A741A14D0D', KIND=I8B), INT(Z'A8D9D1535CE3B396', KIND=I8B), INT(Z'EF0F9B36C18F1581', KIND=I8B), INT(Z'BE5717C6F2F0BDAD', KIND=I8B), INT(Z'1EDE48111209A050', KIND=I8B), INT(Z'D31045A8341CA07C', KIND=I8B), INT(Z'B569C10238F96D70', KIND=I8B), INT(Z'76F66EDC57D6768C', KIND=I8B), INT(Z'934AED0AAB460432', KIND=I8B), INT(Z'83EA2B892091E44D', KIND=I8B), INT(Z'E2C43142C737C8CD', KIND=I8B), INT(Z'14B40A936DCC142F', KIND=I8B), INT(Z'F81DA84D5617853F', KIND=I8B), INT(Z'A4E4B66B68B65D60', KIND=I8B), INT(Z'DB753D937905BB00', KIND=I8B), INT(Z'D9E10D38493F193B', KIND=I8B), INT(Z'36251260AB9D668E', KIND=I8B), INT(Z'CE1DE40642E3F4B9', KIND=I8B), INT(Z'6929467C2BA394E0', KIND=I8B), INT(Z'482CA8432DC76FC5', KIND=I8B), INT(Z'C1D72B7C6B426019', KIND=I8B), INT(Z'80D2AE83E9CE78F3', KIND=I8B), INT(Z'C373981B368C7A18', KIND=I8B), INT(Z'9A37D253F9394BB6', KIND=I8B), INT(Z'B24CF65B8612F81F', KIND=I8B), INT(Z'A1075A24E4421730', KIND=I8B), INT(Z'74507E22042F989E', KIND=I8B), INT(Z'80C5C6E8F7879EA4', KIND=I8B), INT(Z'DEE033F26797B627', KIND=I8B), INT(Z'C94930AE1D529CFC', KIND=I8B), INT(Z'91649DAA853B7EC6', KIND=I8B), INT(Z'60F738A33569864D', KIND=I8B), INT(Z'169840EF017DA3B1', KIND=I8B), INT(Z'FB9B7CD9A4A7443C', KIND=I8B), INT(Z'7ADEE28A93452F3B', KIND=I8B), INT(Z'DC9A83660161F3F0', KIND=I8B), INT(Z'8E1F289560EE864E', KIND=I8B), INT(Z'9D412E0806E88AA5', KIND=I8B), INT(Z'99969B2D38167B0A', KIND=I8B), INT(Z'93C1243F81BA70EC', KIND=I8B), INT(Z'F1A6F2BAB92A27E2', KIND=I8B), INT(Z'C491798A08A2AD4E', KIND=I8B), INT(Z'BFFC41F8861C19CD', KIND=I8B), INT(Z'38B16D4F62290D27', KIND=I8B), INT(Z'AE10AF696774B1DB', KIND=I8B), INT(Z'F5B5D7EC8ACB58A2', KIND=I8B), INT(Z'D7FDA93B53D19020', KIND=I8B), INT(Z'036EE4519D59A838', KIND=I8B), INT(Z'ACCA6DA1E0A8EF29', KIND=I8B), INT(Z'9991A6F3D6BF1765', KIND=I8B), INT(Z'0DFD138A28C5F428', KIND=I8B), INT(Z'444A9D6604B01247', KIND=I8B), INT(Z'17FD090A58D32AF3', KIND=I8B), INT(Z'BFF610B0CC6EDD3F', KIND=I8B), INT(Z'D17C586CB2F77132', KIND=I8B), INT(Z'155D44BF85DC16D8', KIND=I8B), INT(Z'DDFC4B4CEF07F5B0', KIND=I8B), INT(Z'EFF394DCFF8A948E', KIND=I8B), INT(Z'82EDB743EFDAA6BF', KIND=I8B), INT(Z'0D5A4AF7B3A98E47', KIND=I8B), INT(Z'4ABDAF101564F98E', KIND=I8B), INT(Z'95F83D0A1FB69CD9', KIND=I8B), INT(Z'63A92514EBD1506F', KIND=I8B), INT(Z'90B0DDB5A093F1D9', KIND=I8B), INT(Z'9D6D1AD41ABE37F1', KIND=I8B), INT(Z'BB764C4CA7A4440F', KIND=I8B), INT(Z'BC936E5A26C5A48B', KIND=I8B), INT(Z'F4DD152308B8EE4F', KIND=I8B), INT(Z'84C86189216DC5ED', KIND=I8B), INT(Z'EA53DF5FD18D5513', KIND=I8B), INT(Z'D5DC24F8583B86D7', KIND=I8B), INT(Z'B90A2D35E57394F1', KIND=I8B), INT(Z'32FD3CF5B4E49BB4', KIND=I8B), INT(Z'92746B9BE2F8552C', KIND=I8B), INT(Z'4B532E366E4A688C', KIND=I8B), INT(Z'E74CB8835ED07A2E', KIND=I8B), INT(Z'3FBC8C33221DC2A1', KIND=I8B), INT(Z'B7118682DBB66A77', KIND=I8B), INT(Z'DE27F9C409DD02B0', KIND=I8B), INT(Z'611FE6A4368498B9', KIND=I8B), INT(Z'0FABAF3FEAA5334A', KIND=I8B), INT(Z'E4D5E82392A40515', KIND=I8B), INT(Z'2AD8FC1A862A21AE', KIND=I8B), INT(Z'7CB3F026A212DF74', KIND=I8B), INT(Z'29CB4D87F2A7400E', KIND=I8B), INT(Z'8F05B1163BA6832D', KIND=I8B), INT(Z'358F3B2127B4AA19', KIND=I8B), INT(Z'1BE0EC304A979751', KIND=I8B), INT(Z'743E20E9EF511012', KIND=I8B), INT(Z'B2C71D5BCA9023F8', KIND=I8B), INT(Z'82F309E971A1D4A0', KIND=I8B), INT(Z'A2D9273C5D3D7D25', KIND=I8B), INT(Z'914DA9246B255416', KIND=I8B), INT(Z'DF78E4B2BD342CF6', KIND=I8B), INT(Z'71D7E631E70524E4', KIND=I8B), INT(Z'25C7B885BA466E37', KIND=I8B), INT(Z'1AD089B6C2F7548E', KIND=I8B), INT(Z'8BAB8EEFB6409C1A', KIND=I8B), INT(Z'4E4DDFBE60C66E1D', KIND=I8B), INT(Z'AF39A6A728D809C5', KIND=I8B), INT(Z'A184AC2473B529B1', KIND=I8B), INT(Z'AE9672ABA3D0C320', KIND=I8B), INT(Z'A1E157ADF8F809A4', KIND=I8B), INT(Z'1B081050F30E0C36', KIND=I8B), INT(Z'C9E5D72D90A2741E', KIND=I8B), INT(Z'DA3C0F568CC4F3E8', KIND=I8B), INT(Z'252CD6CCBB9B0606', KIND=I8B), INT(Z'D0E50A3297E8C7A2', KIND=I8B), INT(Z'7E2FA67C7A658892', KIND=I8B), INT(Z'8865899617FB1871', KIND=I8B), INT(Z'AE780C7FEA81C788', KIND=I8B), INT(Z'851E4CBF3DE2F98A', KIND=I8B), INT(Z'DDBB901B98FEEAB7', KIND=I8B), INT(Z'AA7EEBFB9DF9DE8D', KIND=I8B), INT(Z'5A160F9FE522396A', KIND=I8B), INT(Z'6665DFEF0D5BB7ED', KIND=I8B), INT(Z'552A74227F3EA565', KIND=I8B), INT(Z'D51EA6FA85785631', KIND=I8B), INT(Z'584DC9C3EF3563E2', KIND=I8B), INT(Z'5FFFABF5685952F4', KIND=I8B), INT(Z'D53A88958F87275F', KIND=I8B), INT(Z'8533285C936B35DE', KIND=I8B), INT(Z'6E613C34EB02BCDB', KIND=I8B), INT(Z'37FF96F2C26FA7B1', KIND=I8B), INT(Z'8A892ABAF368F137', KIND=I8B), INT(Z'A67FF273B8460356', KIND=I8B), INT(Z'C9F98B4225C36C11', KIND=I8B), INT(Z'05FF7CAF730B919D', KIND=I8B), INT(Z'2D2B7569B0432D85', KIND=I8B), INT(Z'D01FEF10A657842C', KIND=I8B), INT(Z'9E3BF709579A238B', KIND=I8B), INT(Z'23BFADEDA7E73B02', KIND=I8B), INT(Z'9C3B29620E29FC73', KIND=I8B), INT(Z'8213F56A67F6B29B', KIND=I8B), INT(Z'45CAF4CBAD80AC6E', KIND=I8B), INT(Z'ECAF996911E109C3', KIND=I8B), INT(Z'8349F3BA91B47B8F', KIND=I8B), INT(Z'A298F2C501F45F42', KIND=I8B), INT(Z'173DB1FE98E0D789', KIND=I8B), INT(Z'E7DB7FC356594C34', KIND=I8B), INT(Z'241C70A936219A73', KIND=I8B), INT(Z'CB3F2F7642717713', KIND=I8B), INT(Z'1D0D1E7E3F190D6B', KIND=I8B), INT(Z'E1D25FB42BEF9F41', KIND=I8B), INT(Z'ED238CD383AA0110', KIND=I8B), INT(Z'FE0EFB53D30DD4D7', KIND=I8B), INT(Z'B228330EE76FA863', KIND=I8B), INT(Z'8D237BD09B75C388', KIND=I8B), INT(Z'F4363804324A40AA', KIND=I8B), INT(Z'9EC95D1463E8A506', KIND=I8B), INT(Z'DEB23FD2A14B927C', KIND=I8B), INT(Z'306C5AC4C253346A', KIND=I8B), INT(Z'B143C6053EDCD0D5', KIND=I8B), INT(Z'C67BB4597CE2CE48', KIND=I8B), INT(Z'965ECFC7499E771B', KIND=I8B), INT(Z'7C877175F2E80185', KIND=I8B), INT(Z'DD94B7868E94050A', KIND=I8B), INT(Z'F81AA16FDC1B81DA', KIND=I8B), INT(Z'7DFB41DC8E030A71', KIND=I8B), INT(Z'8DD4A6E9B7D100F3', KIND=I8B), INT(Z'CA7CF2B4191C8326', KIND=I8B), INT(Z'9B10A4E5E9913128', KIND=I8B), INT(Z'5D7A1253B183CD0D', KIND=I8B), INT(Z'3149D0A425C54130', KIND=I8B), INT(Z'FD1C2F611F63A3F0', KIND=I8B), INT(Z'C1D4CE1F63F57D72', KIND=I8B), INT(Z'74D896E89DE4C050', KIND=I8B), INT(Z'3D9C44CD2F36917C', KIND=I8B), INT(Z'BC633B39673C8CEC', KIND=I8B), INT(Z'F24A01A73CF2DCCF', KIND=I8B), INT(Z'C9075E5162AEF832', KIND=I8B), INT(Z'A681AB003D821AED', KIND=I8B), INT(Z'D5BE0503E085D813', KIND=I8B), INT(Z'976E41088617CA01', KIND=I8B), INT(Z'3B4935E5BB5AB63F', KIND=I8B), INT(Z'902215C04CE2A1A9', KIND=I8B), INT(Z'4B2D8644D8A74E18', KIND=I8B), INT(Z'BD49D14AA79DBC82', KIND=I8B), INT(Z'8A1B835F2A3163CE', KIND=I8B), INT(Z'B42A9B30601B4A13', KIND=I8B), INT(Z'DDF8E7D60ED1219E', KIND=I8B), INT(Z'EC9C459D51852BA2', KIND=I8B), INT(Z'3651321B7A5EDE61', KIND=I8B), INT(Z'309AA0FE3C110E4C', KIND=I8B), INT(Z'CABB90E5C942B503', KIND=I8B), INT(Z'93E1AB8252F33B45', KIND=I8B), INT(Z'43E57EA258F695F9', KIND=I8B), INT(Z'FCC1493DCB1551DF', KIND=I8B), INT(Z'3D6A751F3B936243', KIND=I8B), INT(Z'B8DA1662E7B00A17', KIND=I8B), INT(Z'14DEDE4AEF343B77', KIND=I8B), INT(Z'FBF19B8D3DDAA657', KIND=I8B), INT(Z'0CC512670A783AD4', KIND=I8B), INT(Z'E7109BFBA19C0C9D', KIND=I8B), INT(Z'6D0B4AEED580A52A', KIND=I8B), INT(Z'1D77013846A8A7F6', KIND=I8B), INT(Z'27FB2B80668B24C5', KIND=I8B), INT(Z'906A617D450187E2', KIND=I8B), INT(Z'084E1DAA8AE0CE75', KIND=I8B), INT(Z'64D4C1865852D1F4', KIND=I8B), INT(Z'B1F9F660802DEDF6', KIND=I8B), INT(Z'B484F9DC9641E9DA', KIND=I8B), INT(Z'0A61A5152D990213', KIND=I8B), INT(Z'FE09F1E7EE678671', KIND=I8B), INT(Z'5E7873F8A0396973', KIND=I8B), INT(Z'E1A63853BBD26451', KIND=I8B), INT(Z'A67D072D3C7FA14B', KIND=I8B), INT(Z'7EC63730F500B406', KIND=I8B), INT(Z'DB0B487B6423E1E8', KIND=I8B), INT(Z'8D07E33455637EB2', KIND=I8B), INT(Z'501C48F88B9F899E', KIND=I8B), INT(Z'9E77C4FD3240E108', KIND=I8B), INT(Z'91CE1A9A3D2CDA62', KIND=I8B), INT(Z'B049DC016ABC5E5F', KIND=I8B), INT(Z'64235B36AE876C06', KIND=I8B), INT(Z'4615B63C7ED1194A', KIND=I8B), INT(Z'7641A140CC7810FB', KIND=I8B), INT(Z'DC5C5301C56B75F7', KIND=I8B), INT(Z'7E9619022D14A384', KIND=I8B), INT(Z'0BCD91E5CF42AFCE', KIND=I8B), INT(Z'A9E904C87FCB0A9D', KIND=I8B), INT(Z'89B9B3E11B6329BA', KIND=I8B), INT(Z'1E3B9F42B859CC65', KIND=I8B), INT(Z'4EC0F65F43135BC2', KIND=I8B), INT(Z'546345FA9FBDCD44', KIND=I8B), INT(Z'AC2820D9623BF429', KIND=I8B), INT(Z'A5CA871366703F7E', KIND=I8B), INT(Z'627133F713D832B2', KIND=I8B), INT(Z'A97C177947AD4095', KIND=I8B), INT(Z'D732290FBACAF133', KIND=I8B), INT(Z'A79E946C200627AF', KIND=I8B), INT(Z'5D86C07A6C671FAF', KIND=I8B), INT(Z'49ED8EABCCCC485D', KIND=I8B), INT(Z'867F59A9D4BED6C0', KIND=I8B), INT(Z'918639872807B19A', KIND=I8B), INT(Z'B4E870990780E79B', KIND=I8B), INT(Z'5C68F256BFFF5A74', KIND=I8B), INT(Z'A81F301449EE8C70', KIND=I8B), INT(Z'75E7C7E8F2099E01', KIND=I8B), INT(Z'E2228CBF49612182', KIND=I8B), INT(Z'73832EEC6FFF3111', KIND=I8B), INT(Z'D226FC195C6A2F8C', KIND=I8B), INT(Z'89B0DCF1974602C1', KIND=I8B), INT(Z'2D5597F78DDCB4F1', KIND=I8B), INT(Z'C831FD53C5FF7EAB', KIND=I8B), INT(Z'83585D8FD9C25DB7', KIND=I8B), INT(Z'EC1D142DFD178371', KIND=I8B), INT(Z'F8AAFDF57153E22D', KIND=I8B), INT(Z'BA3E7CA8B77F5E55', KIND=I8B), INT(Z'A42E74F3D032F525', KIND=I8B), INT(Z'672459397C5D644D', KIND=I8B), INT(Z'76D5BD72CDA8DAB9', KIND=I8B), INT(Z'28CE1BD2E55F35EB', KIND=I8B), INT(Z'CD3A1230C43FB26F', KIND=I8B), INT(Z'E076B7C3EDBA5EB0', KIND=I8B), INT(Z'2A459667C08988B3', KIND=I8B), INT(Z'7980D163CF5B81B3', KIND=I8B), INT(Z'80444B5E7AA7CF85', KIND=I8B), INT(Z'D89465B4E928F65C', KIND=I8B), INT(Z'F4D6FC01B0ABEAE0', KIND=I8B), INT(Z'D7E105BCC332621F', KIND=I8B), INT(Z'A0555E361951C366', KIND=I8B), INT(Z'0EB97F22237333F3', KIND=I8B), INT(Z'F20CBB021CD6E599', KIND=I8B), INT(Z'8DD9472BF3FEFAA7', KIND=I8B), INT(Z'C86AB5C39FA63440', KIND=I8B), INT(Z'5267DEEAAC5000F0', KIND=I8B), INT(Z'EE8FE9C2A40C9EFF', KIND=I8B), INT(Z'B14F98F6F0FEB951', KIND=I8B), INT(Z'FA856334878FC150', KIND=I8B), INT(Z'9380EB52ABB20096', KIND=I8B), INT(Z'3519F219A687E35F', KIND=I8B), INT(Z'6ED1BF9A569F33D3', KIND=I8B), INT(Z'9C935E00D4B9D8D2', KIND=I8B), INT(Z'78612627569E80BC', KIND=I8B), INT(Z'02606EA01029DC37', KIND=I8B), INT(Z'0A862F80EC4700C8', KIND=I8B), INT(Z'C3B8358109E84F07', KIND=I8B), INT(Z'56796FB12C4620EB', KIND=I8B), INT(Z'02F88A4814345345', KIND=I8B), INT(Z'CD27BB612758C0FA', KIND=I8B), INT(Z'F4A642E14C6262C8', KIND=I8B), INT(Z'560BE5CEBBABD492', KIND=I8B), INT(Z'41DB566D0CA0B40B', KIND=I8B), INT(Z'8038D51CB897789C', KIND=I8B), INT(Z'98E7E9CCCFBD7DBD', KIND=I8B), INT(Z'2B8EDF426A96C9B7', KIND=I8B), INT(Z'52522C084FC8E10E', KIND=I8B), INT(Z'E0470A63E6BD56C3', KIND=I8B), INT(Z'BF21E44003ACDD2C', KIND=I8B), INT(Z'B6729713053C7C25', KIND=I8B), INT(Z'26E6B70A63BB1951', KIND=I8B), INT(Z'1858CCFCE06CAC74', KIND=I8B), INT(Z'EEEA5D5004981478', KIND=I8B), INT(Z'12079E6BE345CD97', KIND=I8B), INT(Z'985032667E54EFD3', KIND=I8B), INT(Z'0F37801E0C43EBC8', KIND=I8B), INT(Z'95527A5202DF0CCB', KIND=I8B), INT(Z'D6898606DC1740FD', KIND=I8B), INT(Z'BE643F001DEA2BC7', KIND=I8B), INT(Z'D30560258F54E6BA', KIND=I8B), INT(Z'BAA718E68396CFFD', KIND=I8B), INT(Z'CC2BE788931D113C', KIND=I8B), INT(Z'6DFD4EC02564B6B9', KIND=I8B), INT(Z'47C6B82EF32A2069', KIND=I8B), INT(Z'E950DF20247C83FD', KIND=I8B), INT(Z'1F9B70B55BF22AC5', KIND=I8B), INT(Z'E4BE5138175EF234', KIND=I8B), INT(Z'4CDC331D57FA5441', KIND=I8B), INT(Z'91D28B7416CDD27E', KIND=I8B), INT(Z'27824CE2B2EEB577', KIND=I8B), INT(Z'5DEDE5861D36AEC1', KIND=I8B), INT(Z'E0133FE4ADF8E952', KIND=I8B), INT(Z'B6472E511C81471D', KIND=I8B), INT(Z'7162E01B5FAA62D5', KIND=I8B), INT(Z'F5695EE7A4845A71', KIND=I8B), INT(Z'58180FDDD97723A6', KIND=I8B), INT(Z'E3D8F9E563A198E5', KIND=I8B), INT(Z'E6DDCC111BCA7DC5', KIND=I8B), INT(Z'5961DB50C6D2B886', KIND=I8B), INT(Z'570F09EAA7EA7648', KIND=I8B), INT(Z'8E679C2F5E44FF8F', KIND=I8B), INT(Z'A0953F1562BD1D36', KIND=I8B), INT(Z'6FBA5224F88766A8', KIND=I8B), INT(Z'2CD2CC6551E513DA', KIND=I8B), INT(Z'B201833B35D63F73', KIND=I8B), INT(Z'C8BA8EDABB6C6484', KIND=I8B), INT(Z'0BA8E6AE36A94052', KIND=I8B), INT(Z'F8077F7EA65E58D1', KIND=I8B), INT(Z'DE81E40A034BCF4F', KIND=I8B), INT(Z'BD749948B523BED2', KIND=I8B), INT(Z'A749902CE229C833', KIND=I8B), INT(Z'FB04AFAF27FAF782', KIND=I8B), INT(Z'8B112E86420F6191', KIND=I8B), INT(Z'ACD1BF9AE26CAE87', KIND=I8B), INT(Z'511BF4381AB43A40', KIND=I8B), INT(Z'79C5DB9AF1F9B563', KIND=I8B), INT(Z'ADD57A27D29339F6', KIND=I8B), INT(Z'D8062F819B07DA29', KIND=I8B), INT(Z'2562F146216148D0', KIND=I8B), INT(Z'18375281AE7822BC', KIND=I8B), INT(Z'D94AD8B1C7380874', KIND=I8B), INT(Z'8703DDB100E4E859', KIND=I8B), INT(Z'975DD6CBD4DCCD82', KIND=I8B), INT(Z'8F2293910D0B15B5', KIND=I8B), INT(Z'87CEC76F1C830548', KIND=I8B), INT(Z'28C4D51D411E2270', KIND=I8B), INT(Z'FD354C7ECA1400E3', KIND=I8B), INT(Z'B2EB3875504DDB22', KIND=I8B), INT(Z'A9C2794AE3A3C69A', KIND=I8B), INT(Z'F2F60A649165AB0C', KIND=I8B), INT(Z'BC829F9E7C99011B', KIND=I8B), INT(Z'5FA60692A46151EB', KIND=I8B), INT(Z'D433179D9C8CB841', KIND=I8B), INT(Z'77D9C67EDADF8AE7', KIND=I8B), INT(Z'55D1A3C30DDFA0B1', KIND=I8B), INT(Z'DBC7C41BA6BCD333', KIND=I8B), INT(Z'849FEEC281D7F328', KIND=I8B), INT(Z'D5D0381E91976DA1', KIND=I8B), INT(Z'2B460CB3D15788DD', KIND=I8B), INT(Z'12B9B522906C0800', KIND=I8B), INT(Z'A5C7EA73224DEFF3', KIND=I8B), INT(Z'4B44462635FD4909', KIND=I8B), INT(Z'36178FE0C5AD6B15', KIND=I8B), INT(Z'D768226B34870A00', KIND=I8B), INT(Z'CF39E50FEAE16BEF', KIND=I8B), INT(Z'4F0AABD7E1BE4DA6', KIND=I8B), INT(Z'21CEB9EC7B8C62ED', KIND=I8B), INT(Z'E6A1158300D46640', KIND=I8B), INT(Z'81842F29F2CCE375', KIND=I8B), INT(Z'A2CD56CDDA2DE10F', KIND=I8B), INT(Z'2A4268679A6F7BA8', KIND=I8B), INT(Z'60495AE3C1097FD0', KIND=I8B), INT(Z'A1E53AF46F801C53', KIND=I8B), INT(Z'CB80AC8150B95953', KIND=I8B), INT(Z'34D30281810B5A92', KIND=I8B), INT(Z'385BB19CB14BDFC4', KIND=I8B), INT(Z'CA5E89B18B602368', KIND=I8B), INT(Z'7E60D7A1A4E7AFA8', KIND=I8B), INT(Z'4207C321E14E3137', KIND=I8B), INT(Z'46729E03DD9ED7B5', KIND=I8B), INT(Z'FCF62C1DEE382C42', KIND=I8B), INT(Z'AEFC86C50710CDC9', KIND=I8B), INT(Z'4944D9F52CD0DEC2', KIND=I8B), INT(Z'6C07A2C26A8346D1', KIND=I8B), INT(Z'9E19DB92B4E31BA9', KIND=I8B), INT(Z'5ABBA87648D5013B', KIND=I8B), INT(Z'9B96107278051673', KIND=I8B), INT(Z'C7098B7305241885', KIND=I8B), INT(Z'C5A05277621BE293', KIND=I8B), INT(Z'316A9293DB0A418A', KIND=I8B), INT(Z'027B948F16065C10', KIND=I8B), INT(Z'B8CBEE4FC66D1EA7', KIND=I8B), INT(Z'F70867153AA2DB38', KIND=I8B), INT(Z'1EE29B9C68E668F6', KIND=I8B), INT(Z'618D3CD96DC3F98A', KIND=I8B), INT(Z'737F74F1DC043328', KIND=I8B), INT(Z'9A65406D44A5C903', KIND=I8B), INT(Z'A69B428383200334', KIND=I8B), INT(Z'79F08C0FC934F7EC', KIND=I8B), INT(Z'505F522E53053FF2', KIND=I8B), INT(Z'C0FE908895CF3B44', KIND=I8B), INT(Z'D042132463E80401', KIND=I8B), INT(Z'186CAF13BB8235E7', KIND=I8B), INT(Z'647726B9E7C68FEF', KIND=I8B), INT(Z'F13E34AABB430A15', KIND=I8B), INT(Z'E2294BF6BE710280', KIND=I8B), INT(Z'6F43ED6C553161B0', KIND=I8B), INT(Z'5ECA783430DC19F5', KIND=I8B), INT(Z'96C6E0EAB509E64D', KIND=I8B), INT(Z'1AB39EF46E0D4321', KIND=I8B), INT(Z'CB14E8C76A7DBA1D', KIND=I8B), INT(Z'B67D16413D132072', KIND=I8B), INT(Z'BC789925624C5FE0', KIND=I8B), INT(Z'616086B1899093E9', KIND=I8B), INT(Z'7DDA22F9451D28A4', KIND=I8B), INT(Z'E41C5BD18C57E88F', KIND=I8B), INT(Z'EB96BF6EBADF77D8', KIND=I8B), INT(Z'BCDC542EF5FA5C71', KIND=I8B), INT(Z'AEA855DBCB323966', KIND=I8B), INT(Z'8E91B962F7B6F159', KIND=I8B), INT(Z'933E37A534CBAAE7', KIND=I8B), INT(Z'6C13693AB378F38E', KIND=I8B), INT(Z'1A526B52BDFEC7C0', KIND=I8B), INT(Z'723627BBB5A4ADB0', KIND=I8B), INT(Z'B80DC58E81FE95A1', KIND=I8B), INT(Z'8718438960573071', KIND=I8B), INT(Z'20E706276D7E79B0', KIND=I8B), INT(Z'CEC3B1AAA30DD91C', KIND=I8B), INT(Z'E61136F2227E3B09', KIND=I8B), INT(Z'546F2A35DC367E47', KIND=I8B), INT(Z'949063D8A46F0C0E', KIND=I8B), INT(Z'213A4F0AA5E8A7B1', KIND=I8B), INT(Z'8FCAC257558EE4E6', KIND=I8B), INT(Z'E98AF4C353441DD8', KIND=I8B), INT(Z'F9B47CCECD8ACF11', KIND=I8B), INT(Z'A988E2CD4F62D19D', KIND=I8B), INT(Z'B3BD72ED2AF29E1F', KIND=I8B), INT(Z'63EDB1F42815254F', KIND=I8B), INT(Z'78219C0280ED82D6', KIND=I8B), INT(Z'93EB1B80A33B8605', KIND=I8B), INT(Z'E0ACCFA875AF45A7', KIND=I8B), INT(Z'FE748F38990D3751', KIND=I8B), INT(Z'6B150181909471C5', KIND=I8B), INT(Z'BC72F130660533C3', KIND=I8B), INT(Z'8C6C01C9498D8B88', KIND=I8B), INT(Z'7E11B306BF508525', KIND=I8B), INT(Z'45DA41E1F4B98E37', KIND=I8B), INT(Z'EB8FAD7C7F8680B4', KIND=I8B), INT(Z'AF87023B9BF0EE6A', KIND=I8B), INT(Z'5D961FC86F24A66F', KIND=I8B), INT(Z'5750D25A71E7F1C5', KIND=I8B), INT(Z'A67398DB9F6820E1', KIND=I8B), INT(Z'DB68C2CA82ED2A05', KIND=I8B), INT(Z'5A7DD3DD4576E805', KIND=I8B), INT(Z'D69283788730F71B', KIND=I8B), INT(Z'88083F8943A1148C', KIND=I8B), INT(Z'892179BE91D43A43', KIND=I8B), INT(Z'311D48D496D4A206', KIND=I8B), INT(Z'0C372456A8FD34E2', KIND=I8B), INT(Z'6A0A4F6B948959B0', KIND=I8B), INT(Z'AB69D82E364948D4', KIND=I8B), INT(Z'BD649B09BC89CA88', KIND=I8B), INT(Z'0F44ED6C533C821A', KIND=I8B), INT(Z'848CE34679ABB01C', KIND=I8B), INT(Z'D6444E39C3DB9B09', KIND=I8B), INT(Z'B65EE0E615D61E95', KIND=I8B), INT(Z'898B1463B405D150', KIND=I8B), INT(Z'F2D80E0C0C0B4E11', KIND=I8B), INT(Z'85EAB0E41A6940E5', KIND=I8B), INT(Z'E3F6991F9B4BA63A', KIND=I8B), INT(Z'EBEDD97CA10745A4', KIND=I8B), INT(Z'6F8E118F0F0E2195', KIND=I8B), INT(Z'A7655D1D2103911F', KIND=I8B), INT(Z'1CF43F67821E8FC9', KIND=I8B), INT(Z'66E94FDBC949170E', KIND=I8B), INT(Z'4B7195F2D2D1A9FB', KIND=I8B), INT(Z'D13EB46469447567', KIND=I8B), INT(Z'D218A7A0B15319DD', KIND=I8B), INT(Z'2051D1E95DCDAE68', KIND=I8B), INT(Z'8F26FDB7C3C30A3D', KIND=I8B), INT(Z'82C730BEC1CAC960', KIND=I8B), INT(Z'069ED188DDA7E055', KIND=I8B), INT(Z'68664663B5411A03', KIND=I8B), INT(Z'B2F0BD25B4B3CCCC', KIND=I8B), INT(Z'A378FCEE723D7BB8', KIND=I8B), INT(Z'C84685EB1511D86A', KIND=I8B), INT(Z'827FD7FCA2916083', KIND=I8B), INT(Z'DFACEC6F21E0BFFF', KIND=I8B), INT(Z'CC573C2A0ECCDAA6', KIND=I8B)], [4, 701]) This table contains the 256-bit mantissa (or significand) approximations of the\n  powers of 10 from -350 to 350 that can cover the entire exponent ranges of both\n  double- and single-precision floating point numbers. The 256-bit approximations are stored in each row of the array and they are stored\n  in a little-endian order (i.e. the (first) element 0 of each row represents the\n  least significant byte and the (fourth) element 3 is the most significand one). integer(kind=I4B), public, parameter :: Pow5_128_Size = 56 size of the 'Pow5_128_Table' table integer(kind=I8B), public, parameter :: Pow5_128_Table (0:1,0:Pow5_128_Size-1) = RESHAPE([INT(Z'0000000000000001', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000005', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000019', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000000000007D', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000271', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000C35', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000003D09', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000000001312D', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000000005F5E1', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'00000000001DCD65', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'00000000009502F9', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000002E90EDD', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000000E8D4A51', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000048C27395', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000016BCC41E9', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000071AFD498D', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000002386F26FC1', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000000B1A2BC2EC5', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000003782DACE9D9', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'00001158E460913D', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000056BC75E2D631', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0001B1AE4D6E2EF5', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'000878678326EAC9', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'002A5A058FC295ED', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'00D3C21BCECCEDA1', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0422CA8B0A00A425', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'14ADF4B7320334B9', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'6765C793FA10079D', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'04FCE5E3E2502611', KIND=I8B), INT(Z'0000000000000002', KIND=I8B), INT(Z'18F07D736B90BE55', KIND=I8B), INT(Z'000000000000000A', KIND=I8B), INT(Z'7CB2734119D3B7A9', KIND=I8B), INT(Z'0000000000000032', KIND=I8B), INT(Z'6F7C40458122964D', KIND=I8B), INT(Z'00000000000000FC', KIND=I8B), INT(Z'2D6D415B85ACEF81', KIND=I8B), INT(Z'00000000000004EE', KIND=I8B), INT(Z'E32246C99C60AD85', KIND=I8B), INT(Z'00000000000018A6', KIND=I8B), INT(Z'6FAB61F00DE36399', KIND=I8B), INT(Z'0000000000007B42', KIND=I8B), INT(Z'2E58E9B04570F1FD', KIND=I8B), INT(Z'000000000002684C', KIND=I8B), INT(Z'E7BC90715B34B9F1', KIND=I8B), INT(Z'00000000000C097C', KIND=I8B), INT(Z'86AED236C807A1B5', KIND=I8B), INT(Z'00000000003C2F70', KIND=I8B), INT(Z'A16A1B11E8262889', KIND=I8B), INT(Z'00000000012CED32', KIND=I8B), INT(Z'2712875988BECAAD', KIND=I8B), INT(Z'0000000005E0A1FD', KIND=I8B), INT(Z'C35CA4BFABB9F561', KIND=I8B), INT(Z'000000001D6329F1', KIND=I8B), INT(Z'D0CF37BE5AA1CAE5', KIND=I8B), INT(Z'0000000092EFD1B8', KIND=I8B), INT(Z'140C16B7C528F679', KIND=I8B), INT(Z'00000002DEAF189C', KIND=I8B), INT(Z'643C7196D9CCD05D', KIND=I8B), INT(Z'0000000E596B7B0C', KIND=I8B), INT(Z'F52E37F2410011D1', KIND=I8B), INT(Z'00000047BF19673D', KIND=I8B), INT(Z'C9E717BB45005915', KIND=I8B), INT(Z'00000166BB7F0435', KIND=I8B), INT(Z'F18376A85901BD69', KIND=I8B), INT(Z'00000701A97B150C', KIND=I8B), INT(Z'B7915149BD08B30D', KIND=I8B), INT(Z'000023084F676940', KIND=I8B), INT(Z'95D69670B12B7F41', KIND=I8B), INT(Z'0000AF298D050E43', KIND=I8B), INT(Z'ED30F03375D97C45', KIND=I8B), INT(Z'00036BCFC1194751', KIND=I8B), INT(Z'A1F4B1014D3F6D59', KIND=I8B), INT(Z'00111B0EC57E6499', KIND=I8B), INT(Z'29C77506823D22BD', KIND=I8B), INT(Z'00558749DB77F700', KIND=I8B), INT(Z'D0E549208B31ADB1', KIND=I8B), INT(Z'01ABA4714957D300', KIND=I8B), INT(Z'147A6DA2B7F86475', KIND=I8B), INT(Z'085A36366EB71F04', KIND=I8B), INT(Z'6664242D97D9F649', KIND=I8B), INT(Z'29C30F1029939B14', KIND=I8B), INT(Z'FFF4B4E3F741CF6D', KIND=I8B), INT(Z'D0CF4B50CFE20765', KIND=I8B)], [2, 56]) This table contains the 128-bit representations of powers of 5 from 0 to 55. The 128-bit representations are stored in each row of the array and they are stored\nin a little-endian order (i.e. the (first) element 0 of each row represents the\nleast significant byte and the (second) element 1 is the most significand one). integer(kind=I4B), public, parameter :: Pow10_256_Compressed_MinExp = -5005 minimum exponent value of the 'Pow10_256_Compressed_Table' table integer(kind=I4B), public, parameter :: Pow10_256_Compressed_MaxExp = 5019 maximum exponent value of the 'Pow10_256_Compressed_Table' table integer(kind=I8B), public, parameter :: Pow10_256_Compressed_Table (0:3,0:179) = RESHAPE([INT(Z'36551D5CAEBE5F19', KIND=I8B), INT(Z'B76974F01FD4D2A5', KIND=I8B), INT(Z'96C34F43A9FACED7', KIND=I8B), INT(Z'D740992314AD6BB8', KIND=I8B), INT(Z'280FF4BB6DE53C8C', KIND=I8B), INT(Z'910DA112133C7D2F', KIND=I8B), INT(Z'8C1A9EFE537E7256', KIND=I8B), INT(Z'DB777B3B4103CD8E', KIND=I8B), INT(Z'B51DD1A26B3E0AE4', KIND=I8B), INT(Z'DC75C0DE1DBD1518', KIND=I8B), INT(Z'986847E9FC8C0DA2', KIND=I8B), INT(Z'DFC37CE196FE24A6', KIND=I8B), INT(Z'B1DFE4774EA27C85', KIND=I8B), INT(Z'6D717A4AE66C471F', KIND=I8B), INT(Z'FE02584657A5D4A3', KIND=I8B), INT(Z'E42507F5B8D7AB8A', KIND=I8B), INT(Z'62A78FB4471D9C41', KIND=I8B), INT(Z'D5BAC5A3031C0A3D', KIND=I8B), INT(Z'C5AEC6423E968BB7', KIND=I8B), INT(Z'E89C8869F10D2F89', KIND=I8B), INT(Z'CD0F383A196B7237', KIND=I8B), INT(Z'3DA563D1BCF2E89C', KIND=I8B), INT(Z'4774A69ADDF3C50D', KIND=I8B), INT(Z'ED2A6C4D961CCDC9', KIND=I8B), INT(Z'EE753F9DF785A420', KIND=I8B), INT(Z'7D1DF2590CE8203E', KIND=I8B), INT(Z'5C3F923385BE6663', KIND=I8B), INT(Z'F1CF23D7A258D37E', KIND=I8B), INT(Z'0FFF2A51C95A3A72', KIND=I8B), INT(Z'6856EB7268BB8873', KIND=I8B), INT(Z'0FB1034E07547FEB', KIND=I8B), INT(Z'F68B217180D2C34F', KIND=I8B), INT(Z'136B3DAF4BEF6FDF', KIND=I8B), INT(Z'FFAD1F695AC21476', KIND=I8B), INT(Z'A1CB42ADD8C71A34', KIND=I8B), INT(Z'FB5ED9C210689E24', KIND=I8B), INT(Z'339C8F794803A95A', KIND=I8B), INT(Z'B60B57CE59A00FE3', KIND=I8B), INT(Z'537F3DB8E565B56B', KIND=I8B), INT(Z'802561DC6F01E1C2', KIND=I8B), INT(Z'5C2E583532F7A896', KIND=I8B), INT(Z'EA135BA2A6E86A78', KIND=I8B), INT(Z'BDC3551E0A26C72F', KIND=I8B), INT(Z'82A7AC4CCB8F06BD', KIND=I8B), INT(Z'8386C87E9445033E', KIND=I8B), INT(Z'A2F677099BF2A66F', KIND=I8B), INT(Z'78B4BB2AA55193C3', KIND=I8B), INT(Z'85368A03DAD39B5A', KIND=I8B), INT(Z'32F06577D7074E54', KIND=I8B), INT(Z'173D9AA79942373E', KIND=I8B), INT(Z'499E81B4CD4AE3EA', KIND=I8B), INT(Z'87D23A0933350F8C', KIND=I8B), INT(Z'FE908EC116816F8B', KIND=I8B), INT(Z'35CDFBC46A449E10', KIND=I8B), INT(Z'8D4D35B31A8D06C0', KIND=I8B), INT(Z'8A7AFCA0558B9252', KIND=I8B), INT(Z'A23AF279B441588B', KIND=I8B), INT(Z'1493053A1C26C9FE', KIND=I8B), INT(Z'C58E825E9EA5CAB3', KIND=I8B), INT(Z'8D31134EDC8F41F2', KIND=I8B), INT(Z'1D664B9A0D81F3F8', KIND=I8B), INT(Z'F54956CD4A8BF8BB', KIND=I8B), INT(Z'9A68CB84CA90592C', KIND=I8B), INT(Z'8FF4C0E2CB45C6DF', KIND=I8B), INT(Z'C9CC2E96D0D7ECAD', KIND=I8B), INT(Z'4C2B817AE934C413', KIND=I8B), INT(Z'7559CABB281AA312', KIND=I8B), INT(Z'92C64978FB0BBC09', KIND=I8B), INT(Z'D30D14DEDBA3C47A', KIND=I8B), INT(Z'0B2130D22416CA03', KIND=I8B), INT(Z'02EBFFEFCE416A4F', KIND=I8B), INT(Z'95A5F283A9D85228', KIND=I8B), INT(Z'6122213492C7EEBF', KIND=I8B), INT(Z'8B8594477973B5CC', KIND=I8B), INT(Z'A3DD3D019C378C32', KIND=I8B), INT(Z'989402D1295CB59D', KIND=I8B), INT(Z'F462491B6388FF85', KIND=I8B), INT(Z'AC8FC877DDA49C5B', KIND=I8B), INT(Z'9861BAF69ABF15B2', KIND=I8B), INT(Z'9B90C292AFA3E833', KIND=I8B), INT(Z'9B80CC3A2F3F00D2', KIND=I8B), INT(Z'09201621395EB23A', KIND=I8B), INT(Z'6255B4ACB3C54AAC', KIND=I8B), INT(Z'9E9C7B6349DAF965', KIND=I8B), INT(Z'C6A666357166B6F5', KIND=I8B), INT(Z'34817EDA496E980D', KIND=I8B), INT(Z'F18BE95ADFB35BD9', KIND=I8B), INT(Z'A1B7784EF1ECD192', KIND=I8B), INT(Z'E582AC4E79ECB4E5', KIND=I8B), INT(Z'5CC27DE46B2668BA', KIND=I8B), INT(Z'A931725AD5869D0F', KIND=I8B), INT(Z'A4E205D9C7A01E8C', KIND=I8B), INT(Z'E3BD8F843A7379A8', KIND=I8B), INT(Z'EF59CA4D33AEAACA', KIND=I8B), INT(Z'C5D211C6689BB43B', KIND=I8B), INT(Z'A81C72076DE95AD4', KIND=I8B), INT(Z'2C17DBC2A25011F8', KIND=I8B), INT(Z'427B47B78F679F36', KIND=I8B), INT(Z'5634DFC7A23269BC', KIND=I8B), INT(Z'AB670C628D2664FB', KIND=I8B), INT(Z'6941FA8C2552AD87', KIND=I8B), INT(Z'8E2573250417E3EA', KIND=I8B), INT(Z'B1727969F1308DA9', KIND=I8B), INT(Z'AEC226047AFCA9FA', KIND=I8B), INT(Z'BFBF516B03E77A02', KIND=I8B), INT(Z'A0B5539D042A09B3', KIND=I8B), INT(Z'A4029E36D6F23E59', KIND=I8B), INT(Z'B22E119D089684C9', KIND=I8B), INT(Z'E34B0E471219629D', KIND=I8B), INT(Z'6CFFE2FAFFDFB62F', KIND=I8B), INT(Z'B488122830B22F41', KIND=I8B), INT(Z'B5AB237A780026CF', KIND=I8B), INT(Z'C69DE78E00F92C06', KIND=I8B), INT(Z'F4D9A7F47802B282', KIND=I8B), INT(Z'DFA7CE651C7C640E', KIND=I8B), INT(Z'B939B191996820E1', KIND=I8B), INT(Z'D25AF8E4BDEF3D39', KIND=I8B), INT(Z'D1C451AA692CD802', KIND=I8B), INT(Z'C828083CE66AB062', KIND=I8B), INT(Z'BCDA1386110B7B47', KIND=I8B), INT(Z'21631DF1A7CA30CF', KIND=I8B), INT(Z'C04A31CE10142B88', KIND=I8B), INT(Z'2EE136D2BD32E12E', KIND=I8B), INT(Z'C08CA2B2C6993561', KIND=I8B), INT(Z'9849C14804373AD0', KIND=I8B), INT(Z'F34EB109C4272065', KIND=I8B), INT(Z'07CF979EEA155507', KIND=I8B), INT(Z'C451BA327EDD033A', KIND=I8B), INT(Z'F76F45D6A84E6C5C', KIND=I8B), INT(Z'74C89E178C289C4E', KIND=I8B), INT(Z'05538296DEA43314', KIND=I8B), INT(Z'C829B6E8A0853113', KIND=I8B), INT(Z'94F9878998C91025', KIND=I8B), INT(Z'869B308D8DFEDFB8', KIND=I8B), INT(Z'3BD21A71C2B71A8C', KIND=I8B), INT(Z'CC14F78A24DBBB01', KIND=I8B), INT(Z'E2550DF7CD13845E', KIND=I8B), INT(Z'901F6F7FC95EE63C', KIND=I8B), INT(Z'C8601E6FA4BF8F4E', KIND=I8B), INT(Z'D013DCA6B54EE1AF', KIND=I8B), INT(Z'314838C31F12F799', KIND=I8B), INT(Z'21A1837A56C0E7B9', KIND=I8B), INT(Z'673FDADCFB020F43', KIND=I8B), INT(Z'D426C8B1F6A9D56A', KIND=I8B), INT(Z'F2260F65B1FEC8D2', KIND=I8B), INT(Z'BF8AC7AC3234497A', KIND=I8B), INT(Z'E77BFCBF4C9E7ADA', KIND=I8B), INT(Z'D84E200D02E27651', KIND=I8B), INT(Z'65223F685FBB48C5', KIND=I8B), INT(Z'5B005DBF596582AA', KIND=I8B), INT(Z'C128EA94AAFF3332', KIND=I8B), INT(Z'DC8A49101265A45F', KIND=I8B), INT(Z'A84C0547AD3E2669', KIND=I8B), INT(Z'6F8C2E7D0CB97BDC', KIND=I8B), INT(Z'3C43609ED5462D14', KIND=I8B), INT(Z'E0DBAC1455D02C1B', KIND=I8B), INT(Z'9122E1565E556140', KIND=I8B), INT(Z'26444729F361F768', KIND=I8B), INT(Z'30DE25C986024442', KIND=I8B), INT(Z'E542B37E01070609', KIND=I8B), INT(Z'A694E67207B25770', KIND=I8B), INT(Z'4012E15015C7BCB7', KIND=I8B), INT(Z'4D0447208F3D177F', KIND=I8B), INT(Z'E9BFCBC688A65F62', KIND=I8B), INT(Z'0C197AA9F4C79A7E', KIND=I8B), INT(Z'F285D262E981D766', KIND=I8B), INT(Z'0FA349B0CA4EBD47', KIND=I8B), INT(Z'EE53638712C3BAF0', KIND=I8B), INT(Z'30F39A05AE9FAEA9', KIND=I8B), INT(Z'5EEEF1B71939A504', KIND=I8B), INT(Z'AB176A1A25FD6C9C', KIND=I8B), INT(Z'F2FDEB831C04698D', KIND=I8B), INT(Z'AD3A7B296573C53C', KIND=I8B), INT(Z'DBF9B06F93BFFDFB', KIND=I8B), INT(Z'7D0B53BA94B4643D', KIND=I8B), INT(Z'F7BFD6B3520EA329', KIND=I8B), INT(Z'4311E46BBEBF4F06', KIND=I8B), INT(Z'1DFEF1B5137F779F', KIND=I8B), INT(Z'D5CD9080862D2A51', KIND=I8B), INT(Z'FC999A50A460ABC1', KIND=I8B), INT(Z'BD23DF9F8A82A8CB', KIND=I8B), INT(Z'E13695D3E1B9D384', KIND=I8B), INT(Z'7749DE9BF2446B6D', KIND=I8B), INT(Z'80C5D6EFC64F5619', KIND=I8B), INT(Z'9BE5D4853787B437', KIND=I8B), INT(Z'B8E66B56D394147D', KIND=I8B), INT(Z'970CF8CCE40B1107', KIND=I8B), INT(Z'834B459DC7B69EA2', KIND=I8B), INT(Z'2734238D9E3D2D3B', KIND=I8B), INT(Z'6D24AE7C2611BDD5', KIND=I8B), INT(Z'DEFD267424FBAC3F', KIND=I8B), INT(Z'85DD57517B7A0A62', KIND=I8B), INT(Z'0ADCC666E173CF31', KIND=I8B), INT(Z'E17BB1A2FC03AC8C', KIND=I8B), INT(Z'0A4BC1B2A0F829A4', KIND=I8B), INT(Z'887C4B616414E88B', KIND=I8B), INT(Z'42E3E243C3FA365B', KIND=I8B), INT(Z'E7E29AE280A43245', KIND=I8B), INT(Z'19A605AFAC1A9E5B', KIND=I8B), INT(Z'8B2862617A07C409', KIND=I8B), INT(Z'6199216D3B08FCCE', KIND=I8B), INT(Z'ED25F5BD6E1C32A6', KIND=I8B), INT(Z'2BECDE00EDD89640', KIND=I8B), INT(Z'8DE1DE296304417E', KIND=I8B), INT(Z'DE6AC4A65AAA0DDC', KIND=I8B), INT(Z'90CB3DA4EB4E9C54', KIND=I8B), INT(Z'F3578F3AAC8C10D2', KIND=I8B), INT(Z'90A901DAC840396A', KIND=I8B), INT(Z'8B134D8B53B24BDE', KIND=I8B), INT(Z'E8D208C2E554231E', KIND=I8B), INT(Z'A6E54C31936ACD9D', KIND=I8B), INT(Z'937E11E7CC8C33E0', KIND=I8B), INT(Z'3B8A457E418ED2FA', KIND=I8B), INT(Z'9F63CE3B45CEE23D', KIND=I8B), INT(Z'A83DBDBE6FF51F7F', KIND=I8B), INT(Z'96615419A2CC79A5', KIND=I8B), INT(Z'7582AAAF505F7D2C', KIND=I8B), INT(Z'071757FA70F8ECF6', KIND=I8B), INT(Z'1D21BAFBC6BDF274', KIND=I8B), INT(Z'99530F9745770CB1', KIND=I8B), INT(Z'47086751D1BFC244', KIND=I8B), INT(Z'E7DB353A50105038', KIND=I8B), INT(Z'3E83BC53211CC27B', KIND=I8B), INT(Z'9C538CEC4FBC0774', KIND=I8B), INT(Z'AADF733514481AA9', KIND=I8B), INT(Z'7124C52008BCB2F2', KIND=I8B), INT(Z'6C6C2458BB0BFABD', KIND=I8B), INT(Z'9F63160FF9011FE9', KIND=I8B), INT(Z'54A3F155DED79252', KIND=I8B), INT(Z'E340200055D066FE', KIND=I8B), INT(Z'038C474A387E1BEF', KIND=I8B), INT(Z'A281F66C335C5920', KIND=I8B), INT(Z'66F82F83E78F45B2', KIND=I8B), INT(Z'0CA71638CC66C30E', KIND=I8B), INT(Z'E69A144C907D9363', KIND=I8B), INT(Z'A5B07AE4EDBD4C49', KIND=I8B), INT(Z'95F8384A5C10F4AF', KIND=I8B), INT(Z'FB057BAD1325F8A9', KIND=I8B), INT(Z'A903015120C51B50', KIND=I8B), INT(Z'A8EEF1DF7A77E17F', KIND=I8B), INT(Z'899B412D19B80437', KIND=I8B), INT(Z'EE587B35EE0FF080', KIND=I8B), INT(Z'E8F9910BF1580C20', KIND=I8B), INT(Z'AC3DAB4A1AE6D0D6', KIND=I8B), INT(Z'C781090E748A2D6C', KIND=I8B), INT(Z'1B44BA709B41FAC9', KIND=I8B), INT(Z'F3394CF73C86F97A', KIND=I8B), INT(Z'AF9CF8A3B0DFD659', KIND=I8B), INT(Z'88F2DFB2D6849A1B', KIND=I8B), INT(Z'177A0DE1B1C758D1', KIND=I8B), INT(Z'3A6C9FF074C91C03', KIND=I8B), INT(Z'B30D2D0396B72748', KIND=I8B), INT(Z'CB03BBB49ACAE632', KIND=I8B), INT(Z'0535B24D77660984', KIND=I8B), INT(Z'2F20C678A5594431', KIND=I8B), INT(Z'B68E9D219E936D1E', KIND=I8B), INT(Z'ACC440B0C24C4B4A', KIND=I8B), INT(Z'F5FBC25C26DAA523', KIND=I8B), INT(Z'0D68F1075451173E', KIND=I8B), INT(Z'BA219F5E39D75394', KIND=I8B), INT(Z'8A43060F0FA775D5', KIND=I8B), INT(Z'360ED84A5CE0FECD', KIND=I8B), INT(Z'7ED38C896B5E26BC', KIND=I8B), INT(Z'BDC68BCAC969926B', KIND=I8B), INT(Z'A3764C9E7BFDD6FB', KIND=I8B), INT(Z'6CD38FF92700788A', KIND=I8B), INT(Z'898B6959D41B8DCB', KIND=I8B), INT(Z'C17DBC3217A84AE2', KIND=I8B), INT(Z'155FF45CE16E1F8E', KIND=I8B), INT(Z'E4C545B373C08B0C', KIND=I8B), INT(Z'1C478DB63FD474C8', KIND=I8B), INT(Z'C5478C20FCD89358', KIND=I8B), INT(Z'CE3638886093157F', KIND=I8B), INT(Z'78897A81F9722117', KIND=I8B), INT(Z'6BAECA12558DFE94', KIND=I8B), INT(Z'C92458EF2EE7227E', KIND=I8B), INT(Z'96DE8F78F20CF4DD', KIND=I8B), INT(Z'7F697E055C034630', KIND=I8B), INT(Z'0A02E2256B1ED9A5', KIND=I8B), INT(Z'CD1481C83D5336C6', KIND=I8B), INT(Z'F84D26BA382A3B98', KIND=I8B), INT(Z'6349D1696F488AB2', KIND=I8B), INT(Z'DF346BD1FD310984', KIND=I8B), INT(Z'D11867B4BA2116E0', KIND=I8B), INT(Z'0ECD499A09D856E7', KIND=I8B), INT(Z'00BAE25A886CC532', KIND=I8B), INT(Z'AAC084D5DF2B9D7F', KIND=I8B), INT(Z'D5306DA390B5DDBE', KIND=I8B), INT(Z'1A4714F6BC521D16', KIND=I8B), INT(Z'2DA8B27ADE6D68DA', KIND=I8B), INT(Z'4BB701B3132A032B', KIND=I8B), INT(Z'D95CF8738B82AFA0', KIND=I8B), INT(Z'DB2EA6A7A8E49E3C', KIND=I8B), INT(Z'151F22907EC8BCBD', KIND=I8B), INT(Z'8F0B721F9065BE13', KIND=I8B), INT(Z'DD9E6EFD0969F740', KIND=I8B), INT(Z'3A24849862F07EBF', KIND=I8B), INT(Z'B49E54F0256A1BE0', KIND=I8B), INT(Z'BB9EA0FAD10358FE', KIND=I8B), INT(Z'E1F53A1BE3CDE207', KIND=I8B), INT(Z'A1806409F8521533', KIND=I8B), INT(Z'6F53FE5D3EA6702D', KIND=I8B), INT(Z'AD6A4818B4F04B25', KIND=I8B), INT(Z'E661C4B9863C013B', KIND=I8B), INT(Z'E76EE55162932FEB', KIND=I8B), INT(Z'025409857EA88B50', KIND=I8B), INT(Z'745B736C0E0205A3', KIND=I8B), INT(Z'EAE47BD738AEBC94', KIND=I8B), INT(Z'2F5BEFDF9355F1DD', KIND=I8B), INT(Z'0F89E3CD2D596A50', KIND=I8B), INT(Z'C08F832678E89903', KIND=I8B), INT(Z'EF7DCE989D622102', KIND=I8B), INT(Z'9D0EFCD7B695D7A2', KIND=I8B), INT(Z'5AC7C7E22FEBBF6B', KIND=I8B), INT(Z'E36D0C8C2768EED3', KIND=I8B), INT(Z'F42E2E4E633E8D41', KIND=I8B), INT(Z'3FE72686E60A41A0', KIND=I8B), INT(Z'F296A8198AA40FB8', KIND=I8B), INT(Z'235532B08487FE6A', KIND=I8B), INT(Z'F8F60E812DE0CD7D', KIND=I8B), INT(Z'3416E09C76D3C065', KIND=I8B), INT(Z'F29262D9A2BCBE28', KIND=I8B), INT(Z'435857D1D2216CB0', KIND=I8B), INT(Z'FDD5E4FCB44C605C', KIND=I8B), INT(Z'292D213B72C4176E', KIND=I8B), INT(Z'A0B0E1D947665B46', KIND=I8B), INT(Z'4BB64866F22E6EC9', KIND=I8B), INT(Z'816714ED8BACF15A', KIND=I8B), INT(Z'FB1F407E06A544D4', KIND=I8B), INT(Z'9EBD860F071DB94D', KIND=I8B), INT(Z'35B0D7E6CDFF33AF', KIND=I8B), INT(Z'83EFABC8387C7E32', KIND=I8B), INT(Z'9FE0614A0AFB6D60', KIND=I8B), INT(Z'324658E593E74E2E', KIND=I8B), INT(Z'0A1F981D74D2D6E5', KIND=I8B), INT(Z'8684F57B4EB15085', KIND=I8B), INT(Z'85D73FFB60E28C47', KIND=I8B), INT(Z'0A3A9F2C0ACF71A2', KIND=I8B), INT(Z'BE311C083A225CD2', KIND=I8B), INT(Z'892731AC9FAF056E', KIND=I8B), INT(Z'0051727975F71E76', KIND=I8B), INT(Z'6853926E2EDA2D0C', KIND=I8B), INT(Z'E0C8BB2C5C6D24E0', KIND=I8B), INT(Z'8BD6A141006042BD', KIND=I8B), INT(Z'D54D9E55435C2CF5', KIND=I8B), INT(Z'41B0230E1421487D', KIND=I8B), INT(Z'547EB47B7282EE9C', KIND=I8B), INT(Z'8E938662882AF53E', KIND=I8B), INT(Z'FE80EA9C004B0589', KIND=I8B), INT(Z'F24512F07CC4EF84', KIND=I8B), INT(Z'0ACE1474DC1D122E', KIND=I8B), INT(Z'915E2486EF32CD60', KIND=I8B), INT(Z'737477AEDBD3605F', KIND=I8B), INT(Z'6610F6D247AB80DF', KIND=I8B), INT(Z'F9A0B6720AAF6521', KIND=I8B), INT(Z'9436C0760C86E30B', KIND=I8B), INT(Z'A48737A51A997A94', KIND=I8B), INT(Z'467EECD14C5EA8EE', KIND=I8B), INT(Z'D3F6FC16EBCA5E03', KIND=I8B), INT(Z'971DA05074DA7BEE', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'0000000000000000', KIND=I8B), INT(Z'3C7F400000000000', KIND=I8B), INT(Z'9A130B963A6C115C', KIND=I8B), INT(Z'E0A9D00000000000', KIND=I8B), INT(Z'6FF006B0F858134F', KIND=I8B), INT(Z'62EB0D64283F9C76', KIND=I8B), INT(Z'9D174B2DCEC0E47B', KIND=I8B), INT(Z'3D425AED07E6CE06', KIND=I8B), INT(Z'54702DD23D2A72F9', KIND=I8B), INT(Z'F2DB9BAA10B7BD6C', KIND=I8B), INT(Z'A02AA96B06DEB0FD', KIND=I8B), INT(Z'A33B45B3F4DC0E48', KIND=I8B), INT(Z'1D1D31810D054722', KIND=I8B), INT(Z'27F002D7F95D0190', KIND=I8B), INT(Z'A34D721642B06084', KIND=I8B), INT(Z'6E613C34EB02BCDB', KIND=I8B), INT(Z'37FF96F2C26FA7B1', KIND=I8B), INT(Z'8A892ABAF368F137', KIND=I8B), INT(Z'A67FF273B8460356', KIND=I8B), INT(Z'28C4D51D411E2270', KIND=I8B), INT(Z'FD354C7ECA1400E3', KIND=I8B), INT(Z'B2EB3875504DDB22', KIND=I8B), INT(Z'A9C2794AE3A3C69A', KIND=I8B), INT(Z'96E71C63FA8E0C8A', KIND=I8B), INT(Z'89148BECA64785D5', KIND=I8B), INT(Z'7D3950E1849329B6', KIND=I8B), INT(Z'AD1556EE1BD724F1', KIND=I8B), INT(Z'BFE07D41E3BFDE1F', KIND=I8B), INT(Z'FC0EB21CDCF588B1', KIND=I8B), INT(Z'0B4AB6F05722C440', KIND=I8B), INT(Z'B078DD424E0D24D9', KIND=I8B), INT(Z'8599DEC62AA45CF8', KIND=I8B), INT(Z'8A035DC1859025A2', KIND=I8B), INT(Z'2F005235946EC71B', KIND=I8B), INT(Z'B3ED5FC6DF682094', KIND=I8B), INT(Z'BF2F5AB5C6B1798A', KIND=I8B), INT(Z'BA6222B3BC8CA210', KIND=I8B), INT(Z'81172E3256403718', KIND=I8B), INT(Z'B773339DB6574E15', KIND=I8B), INT(Z'2DCB54067B49ABE5', KIND=I8B), INT(Z'A27D1FB9913E8C63', KIND=I8B), INT(Z'61BAD659DC1A29D3', KIND=I8B), INT(Z'BB0AAF936C360ADA', KIND=I8B), INT(Z'CF82C283D2AE6243', KIND=I8B), INT(Z'E0D2875E2C6F8C2B', KIND=I8B), INT(Z'1A28B472837D513E', KIND=I8B), INT(Z'BEB42C27A7FCD01F', KIND=I8B), INT(Z'EEDB8F15666F0AB2', KIND=I8B), INT(Z'EC54289350C6DDC0', KIND=I8B), INT(Z'D7FB345A83BBDB9F', KIND=I8B), INT(Z'C2700395A2D1A7C0', KIND=I8B), INT(Z'1B58F1A7E9575563', KIND=I8B), INT(Z'0A4791958ACF329D', KIND=I8B), INT(Z'A869D6ED6B1F7250', KIND=I8B), INT(Z'C63E91DCD74A01DD', KIND=I8B), INT(Z'473C3C084839D2C5', KIND=I8B), INT(Z'89B7E501E1B9B7A1', KIND=I8B), INT(Z'4155C21BA0854403', KIND=I8B), INT(Z'CA2034C9DC33E731', KIND=I8B), INT(Z'8506F998BB1EB395', KIND=I8B), INT(Z'2BF7DBDF81EBC672', KIND=I8B), INT(Z'86747C247C393509', KIND=I8B), INT(Z'CE154BFF6BC0B4B4', KIND=I8B), INT(Z'74A8362631F48271', KIND=I8B), INT(Z'4EC8888FE2907901', KIND=I8B), INT(Z'8CE74D4BBF82DD1E', KIND=I8B), INT(Z'D21E38FF97EFD28C', KIND=I8B), INT(Z'29E17220796141E6', KIND=I8B), INT(Z'C7303E79A90E62EC', KIND=I8B), INT(Z'A706E68F2F6D3D6F', KIND=I8B), INT(Z'D63B5F352D1C3345', KIND=I8B), INT(Z'DFC0B324CB257560', KIND=I8B), INT(Z'62CFFDAF0A5A9271', KIND=I8B), INT(Z'0CA211F8F5C4287E', KIND=I8B), INT(Z'DA6D23FD4393D91B', KIND=I8B), INT(Z'C23187222CEE0355', KIND=I8B), INT(Z'BD79F8EA904D59AF', KIND=I8B), INT(Z'6AC121136186B8C7', KIND=I8B), INT(Z'DEB3EEB101252611', KIND=I8B), INT(Z'39A7C75E6BAF4D71', KIND=I8B), INT(Z'3BD6C04D190F6CCC', KIND=I8B), INT(Z'96F041C58BD75F4F', KIND=I8B), INT(Z'E31028AF8B925961', KIND=I8B), INT(Z'1A13F35115B27490', KIND=I8B), INT(Z'96F5BBA516A81310', KIND=I8B), INT(Z'8A03282E68988712', KIND=I8B), INT(Z'E7823D682CE0518A', KIND=I8B), INT(Z'FBA1D8FACB6A5D0E', KIND=I8B), INT(Z'D0493A8928D434E5', KIND=I8B), INT(Z'9C29EA61E8321EFB', KIND=I8B), INT(Z'EC0A9A64AA7A76D2', KIND=I8B), INT(Z'393C093F92D4EC25', KIND=I8B), INT(Z'D1AFD23AE4C0BFD3', KIND=I8B), INT(Z'FC3B2DEF8A1294AA', KIND=I8B), INT(Z'F0A9AF53D02A967D', KIND=I8B), INT(Z'42973FDA4BED6825', KIND=I8B), INT(Z'1BC70FEBA6B21D1E', KIND=I8B), INT(Z'131A24A373AC0A2D', KIND=I8B), INT(Z'F55FEE142FE87404', KIND=I8B), INT(Z'917E0B421F5DC9D4', KIND=I8B), INT(Z'E78D564BAC9ED016', KIND=I8B), INT(Z'DB1E788C843F1A75', KIND=I8B), INT(Z'FA2DCABF1789EB91', KIND=I8B), INT(Z'98D69827B2CD2E4B', KIND=I8B), INT(Z'BE68BAD520283CE7', KIND=I8B), INT(Z'7B74B18337DAE16E', KIND=I8B), INT(Z'FF13BBB3BD61B0A9', KIND=I8B), INT(Z'72CDF11806D10874', KIND=I8B), INT(Z'422D9DD5C498DF39', KIND=I8B), INT(Z'BADF34926ADBC6D4', KIND=I8B), INT(Z'82091CD1526FFE97', KIND=I8B), INT(Z'0B0A917F718555B1', KIND=I8B), INT(Z'20CD5A8AF8F923C8', KIND=I8B), INT(Z'D73157C19629C9CF', KIND=I8B), INT(Z'8494DFCC9E26F49A', KIND=I8B), INT(Z'E404064CED8D712A', KIND=I8B), INT(Z'385560121DC226CA', KIND=I8B), INT(Z'B04529F4C782E2A5', KIND=I8B), INT(Z'872D6586DA60D16C', KIND=I8B), INT(Z'B230972E25E77689', KIND=I8B), INT(Z'ECF3E4AC4EFF0A32', KIND=I8B), INT(Z'08FB1467A500014A', KIND=I8B), INT(Z'89D2EDF58AB7AC0D', KIND=I8B), INT(Z'410060FD92FCB3CF', KIND=I8B), INT(Z'004C30B113A8F305', KIND=I8B), INT(Z'75DF971F5AA72411', KIND=I8B), INT(Z'8C85BA4EC5C02D9B', KIND=I8B), INT(Z'413353AE3A7B5BDD', KIND=I8B), INT(Z'A7F3672E7145AF76', KIND=I8B), INT(Z'215BEACF912AD3C4', KIND=I8B), INT(Z'8F460D0F7BCFEEB5', KIND=I8B), INT(Z'A4BF00F4785A889D', KIND=I8B), INT(Z'F557B93FB3F0A137', KIND=I8B), INT(Z'0EA153782222DC1D', KIND=I8B), INT(Z'92142A01DD39462C', KIND=I8B), INT(Z'6D693C62A0526BC1', KIND=I8B), INT(Z'7B5F0832AD97744D', KIND=I8B), INT(Z'3E905F5CA347E976', KIND=I8B), INT(Z'94F05643E09A3663', KIND=I8B), INT(Z'64A2130914A11E5F', KIND=I8B), INT(Z'9CC376D8ED0C9850', KIND=I8B), INT(Z'2BCAFF0DB53F45D1', KIND=I8B), INT(Z'97DAD84DE9DF3CE9', KIND=I8B), INT(Z'9A4ACD156C4DBCCC', KIND=I8B), INT(Z'7BB46E2D845BB13B', KIND=I8B), INT(Z'4B6159D95D6B2D7C', KIND=I8B), INT(Z'9AD3F7F9929DEDB1', KIND=I8B), INT(Z'D591674EB18C527B', KIND=I8B), INT(Z'DA23168537779930', KIND=I8B), INT(Z'2C1B00ACF3524228', KIND=I8B), INT(Z'9DDBFE88946E78DB', KIND=I8B), INT(Z'6D3B2E1019201985', KIND=I8B), INT(Z'2440AF6D98524E33', KIND=I8B), INT(Z'81F5EA317433BEF4', KIND=I8B), INT(Z'A0F336ABD5EE7F99', KIND=I8B), INT(Z'93A10F44A80F33C8', KIND=I8B), INT(Z'337D80E31DB6AEF3', KIND=I8B), INT(Z'851BC9AD231A80BE', KIND=I8B), INT(Z'A419EC8A9B1AF2D5', KIND=I8B), INT(Z'19AF0317E895460A', KIND=I8B), INT(Z'AB0913F37BFD99DF', KIND=I8B), INT(Z'BE64B501269FB5C4', KIND=I8B), INT(Z'A7506DC9D9B21CED', KIND=I8B), INT(Z'C375DA4FC0194001', KIND=I8B), INT(Z'3B265316E40B3772', KIND=I8B), INT(Z'76A3718B5911A726', KIND=I8B), INT(Z'AA970993B2526FBE', KIND=I8B), INT(Z'C504151E575A9779', KIND=I8B), INT(Z'8716A6AC9483E77D', KIND=I8B), INT(Z'F49CD30202D41350', KIND=I8B), INT(Z'ADEE109F0F0E3952', KIND=I8B), INT(Z'3068E95C665AA02B', KIND=I8B), INT(Z'87D5E085A65C15DB', KIND=I8B), INT(Z'A72B6697C1695603', KIND=I8B), INT(Z'B155D537682FFC88', KIND=I8B), INT(Z'11213ACC4D36CF9A', KIND=I8B), INT(Z'3B903AE48F4FC93B', KIND=I8B), INT(Z'19D343DF2EC654F8', KIND=I8B), INT(Z'B4CEAB44AFEED7E9', KIND=I8B), INT(Z'DAA1581870D5B72C', KIND=I8B), INT(Z'CC83B1E48401CF12', KIND=I8B), INT(Z'B3511A96BEC03C53', KIND=I8B), INT(Z'B858E85365D62467', KIND=I8B), INT(Z'91C8BC100512A9B9', KIND=I8B), INT(Z'87802DD9987F5811', KIND=I8B), INT(Z'16CE86A4BA01377B', KIND=I8B), INT(Z'BBF4E39CD2A747E1', KIND=I8B), INT(Z'3AF95CBF0946009E', KIND=I8B), INT(Z'9EA3266A1AAD74B9', KIND=I8B), INT(Z'B783F4FCC19195F0', KIND=I8B), INT(Z'BFA2F60F6D809C91', KIND=I8B), INT(Z'A010925E4C6122FF', KIND=I8B), INT(Z'7AC8EB131770B5DA', KIND=I8B), INT(Z'C1B9DE62331F1C84', KIND=I8B), INT(Z'C3637A576B184797', KIND=I8B), INT(Z'141471DAE08D526A', KIND=I8B), INT(Z'60DC6A4185C03AE1', KIND=I8B), INT(Z'CA7D3CCD0F578270', KIND=I8B), INT(Z'C736CCE777DDE55B', KIND=I8B), INT(Z'BEB13E2E44A792AF', KIND=I8B), INT(Z'8F9D3DE52E498711', KIND=I8B), INT(Z'8AB05967FF2004E2', KIND=I8B), INT(Z'CB1D4C019DDA13CF', KIND=I8B), INT(Z'E4187B58FD28A94D', KIND=I8B), INT(Z'CEAFE789CDF47A1B', KIND=I8B), INT(Z'004B98F7D57FE9A3', KIND=I8B), INT(Z'CF1757C057271838', KIND=I8B), INT(Z'5D99BED0BF71C4FE', KIND=I8B), INT(Z'B74893236B751658', KIND=I8B), INT(Z'657697F11447157E', KIND=I8B), INT(Z'D325521FCDE22918', KIND=I8B), INT(Z'68D72BEC56D281BA', KIND=I8B), INT(Z'E389A8795D86FEF4', KIND=I8B), INT(Z'44641E2A07D9BD48', KIND=I8B), INT(Z'D7479F074A794537', KIND=I8B), INT(Z'18A8B9AC109F18C1', KIND=I8B), INT(Z'36D950769B40F3FD', KIND=I8B), INT(Z'5E6B2C1F8B606532', KIND=I8B), INT(Z'DB7EA452D13DF70A', KIND=I8B), INT(Z'A9B5D49B906C498A', KIND=I8B), INT(Z'8ED3101419CB3227', KIND=I8B), INT(Z'17122D6F7054A794', KIND=I8B), INT(Z'DFCAC9DCF029F087', KIND=I8B), INT(Z'EFB85F52D1C112FE', KIND=I8B), INT(Z'98F8941008B79677', KIND=I8B), INT(Z'B2175EE88BE4A8F9', KIND=I8B), INT(Z'E42C7988BDC70ED3', KIND=I8B), INT(Z'2E5A66D4570F98B0', KIND=I8B), INT(Z'430B34D10EB0ECF4', KIND=I8B), INT(Z'413F8C185698DD07', KIND=I8B), INT(Z'E8A41F4C0A311014', KIND=I8B), INT(Z'CC0F55EA864DD7F5', KIND=I8B), INT(Z'456509D69D08D96C', KIND=I8B), INT(Z'240421CC6ACC3893', KIND=I8B), INT(Z'ED322939C32C1801', KIND=I8B), INT(Z'0ABFF31D3CEC5E4F', KIND=I8B), INT(Z'1E0D12F1BBDE0514', KIND=I8B), INT(Z'48590390281493F6', KIND=I8B), INT(Z'F1D7078C8C500A93', KIND=I8B), INT(Z'A3503F8C8AC1EB3A', KIND=I8B), INT(Z'A096E22CEC16E455', KIND=I8B), INT(Z'1473102F0414AD2C', KIND=I8B), INT(Z'F6932CB18C4DC755', KIND=I8B), INT(Z'5281D93D02664652', KIND=I8B), INT(Z'85CE35CB6C04C918', KIND=I8B), INT(Z'88A7B9666E181071', KIND=I8B), INT(Z'FB670D5370586C49', KIND=I8B), INT(Z'D541AC1F3C506316', KIND=I8B), INT(Z'4F14396264F2916E', KIND=I8B), INT(Z'D61515C3B3AAA229', KIND=I8B), INT(Z'80299032D360FEAD', KIND=I8B), INT(Z'7946464C91702D77', KIND=I8B), INT(Z'59012A5F505E728C', KIND=I8B), INT(Z'8E5FB9B92F0514A8', KIND=I8B), INT(Z'82ABEF97E8F00EB3', KIND=I8B), INT(Z'D5021D4C84E67979', KIND=I8B), INT(Z'494EBE658276DB57', KIND=I8B), INT(Z'449B9FE2AC34E8BD', KIND=I8B), INT(Z'853AE2ACBA297855', KIND=I8B), INT(Z'79A5E56484591846', KIND=I8B), INT(Z'965C9079F7DC4B25', KIND=I8B), INT(Z'B8B22E9DBD871702', KIND=I8B), INT(Z'87D6A87AEBE6E32D', KIND=I8B), INT(Z'E90E1D9A61AB958B', KIND=I8B), INT(Z'AB34E1EF0F78BCC8', KIND=I8B), INT(Z'E926B14801CA9B38', KIND=I8B), INT(Z'8A7F814817C36453', KIND=I8B), INT(Z'6B08E5E200510F62', KIND=I8B), INT(Z'34279133827C7DC8', KIND=I8B), INT(Z'95238D2B41523B5D', KIND=I8B), INT(Z'8D35AE9BFBBC5820', KIND=I8B), INT(Z'18D892A5C744F415', KIND=I8B), INT(Z'A40CAD1FA3FDA9C5', KIND=I8B), INT(Z'FAFD9FEFC5B84A78', KIND=I8B), INT(Z'8FF97346C8D3A990', KIND=I8B), INT(Z'85B5AD3AFA998F3A', KIND=I8B), INT(Z'B0E097EEB6CEA81E', KIND=I8B), INT(Z'D4B88CB6422B9BE0', KIND=I8B), INT(Z'92CB1367914EEF15', KIND=I8B), INT(Z'7AF50AE289EB0B9E', KIND=I8B), INT(Z'3241430E3B081CB2', KIND=I8B), INT(Z'232E116F38AC1680', KIND=I8B), INT(Z'95AAD472D731CF89', KIND=I8B), INT(Z'266A57B55352EA2A', KIND=I8B), INT(Z'7E988AFB1F791E14', KIND=I8B), INT(Z'FDD82EF0BEAEB5BC', KIND=I8B), INT(Z'9898FD393B953C30', KIND=I8B), INT(Z'555464B4F76B344B', KIND=I8B), INT(Z'3666AF1CB2F0356B', KIND=I8B), INT(Z'C8DD55687A68BB70', KIND=I8B), INT(Z'9B95D5EE4F80366D', KIND=I8B), INT(Z'B19E3D897426AC0E', KIND=I8B), INT(Z'3967066B4C3B300B', KIND=I8B), INT(Z'D3F876B1CC8650E1', KIND=I8B), INT(Z'9EA1A82F86EA1144', KIND=I8B), INT(Z'993C1ECD6C0A7050', KIND=I8B), INT(Z'58EC01B8360275DC', KIND=I8B), INT(Z'F0E4E5DDF50D5649', KIND=I8B), INT(Z'A1BCBF0B4E9168B4', KIND=I8B), INT(Z'DC2AF1C2CA957B28', KIND=I8B), INT(Z'7E79FE958F3081F2', KIND=I8B), INT(Z'0B13A89E71F04607', KIND=I8B), INT(Z'A4E76708455662FA', KIND=I8B), INT(Z'F35E6D39041D980A', KIND=I8B), INT(Z'1C3B4799BB16146C', KIND=I8B), INT(Z'CEAA3A0DF738FF67', KIND=I8B), INT(Z'A821EE2C99CA3AE9', KIND=I8B), INT(Z'EA17B9D4D87BC7A6', KIND=I8B), INT(Z'A6E6122F56F94A45', KIND=I8B), INT(Z'323264FA08A6A297', KIND=I8B), INT(Z'AB6CA4058CA98EBA', KIND=I8B), INT(Z'C53D1851C3B12E0B', KIND=I8B), INT(Z'009DEACABC65F455', KIND=I8B), INT(Z'1B276317CDEA9189', KIND=I8B), INT(Z'AEC7D9AF18FA7C21', KIND=I8B), INT(Z'02C9923A00FBF051', KIND=I8B), INT(Z'B64EB80E63EC3A6C', KIND=I8B), INT(Z'E640102E40AF6BFC', KIND=I8B), INT(Z'B233E1DBC28B3229', KIND=I8B), INT(Z'323B2FE8DB975585', KIND=I8B), INT(Z'547A6847BF6D2E85', KIND=I8B), INT(Z'9C5AC5E3502E3B09', KIND=I8B), INT(Z'B5B110DC8B9152B3', KIND=I8B), INT(Z'A045490080841594', KIND=I8B), INT(Z'D5DC095935E521CF', KIND=I8B), INT(Z'0F0E9F521B9270FB', KIND=I8B), INT(Z'B93FBCA9122E41A4', KIND=I8B), INT(Z'8F55910806D59BAF', KIND=I8B), INT(Z'6E5242257641D880', KIND=I8B), INT(Z'C71261CB384C6321', KIND=I8B), INT(Z'BCE03CE7D6A056D5', KIND=I8B), INT(Z'763A723DF9686922', KIND=I8B), INT(Z'CC3C376FF5DEB4B3', KIND=I8B), INT(Z'36EE15C1030A006C', KIND=I8B), INT(Z'C092EAF6AAECD1FF', KIND=I8B), INT(Z'12CAD6DE3D40F431', KIND=I8B), INT(Z'B64F1457442E6578', KIND=I8B), INT(Z'7C07A28F8AD104CF', KIND=I8B), INT(Z'C45821F34CD26DA9', KIND=I8B), INT(Z'C45BD180F52795FD', KIND=I8B), INT(Z'4E1C7E58586D7EEB', KIND=I8B), INT(Z'78C6A18DA2580215', KIND=I8B), INT(Z'C8303EC42AD88026', KIND=I8B), INT(Z'077D5A3C610B9F25', KIND=I8B), INT(Z'987D13FEC0991258', KIND=I8B), INT(Z'82F57D31A71C1D89', KIND=I8B), INT(Z'CC1BA0215552BFB5', KIND=I8B), INT(Z'28EB73FA309BAEFB', KIND=I8B), INT(Z'C619DB404F575681', KIND=I8B), INT(Z'7EF53A6634A89048', KIND=I8B), INT(Z'D01AA69D9C35FA11', KIND=I8B), INT(Z'218EFB2874B19ADF', KIND=I8B), INT(Z'C02D55F188327C0D', KIND=I8B), INT(Z'48868DA790C354D1', KIND=I8B), INT(Z'D42DB4AFDA9E5FE3', KIND=I8B), INT(Z'F40AEB9752B3AA0B', KIND=I8B), INT(Z'B290C89B8CA89F01', KIND=I8B), INT(Z'050846AE4FECC8BB', KIND=I8B), INT(Z'D8552EBC70EC6A72', KIND=I8B)], [4, 180]) This table contains the 256-bit mantissa (or significand) approximations of the\n  powers of 10 from -5005 to 5019 that can cover the entire exponent ranges of all\n  three (quadruple-, double- and single-precision) floating point numbers. The 256-bit approximations are stored in each row of the array and they are stored\n  in a little-endian order (i.e. the (first) element 0 of each row represents the\n  least significant byte and the (fourth) element 3 is the most significand one). Important Note :  the 256-bit approximations are stored in a compressed form;\ntherefore, this table must be used in conjunction with the 'Pow5_128_Table'\nlisted above to compute the actual approximation for the required exponent. character(len=1), public, parameter :: Char1Digit (0:9) = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] table of digit characters with 1-digit entries character(len=2), public, parameter :: Char2Digits (0:99) = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99'] table of digit characters with 2-digit entries character(len=4), public, parameter :: Char4Digits (0:9999) = ['0000', '0001', '0002', '0003', '0004', '0005', '0006', '0007', '0008', '0009', '0010', '0011', '0012', '0013', '0014', '0015', '0016', '0017', '0018', '0019', '0020', '0021', '0022', '0023', '0024', '0025', '0026', '0027', '0028', '0029', '0030', '0031', '0032', '0033', '0034', '0035', '0036', '0037', '0038', '0039', '0040', '0041', '0042', '0043', '0044', '0045', '0046', '0047', '0048', '0049', '0050', '0051', '0052', '0053', '0054', '0055', '0056', '0057', '0058', '0059', '0060', '0061', '0062', '0063', '0064', '0065', '0066', '0067', '0068', '0069', '0070', '0071', '0072', '0073', '0074', '0075', '0076', '0077', '0078', '0079', '0080', '0081', '0082', '0083', '0084', '0085', '0086', '0087', '0088', '0089', '0090', '0091', '0092', '0093', '0094', '0095', '0096', '0097', '0098', '0099', '0100', '0101', '0102', '0103', '0104', '0105', '0106', '0107', '0108', '0109', '0110', '0111', '0112', '0113', '0114', '0115', '0116', '0117', '0118', '0119', '0120', '0121', '0122', '0123', '0124', '0125', '0126', '0127', '0128', '0129', '0130', '0131', '0132', '0133', '0134', '0135', '0136', '0137', '0138', '0139', '0140', '0141', '0142', '0143', '0144', '0145', '0146', '0147', '0148', '0149', '0150', '0151', '0152', '0153', '0154', '0155', '0156', '0157', '0158', '0159', '0160', '0161', '0162', '0163', '0164', '0165', '0166', '0167', '0168', '0169', '0170', '0171', '0172', '0173', '0174', '0175', '0176', '0177', '0178', '0179', '0180', '0181', '0182', '0183', '0184', '0185', '0186', '0187', '0188', '0189', '0190', '0191', '0192', '0193', '0194', '0195', '0196', '0197', '0198', '0199', '0200', '0201', '0202', '0203', '0204', '0205', '0206', '0207', '0208', '0209', '0210', '0211', '0212', '0213', '0214', '0215', '0216', '0217', '0218', '0219', '0220', '0221', '0222', '0223', '0224', '0225', '0226', '0227', '0228', '0229', '0230', '0231', '0232', '0233', '0234', '0235', '0236', '0237', '0238', '0239', '0240', '0241', '0242', '0243', '0244', '0245', '0246', '0247', '0248', '0249', '0250', '0251', '0252', '0253', '0254', '0255', '0256', '0257', '0258', '0259', '0260', '0261', '0262', '0263', '0264', '0265', '0266', '0267', '0268', '0269', '0270', '0271', '0272', '0273', '0274', '0275', '0276', '0277', '0278', '0279', '0280', '0281', '0282', '0283', '0284', '0285', '0286', '0287', '0288', '0289', '0290', '0291', '0292', '0293', '0294', '0295', '0296', '0297', '0298', '0299', '0300', '0301', '0302', '0303', '0304', '0305', '0306', '0307', '0308', '0309', '0310', '0311', '0312', '0313', '0314', '0315', '0316', '0317', '0318', '0319', '0320', '0321', '0322', '0323', '0324', '0325', '0326', '0327', '0328', '0329', '0330', '0331', '0332', '0333', '0334', '0335', '0336', '0337', '0338', '0339', '0340', '0341', '0342', '0343', '0344', '0345', '0346', '0347', '0348', '0349', '0350', '0351', '0352', '0353', '0354', '0355', '0356', '0357', '0358', '0359', '0360', '0361', '0362', '0363', '0364', '0365', '0366', '0367', '0368', '0369', '0370', '0371', '0372', '0373', '0374', '0375', '0376', '0377', '0378', '0379', '0380', '0381', '0382', '0383', '0384', '0385', '0386', '0387', '0388', '0389', '0390', '0391', '0392', '0393', '0394', '0395', '0396', '0397', '0398', '0399', '0400', '0401', '0402', '0403', '0404', '0405', '0406', '0407', '0408', '0409', '0410', '0411', '0412', '0413', '0414', '0415', '0416', '0417', '0418', '0419', '0420', '0421', '0422', '0423', '0424', '0425', '0426', '0427', '0428', '0429', '0430', '0431', '0432', '0433', '0434', '0435', '0436', '0437', '0438', '0439', '0440', '0441', '0442', '0443', '0444', '0445', '0446', '0447', '0448', '0449', '0450', '0451', '0452', '0453', '0454', '0455', '0456', '0457', '0458', '0459', '0460', '0461', '0462', '0463', '0464', '0465', '0466', '0467', '0468', '0469', '0470', '0471', '0472', '0473', '0474', '0475', '0476', '0477', '0478', '0479', '0480', '0481', '0482', '0483', '0484', '0485', '0486', '0487', '0488', '0489', '0490', '0491', '0492', '0493', '0494', '0495', '0496', '0497', '0498', '0499', '0500', '0501', '0502', '0503', '0504', '0505', '0506', '0507', '0508', '0509', '0510', '0511', '0512', '0513', '0514', '0515', '0516', '0517', '0518', '0519', '0520', '0521', '0522', '0523', '0524', '0525', '0526', '0527', '0528', '0529', '0530', '0531', '0532', '0533', '0534', '0535', '0536', '0537', '0538', '0539', '0540', '0541', '0542', '0543', '0544', '0545', '0546', '0547', '0548', '0549', '0550', '0551', '0552', '0553', '0554', '0555', '0556', '0557', '0558', '0559', '0560', '0561', '0562', '0563', '0564', '0565', '0566', '0567', '0568', '0569', '0570', '0571', '0572', '0573', '0574', '0575', '0576', '0577', '0578', '0579', '0580', '0581', '0582', '0583', '0584', '0585', '0586', '0587', '0588', '0589', '0590', '0591', '0592', '0593', '0594', '0595', '0596', '0597', '0598', '0599', '0600', '0601', '0602', '0603', '0604', '0605', '0606', '0607', '0608', '0609', '0610', '0611', '0612', '0613', '0614', '0615', '0616', '0617', '0618', '0619', '0620', '0621', '0622', '0623', '0624', '0625', '0626', '0627', '0628', '0629', '0630', '0631', '0632', '0633', '0634', '0635', '0636', '0637', '0638', '0639', '0640', '0641', '0642', '0643', '0644', '0645', '0646', '0647', '0648', '0649', '0650', '0651', '0652', '0653', '0654', '0655', '0656', '0657', '0658', '0659', '0660', '0661', '0662', '0663', '0664', '0665', '0666', '0667', '0668', '0669', '0670', '0671', '0672', '0673', '0674', '0675', '0676', '0677', '0678', '0679', '0680', '0681', '0682', '0683', '0684', '0685', '0686', '0687', '0688', '0689', '0690', '0691', '0692', '0693', '0694', '0695', '0696', '0697', '0698', '0699', '0700', '0701', '0702', '0703', '0704', '0705', '0706', '0707', '0708', '0709', '0710', '0711', '0712', '0713', '0714', '0715', '0716', '0717', '0718', '0719', '0720', '0721', '0722', '0723', '0724', '0725', '0726', '0727', '0728', '0729', '0730', '0731', '0732', '0733', '0734', '0735', '0736', '0737', '0738', '0739', '0740', '0741', '0742', '0743', '0744', '0745', '0746', '0747', '0748', '0749', '0750', '0751', '0752', '0753', '0754', '0755', '0756', '0757', '0758', '0759', '0760', '0761', '0762', '0763', '0764', '0765', '0766', '0767', '0768', '0769', '0770', '0771', '0772', '0773', '0774', '0775', '0776', '0777', '0778', '0779', '0780', '0781', '0782', '0783', '0784', '0785', '0786', '0787', '0788', '0789', '0790', '0791', '0792', '0793', '0794', '0795', '0796', '0797', '0798', '0799', '0800', '0801', '0802', '0803', '0804', '0805', '0806', '0807', '0808', '0809', '0810', '0811', '0812', '0813', '0814', '0815', '0816', '0817', '0818', '0819', '0820', '0821', '0822', '0823', '0824', '0825', '0826', '0827', '0828', '0829', '0830', '0831', '0832', '0833', '0834', '0835', '0836', '0837', '0838', '0839', '0840', '0841', '0842', '0843', '0844', '0845', '0846', '0847', '0848', '0849', '0850', '0851', '0852', '0853', '0854', '0855', '0856', '0857', '0858', '0859', '0860', '0861', '0862', '0863', '0864', '0865', '0866', '0867', '0868', '0869', '0870', '0871', '0872', '0873', '0874', '0875', '0876', '0877', '0878', '0879', '0880', '0881', '0882', '0883', '0884', '0885', '0886', '0887', '0888', '0889', '0890', '0891', '0892', '0893', '0894', '0895', '0896', '0897', '0898', '0899', '0900', '0901', '0902', '0903', '0904', '0905', '0906', '0907', '0908', '0909', '0910', '0911', '0912', '0913', '0914', '0915', '0916', '0917', '0918', '0919', '0920', '0921', '0922', '0923', '0924', '0925', '0926', '0927', '0928', '0929', '0930', '0931', '0932', '0933', '0934', '0935', '0936', '0937', '0938', '0939', '0940', '0941', '0942', '0943', '0944', '0945', '0946', '0947', '0948', '0949', '0950', '0951', '0952', '0953', '0954', '0955', '0956', '0957', '0958', '0959', '0960', '0961', '0962', '0963', '0964', '0965', '0966', '0967', '0968', '0969', '0970', '0971', '0972', '0973', '0974', '0975', '0976', '0977', '0978', '0979', '0980', '0981', '0982', '0983', '0984', '0985', '0986', '0987', '0988', '0989', '0990', '0991', '0992', '0993', '0994', '0995', '0996', '0997', '0998', '0999', '1000', '1001', '1002', '1003', '1004', '1005', '1006', '1007', '1008', '1009', '1010', '1011', '1012', '1013', '1014', '1015', '1016', '1017', '1018', '1019', '1020', '1021', '1022', '1023', '1024', '1025', '1026', '1027', '1028', '1029', '1030', '1031', '1032', '1033', '1034', '1035', '1036', '1037', '1038', '1039', '1040', '1041', '1042', '1043', '1044', '1045', '1046', '1047', '1048', '1049', '1050', '1051', '1052', '1053', '1054', '1055', '1056', '1057', '1058', '1059', '1060', '1061', '1062', '1063', '1064', '1065', '1066', '1067', '1068', '1069', '1070', '1071', '1072', '1073', '1074', '1075', '1076', '1077', '1078', '1079', '1080', '1081', '1082', '1083', '1084', '1085', '1086', '1087', '1088', '1089', '1090', '1091', '1092', '1093', '1094', '1095', '1096', '1097', '1098', '1099', '1100', '1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110', '1111', '1112', '1113', '1114', '1115', '1116', '1117', '1118', '1119', '1120', '1121', '1122', '1123', '1124', '1125', '1126', '1127', '1128', '1129', '1130', '1131', '1132', '1133', '1134', '1135', '1136', '1137', '1138', '1139', '1140', '1141', '1142', '1143', '1144', '1145', '1146', '1147', '1148', '1149', '1150', '1151', '1152', '1153', '1154', '1155', '1156', '1157', '1158', '1159', '1160', '1161', '1162', '1163', '1164', '1165', '1166', '1167', '1168', '1169', '1170', '1171', '1172', '1173', '1174', '1175', '1176', '1177', '1178', '1179', '1180', '1181', '1182', '1183', '1184', '1185', '1186', '1187', '1188', '1189', '1190', '1191', '1192', '1193', '1194', '1195', '1196', '1197', '1198', '1199', '1200', '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210', '1211', '1212', '1213', '1214', '1215', '1216', '1217', '1218', '1219', '1220', '1221', '1222', '1223', '1224', '1225', '1226', '1227', '1228', '1229', '1230', '1231', '1232', '1233', '1234', '1235', '1236', '1237', '1238', '1239', '1240', '1241', '1242', '1243', '1244', '1245', '1246', '1247', '1248', '1249', '1250', '1251', '1252', '1253', '1254', '1255', '1256', '1257', '1258', '1259', '1260', '1261', '1262', '1263', '1264', '1265', '1266', '1267', '1268', '1269', '1270', '1271', '1272', '1273', '1274', '1275', '1276', '1277', '1278', '1279', '1280', '1281', '1282', '1283', '1284', '1285', '1286', '1287', '1288', '1289', '1290', '1291', '1292', '1293', '1294', '1295', '1296', '1297', '1298', '1299', '1300', '1301', '1302', '1303', '1304', '1305', '1306', '1307', '1308', '1309', '1310', '1311', '1312', '1313', '1314', '1315', '1316', '1317', '1318', '1319', '1320', '1321', '1322', '1323', '1324', '1325', '1326', '1327', '1328', '1329', '1330', '1331', '1332', '1333', '1334', '1335', '1336', '1337', '1338', '1339', '1340', '1341', '1342', '1343', '1344', '1345', '1346', '1347', '1348', '1349', '1350', '1351', '1352', '1353', '1354', '1355', '1356', '1357', '1358', '1359', '1360', '1361', '1362', '1363', '1364', '1365', '1366', '1367', '1368', '1369', '1370', '1371', '1372', '1373', '1374', '1375', '1376', '1377', '1378', '1379', '1380', '1381', '1382', '1383', '1384', '1385', '1386', '1387', '1388', '1389', '1390', '1391', '1392', '1393', '1394', '1395', '1396', '1397', '1398', '1399', '1400', '1401', '1402', '1403', '1404', '1405', '1406', '1407', '1408', '1409', '1410', '1411', '1412', '1413', '1414', '1415', '1416', '1417', '1418', '1419', '1420', '1421', '1422', '1423', '1424', '1425', '1426', '1427', '1428', '1429', '1430', '1431', '1432', '1433', '1434', '1435', '1436', '1437', '1438', '1439', '1440', '1441', '1442', '1443', '1444', '1445', '1446', '1447', '1448', '1449', '1450', '1451', '1452', '1453', '1454', '1455', '1456', '1457', '1458', '1459', '1460', '1461', '1462', '1463', '1464', '1465', '1466', '1467', '1468', '1469', '1470', '1471', '1472', '1473', '1474', '1475', '1476', '1477', '1478', '1479', '1480', '1481', '1482', '1483', '1484', '1485', '1486', '1487', '1488', '1489', '1490', '1491', '1492', '1493', '1494', '1495', '1496', '1497', '1498', '1499', '1500', '1501', '1502', '1503', '1504', '1505', '1506', '1507', '1508', '1509', '1510', '1511', '1512', '1513', '1514', '1515', '1516', '1517', '1518', '1519', '1520', '1521', '1522', '1523', '1524', '1525', '1526', '1527', '1528', '1529', '1530', '1531', '1532', '1533', '1534', '1535', '1536', '1537', '1538', '1539', '1540', '1541', '1542', '1543', '1544', '1545', '1546', '1547', '1548', '1549', '1550', '1551', '1552', '1553', '1554', '1555', '1556', '1557', '1558', '1559', '1560', '1561', '1562', '1563', '1564', '1565', '1566', '1567', '1568', '1569', '1570', '1571', '1572', '1573', '1574', '1575', '1576', '1577', '1578', '1579', '1580', '1581', '1582', '1583', '1584', '1585', '1586', '1587', '1588', '1589', '1590', '1591', '1592', '1593', '1594', '1595', '1596', '1597', '1598', '1599', '1600', '1601', '1602', '1603', '1604', '1605', '1606', '1607', '1608', '1609', '1610', '1611', '1612', '1613', '1614', '1615', '1616', '1617', '1618', '1619', '1620', '1621', '1622', '1623', '1624', '1625', '1626', '1627', '1628', '1629', '1630', '1631', '1632', '1633', '1634', '1635', '1636', '1637', '1638', '1639', '1640', '1641', '1642', '1643', '1644', '1645', '1646', '1647', '1648', '1649', '1650', '1651', '1652', '1653', '1654', '1655', '1656', '1657', '1658', '1659', '1660', '1661', '1662', '1663', '1664', '1665', '1666', '1667', '1668', '1669', '1670', '1671', '1672', '1673', '1674', '1675', '1676', '1677', '1678', '1679', '1680', '1681', '1682', '1683', '1684', '1685', '1686', '1687', '1688', '1689', '1690', '1691', '1692', '1693', '1694', '1695', '1696', '1697', '1698', '1699', '1700', '1701', '1702', '1703', '1704', '1705', '1706', '1707', '1708', '1709', '1710', '1711', '1712', '1713', '1714', '1715', '1716', '1717', '1718', '1719', '1720', '1721', '1722', '1723', '1724', '1725', '1726', '1727', '1728', '1729', '1730', '1731', '1732', '1733', '1734', '1735', '1736', '1737', '1738', '1739', '1740', '1741', '1742', '1743', '1744', '1745', '1746', '1747', '1748', '1749', '1750', '1751', '1752', '1753', '1754', '1755', '1756', '1757', '1758', '1759', '1760', '1761', '1762', '1763', '1764', '1765', '1766', '1767', '1768', '1769', '1770', '1771', '1772', '1773', '1774', '1775', '1776', '1777', '1778', '1779', '1780', '1781', '1782', '1783', '1784', '1785', '1786', '1787', '1788', '1789', '1790', '1791', '1792', '1793', '1794', '1795', '1796', '1797', '1798', '1799', '1800', '1801', '1802', '1803', '1804', '1805', '1806', '1807', '1808', '1809', '1810', '1811', '1812', '1813', '1814', '1815', '1816', '1817', '1818', '1819', '1820', '1821', '1822', '1823', '1824', '1825', '1826', '1827', '1828', '1829', '1830', '1831', '1832', '1833', '1834', '1835', '1836', '1837', '1838', '1839', '1840', '1841', '1842', '1843', '1844', '1845', '1846', '1847', '1848', '1849', '1850', '1851', '1852', '1853', '1854', '1855', '1856', '1857', '1858', '1859', '1860', '1861', '1862', '1863', '1864', '1865', '1866', '1867', '1868', '1869', '1870', '1871', '1872', '1873', '1874', '1875', '1876', '1877', '1878', '1879', '1880', '1881', '1882', '1883', '1884', '1885', '1886', '1887', '1888', '1889', '1890', '1891', '1892', '1893', '1894', '1895', '1896', '1897', '1898', '1899', '1900', '1901', '1902', '1903', '1904', '1905', '1906', '1907', '1908', '1909', '1910', '1911', '1912', '1913', '1914', '1915', '1916', '1917', '1918', '1919', '1920', '1921', '1922', '1923', '1924', '1925', '1926', '1927', '1928', '1929', '1930', '1931', '1932', '1933', '1934', '1935', '1936', '1937', '1938', '1939', '1940', '1941', '1942', '1943', '1944', '1945', '1946', '1947', '1948', '1949', '1950', '1951', '1952', '1953', '1954', '1955', '1956', '1957', '1958', '1959', '1960', '1961', '1962', '1963', '1964', '1965', '1966', '1967', '1968', '1969', '1970', '1971', '1972', '1973', '1974', '1975', '1976', '1977', '1978', '1979', '1980', '1981', '1982', '1983', '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992', '1993', '1994', '1995', '1996', '1997', '1998', '1999', '2000', '2001', '2002', '2003', '2004', '2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023', '2024', '2025', '2026', '2027', '2028', '2029', '2030', '2031', '2032', '2033', '2034', '2035', '2036', '2037', '2038', '2039', '2040', '2041', '2042', '2043', '2044', '2045', '2046', '2047', '2048', '2049', '2050', '2051', '2052', '2053', '2054', '2055', '2056', '2057', '2058', '2059', '2060', '2061', '2062', '2063', '2064', '2065', '2066', '2067', '2068', '2069', '2070', '2071', '2072', '2073', '2074', '2075', '2076', '2077', '2078', '2079', '2080', '2081', '2082', '2083', '2084', '2085', '2086', '2087', '2088', '2089', '2090', '2091', '2092', '2093', '2094', '2095', '2096', '2097', '2098', '2099', '2100', '2101', '2102', '2103', '2104', '2105', '2106', '2107', '2108', '2109', '2110', '2111', '2112', '2113', '2114', '2115', '2116', '2117', '2118', '2119', '2120', '2121', '2122', '2123', '2124', '2125', '2126', '2127', '2128', '2129', '2130', '2131', '2132', '2133', '2134', '2135', '2136', '2137', '2138', '2139', '2140', '2141', '2142', '2143', '2144', '2145', '2146', '2147', '2148', '2149', '2150', '2151', '2152', '2153', '2154', '2155', '2156', '2157', '2158', '2159', '2160', '2161', '2162', '2163', '2164', '2165', '2166', '2167', '2168', '2169', '2170', '2171', '2172', '2173', '2174', '2175', '2176', '2177', '2178', '2179', '2180', '2181', '2182', '2183', '2184', '2185', '2186', '2187', '2188', '2189', '2190', '2191', '2192', '2193', '2194', '2195', '2196', '2197', '2198', '2199', '2200', '2201', '2202', '2203', '2204', '2205', '2206', '2207', '2208', '2209', '2210', '2211', '2212', '2213', '2214', '2215', '2216', '2217', '2218', '2219', '2220', '2221', '2222', '2223', '2224', '2225', '2226', '2227', '2228', '2229', '2230', '2231', '2232', '2233', '2234', '2235', '2236', '2237', '2238', '2239', '2240', '2241', '2242', '2243', '2244', '2245', '2246', '2247', '2248', '2249', '2250', '2251', '2252', '2253', '2254', '2255', '2256', '2257', '2258', '2259', '2260', '2261', '2262', '2263', '2264', '2265', '2266', '2267', '2268', '2269', '2270', '2271', '2272', '2273', '2274', '2275', '2276', '2277', '2278', '2279', '2280', '2281', '2282', '2283', '2284', '2285', '2286', '2287', '2288', '2289', '2290', '2291', '2292', '2293', '2294', '2295', '2296', '2297', '2298', '2299', '2300', '2301', '2302', '2303', '2304', '2305', '2306', '2307', '2308', '2309', '2310', '2311', '2312', '2313', '2314', '2315', '2316', '2317', '2318', '2319', '2320', '2321', '2322', '2323', '2324', '2325', '2326', '2327', '2328', '2329', '2330', '2331', '2332', '2333', '2334', '2335', '2336', '2337', '2338', '2339', '2340', '2341', '2342', '2343', '2344', '2345', '2346', '2347', '2348', '2349', '2350', '2351', '2352', '2353', '2354', '2355', '2356', '2357', '2358', '2359', '2360', '2361', '2362', '2363', '2364', '2365', '2366', '2367', '2368', '2369', '2370', '2371', '2372', '2373', '2374', '2375', '2376', '2377', '2378', '2379', '2380', '2381', '2382', '2383', '2384', '2385', '2386', '2387', '2388', '2389', '2390', '2391', '2392', '2393', '2394', '2395', '2396', '2397', '2398', '2399', '2400', '2401', '2402', '2403', '2404', '2405', '2406', '2407', '2408', '2409', '2410', '2411', '2412', '2413', '2414', '2415', '2416', '2417', '2418', '2419', '2420', '2421', '2422', '2423', '2424', '2425', '2426', '2427', '2428', '2429', '2430', '2431', '2432', '2433', '2434', '2435', '2436', '2437', '2438', '2439', '2440', '2441', '2442', '2443', '2444', '2445', '2446', '2447', '2448', '2449', '2450', '2451', '2452', '2453', '2454', '2455', '2456', '2457', '2458', '2459', '2460', '2461', '2462', '2463', '2464', '2465', '2466', '2467', '2468', '2469', '2470', '2471', '2472', '2473', '2474', '2475', '2476', '2477', '2478', '2479', '2480', '2481', '2482', '2483', '2484', '2485', '2486', '2487', '2488', '2489', '2490', '2491', '2492', '2493', '2494', '2495', '2496', '2497', '2498', '2499', '2500', '2501', '2502', '2503', '2504', '2505', '2506', '2507', '2508', '2509', '2510', '2511', '2512', '2513', '2514', '2515', '2516', '2517', '2518', '2519', '2520', '2521', '2522', '2523', '2524', '2525', '2526', '2527', '2528', '2529', '2530', '2531', '2532', '2533', '2534', '2535', '2536', '2537', '2538', '2539', '2540', '2541', '2542', '2543', '2544', '2545', '2546', '2547', '2548', '2549', '2550', '2551', '2552', '2553', '2554', '2555', '2556', '2557', '2558', '2559', '2560', '2561', '2562', '2563', '2564', '2565', '2566', '2567', '2568', '2569', '2570', '2571', '2572', '2573', '2574', '2575', '2576', '2577', '2578', '2579', '2580', '2581', '2582', '2583', '2584', '2585', '2586', '2587', '2588', '2589', '2590', '2591', '2592', '2593', '2594', '2595', '2596', '2597', '2598', '2599', '2600', '2601', '2602', '2603', '2604', '2605', '2606', '2607', '2608', '2609', '2610', '2611', '2612', '2613', '2614', '2615', '2616', '2617', '2618', '2619', '2620', '2621', '2622', '2623', '2624', '2625', '2626', '2627', '2628', '2629', '2630', '2631', '2632', '2633', '2634', '2635', '2636', '2637', '2638', '2639', '2640', '2641', '2642', '2643', '2644', '2645', '2646', '2647', '2648', '2649', '2650', '2651', '2652', '2653', '2654', '2655', '2656', '2657', '2658', '2659', '2660', '2661', '2662', '2663', '2664', '2665', '2666', '2667', '2668', '2669', '2670', '2671', '2672', '2673', '2674', '2675', '2676', '2677', '2678', '2679', '2680', '2681', '2682', '2683', '2684', '2685', '2686', '2687', '2688', '2689', '2690', '2691', '2692', '2693', '2694', '2695', '2696', '2697', '2698', '2699', '2700', '2701', '2702', '2703', '2704', '2705', '2706', '2707', '2708', '2709', '2710', '2711', '2712', '2713', '2714', '2715', '2716', '2717', '2718', '2719', '2720', '2721', '2722', '2723', '2724', '2725', '2726', '2727', '2728', '2729', '2730', '2731', '2732', '2733', '2734', '2735', '2736', '2737', '2738', '2739', '2740', '2741', '2742', '2743', '2744', '2745', '2746', '2747', '2748', '2749', '2750', '2751', '2752', '2753', '2754', '2755', '2756', '2757', '2758', '2759', '2760', '2761', '2762', '2763', '2764', '2765', '2766', '2767', '2768', '2769', '2770', '2771', '2772', '2773', '2774', '2775', '2776', '2777', '2778', '2779', '2780', '2781', '2782', '2783', '2784', '2785', '2786', '2787', '2788', '2789', '2790', '2791', '2792', '2793', '2794', '2795', '2796', '2797', '2798', '2799', '2800', '2801', '2802', '2803', '2804', '2805', '2806', '2807', '2808', '2809', '2810', '2811', '2812', '2813', '2814', '2815', '2816', '2817', '2818', '2819', '2820', '2821', '2822', '2823', '2824', '2825', '2826', '2827', '2828', '2829', '2830', '2831', '2832', '2833', '2834', '2835', '2836', '2837', '2838', '2839', '2840', '2841', '2842', '2843', '2844', '2845', '2846', '2847', '2848', '2849', '2850', '2851', '2852', '2853', '2854', '2855', '2856', '2857', '2858', '2859', '2860', '2861', '2862', '2863', '2864', '2865', '2866', '2867', '2868', '2869', '2870', '2871', '2872', '2873', '2874', '2875', '2876', '2877', '2878', '2879', '2880', '2881', '2882', '2883', '2884', '2885', '2886', '2887', '2888', '2889', '2890', '2891', '2892', '2893', '2894', '2895', '2896', '2897', '2898', '2899', '2900', '2901', '2902', '2903', '2904', '2905', '2906', '2907', '2908', '2909', '2910', '2911', '2912', '2913', '2914', '2915', '2916', '2917', '2918', '2919', '2920', '2921', '2922', '2923', '2924', '2925', '2926', '2927', '2928', '2929', '2930', '2931', '2932', '2933', '2934', '2935', '2936', '2937', '2938', '2939', '2940', '2941', '2942', '2943', '2944', '2945', '2946', '2947', '2948', '2949', '2950', '2951', '2952', '2953', '2954', '2955', '2956', '2957', '2958', '2959', '2960', '2961', '2962', '2963', '2964', '2965', '2966', '2967', '2968', '2969', '2970', '2971', '2972', '2973', '2974', '2975', '2976', '2977', '2978', '2979', '2980', '2981', '2982', '2983', '2984', '2985', '2986', '2987', '2988', '2989', '2990', '2991', '2992', '2993', '2994', '2995', '2996', '2997', '2998', '2999', '3000', '3001', '3002', '3003', '3004', '3005', '3006', '3007', '3008', '3009', '3010', '3011', '3012', '3013', '3014', '3015', '3016', '3017', '3018', '3019', '3020', '3021', '3022', '3023', '3024', '3025', '3026', '3027', '3028', '3029', '3030', '3031', '3032', '3033', '3034', '3035', '3036', '3037', '3038', '3039', '3040', '3041', '3042', '3043', '3044', '3045', '3046', '3047', '3048', '3049', '3050', '3051', '3052', '3053', '3054', '3055', '3056', '3057', '3058', '3059', '3060', '3061', '3062', '3063', '3064', '3065', '3066', '3067', '3068', '3069', '3070', '3071', '3072', '3073', '3074', '3075', '3076', '3077', '3078', '3079', '3080', '3081', '3082', '3083', '3084', '3085', '3086', '3087', '3088', '3089', '3090', '3091', '3092', '3093', '3094', '3095', '3096', '3097', '3098', '3099', '3100', '3101', '3102', '3103', '3104', '3105', '3106', '3107', '3108', '3109', '3110', '3111', '3112', '3113', '3114', '3115', '3116', '3117', '3118', '3119', '3120', '3121', '3122', '3123', '3124', '3125', '3126', '3127', '3128', '3129', '3130', '3131', '3132', '3133', '3134', '3135', '3136', '3137', '3138', '3139', '3140', '3141', '3142', '3143', '3144', '3145', '3146', '3147', '3148', '3149', '3150', '3151', '3152', '3153', '3154', '3155', '3156', '3157', '3158', '3159', '3160', '3161', '3162', '3163', '3164', '3165', '3166', '3167', '3168', '3169', '3170', '3171', '3172', '3173', '3174', '3175', '3176', '3177', '3178', '3179', '3180', '3181', '3182', '3183', '3184', '3185', '3186', '3187', '3188', '3189', '3190', '3191', '3192', '3193', '3194', '3195', '3196', '3197', '3198', '3199', '3200', '3201', '3202', '3203', '3204', '3205', '3206', '3207', '3208', '3209', '3210', '3211', '3212', '3213', '3214', '3215', '3216', '3217', '3218', '3219', '3220', '3221', '3222', '3223', '3224', '3225', '3226', '3227', '3228', '3229', '3230', '3231', '3232', '3233', '3234', '3235', '3236', '3237', '3238', '3239', '3240', '3241', '3242', '3243', '3244', '3245', '3246', '3247', '3248', '3249', '3250', '3251', '3252', '3253', '3254', '3255', '3256', '3257', '3258', '3259', '3260', '3261', '3262', '3263', '3264', '3265', '3266', '3267', '3268', '3269', '3270', '3271', '3272', '3273', '3274', '3275', '3276', '3277', '3278', '3279', '3280', '3281', '3282', '3283', '3284', '3285', '3286', '3287', '3288', '3289', '3290', '3291', '3292', '3293', '3294', '3295', '3296', '3297', '3298', '3299', '3300', '3301', '3302', '3303', '3304', '3305', '3306', '3307', '3308', '3309', '3310', '3311', '3312', '3313', '3314', '3315', '3316', '3317', '3318', '3319', '3320', '3321', '3322', '3323', '3324', '3325', '3326', '3327', '3328', '3329', '3330', '3331', '3332', '3333', '3334', '3335', '3336', '3337', '3338', '3339', '3340', '3341', '3342', '3343', '3344', '3345', '3346', '3347', '3348', '3349', '3350', '3351', '3352', '3353', '3354', '3355', '3356', '3357', '3358', '3359', '3360', '3361', '3362', '3363', '3364', '3365', '3366', '3367', '3368', '3369', '3370', '3371', '3372', '3373', '3374', '3375', '3376', '3377', '3378', '3379', '3380', '3381', '3382', '3383', '3384', '3385', '3386', '3387', '3388', '3389', '3390', '3391', '3392', '3393', '3394', '3395', '3396', '3397', '3398', '3399', '3400', '3401', '3402', '3403', '3404', '3405', '3406', '3407', '3408', '3409', '3410', '3411', '3412', '3413', '3414', '3415', '3416', '3417', '3418', '3419', '3420', '3421', '3422', '3423', '3424', '3425', '3426', '3427', '3428', '3429', '3430', '3431', '3432', '3433', '3434', '3435', '3436', '3437', '3438', '3439', '3440', '3441', '3442', '3443', '3444', '3445', '3446', '3447', '3448', '3449', '3450', '3451', '3452', '3453', '3454', '3455', '3456', '3457', '3458', '3459', '3460', '3461', '3462', '3463', '3464', '3465', '3466', '3467', '3468', '3469', '3470', '3471', '3472', '3473', '3474', '3475', '3476', '3477', '3478', '3479', '3480', '3481', '3482', '3483', '3484', '3485', '3486', '3487', '3488', '3489', '3490', '3491', '3492', '3493', '3494', '3495', '3496', '3497', '3498', '3499', '3500', '3501', '3502', '3503', '3504', '3505', '3506', '3507', '3508', '3509', '3510', '3511', '3512', '3513', '3514', '3515', '3516', '3517', '3518', '3519', '3520', '3521', '3522', '3523', '3524', '3525', '3526', '3527', '3528', '3529', '3530', '3531', '3532', '3533', '3534', '3535', '3536', '3537', '3538', '3539', '3540', '3541', '3542', '3543', '3544', '3545', '3546', '3547', '3548', '3549', '3550', '3551', '3552', '3553', '3554', '3555', '3556', '3557', '3558', '3559', '3560', '3561', '3562', '3563', '3564', '3565', '3566', '3567', '3568', '3569', '3570', '3571', '3572', '3573', '3574', '3575', '3576', '3577', '3578', '3579', '3580', '3581', '3582', '3583', '3584', '3585', '3586', '3587', '3588', '3589', '3590', '3591', '3592', '3593', '3594', '3595', '3596', '3597', '3598', '3599', '3600', '3601', '3602', '3603', '3604', '3605', '3606', '3607', '3608', '3609', '3610', '3611', '3612', '3613', '3614', '3615', '3616', '3617', '3618', '3619', '3620', '3621', '3622', '3623', '3624', '3625', '3626', '3627', '3628', '3629', '3630', '3631', '3632', '3633', '3634', '3635', '3636', '3637', '3638', '3639', '3640', '3641', '3642', '3643', '3644', '3645', '3646', '3647', '3648', '3649', '3650', '3651', '3652', '3653', '3654', '3655', '3656', '3657', '3658', '3659', '3660', '3661', '3662', '3663', '3664', '3665', '3666', '3667', '3668', '3669', '3670', '3671', '3672', '3673', '3674', '3675', '3676', '3677', '3678', '3679', '3680', '3681', '3682', '3683', '3684', '3685', '3686', '3687', '3688', '3689', '3690', '3691', '3692', '3693', '3694', '3695', '3696', '3697', '3698', '3699', '3700', '3701', '3702', '3703', '3704', '3705', '3706', '3707', '3708', '3709', '3710', '3711', '3712', '3713', '3714', '3715', '3716', '3717', '3718', '3719', '3720', '3721', '3722', '3723', '3724', '3725', '3726', '3727', '3728', '3729', '3730', '3731', '3732', '3733', '3734', '3735', '3736', '3737', '3738', '3739', '3740', '3741', '3742', '3743', '3744', '3745', '3746', '3747', '3748', '3749', '3750', '3751', '3752', '3753', '3754', '3755', '3756', '3757', '3758', '3759', '3760', '3761', '3762', '3763', '3764', '3765', '3766', '3767', '3768', '3769', '3770', '3771', '3772', '3773', '3774', '3775', '3776', '3777', '3778', '3779', '3780', '3781', '3782', '3783', '3784', '3785', '3786', '3787', '3788', '3789', '3790', '3791', '3792', '3793', '3794', '3795', '3796', '3797', '3798', '3799', '3800', '3801', '3802', '3803', '3804', '3805', '3806', '3807', '3808', '3809', '3810', '3811', '3812', '3813', '3814', '3815', '3816', '3817', '3818', '3819', '3820', '3821', '3822', '3823', '3824', '3825', '3826', '3827', '3828', '3829', '3830', '3831', '3832', '3833', '3834', '3835', '3836', '3837', '3838', '3839', '3840', '3841', '3842', '3843', '3844', '3845', '3846', '3847', '3848', '3849', '3850', '3851', '3852', '3853', '3854', '3855', '3856', '3857', '3858', '3859', '3860', '3861', '3862', '3863', '3864', '3865', '3866', '3867', '3868', '3869', '3870', '3871', '3872', '3873', '3874', '3875', '3876', '3877', '3878', '3879', '3880', '3881', '3882', '3883', '3884', '3885', '3886', '3887', '3888', '3889', '3890', '3891', '3892', '3893', '3894', '3895', '3896', '3897', '3898', '3899', '3900', '3901', '3902', '3903', '3904', '3905', '3906', '3907', '3908', '3909', '3910', '3911', '3912', '3913', '3914', '3915', '3916', '3917', '3918', '3919', '3920', '3921', '3922', '3923', '3924', '3925', '3926', '3927', '3928', '3929', '3930', '3931', '3932', '3933', '3934', '3935', '3936', '3937', '3938', '3939', '3940', '3941', '3942', '3943', '3944', '3945', '3946', '3947', '3948', '3949', '3950', '3951', '3952', '3953', '3954', '3955', '3956', '3957', '3958', '3959', '3960', '3961', '3962', '3963', '3964', '3965', '3966', '3967', '3968', '3969', '3970', '3971', '3972', '3973', '3974', '3975', '3976', '3977', '3978', '3979', '3980', '3981', '3982', '3983', '3984', '3985', '3986', '3987', '3988', '3989', '3990', '3991', '3992', '3993', '3994', '3995', '3996', '3997', '3998', '3999', '4000', '4001', '4002', '4003', '4004', '4005', '4006', '4007', '4008', '4009', '4010', '4011', '4012', '4013', '4014', '4015', '4016', '4017', '4018', '4019', '4020', '4021', '4022', '4023', '4024', '4025', '4026', '4027', '4028', '4029', '4030', '4031', '4032', '4033', '4034', '4035', '4036', '4037', '4038', '4039', '4040', '4041', '4042', '4043', '4044', '4045', '4046', '4047', '4048', '4049', '4050', '4051', '4052', '4053', '4054', '4055', '4056', '4057', '4058', '4059', '4060', '4061', '4062', '4063', '4064', '4065', '4066', '4067', '4068', '4069', '4070', '4071', '4072', '4073', '4074', '4075', '4076', '4077', '4078', '4079', '4080', '4081', '4082', '4083', '4084', '4085', '4086', '4087', '4088', '4089', '4090', '4091', '4092', '4093', '4094', '4095', '4096', '4097', '4098', '4099', '4100', '4101', '4102', '4103', '4104', '4105', '4106', '4107', '4108', '4109', '4110', '4111', '4112', '4113', '4114', '4115', '4116', '4117', '4118', '4119', '4120', '4121', '4122', '4123', '4124', '4125', '4126', '4127', '4128', '4129', '4130', '4131', '4132', '4133', '4134', '4135', '4136', '4137', '4138', '4139', '4140', '4141', '4142', '4143', '4144', '4145', '4146', '4147', '4148', '4149', '4150', '4151', '4152', '4153', '4154', '4155', '4156', '4157', '4158', '4159', '4160', '4161', '4162', '4163', '4164', '4165', '4166', '4167', '4168', '4169', '4170', '4171', '4172', '4173', '4174', '4175', '4176', '4177', '4178', '4179', '4180', '4181', '4182', '4183', '4184', '4185', '4186', '4187', '4188', '4189', '4190', '4191', '4192', '4193', '4194', '4195', '4196', '4197', '4198', '4199', '4200', '4201', '4202', '4203', '4204', '4205', '4206', '4207', '4208', '4209', '4210', '4211', '4212', '4213', '4214', '4215', '4216', '4217', '4218', '4219', '4220', '4221', '4222', '4223', '4224', '4225', '4226', '4227', '4228', '4229', '4230', '4231', '4232', '4233', '4234', '4235', '4236', '4237', '4238', '4239', '4240', '4241', '4242', '4243', '4244', '4245', '4246', '4247', '4248', '4249', '4250', '4251', '4252', '4253', '4254', '4255', '4256', '4257', '4258', '4259', '4260', '4261', '4262', '4263', '4264', '4265', '4266', '4267', '4268', '4269', '4270', '4271', '4272', '4273', '4274', '4275', '4276', '4277', '4278', '4279', '4280', '4281', '4282', '4283', '4284', '4285', '4286', '4287', '4288', '4289', '4290', '4291', '4292', '4293', '4294', '4295', '4296', '4297', '4298', '4299', '4300', '4301', '4302', '4303', '4304', '4305', '4306', '4307', '4308', '4309', '4310', '4311', '4312', '4313', '4314', '4315', '4316', '4317', '4318', '4319', '4320', '4321', '4322', '4323', '4324', '4325', '4326', '4327', '4328', '4329', '4330', '4331', '4332', '4333', '4334', '4335', '4336', '4337', '4338', '4339', '4340', '4341', '4342', '4343', '4344', '4345', '4346', '4347', '4348', '4349', '4350', '4351', '4352', '4353', '4354', '4355', '4356', '4357', '4358', '4359', '4360', '4361', '4362', '4363', '4364', '4365', '4366', '4367', '4368', '4369', '4370', '4371', '4372', '4373', '4374', '4375', '4376', '4377', '4378', '4379', '4380', '4381', '4382', '4383', '4384', '4385', '4386', '4387', '4388', '4389', '4390', '4391', '4392', '4393', '4394', '4395', '4396', '4397', '4398', '4399', '4400', '4401', '4402', '4403', '4404', '4405', '4406', '4407', '4408', '4409', '4410', '4411', '4412', '4413', '4414', '4415', '4416', '4417', '4418', '4419', '4420', '4421', '4422', '4423', '4424', '4425', '4426', '4427', '4428', '4429', '4430', '4431', '4432', '4433', '4434', '4435', '4436', '4437', '4438', '4439', '4440', '4441', '4442', '4443', '4444', '4445', '4446', '4447', '4448', '4449', '4450', '4451', '4452', '4453', '4454', '4455', '4456', '4457', '4458', '4459', '4460', '4461', '4462', '4463', '4464', '4465', '4466', '4467', '4468', '4469', '4470', '4471', '4472', '4473', '4474', '4475', '4476', '4477', '4478', '4479', '4480', '4481', '4482', '4483', '4484', '4485', '4486', '4487', '4488', '4489', '4490', '4491', '4492', '4493', '4494', '4495', '4496', '4497', '4498', '4499', '4500', '4501', '4502', '4503', '4504', '4505', '4506', '4507', '4508', '4509', '4510', '4511', '4512', '4513', '4514', '4515', '4516', '4517', '4518', '4519', '4520', '4521', '4522', '4523', '4524', '4525', '4526', '4527', '4528', '4529', '4530', '4531', '4532', '4533', '4534', '4535', '4536', '4537', '4538', '4539', '4540', '4541', '4542', '4543', '4544', '4545', '4546', '4547', '4548', '4549', '4550', '4551', '4552', '4553', '4554', '4555', '4556', '4557', '4558', '4559', '4560', '4561', '4562', '4563', '4564', '4565', '4566', '4567', '4568', '4569', '4570', '4571', '4572', '4573', '4574', '4575', '4576', '4577', '4578', '4579', '4580', '4581', '4582', '4583', '4584', '4585', '4586', '4587', '4588', '4589', '4590', '4591', '4592', '4593', '4594', '4595', '4596', '4597', '4598', '4599', '4600', '4601', '4602', '4603', '4604', '4605', '4606', '4607', '4608', '4609', '4610', '4611', '4612', '4613', '4614', '4615', '4616', '4617', '4618', '4619', '4620', '4621', '4622', '4623', '4624', '4625', '4626', '4627', '4628', '4629', '4630', '4631', '4632', '4633', '4634', '4635', '4636', '4637', '4638', '4639', '4640', '4641', '4642', '4643', '4644', '4645', '4646', '4647', '4648', '4649', '4650', '4651', '4652', '4653', '4654', '4655', '4656', '4657', '4658', '4659', '4660', '4661', '4662', '4663', '4664', '4665', '4666', '4667', '4668', '4669', '4670', '4671', '4672', '4673', '4674', '4675', '4676', '4677', '4678', '4679', '4680', '4681', '4682', '4683', '4684', '4685', '4686', '4687', '4688', '4689', '4690', '4691', '4692', '4693', '4694', '4695', '4696', '4697', '4698', '4699', '4700', '4701', '4702', '4703', '4704', '4705', '4706', '4707', '4708', '4709', '4710', '4711', '4712', '4713', '4714', '4715', '4716', '4717', '4718', '4719', '4720', '4721', '4722', '4723', '4724', '4725', '4726', '4727', '4728', '4729', '4730', '4731', '4732', '4733', '4734', '4735', '4736', '4737', '4738', '4739', '4740', '4741', '4742', '4743', '4744', '4745', '4746', '4747', '4748', '4749', '4750', '4751', '4752', '4753', '4754', '4755', '4756', '4757', '4758', '4759', '4760', '4761', '4762', '4763', '4764', '4765', '4766', '4767', '4768', '4769', '4770', '4771', '4772', '4773', '4774', '4775', '4776', '4777', '4778', '4779', '4780', '4781', '4782', '4783', '4784', '4785', '4786', '4787', '4788', '4789', '4790', '4791', '4792', '4793', '4794', '4795', '4796', '4797', '4798', '4799', '4800', '4801', '4802', '4803', '4804', '4805', '4806', '4807', '4808', '4809', '4810', '4811', '4812', '4813', '4814', '4815', '4816', '4817', '4818', '4819', '4820', '4821', '4822', '4823', '4824', '4825', '4826', '4827', '4828', '4829', '4830', '4831', '4832', '4833', '4834', '4835', '4836', '4837', '4838', '4839', '4840', '4841', '4842', '4843', '4844', '4845', '4846', '4847', '4848', '4849', '4850', '4851', '4852', '4853', '4854', '4855', '4856', '4857', '4858', '4859', '4860', '4861', '4862', '4863', '4864', '4865', '4866', '4867', '4868', '4869', '4870', '4871', '4872', '4873', '4874', '4875', '4876', '4877', '4878', '4879', '4880', '4881', '4882', '4883', '4884', '4885', '4886', '4887', '4888', '4889', '4890', '4891', '4892', '4893', '4894', '4895', '4896', '4897', '4898', '4899', '4900', '4901', '4902', '4903', '4904', '4905', '4906', '4907', '4908', '4909', '4910', '4911', '4912', '4913', '4914', '4915', '4916', '4917', '4918', '4919', '4920', '4921', '4922', '4923', '4924', '4925', '4926', '4927', '4928', '4929', '4930', '4931', '4932', '4933', '4934', '4935', '4936', '4937', '4938', '4939', '4940', '4941', '4942', '4943', '4944', '4945', '4946', '4947', '4948', '4949', '4950', '4951', '4952', '4953', '4954', '4955', '4956', '4957', '4958', '4959', '4960', '4961', '4962', '4963', '4964', '4965', '4966', '4967', '4968', '4969', '4970', '4971', '4972', '4973', '4974', '4975', '4976', '4977', '4978', '4979', '4980', '4981', '4982', '4983', '4984', '4985', '4986', '4987', '4988', '4989', '4990', '4991', '4992', '4993', '4994', '4995', '4996', '4997', '4998', '4999', '5000', '5001', '5002', '5003', '5004', '5005', '5006', '5007', '5008', '5009', '5010', '5011', '5012', '5013', '5014', '5015', '5016', '5017', '5018', '5019', '5020', '5021', '5022', '5023', '5024', '5025', '5026', '5027', '5028', '5029', '5030', '5031', '5032', '5033', '5034', '5035', '5036', '5037', '5038', '5039', '5040', '5041', '5042', '5043', '5044', '5045', '5046', '5047', '5048', '5049', '5050', '5051', '5052', '5053', '5054', '5055', '5056', '5057', '5058', '5059', '5060', '5061', '5062', '5063', '5064', '5065', '5066', '5067', '5068', '5069', '5070', '5071', '5072', '5073', '5074', '5075', '5076', '5077', '5078', '5079', '5080', '5081', '5082', '5083', '5084', '5085', '5086', '5087', '5088', '5089', '5090', '5091', '5092', '5093', '5094', '5095', '5096', '5097', '5098', '5099', '5100', '5101', '5102', '5103', '5104', '5105', '5106', '5107', '5108', '5109', '5110', '5111', '5112', '5113', '5114', '5115', '5116', '5117', '5118', '5119', '5120', '5121', '5122', '5123', '5124', '5125', '5126', '5127', '5128', '5129', '5130', '5131', '5132', '5133', '5134', '5135', '5136', '5137', '5138', '5139', '5140', '5141', '5142', '5143', '5144', '5145', '5146', '5147', '5148', '5149', '5150', '5151', '5152', '5153', '5154', '5155', '5156', '5157', '5158', '5159', '5160', '5161', '5162', '5163', '5164', '5165', '5166', '5167', '5168', '5169', '5170', '5171', '5172', '5173', '5174', '5175', '5176', '5177', '5178', '5179', '5180', '5181', '5182', '5183', '5184', '5185', '5186', '5187', '5188', '5189', '5190', '5191', '5192', '5193', '5194', '5195', '5196', '5197', '5198', '5199', '5200', '5201', '5202', '5203', '5204', '5205', '5206', '5207', '5208', '5209', '5210', '5211', '5212', '5213', '5214', '5215', '5216', '5217', '5218', '5219', '5220', '5221', '5222', '5223', '5224', '5225', '5226', '5227', '5228', '5229', '5230', '5231', '5232', '5233', '5234', '5235', '5236', '5237', '5238', '5239', '5240', '5241', '5242', '5243', '5244', '5245', '5246', '5247', '5248', '5249', '5250', '5251', '5252', '5253', '5254', '5255', '5256', '5257', '5258', '5259', '5260', '5261', '5262', '5263', '5264', '5265', '5266', '5267', '5268', '5269', '5270', '5271', '5272', '5273', '5274', '5275', '5276', '5277', '5278', '5279', '5280', '5281', '5282', '5283', '5284', '5285', '5286', '5287', '5288', '5289', '5290', '5291', '5292', '5293', '5294', '5295', '5296', '5297', '5298', '5299', '5300', '5301', '5302', '5303', '5304', '5305', '5306', '5307', '5308', '5309', '5310', '5311', '5312', '5313', '5314', '5315', '5316', '5317', '5318', '5319', '5320', '5321', '5322', '5323', '5324', '5325', '5326', '5327', '5328', '5329', '5330', '5331', '5332', '5333', '5334', '5335', '5336', '5337', '5338', '5339', '5340', '5341', '5342', '5343', '5344', '5345', '5346', '5347', '5348', '5349', '5350', '5351', '5352', '5353', '5354', '5355', '5356', '5357', '5358', '5359', '5360', '5361', '5362', '5363', '5364', '5365', '5366', '5367', '5368', '5369', '5370', '5371', '5372', '5373', '5374', '5375', '5376', '5377', '5378', '5379', '5380', '5381', '5382', '5383', '5384', '5385', '5386', '5387', '5388', '5389', '5390', '5391', '5392', '5393', '5394', '5395', '5396', '5397', '5398', '5399', '5400', '5401', '5402', '5403', '5404', '5405', '5406', '5407', '5408', '5409', '5410', '5411', '5412', '5413', '5414', '5415', '5416', '5417', '5418', '5419', '5420', '5421', '5422', '5423', '5424', '5425', '5426', '5427', '5428', '5429', '5430', '5431', '5432', '5433', '5434', '5435', '5436', '5437', '5438', '5439', '5440', '5441', '5442', '5443', '5444', '5445', '5446', '5447', '5448', '5449', '5450', '5451', '5452', '5453', '5454', '5455', '5456', '5457', '5458', '5459', '5460', '5461', '5462', '5463', '5464', '5465', '5466', '5467', '5468', '5469', '5470', '5471', '5472', '5473', '5474', '5475', '5476', '5477', '5478', '5479', '5480', '5481', '5482', '5483', '5484', '5485', '5486', '5487', '5488', '5489', '5490', '5491', '5492', '5493', '5494', '5495', '5496', '5497', '5498', '5499', '5500', '5501', '5502', '5503', '5504', '5505', '5506', '5507', '5508', '5509', '5510', '5511', '5512', '5513', '5514', '5515', '5516', '5517', '5518', '5519', '5520', '5521', '5522', '5523', '5524', '5525', '5526', '5527', '5528', '5529', '5530', '5531', '5532', '5533', '5534', '5535', '5536', '5537', '5538', '5539', '5540', '5541', '5542', '5543', '5544', '5545', '5546', '5547', '5548', '5549', '5550', '5551', '5552', '5553', '5554', '5555', '5556', '5557', '5558', '5559', '5560', '5561', '5562', '5563', '5564', '5565', '5566', '5567', '5568', '5569', '5570', '5571', '5572', '5573', '5574', '5575', '5576', '5577', '5578', '5579', '5580', '5581', '5582', '5583', '5584', '5585', '5586', '5587', '5588', '5589', '5590', '5591', '5592', '5593', '5594', '5595', '5596', '5597', '5598', '5599', '5600', '5601', '5602', '5603', '5604', '5605', '5606', '5607', '5608', '5609', '5610', '5611', '5612', '5613', '5614', '5615', '5616', '5617', '5618', '5619', '5620', '5621', '5622', '5623', '5624', '5625', '5626', '5627', '5628', '5629', '5630', '5631', '5632', '5633', '5634', '5635', '5636', '5637', '5638', '5639', '5640', '5641', '5642', '5643', '5644', '5645', '5646', '5647', '5648', '5649', '5650', '5651', '5652', '5653', '5654', '5655', '5656', '5657', '5658', '5659', '5660', '5661', '5662', '5663', '5664', '5665', '5666', '5667', '5668', '5669', '5670', '5671', '5672', '5673', '5674', '5675', '5676', '5677', '5678', '5679', '5680', '5681', '5682', '5683', '5684', '5685', '5686', '5687', '5688', '5689', '5690', '5691', '5692', '5693', '5694', '5695', '5696', '5697', '5698', '5699', '5700', '5701', '5702', '5703', '5704', '5705', '5706', '5707', '5708', '5709', '5710', '5711', '5712', '5713', '5714', '5715', '5716', '5717', '5718', '5719', '5720', '5721', '5722', '5723', '5724', '5725', '5726', '5727', '5728', '5729', '5730', '5731', '5732', '5733', '5734', '5735', '5736', '5737', '5738', '5739', '5740', '5741', '5742', '5743', '5744', '5745', '5746', '5747', '5748', '5749', '5750', '5751', '5752', '5753', '5754', '5755', '5756', '5757', '5758', '5759', '5760', '5761', '5762', '5763', '5764', '5765', '5766', '5767', '5768', '5769', '5770', '5771', '5772', '5773', '5774', '5775', '5776', '5777', '5778', '5779', '5780', '5781', '5782', '5783', '5784', '5785', '5786', '5787', '5788', '5789', '5790', '5791', '5792', '5793', '5794', '5795', '5796', '5797', '5798', '5799', '5800', '5801', '5802', '5803', '5804', '5805', '5806', '5807', '5808', '5809', '5810', '5811', '5812', '5813', '5814', '5815', '5816', '5817', '5818', '5819', '5820', '5821', '5822', '5823', '5824', '5825', '5826', '5827', '5828', '5829', '5830', '5831', '5832', '5833', '5834', '5835', '5836', '5837', '5838', '5839', '5840', '5841', '5842', '5843', '5844', '5845', '5846', '5847', '5848', '5849', '5850', '5851', '5852', '5853', '5854', '5855', '5856', '5857', '5858', '5859', '5860', '5861', '5862', '5863', '5864', '5865', '5866', '5867', '5868', '5869', '5870', '5871', '5872', '5873', '5874', '5875', '5876', '5877', '5878', '5879', '5880', '5881', '5882', '5883', '5884', '5885', '5886', '5887', '5888', '5889', '5890', '5891', '5892', '5893', '5894', '5895', '5896', '5897', '5898', '5899', '5900', '5901', '5902', '5903', '5904', '5905', '5906', '5907', '5908', '5909', '5910', '5911', '5912', '5913', '5914', '5915', '5916', '5917', '5918', '5919', '5920', '5921', '5922', '5923', '5924', '5925', '5926', '5927', '5928', '5929', '5930', '5931', '5932', '5933', '5934', '5935', '5936', '5937', '5938', '5939', '5940', '5941', '5942', '5943', '5944', '5945', '5946', '5947', '5948', '5949', '5950', '5951', '5952', '5953', '5954', '5955', '5956', '5957', '5958', '5959', '5960', '5961', '5962', '5963', '5964', '5965', '5966', '5967', '5968', '5969', '5970', '5971', '5972', '5973', '5974', '5975', '5976', '5977', '5978', '5979', '5980', '5981', '5982', '5983', '5984', '5985', '5986', '5987', '5988', '5989', '5990', '5991', '5992', '5993', '5994', '5995', '5996', '5997', '5998', '5999', '6000', '6001', '6002', '6003', '6004', '6005', '6006', '6007', '6008', '6009', '6010', '6011', '6012', '6013', '6014', '6015', '6016', '6017', '6018', '6019', '6020', '6021', '6022', '6023', '6024', '6025', '6026', '6027', '6028', '6029', '6030', '6031', '6032', '6033', '6034', '6035', '6036', '6037', '6038', '6039', '6040', '6041', '6042', '6043', '6044', '6045', '6046', '6047', '6048', '6049', '6050', '6051', '6052', '6053', '6054', '6055', '6056', '6057', '6058', '6059', '6060', '6061', '6062', '6063', '6064', '6065', '6066', '6067', '6068', '6069', '6070', '6071', '6072', '6073', '6074', '6075', '6076', '6077', '6078', '6079', '6080', '6081', '6082', '6083', '6084', '6085', '6086', '6087', '6088', '6089', '6090', '6091', '6092', '6093', '6094', '6095', '6096', '6097', '6098', '6099', '6100', '6101', '6102', '6103', '6104', '6105', '6106', '6107', '6108', '6109', '6110', '6111', '6112', '6113', '6114', '6115', '6116', '6117', '6118', '6119', '6120', '6121', '6122', '6123', '6124', '6125', '6126', '6127', '6128', '6129', '6130', '6131', '6132', '6133', '6134', '6135', '6136', '6137', '6138', '6139', '6140', '6141', '6142', '6143', '6144', '6145', '6146', '6147', '6148', '6149', '6150', '6151', '6152', '6153', '6154', '6155', '6156', '6157', '6158', '6159', '6160', '6161', '6162', '6163', '6164', '6165', '6166', '6167', '6168', '6169', '6170', '6171', '6172', '6173', '6174', '6175', '6176', '6177', '6178', '6179', '6180', '6181', '6182', '6183', '6184', '6185', '6186', '6187', '6188', '6189', '6190', '6191', '6192', '6193', '6194', '6195', '6196', '6197', '6198', '6199', '6200', '6201', '6202', '6203', '6204', '6205', '6206', '6207', '6208', '6209', '6210', '6211', '6212', '6213', '6214', '6215', '6216', '6217', '6218', '6219', '6220', '6221', '6222', '6223', '6224', '6225', '6226', '6227', '6228', '6229', '6230', '6231', '6232', '6233', '6234', '6235', '6236', '6237', '6238', '6239', '6240', '6241', '6242', '6243', '6244', '6245', '6246', '6247', '6248', '6249', '6250', '6251', '6252', '6253', '6254', '6255', '6256', '6257', '6258', '6259', '6260', '6261', '6262', '6263', '6264', '6265', '6266', '6267', '6268', '6269', '6270', '6271', '6272', '6273', '6274', '6275', '6276', '6277', '6278', '6279', '6280', '6281', '6282', '6283', '6284', '6285', '6286', '6287', '6288', '6289', '6290', '6291', '6292', '6293', '6294', '6295', '6296', '6297', '6298', '6299', '6300', '6301', '6302', '6303', '6304', '6305', '6306', '6307', '6308', '6309', '6310', '6311', '6312', '6313', '6314', '6315', '6316', '6317', '6318', '6319', '6320', '6321', '6322', '6323', '6324', '6325', '6326', '6327', '6328', '6329', '6330', '6331', '6332', '6333', '6334', '6335', '6336', '6337', '6338', '6339', '6340', '6341', '6342', '6343', '6344', '6345', '6346', '6347', '6348', '6349', '6350', '6351', '6352', '6353', '6354', '6355', '6356', '6357', '6358', '6359', '6360', '6361', '6362', '6363', '6364', '6365', '6366', '6367', '6368', '6369', '6370', '6371', '6372', '6373', '6374', '6375', '6376', '6377', '6378', '6379', '6380', '6381', '6382', '6383', '6384', '6385', '6386', '6387', '6388', '6389', '6390', '6391', '6392', '6393', '6394', '6395', '6396', '6397', '6398', '6399', '6400', '6401', '6402', '6403', '6404', '6405', '6406', '6407', '6408', '6409', '6410', '6411', '6412', '6413', '6414', '6415', '6416', '6417', '6418', '6419', '6420', '6421', '6422', '6423', '6424', '6425', '6426', '6427', '6428', '6429', '6430', '6431', '6432', '6433', '6434', '6435', '6436', '6437', '6438', '6439', '6440', '6441', '6442', '6443', '6444', '6445', '6446', '6447', '6448', '6449', '6450', '6451', '6452', '6453', '6454', '6455', '6456', '6457', '6458', '6459', '6460', '6461', '6462', '6463', '6464', '6465', '6466', '6467', '6468', '6469', '6470', '6471', '6472', '6473', '6474', '6475', '6476', '6477', '6478', '6479', '6480', '6481', '6482', '6483', '6484', '6485', '6486', '6487', '6488', '6489', '6490', '6491', '6492', '6493', '6494', '6495', '6496', '6497', '6498', '6499', '6500', '6501', '6502', '6503', '6504', '6505', '6506', '6507', '6508', '6509', '6510', '6511', '6512', '6513', '6514', '6515', '6516', '6517', '6518', '6519', '6520', '6521', '6522', '6523', '6524', '6525', '6526', '6527', '6528', '6529', '6530', '6531', '6532', '6533', '6534', '6535', '6536', '6537', '6538', '6539', '6540', '6541', '6542', '6543', '6544', '6545', '6546', '6547', '6548', '6549', '6550', '6551', '6552', '6553', '6554', '6555', '6556', '6557', '6558', '6559', '6560', '6561', '6562', '6563', '6564', '6565', '6566', '6567', '6568', '6569', '6570', '6571', '6572', '6573', '6574', '6575', '6576', '6577', '6578', '6579', '6580', '6581', '6582', '6583', '6584', '6585', '6586', '6587', '6588', '6589', '6590', '6591', '6592', '6593', '6594', '6595', '6596', '6597', '6598', '6599', '6600', '6601', '6602', '6603', '6604', '6605', '6606', '6607', '6608', '6609', '6610', '6611', '6612', '6613', '6614', '6615', '6616', '6617', '6618', '6619', '6620', '6621', '6622', '6623', '6624', '6625', '6626', '6627', '6628', '6629', '6630', '6631', '6632', '6633', '6634', '6635', '6636', '6637', '6638', '6639', '6640', '6641', '6642', '6643', '6644', '6645', '6646', '6647', '6648', '6649', '6650', '6651', '6652', '6653', '6654', '6655', '6656', '6657', '6658', '6659', '6660', '6661', '6662', '6663', '6664', '6665', '6666', '6667', '6668', '6669', '6670', '6671', '6672', '6673', '6674', '6675', '6676', '6677', '6678', '6679', '6680', '6681', '6682', '6683', '6684', '6685', '6686', '6687', '6688', '6689', '6690', '6691', '6692', '6693', '6694', '6695', '6696', '6697', '6698', '6699', '6700', '6701', '6702', '6703', '6704', '6705', '6706', '6707', '6708', '6709', '6710', '6711', '6712', '6713', '6714', '6715', '6716', '6717', '6718', '6719', '6720', '6721', '6722', '6723', '6724', '6725', '6726', '6727', '6728', '6729', '6730', '6731', '6732', '6733', '6734', '6735', '6736', '6737', '6738', '6739', '6740', '6741', '6742', '6743', '6744', '6745', '6746', '6747', '6748', '6749', '6750', '6751', '6752', '6753', '6754', '6755', '6756', '6757', '6758', '6759', '6760', '6761', '6762', '6763', '6764', '6765', '6766', '6767', '6768', '6769', '6770', '6771', '6772', '6773', '6774', '6775', '6776', '6777', '6778', '6779', '6780', '6781', '6782', '6783', '6784', '6785', '6786', '6787', '6788', '6789', '6790', '6791', '6792', '6793', '6794', '6795', '6796', '6797', '6798', '6799', '6800', '6801', '6802', '6803', '6804', '6805', '6806', '6807', '6808', '6809', '6810', '6811', '6812', '6813', '6814', '6815', '6816', '6817', '6818', '6819', '6820', '6821', '6822', '6823', '6824', '6825', '6826', '6827', '6828', '6829', '6830', '6831', '6832', '6833', '6834', '6835', '6836', '6837', '6838', '6839', '6840', '6841', '6842', '6843', '6844', '6845', '6846', '6847', '6848', '6849', '6850', '6851', '6852', '6853', '6854', '6855', '6856', '6857', '6858', '6859', '6860', '6861', '6862', '6863', '6864', '6865', '6866', '6867', '6868', '6869', '6870', '6871', '6872', '6873', '6874', '6875', '6876', '6877', '6878', '6879', '6880', '6881', '6882', '6883', '6884', '6885', '6886', '6887', '6888', '6889', '6890', '6891', '6892', '6893', '6894', '6895', '6896', '6897', '6898', '6899', '6900', '6901', '6902', '6903', '6904', '6905', '6906', '6907', '6908', '6909', '6910', '6911', '6912', '6913', '6914', '6915', '6916', '6917', '6918', '6919', '6920', '6921', '6922', '6923', '6924', '6925', '6926', '6927', '6928', '6929', '6930', '6931', '6932', '6933', '6934', '6935', '6936', '6937', '6938', '6939', '6940', '6941', '6942', '6943', '6944', '6945', '6946', '6947', '6948', '6949', '6950', '6951', '6952', '6953', '6954', '6955', '6956', '6957', '6958', '6959', '6960', '6961', '6962', '6963', '6964', '6965', '6966', '6967', '6968', '6969', '6970', '6971', '6972', '6973', '6974', '6975', '6976', '6977', '6978', '6979', '6980', '6981', '6982', '6983', '6984', '6985', '6986', '6987', '6988', '6989', '6990', '6991', '6992', '6993', '6994', '6995', '6996', '6997', '6998', '6999', '7000', '7001', '7002', '7003', '7004', '7005', '7006', '7007', '7008', '7009', '7010', '7011', '7012', '7013', '7014', '7015', '7016', '7017', '7018', '7019', '7020', '7021', '7022', '7023', '7024', '7025', '7026', '7027', '7028', '7029', '7030', '7031', '7032', '7033', '7034', '7035', '7036', '7037', '7038', '7039', '7040', '7041', '7042', '7043', '7044', '7045', '7046', '7047', '7048', '7049', '7050', '7051', '7052', '7053', '7054', '7055', '7056', '7057', '7058', '7059', '7060', '7061', '7062', '7063', '7064', '7065', '7066', '7067', '7068', '7069', '7070', '7071', '7072', '7073', '7074', '7075', '7076', '7077', '7078', '7079', '7080', '7081', '7082', '7083', '7084', '7085', '7086', '7087', '7088', '7089', '7090', '7091', '7092', '7093', '7094', '7095', '7096', '7097', '7098', '7099', '7100', '7101', '7102', '7103', '7104', '7105', '7106', '7107', '7108', '7109', '7110', '7111', '7112', '7113', '7114', '7115', '7116', '7117', '7118', '7119', '7120', '7121', '7122', '7123', '7124', '7125', '7126', '7127', '7128', '7129', '7130', '7131', '7132', '7133', '7134', '7135', '7136', '7137', '7138', '7139', '7140', '7141', '7142', '7143', '7144', '7145', '7146', '7147', '7148', '7149', '7150', '7151', '7152', '7153', '7154', '7155', '7156', '7157', '7158', '7159', '7160', '7161', '7162', '7163', '7164', '7165', '7166', '7167', '7168', '7169', '7170', '7171', '7172', '7173', '7174', '7175', '7176', '7177', '7178', '7179', '7180', '7181', '7182', '7183', '7184', '7185', '7186', '7187', '7188', '7189', '7190', '7191', '7192', '7193', '7194', '7195', '7196', '7197', '7198', '7199', '7200', '7201', '7202', '7203', '7204', '7205', '7206', '7207', '7208', '7209', '7210', '7211', '7212', '7213', '7214', '7215', '7216', '7217', '7218', '7219', '7220', '7221', '7222', '7223', '7224', '7225', '7226', '7227', '7228', '7229', '7230', '7231', '7232', '7233', '7234', '7235', '7236', '7237', '7238', '7239', '7240', '7241', '7242', '7243', '7244', '7245', '7246', '7247', '7248', '7249', '7250', '7251', '7252', '7253', '7254', '7255', '7256', '7257', '7258', '7259', '7260', '7261', '7262', '7263', '7264', '7265', '7266', '7267', '7268', '7269', '7270', '7271', '7272', '7273', '7274', '7275', '7276', '7277', '7278', '7279', '7280', '7281', '7282', '7283', '7284', '7285', '7286', '7287', '7288', '7289', '7290', '7291', '7292', '7293', '7294', '7295', '7296', '7297', '7298', '7299', '7300', '7301', '7302', '7303', '7304', '7305', '7306', '7307', '7308', '7309', '7310', '7311', '7312', '7313', '7314', '7315', '7316', '7317', '7318', '7319', '7320', '7321', '7322', '7323', '7324', '7325', '7326', '7327', '7328', '7329', '7330', '7331', '7332', '7333', '7334', '7335', '7336', '7337', '7338', '7339', '7340', '7341', '7342', '7343', '7344', '7345', '7346', '7347', '7348', '7349', '7350', '7351', '7352', '7353', '7354', '7355', '7356', '7357', '7358', '7359', '7360', '7361', '7362', '7363', '7364', '7365', '7366', '7367', '7368', '7369', '7370', '7371', '7372', '7373', '7374', '7375', '7376', '7377', '7378', '7379', '7380', '7381', '7382', '7383', '7384', '7385', '7386', '7387', '7388', '7389', '7390', '7391', '7392', '7393', '7394', '7395', '7396', '7397', '7398', '7399', '7400', '7401', '7402', '7403', '7404', '7405', '7406', '7407', '7408', '7409', '7410', '7411', '7412', '7413', '7414', '7415', '7416', '7417', '7418', '7419', '7420', '7421', '7422', '7423', '7424', '7425', '7426', '7427', '7428', '7429', '7430', '7431', '7432', '7433', '7434', '7435', '7436', '7437', '7438', '7439', '7440', '7441', '7442', '7443', '7444', '7445', '7446', '7447', '7448', '7449', '7450', '7451', '7452', '7453', '7454', '7455', '7456', '7457', '7458', '7459', '7460', '7461', '7462', '7463', '7464', '7465', '7466', '7467', '7468', '7469', '7470', '7471', '7472', '7473', '7474', '7475', '7476', '7477', '7478', '7479', '7480', '7481', '7482', '7483', '7484', '7485', '7486', '7487', '7488', '7489', '7490', '7491', '7492', '7493', '7494', '7495', '7496', '7497', '7498', '7499', '7500', '7501', '7502', '7503', '7504', '7505', '7506', '7507', '7508', '7509', '7510', '7511', '7512', '7513', '7514', '7515', '7516', '7517', '7518', '7519', '7520', '7521', '7522', '7523', '7524', '7525', '7526', '7527', '7528', '7529', '7530', '7531', '7532', '7533', '7534', '7535', '7536', '7537', '7538', '7539', '7540', '7541', '7542', '7543', '7544', '7545', '7546', '7547', '7548', '7549', '7550', '7551', '7552', '7553', '7554', '7555', '7556', '7557', '7558', '7559', '7560', '7561', '7562', '7563', '7564', '7565', '7566', '7567', '7568', '7569', '7570', '7571', '7572', '7573', '7574', '7575', '7576', '7577', '7578', '7579', '7580', '7581', '7582', '7583', '7584', '7585', '7586', '7587', '7588', '7589', '7590', '7591', '7592', '7593', '7594', '7595', '7596', '7597', '7598', '7599', '7600', '7601', '7602', '7603', '7604', '7605', '7606', '7607', '7608', '7609', '7610', '7611', '7612', '7613', '7614', '7615', '7616', '7617', '7618', '7619', '7620', '7621', '7622', '7623', '7624', '7625', '7626', '7627', '7628', '7629', '7630', '7631', '7632', '7633', '7634', '7635', '7636', '7637', '7638', '7639', '7640', '7641', '7642', '7643', '7644', '7645', '7646', '7647', '7648', '7649', '7650', '7651', '7652', '7653', '7654', '7655', '7656', '7657', '7658', '7659', '7660', '7661', '7662', '7663', '7664', '7665', '7666', '7667', '7668', '7669', '7670', '7671', '7672', '7673', '7674', '7675', '7676', '7677', '7678', '7679', '7680', '7681', '7682', '7683', '7684', '7685', '7686', '7687', '7688', '7689', '7690', '7691', '7692', '7693', '7694', '7695', '7696', '7697', '7698', '7699', '7700', '7701', '7702', '7703', '7704', '7705', '7706', '7707', '7708', '7709', '7710', '7711', '7712', '7713', '7714', '7715', '7716', '7717', '7718', '7719', '7720', '7721', '7722', '7723', '7724', '7725', '7726', '7727', '7728', '7729', '7730', '7731', '7732', '7733', '7734', '7735', '7736', '7737', '7738', '7739', '7740', '7741', '7742', '7743', '7744', '7745', '7746', '7747', '7748', '7749', '7750', '7751', '7752', '7753', '7754', '7755', '7756', '7757', '7758', '7759', '7760', '7761', '7762', '7763', '7764', '7765', '7766', '7767', '7768', '7769', '7770', '7771', '7772', '7773', '7774', '7775', '7776', '7777', '7778', '7779', '7780', '7781', '7782', '7783', '7784', '7785', '7786', '7787', '7788', '7789', '7790', '7791', '7792', '7793', '7794', '7795', '7796', '7797', '7798', '7799', '7800', '7801', '7802', '7803', '7804', '7805', '7806', '7807', '7808', '7809', '7810', '7811', '7812', '7813', '7814', '7815', '7816', '7817', '7818', '7819', '7820', '7821', '7822', '7823', '7824', '7825', '7826', '7827', '7828', '7829', '7830', '7831', '7832', '7833', '7834', '7835', '7836', '7837', '7838', '7839', '7840', '7841', '7842', '7843', '7844', '7845', '7846', '7847', '7848', '7849', '7850', '7851', '7852', '7853', '7854', '7855', '7856', '7857', '7858', '7859', '7860', '7861', '7862', '7863', '7864', '7865', '7866', '7867', '7868', '7869', '7870', '7871', '7872', '7873', '7874', '7875', '7876', '7877', '7878', '7879', '7880', '7881', '7882', '7883', '7884', '7885', '7886', '7887', '7888', '7889', '7890', '7891', '7892', '7893', '7894', '7895', '7896', '7897', '7898', '7899', '7900', '7901', '7902', '7903', '7904', '7905', '7906', '7907', '7908', '7909', '7910', '7911', '7912', '7913', '7914', '7915', '7916', '7917', '7918', '7919', '7920', '7921', '7922', '7923', '7924', '7925', '7926', '7927', '7928', '7929', '7930', '7931', '7932', '7933', '7934', '7935', '7936', '7937', '7938', '7939', '7940', '7941', '7942', '7943', '7944', '7945', '7946', '7947', '7948', '7949', '7950', '7951', '7952', '7953', '7954', '7955', '7956', '7957', '7958', '7959', '7960', '7961', '7962', '7963', '7964', '7965', '7966', '7967', '7968', '7969', '7970', '7971', '7972', '7973', '7974', '7975', '7976', '7977', '7978', '7979', '7980', '7981', '7982', '7983', '7984', '7985', '7986', '7987', '7988', '7989', '7990', '7991', '7992', '7993', '7994', '7995', '7996', '7997', '7998', '7999', '8000', '8001', '8002', '8003', '8004', '8005', '8006', '8007', '8008', '8009', '8010', '8011', '8012', '8013', '8014', '8015', '8016', '8017', '8018', '8019', '8020', '8021', '8022', '8023', '8024', '8025', '8026', '8027', '8028', '8029', '8030', '8031', '8032', '8033', '8034', '8035', '8036', '8037', '8038', '8039', '8040', '8041', '8042', '8043', '8044', '8045', '8046', '8047', '8048', '8049', '8050', '8051', '8052', '8053', '8054', '8055', '8056', '8057', '8058', '8059', '8060', '8061', '8062', '8063', '8064', '8065', '8066', '8067', '8068', '8069', '8070', '8071', '8072', '8073', '8074', '8075', '8076', '8077', '8078', '8079', '8080', '8081', '8082', '8083', '8084', '8085', '8086', '8087', '8088', '8089', '8090', '8091', '8092', '8093', '8094', '8095', '8096', '8097', '8098', '8099', '8100', '8101', '8102', '8103', '8104', '8105', '8106', '8107', '8108', '8109', '8110', '8111', '8112', '8113', '8114', '8115', '8116', '8117', '8118', '8119', '8120', '8121', '8122', '8123', '8124', '8125', '8126', '8127', '8128', '8129', '8130', '8131', '8132', '8133', '8134', '8135', '8136', '8137', '8138', '8139', '8140', '8141', '8142', '8143', '8144', '8145', '8146', '8147', '8148', '8149', '8150', '8151', '8152', '8153', '8154', '8155', '8156', '8157', '8158', '8159', '8160', '8161', '8162', '8163', '8164', '8165', '8166', '8167', '8168', '8169', '8170', '8171', '8172', '8173', '8174', '8175', '8176', '8177', '8178', '8179', '8180', '8181', '8182', '8183', '8184', '8185', '8186', '8187', '8188', '8189', '8190', '8191', '8192', '8193', '8194', '8195', '8196', '8197', '8198', '8199', '8200', '8201', '8202', '8203', '8204', '8205', '8206', '8207', '8208', '8209', '8210', '8211', '8212', '8213', '8214', '8215', '8216', '8217', '8218', '8219', '8220', '8221', '8222', '8223', '8224', '8225', '8226', '8227', '8228', '8229', '8230', '8231', '8232', '8233', '8234', '8235', '8236', '8237', '8238', '8239', '8240', '8241', '8242', '8243', '8244', '8245', '8246', '8247', '8248', '8249', '8250', '8251', '8252', '8253', '8254', '8255', '8256', '8257', '8258', '8259', '8260', '8261', '8262', '8263', '8264', '8265', '8266', '8267', '8268', '8269', '8270', '8271', '8272', '8273', '8274', '8275', '8276', '8277', '8278', '8279', '8280', '8281', '8282', '8283', '8284', '8285', '8286', '8287', '8288', '8289', '8290', '8291', '8292', '8293', '8294', '8295', '8296', '8297', '8298', '8299', '8300', '8301', '8302', '8303', '8304', '8305', '8306', '8307', '8308', '8309', '8310', '8311', '8312', '8313', '8314', '8315', '8316', '8317', '8318', '8319', '8320', '8321', '8322', '8323', '8324', '8325', '8326', '8327', '8328', '8329', '8330', '8331', '8332', '8333', '8334', '8335', '8336', '8337', '8338', '8339', '8340', '8341', '8342', '8343', '8344', '8345', '8346', '8347', '8348', '8349', '8350', '8351', '8352', '8353', '8354', '8355', '8356', '8357', '8358', '8359', '8360', '8361', '8362', '8363', '8364', '8365', '8366', '8367', '8368', '8369', '8370', '8371', '8372', '8373', '8374', '8375', '8376', '8377', '8378', '8379', '8380', '8381', '8382', '8383', '8384', '8385', '8386', '8387', '8388', '8389', '8390', '8391', '8392', '8393', '8394', '8395', '8396', '8397', '8398', '8399', '8400', '8401', '8402', '8403', '8404', '8405', '8406', '8407', '8408', '8409', '8410', '8411', '8412', '8413', '8414', '8415', '8416', '8417', '8418', '8419', '8420', '8421', '8422', '8423', '8424', '8425', '8426', '8427', '8428', '8429', '8430', '8431', '8432', '8433', '8434', '8435', '8436', '8437', '8438', '8439', '8440', '8441', '8442', '8443', '8444', '8445', '8446', '8447', '8448', '8449', '8450', '8451', '8452', '8453', '8454', '8455', '8456', '8457', '8458', '8459', '8460', '8461', '8462', '8463', '8464', '8465', '8466', '8467', '8468', '8469', '8470', '8471', '8472', '8473', '8474', '8475', '8476', '8477', '8478', '8479', '8480', '8481', '8482', '8483', '8484', '8485', '8486', '8487', '8488', '8489', '8490', '8491', '8492', '8493', '8494', '8495', '8496', '8497', '8498', '8499', '8500', '8501', '8502', '8503', '8504', '8505', '8506', '8507', '8508', '8509', '8510', '8511', '8512', '8513', '8514', '8515', '8516', '8517', '8518', '8519', '8520', '8521', '8522', '8523', '8524', '8525', '8526', '8527', '8528', '8529', '8530', '8531', '8532', '8533', '8534', '8535', '8536', '8537', '8538', '8539', '8540', '8541', '8542', '8543', '8544', '8545', '8546', '8547', '8548', '8549', '8550', '8551', '8552', '8553', '8554', '8555', '8556', '8557', '8558', '8559', '8560', '8561', '8562', '8563', '8564', '8565', '8566', '8567', '8568', '8569', '8570', '8571', '8572', '8573', '8574', '8575', '8576', '8577', '8578', '8579', '8580', '8581', '8582', '8583', '8584', '8585', '8586', '8587', '8588', '8589', '8590', '8591', '8592', '8593', '8594', '8595', '8596', '8597', '8598', '8599', '8600', '8601', '8602', '8603', '8604', '8605', '8606', '8607', '8608', '8609', '8610', '8611', '8612', '8613', '8614', '8615', '8616', '8617', '8618', '8619', '8620', '8621', '8622', '8623', '8624', '8625', '8626', '8627', '8628', '8629', '8630', '8631', '8632', '8633', '8634', '8635', '8636', '8637', '8638', '8639', '8640', '8641', '8642', '8643', '8644', '8645', '8646', '8647', '8648', '8649', '8650', '8651', '8652', '8653', '8654', '8655', '8656', '8657', '8658', '8659', '8660', '8661', '8662', '8663', '8664', '8665', '8666', '8667', '8668', '8669', '8670', '8671', '8672', '8673', '8674', '8675', '8676', '8677', '8678', '8679', '8680', '8681', '8682', '8683', '8684', '8685', '8686', '8687', '8688', '8689', '8690', '8691', '8692', '8693', '8694', '8695', '8696', '8697', '8698', '8699', '8700', '8701', '8702', '8703', '8704', '8705', '8706', '8707', '8708', '8709', '8710', '8711', '8712', '8713', '8714', '8715', '8716', '8717', '8718', '8719', '8720', '8721', '8722', '8723', '8724', '8725', '8726', '8727', '8728', '8729', '8730', '8731', '8732', '8733', '8734', '8735', '8736', '8737', '8738', '8739', '8740', '8741', '8742', '8743', '8744', '8745', '8746', '8747', '8748', '8749', '8750', '8751', '8752', '8753', '8754', '8755', '8756', '8757', '8758', '8759', '8760', '8761', '8762', '8763', '8764', '8765', '8766', '8767', '8768', '8769', '8770', '8771', '8772', '8773', '8774', '8775', '8776', '8777', '8778', '8779', '8780', '8781', '8782', '8783', '8784', '8785', '8786', '8787', '8788', '8789', '8790', '8791', '8792', '8793', '8794', '8795', '8796', '8797', '8798', '8799', '8800', '8801', '8802', '8803', '8804', '8805', '8806', '8807', '8808', '8809', '8810', '8811', '8812', '8813', '8814', '8815', '8816', '8817', '8818', '8819', '8820', '8821', '8822', '8823', '8824', '8825', '8826', '8827', '8828', '8829', '8830', '8831', '8832', '8833', '8834', '8835', '8836', '8837', '8838', '8839', '8840', '8841', '8842', '8843', '8844', '8845', '8846', '8847', '8848', '8849', '8850', '8851', '8852', '8853', '8854', '8855', '8856', '8857', '8858', '8859', '8860', '8861', '8862', '8863', '8864', '8865', '8866', '8867', '8868', '8869', '8870', '8871', '8872', '8873', '8874', '8875', '8876', '8877', '8878', '8879', '8880', '8881', '8882', '8883', '8884', '8885', '8886', '8887', '8888', '8889', '8890', '8891', '8892', '8893', '8894', '8895', '8896', '8897', '8898', '8899', '8900', '8901', '8902', '8903', '8904', '8905', '8906', '8907', '8908', '8909', '8910', '8911', '8912', '8913', '8914', '8915', '8916', '8917', '8918', '8919', '8920', '8921', '8922', '8923', '8924', '8925', '8926', '8927', '8928', '8929', '8930', '8931', '8932', '8933', '8934', '8935', '8936', '8937', '8938', '8939', '8940', '8941', '8942', '8943', '8944', '8945', '8946', '8947', '8948', '8949', '8950', '8951', '8952', '8953', '8954', '8955', '8956', '8957', '8958', '8959', '8960', '8961', '8962', '8963', '8964', '8965', '8966', '8967', '8968', '8969', '8970', '8971', '8972', '8973', '8974', '8975', '8976', '8977', '8978', '8979', '8980', '8981', '8982', '8983', '8984', '8985', '8986', '8987', '8988', '8989', '8990', '8991', '8992', '8993', '8994', '8995', '8996', '8997', '8998', '8999', '9000', '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009', '9010', '9011', '9012', '9013', '9014', '9015', '9016', '9017', '9018', '9019', '9020', '9021', '9022', '9023', '9024', '9025', '9026', '9027', '9028', '9029', '9030', '9031', '9032', '9033', '9034', '9035', '9036', '9037', '9038', '9039', '9040', '9041', '9042', '9043', '9044', '9045', '9046', '9047', '9048', '9049', '9050', '9051', '9052', '9053', '9054', '9055', '9056', '9057', '9058', '9059', '9060', '9061', '9062', '9063', '9064', '9065', '9066', '9067', '9068', '9069', '9070', '9071', '9072', '9073', '9074', '9075', '9076', '9077', '9078', '9079', '9080', '9081', '9082', '9083', '9084', '9085', '9086', '9087', '9088', '9089', '9090', '9091', '9092', '9093', '9094', '9095', '9096', '9097', '9098', '9099', '9100', '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109', '9110', '9111', '9112', '9113', '9114', '9115', '9116', '9117', '9118', '9119', '9120', '9121', '9122', '9123', '9124', '9125', '9126', '9127', '9128', '9129', '9130', '9131', '9132', '9133', '9134', '9135', '9136', '9137', '9138', '9139', '9140', '9141', '9142', '9143', '9144', '9145', '9146', '9147', '9148', '9149', '9150', '9151', '9152', '9153', '9154', '9155', '9156', '9157', '9158', '9159', '9160', '9161', '9162', '9163', '9164', '9165', '9166', '9167', '9168', '9169', '9170', '9171', '9172', '9173', '9174', '9175', '9176', '9177', '9178', '9179', '9180', '9181', '9182', '9183', '9184', '9185', '9186', '9187', '9188', '9189', '9190', '9191', '9192', '9193', '9194', '9195', '9196', '9197', '9198', '9199', '9200', '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209', '9210', '9211', '9212', '9213', '9214', '9215', '9216', '9217', '9218', '9219', '9220', '9221', '9222', '9223', '9224', '9225', '9226', '9227', '9228', '9229', '9230', '9231', '9232', '9233', '9234', '9235', '9236', '9237', '9238', '9239', '9240', '9241', '9242', '9243', '9244', '9245', '9246', '9247', '9248', '9249', '9250', '9251', '9252', '9253', '9254', '9255', '9256', '9257', '9258', '9259', '9260', '9261', '9262', '9263', '9264', '9265', '9266', '9267', '9268', '9269', '9270', '9271', '9272', '9273', '9274', '9275', '9276', '9277', '9278', '9279', '9280', '9281', '9282', '9283', '9284', '9285', '9286', '9287', '9288', '9289', '9290', '9291', '9292', '9293', '9294', '9295', '9296', '9297', '9298', '9299', '9300', '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309', '9310', '9311', '9312', '9313', '9314', '9315', '9316', '9317', '9318', '9319', '9320', '9321', '9322', '9323', '9324', '9325', '9326', '9327', '9328', '9329', '9330', '9331', '9332', '9333', '9334', '9335', '9336', '9337', '9338', '9339', '9340', '9341', '9342', '9343', '9344', '9345', '9346', '9347', '9348', '9349', '9350', '9351', '9352', '9353', '9354', '9355', '9356', '9357', '9358', '9359', '9360', '9361', '9362', '9363', '9364', '9365', '9366', '9367', '9368', '9369', '9370', '9371', '9372', '9373', '9374', '9375', '9376', '9377', '9378', '9379', '9380', '9381', '9382', '9383', '9384', '9385', '9386', '9387', '9388', '9389', '9390', '9391', '9392', '9393', '9394', '9395', '9396', '9397', '9398', '9399', '9400', '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409', '9410', '9411', '9412', '9413', '9414', '9415', '9416', '9417', '9418', '9419', '9420', '9421', '9422', '9423', '9424', '9425', '9426', '9427', '9428', '9429', '9430', '9431', '9432', '9433', '9434', '9435', '9436', '9437', '9438', '9439', '9440', '9441', '9442', '9443', '9444', '9445', '9446', '9447', '9448', '9449', '9450', '9451', '9452', '9453', '9454', '9455', '9456', '9457', '9458', '9459', '9460', '9461', '9462', '9463', '9464', '9465', '9466', '9467', '9468', '9469', '9470', '9471', '9472', '9473', '9474', '9475', '9476', '9477', '9478', '9479', '9480', '9481', '9482', '9483', '9484', '9485', '9486', '9487', '9488', '9489', '9490', '9491', '9492', '9493', '9494', '9495', '9496', '9497', '9498', '9499', '9500', '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509', '9510', '9511', '9512', '9513', '9514', '9515', '9516', '9517', '9518', '9519', '9520', '9521', '9522', '9523', '9524', '9525', '9526', '9527', '9528', '9529', '9530', '9531', '9532', '9533', '9534', '9535', '9536', '9537', '9538', '9539', '9540', '9541', '9542', '9543', '9544', '9545', '9546', '9547', '9548', '9549', '9550', '9551', '9552', '9553', '9554', '9555', '9556', '9557', '9558', '9559', '9560', '9561', '9562', '9563', '9564', '9565', '9566', '9567', '9568', '9569', '9570', '9571', '9572', '9573', '9574', '9575', '9576', '9577', '9578', '9579', '9580', '9581', '9582', '9583', '9584', '9585', '9586', '9587', '9588', '9589', '9590', '9591', '9592', '9593', '9594', '9595', '9596', '9597', '9598', '9599', '9600', '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609', '9610', '9611', '9612', '9613', '9614', '9615', '9616', '9617', '9618', '9619', '9620', '9621', '9622', '9623', '9624', '9625', '9626', '9627', '9628', '9629', '9630', '9631', '9632', '9633', '9634', '9635', '9636', '9637', '9638', '9639', '9640', '9641', '9642', '9643', '9644', '9645', '9646', '9647', '9648', '9649', '9650', '9651', '9652', '9653', '9654', '9655', '9656', '9657', '9658', '9659', '9660', '9661', '9662', '9663', '9664', '9665', '9666', '9667', '9668', '9669', '9670', '9671', '9672', '9673', '9674', '9675', '9676', '9677', '9678', '9679', '9680', '9681', '9682', '9683', '9684', '9685', '9686', '9687', '9688', '9689', '9690', '9691', '9692', '9693', '9694', '9695', '9696', '9697', '9698', '9699', '9700', '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709', '9710', '9711', '9712', '9713', '9714', '9715', '9716', '9717', '9718', '9719', '9720', '9721', '9722', '9723', '9724', '9725', '9726', '9727', '9728', '9729', '9730', '9731', '9732', '9733', '9734', '9735', '9736', '9737', '9738', '9739', '9740', '9741', '9742', '9743', '9744', '9745', '9746', '9747', '9748', '9749', '9750', '9751', '9752', '9753', '9754', '9755', '9756', '9757', '9758', '9759', '9760', '9761', '9762', '9763', '9764', '9765', '9766', '9767', '9768', '9769', '9770', '9771', '9772', '9773', '9774', '9775', '9776', '9777', '9778', '9779', '9780', '9781', '9782', '9783', '9784', '9785', '9786', '9787', '9788', '9789', '9790', '9791', '9792', '9793', '9794', '9795', '9796', '9797', '9798', '9799', '9800', '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809', '9810', '9811', '9812', '9813', '9814', '9815', '9816', '9817', '9818', '9819', '9820', '9821', '9822', '9823', '9824', '9825', '9826', '9827', '9828', '9829', '9830', '9831', '9832', '9833', '9834', '9835', '9836', '9837', '9838', '9839', '9840', '9841', '9842', '9843', '9844', '9845', '9846', '9847', '9848', '9849', '9850', '9851', '9852', '9853', '9854', '9855', '9856', '9857', '9858', '9859', '9860', '9861', '9862', '9863', '9864', '9865', '9866', '9867', '9868', '9869', '9870', '9871', '9872', '9873', '9874', '9875', '9876', '9877', '9878', '9879', '9880', '9881', '9882', '9883', '9884', '9885', '9886', '9887', '9888', '9889', '9890', '9891', '9892', '9893', '9894', '9895', '9896', '9897', '9898', '9899', '9900', '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909', '9910', '9911', '9912', '9913', '9914', '9915', '9916', '9917', '9918', '9919', '9920', '9921', '9922', '9923', '9924', '9925', '9926', '9927', '9928', '9929', '9930', '9931', '9932', '9933', '9934', '9935', '9936', '9937', '9938', '9939', '9940', '9941', '9942', '9943', '9944', '9945', '9946', '9947', '9948', '9949', '9950', '9951', '9952', '9953', '9954', '9955', '9956', '9957', '9958', '9959', '9960', '9961', '9962', '9963', '9964', '9965', '9966', '9967', '9968', '9969', '9970', '9971', '9972', '9973', '9974', '9975', '9976', '9977', '9978', '9979', '9980', '9981', '9982', '9983', '9984', '9985', '9986', '9987', '9988', '9989', '9990', '9991', '9992', '9993', '9994', '9995', '9996', '9997', '9998', '9999'] table of digit characters with 4-digit entries integer(kind=I4B), public, parameter :: LShift_Digits (0:60) = [0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19] The following three precomputed parameters speed up left shifts by having the number\n  of new digits that will be added by multiplying 5&#94;i by 2&#94;i. If the number is less\n  than 5&#94;i then it will add one fewer digit. There are only 60 entries since\n  that's the max shift amount. integer(kind=I4B), public, parameter :: LShift_Length (0:60) = [0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8, 9, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24, 25, 26, 26, 27, 28, 28, 29, 30, 31, 31, 32, 33, 33, 34, 35, 35, 36, 37, 38, 38, 39, 40, 40, 41, 42, 42] character(len=42), public, parameter :: LShift_PowFive (0:60) = ['&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '3125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '15625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '78125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '390625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '1953125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '9765625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '48828125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '244140625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '1220703125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '6103515625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '30517578125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '152587890625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '762939453125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '3814697265625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '19073486328125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '95367431640625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '476837158203125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '2384185791015625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '11920928955078125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '59604644775390625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '298023223876953125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '1490116119384765625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '7450580596923828125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '37252902984619140625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '186264514923095703125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '931322574615478515625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '4656612873077392578125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '23283064365386962890625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '116415321826934814453125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '582076609134674072265625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '2910383045673370361328125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '14551915228366851806640625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '72759576141834259033203125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '363797880709171295166015625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '1818989403545856475830078125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '9094947017729282379150390625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '45474735088646411895751953125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '227373675443232059478759765625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '1136868377216160297393798828125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '5684341886080801486968994140625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '28421709430404007434844970703125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '142108547152020037174224853515625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '710542735760100185871124267578125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '3552713678800500929355621337890625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '17763568394002504646778106689453125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '88817841970012523233890533447265625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '444089209850062616169452667236328125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '2220446049250313080847263336181640625&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', '11102230246251565404236316680908203125&nbsp;&nbsp;&nbsp;&nbsp;', '55511151231257827021181583404541015625&nbsp;&nbsp;&nbsp;&nbsp;', '277555756156289135105907917022705078125&nbsp;&nbsp;&nbsp;', '1387778780781445675529539585113525390625&nbsp;&nbsp;', '6938893903907228377647697925567626953125&nbsp;&nbsp;', '34694469519536141888238489627838134765625 ', '173472347597680709441192448139190673828125', '867361737988403547205962240695953369140625']","tags":"","loc":"module\\modbase_tables_charconv.html"},{"title":"ModBase_Integer_FromChar – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains routines that convert a decimal string into an integer value. REFERENCES : [1] Number Conversion Benchmark in C TECHNICAL NOTES : 1. A Fortran number (FortNum) that has the form as: [S]N[N...] where S is a sign indicator (required if negative '-', optional if positive '+'). N is a decimal digit (0 through 9). Any leading zeros, leading and trailing\n          spaces are ignored. Unlike Fortran constants, the optional kind parameter (_k) is not allowed here. 2. A FortPlus number (FortPlus) has a slightly more relaxed rule than that of a Fortran\n   number such that any invalid characters after characters that are valid are ignored.\n   For example, -3567e23 is treated as a valid number with a value of -3567. 3. A JSON number (JsonNum) has a slightly stricter rule than that of a Fortran number\n   such that a plus sign and leading zoroes are not allowed. Uses ModBase_Common Functions public  function I32_FromChar_CC_FortNum (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a Fortran number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number public  function I32_FromChar_CC_FortPlus (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number public  function I32_FromChar_CC_JsonNum (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number public  function I32_FromChar_Lemire_FortPlus (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number public  function I32_FromChar_YY_JsonNum (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I4B) number public  function I64_FromChar_CC_FortNum (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a Fortran number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number public  function I64_FromChar_CC_FortPlus (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number public  function I64_FromChar_CC_JsonNum (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number public  function I64_FromChar_Lemire_FortPlus (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number public  function I64_FromChar_YY_JsonNum (cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number Arguments Type Intent Optional Attributes Name character(len=*), intent(in), TARGET :: cStr character string logical(kind=4), intent(out), optional :: ErrFlag true if input is not invalid character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=I8B) number","tags":"","loc":"module\\modbase_integer_fromchar.html"},{"title":"ModBase_RealQP_CharConv – FortCharConv","text":"PURPOSE OF THIS MODULE : This module contains routines that perform a conversion between a 128-bit\n  floating point number and a string. REFERENCE TECHNICAL ARTICLES : [1]  Junekey Jeon. Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm [2]  Ulf Adams. Ryu: Fast Float-to-String Conversion [3]  Raffaello Giulietti. The Schubfach way to render doubles [4]  Clinger WD. How to Read Floating Point Numbers Accurately ,\n  SIGPLAN Not 2004 Apr;39(4):360–371. [5]  Daniel Lemire. Number Parsing at a Gigabyte per Second ,\n  Software: Practice and Experience 51 (8), 2021. [6]  Noble Mushtak and Daniel Lemire. Fast Number Parsing Without Fallback ,\n  Software: Practice and Experience 53 (7), 2023. [7]  Bouvier & Zimmermann. Division-Free Binary-to-Decimal Conversion [8]  Hacker's Delight, 2nd Edition. [9]  Nigel Tao. The Eisel-Lemire ParseNumberF64 Algorithm [10] Nigel Tao. ParseNumberF64 by Simple Decimal Conversion REFERENCE CODE IMPLEMENTATION : [11] DragonBox: C++ reference implementation [12] Ryu: C reference implementation [13] Schubfach: Java reference implementation [14] Drachennest: Different algorithms for converting binary to decimal floating-point numbers [15] Number Conversion Benchmark in C [16] fast_float number parsing library: 4x faster than strtod [17] fast_double_parser: 4x faster than strtod [18] The LLVM Project: LibC Support [19] Double Conversion: Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles [20] fmt: A modern formatting library TECHNICAL AND IMPLEMENTATION NOTES : On the output to string : 1) Three routines are available to convert a real (floating-point) number into a string. - \"RealToString_DragonBox\" is based on the Dragonbox binary-to-decimal conversion algorithm [1]\n     and the reference implementation [11, 14, 20] - \"RealToString_Ryu\" is based on the Ryu binary-to-decimal conversion algorithm [2]\n     and the reference implementation [12, 14] - \"RealToString_Schubfach\" is based on the Schubfach binary-to-decimal conversion algorithm [3]\n     and the reference implementation [13, 14, 15] 2) All three binary-to-decimal conversion algorithms employed here produce the so-called shortest\n   output representation that provide an error-free write-read cycle.  This means that any correct\n   parsers (e.g. RealFromString routines) will read in the output string and return the original\n   real (floating-poing) number. 3) Although the DragonBox reference implementation provides several modes of rounding, only the\n   round-to-nearest mode is implemented here (the other two algorithms also use this mode). 4) Although the Ryu reference implementation provides several conversion output formats (Shortest,\n   Scientific, Fixed), only the shortest representation (as mentioned above) is implemented.\n   Therefore, all three routines will produces the output string in a format similar to \"G0\" format\n   specification in Fortran. 5) Actually, the RealToString routines have an optional \"format\" argument that we can use to specify\n   whether to output the string in \"General (G)\" or \"Scientific (ES)\" format.  However, because they\n   always produce the shortest output, no input argument to the routines is provided to specify\n   the desired number of significant digits as typically done in Fortran format specifications. On the input from string : 1) Four routines are available to convert a string into a real (floating-point) number.  All four\n   routines utilize the so-call Clinger's fast-path algorithm [4].  Three of them (except \"YY\") employ\n   the so-call Eisel-Lemire decimal-to-binary conversion algorithm [5, 9] but are based on different\n   reference implementation.  When the Eisel-Lemire (or YY's fast-path) algorithm is NOT valid, three\n   of the routines (except \"LibC\") use multi-precision (unsigned) integer arithmetic (i.e. BigUInt)\n   whereas \"LibC\" employs the so-call Simple Decimal Conversion algorithm [10]. - \"RealFromString_FastFloat\" is based on the reference implementation [16] - \"RealFromString_LibC\" is based on the reference implementation [18] - \"RealFromString_YY\" is based on the reference implementation [15, 19] - \"RealFromString_Lemire\" is based on the reference implementation [17, 19] 2) The RealFromString routines have an optional \"parsing\" argument that we can use to specify how\n   the routines interpret the input string. 3) The \"Parse_Fortran_String\" routine is called when the optional \"parsing\" argument is not specified\n   (i.e. the default option) or \"FortNum (or 1)\" value is supplied as the parsing argument.  The routine\n   will interpret the input string as a valid Fortran real (floating point) number if it has one of\n   the two following forms: <1> A number without exponent part -> [S]N[N...] <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] where [ ] indicates an optional field S is a sign indicator (required if negative '-', optional if positive '+'). N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere\n          after the sign (but before the exponent). E is an exponent indicator (either 'e' or 'E') The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. - The optional kind parameter (e.g. 10.0_QP) is not allowed here. Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered\n   valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\"\n   is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement\n   where spaces inside the valid number are allowed. However, this can easily be done by adding an\n   optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or 'ignored'.\n   Then, the input will be pre-processed according to the flag.  Nonetheless, this routine neglects\n   this optional input because it will make the routine much less efficient due to the fact that\n   we will need to scan the whole string twice and we will also need to copy the input string into\n   a buffer string and working with the buffer instead of directly handling the input string. 4) The \"Parse_FPlus_String\" routine is called when \"FPlusNum (or 2)\" value is supplied as the parsing\n   argument.  The routine will parse a valid Fortran real (floating point) number with more relaxed\n   rules than those used in \"Parse_Fortran_Number\" routine. The relaxed rules consider the following\n   numbers as valid: - a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q'\n     in place of 'e' or 'E'. - a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to\n     be expressed in a valid number expressed in the scientific format. - digits before any invalid character encountered are treated as a valid number\n     and any characters after the first encounter (including the first invalid one)\n     are neglected.  therefore, for example, a '12.56ax-300' is considered to be\n     a valid number with a value of 12.56. 5) The \"Parse_JSON_String\" routine is called when \"JsonNum (or 3)\" value is supplied as the parsing\n   argument.  The routine will parse a valid JSON floating point number where its differences from\n   from Fortran number are as follows: - leading and trailing spaces are not allowed. - a plus sign as the first character is not allowed. - leading zero(s) is not allowed (if 0 is the first character, the second one\n     must either be a period or an exponent indicator.) - a period must be followed by at least one digit. USAGE : On the output to string : => cStr = RealXP_ToString_DragonBox(Number, IsScientific) => cStr = RealXP_ToString_Ryu(Number, IsScientific) => cStr = RealXP_ToString_Schubfach(Number, IsScientific) where \"cStr\" is an \"allocatable\" character string representing the output string \"Number\" is a real number representing the floating point value \"IsScientific\" is a logical flag (optional argument) indicating whether\n      the output string is in \"General\" or \"Scientific\" format. If present and true, the output string is in \"Scientific\" format. Otherwise, the output string is in \"General\" format. On the input from string : => Number = RealXP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) => Number = RealXP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) where \"Number\" is a real number representing the floating point value if the input string is valid \"cStr\" is a character string representing the floating-point number string \"ParseOpt\" is an integer input flag (optional) indicating how to interpret the input string.\n      The valid value is FortNum (1), FPlusNum (2) or JsonNum (3).\n      If not specified and invalid, the routines will interpret the input string as a Fortran number. \"ErrFlag\" is a logical output flag (optional) indicating whether there is an error in parsing\n      the input string.  True if the string represents a valid number.  False, otherwise. \"ErrMsg\" is an allocatable output character string (optional) that returns a message that describe\n      the result of parsing the input string. NOTE : \"XP\" in the routine names shown above indicate the precision of the real number.\n  The actual name will either be \"RealSP_...\", \"RealQP_...\" or \"RealQP_...\" for single-precision,\n  double-precision and quadruple-precision number, respectively. Uses ModBase_UIntUtil ieee_arithmetic ModBase_Common ModBase_UInt128 ModBase_Tables_CharConv ModBase_SIntUtil Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: FortNum = 1 integer(kind=I4B), public, parameter :: FPlusNum = 2 integer(kind=I4B), public, parameter :: JsonNum = 3 type( UInt128 ), public, parameter :: MinSubnormal = UInt128(0_I8B, 1_I8B) type( UInt128 ), public, parameter :: MaxSubnormal = UInt128(SHIFTL(1_I8B, SignificandBits-64)-1_I8B, -1_I8B) type( UInt128 ), public, parameter :: MinNormal = UInt128(SHIFTL(1_I8B, SignificandBits-64), 0_I8B) type( UInt128 ), public, parameter :: MaxNormal = UInt128(IOR(SHIFTL(MaxExponent-1_I8B, SignificandBits-64), MaxSubnormal%High), IOR(0_I8B, MaxSubnormal%Low)) Functions public  function RealQP_ToString_DragonBox (Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: Number logical, intent(in), optional :: IsScientific Return Value character(len=:), ALLOCATABLE public  function RealQP_ToString_Ryu (Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: Number logical, intent(in), optional :: IsScientific Return Value character(len=:), ALLOCATABLE public  function RealQP_ToString_Schubfach (Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in) :: Number logical, intent(in), optional :: IsScientific Return Value character(len=:), ALLOCATABLE public  function RealQP_FromString_FastFloat (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) public  function RealQP_FromString_LibC (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) public  function RealQP_FromString_YY (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP) public  function RealQP_FromString_Lemire (cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cStr integer(kind=I4B), intent(in), optional :: ParseOpt logical, intent(out), optional :: ErrFlag character(len=:), intent(out), optional, ALLOCATABLE :: ErrMsg Return Value real(kind=QP)","tags":"","loc":"module\\modbase_realqp_charconv.html"},{"title":"ModBase - Integer - ToChar.f90 – FortCharConv","text":"Source Code MODULE ModBase_Integer_ToChar !&#94; **PURPOSE OF THIS MODULE**: ! This module contains routines that convert an integer value into a decimal string. ! !&#94; **REFERENCES**: ! [1] [Number Conversion Benchmark in C](https://github.com/ibireme/c_numconv_benchmark) ! [2] [itoa - Fast integer to ascii / integer to string conversion](https://github.com/jeaiii/itoa) !** USE STATEMENTS: USE ModBase_Common USE ModBase_UIntUtil , ONLY : U128_Multiply_High => UMul128_Upper64 USE ModBase_Tables_CharConv , ONLY : Char1Digit , Char2Digits , Char4Digits IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! 32-bit integer PUBLIC :: I32_ToChar_Basic , I32_ToChar_CC PUBLIC :: I32_ToChar_YY , I32_ToChar_YYLL PUBLIC :: I32_ToChar_JEA ! 64-bit integer PUBLIC :: I64_ToChar_Basic , I64_ToChar_CC PUBLIC :: I64_ToChar_YY , I64_ToChar_YYLL PUBLIC :: I64_ToChar_JEA PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: INTEGER ( KIND = I4B ), PARAMETER :: MinI32 = INT ( Z '80000000' , KIND = I4B ) ! -2147483648 INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! -9223372036854775808 !** DERIVED TYPE DEFINITIONS ! na !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE DEFINITIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                           32-BIT INTEGER ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I32_ToChar_Basic ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using basic (naive) algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 INTEGER ( KIND = I4B ), PARAMETER :: Base = 10 CHARACTER ( LEN = 1 ), PARAMETER :: NumStr ( 0 : 9 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I4B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I4B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I4B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0 ) THEN cStr = '0' RETURN END IF IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = PosNum / Base ! compute the remainder RemNum = CurNum - PosNum * Base ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0 ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0 ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I32_ToChar_Basic !****************************************************************************** FUNCTION I32_ToChar_CC ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using CC algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I4B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I4B ) :: NxtNum ! next round of positive number INTEGER ( KIND = I4B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Start , Finish !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 10000 ) THEN Start = 1 IF ( PosNum < 100 ) THEN wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 IF ( wStr ( Start : Start ) == '0' ) Start = 2 ELSE wStr ( 1 : 4 ) = Char4Digits ( PosNum ) Finish = 4 IF ( wStr ( Start : Start ) == '0' ) Start = 2 END IF ELSE ! compute the next round of working number NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! NxtNum = PosNum/10000 ! compute the remainder RemNum = PosNum - NxtNum * Divisor ! RemNum = MOD(PosNum, 10000) ! convert the remainder to a working string wStr ( 7 : 10 ) = Char4Digits ( RemNum ) Finish = 10 PosNum = NxtNum IF ( PosNum < 10000 ) THEN IF ( PosNum < 100 ) THEN wStr ( 5 : 6 ) = Char2Digits ( PosNum ) Start = 5 IF ( wStr ( Start : Start ) == '0' ) Start = 6 ELSE wStr ( 3 : 6 ) = Char4Digits ( PosNum ) Start = 3 IF ( wStr ( Start : Start ) == '0' ) Start = 4 END IF ELSE ! compute the next round of working number NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! NxtNum = PosNum/10000 ! compute the remainder RemNum = PosNum - NxtNum * Divisor ! RemNum = MOD(PosNum, 10000) ! convert the remainder to a working string wStr ( 3 : 6 ) = Char4Digits ( RemNum ) IF ( NxtNum > 0 ) THEN IF ( NxtNum < 10 ) THEN wStr ( 2 : 2 ) = Char2Digits ( NxtNum )( 2 : 2 ) Start = 2 ELSE wStr ( 1 : 2 ) = Char2Digits ( NxtNum ) Start = 1 END IF ELSE Start = 3 END IF END IF END IF IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_CC !****************************************************************************** FUNCTION I32_ToChar_YY ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using YY algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I4B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I4B ) :: AA , BB , CC , DD INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD INTEGER ( KIND = I4B ) :: AABBCC , DDEE , EE !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100 ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 10000 ) THEN ! 3-4 digits AA = INT ( SHIFTR ( PosNum * 5243 , 19 ), KIND = I4B ) ! PosNum / 100 BB = PosNum - AA * 100 ! MOD(PosNum, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) Finish = 4 ELSEIF ( PosNum < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( PosNum * 429497_I8B , 32 ), KIND = I4B ) ! PosNum / 10000 BBCC = PosNum - AA * 10000 ! MOD(PosNum, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) Finish = 6 ELSEIF ( PosNum < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( PosNum * 109951163_I8B , 40 ), KIND = I4B ) ! PosNum / 10000 CCDD = PosNum - AABB * 10000 ! MOD(PosNum, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) wStr ( 7 : 8 ) = Char2Digits ( DD ) Finish = 8 ELSE ! 9-10 digits AABBCC = INT ( SHIFTR ( PosNum * 3518437209_I8B , 45 ), KIND = I4B ) ! PosNum / 10000 AA = INT ( SHIFTR ( AABBCC * 429497_I8B , 32 ), KIND = I4B ) ! aabbcc / 10000 DDEE = PosNum - AABBCC * 10000 ! MOD(PosNum, 10000) BBCC = AABBCC - AA * 10000 ! MOD(aabbcc, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! bbcc / 100 DD = SHIFTR ( DDEE * 5243 , 19 ) ! ddee / 100 CC = BBCC - BB * 100 ! MOD(bbcc, 100) EE = DDEE - DD * 100 ! MOD(ddee, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) wStr ( 7 : 8 ) = Char2Digits ( DD ) wStr ( 9 : 10 ) = Char2Digits ( EE ) Finish = 10 END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_YY !****************************************************************************** FUNCTION I32_ToChar_YYLL ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using YY algorithm with large table IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I4B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I4B ) :: AA INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD INTEGER ( KIND = I4B ) :: BBCCDDEE , DDEE !** FLOW ! set positive number PosNum = ABS ( Number ) Start = 1 ! start the conversion IF ( PosNum < 10000 ) THEN ! 1-4 digits wStr ( 1 : 4 ) = Char4Digits ( PosNum ) IF ( wStr ( 1 : 1 ) == '0' ) THEN Start = 2 IF ( wStr ( 2 : 2 ) == '0' ) THEN Start = 3 IF ( wStr ( 3 : 3 ) == '0' ) THEN Start = 4 END IF END IF END IF Finish = 4 ELSEIF ( PosNum < 100000000 ) THEN ! 5-8 digits AABB = INT ( SHIFTR ( PosNum * 109951163_I8B , 40 ), KIND = I4B ) ! PosNum / 10000 CCDD = PosNum - AABB * 10000 ! MOD(PosNum, 10000) wStr ( 1 : 4 ) = Char4Digits ( AABB ) wStr ( 5 : 8 ) = Char4Digits ( CCDD ) IF ( wStr ( 1 : 1 ) == '0' ) THEN Start = 2 IF ( wStr ( 2 : 2 ) == '0' ) THEN Start = 3 IF ( wStr ( 3 : 3 ) == '0' ) THEN Start = 4 END IF END IF END IF Finish = 8 ELSE ! 9-10 digits AA = INT ( SHIFTR ( PosNum * 1441151881_I8B , 57 ), KIND = I4B ) ! PosNum / 100000000 BBCCDDEE = PosNum - AA * 100000000 ! MOD(PosNum, 100000000) BBCC = INT ( SHIFTR ( BBCCDDEE * 109951163_I8B , 40 ), KIND = I4B ) ! BBCCDDEE / 10000 DDEE = BBCCDDEE - BBCC * 10000 ! MOD(BBCCDDEE, 10000) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 6 ) = Char4Digits ( BBCC ) wStr ( 7 : 10 ) = Char4Digits ( DDEE ) IF ( wStr ( 1 : 1 ) == '0' ) THEN Start = 2 END IF Finish = 10 END IF IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_YYLL !****************************************************************************** FUNCTION I32_ToChar_JEA ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit integer to a decimal string using JEA algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 REAL ( KIND = QP ), PARAMETER :: R1 = 1.0_QP REAL ( KIND = QP ), PARAMETER :: R2 = 2.0_QP INTEGER ( KIND = I8B ), PARAMETER :: K24 = INT ( R2 ** 24 / 1.0E2_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K32 = INT ( R2 ** 32 / 1.0E4_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K48 = INT ( R2 ** 48 / 1.0E6_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K57 = INT ( R2 ** 57 / 1.0E8_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M24 = SHIFTL ( 1_I8B , 24 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M32 = SHIFTL ( 1_I8B , 32 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M57 = SHIFTL ( 1_I8B , 57 ) - 1_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I8B ) :: F0 , F2 , F4 , F6 , F8 !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 10000_I8B ) THEN ! 3-4 digits F0 = K24 * PosNum F2 = IAND ( F0 , M24 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 24 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 24 )) Finish = 4 ELSEIF ( PosNum < 1000000_I8B ) THEN ! 5-6 digits F0 = K32 * PosNum F2 = IAND ( F0 , M32 ) * 100_I8B F4 = IAND ( F2 , M32 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 32 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 32 )) wStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 32 )) Finish = 6 ELSEIF ( PosNum < 100000000_I8B ) THEN ! 7-8 digits F0 = SHIFTR ( K48 * PosNum , 16 ) F2 = IAND ( F0 , M32 ) * 100_I8B F4 = IAND ( F2 , M32 ) * 100_I8B F6 = IAND ( F4 , M32 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 32 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 32 )) wStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 32 )) wStr ( 7 : 8 ) = Char2Digits ( SHIFTR ( F6 , 32 )) Finish = 8 ELSE ! 9-10 digits F0 = K57 * PosNum F2 = IAND ( F0 , M57 ) * 100_I8B F4 = IAND ( F2 , M57 ) * 100_I8B F6 = IAND ( F4 , M57 ) * 100_I8B F8 = IAND ( F6 , M57 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 57 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 57 )) wStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 57 )) wStr ( 7 : 8 ) = Char2Digits ( SHIFTR ( F6 , 57 )) wStr ( 9 : 10 ) = Char2Digits ( SHIFTR ( F8 , 57 )) Finish = 10 END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MinI32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToChar_JEA !------------------------------------------------------------------------------ ! !                           64-BIT INTEGER ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I64_ToChar_Basic ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using basic (naive) algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 19 INTEGER ( KIND = I8B ), PARAMETER :: Base = 10_I8B CHARACTER ( LEN = 1 ), PARAMETER :: NumStr ( 0 : 9 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I8B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I8B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I8B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0_I8B ) THEN cStr = '0' RETURN END IF IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = PosNum / Base ! compute the remainder RemNum = CurNum - PosNum * Base ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0_I8B ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0_I8B ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I64_ToChar_Basic !****************************************************************************** FUNCTION I64_ToChar_CC ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using CC algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 19 INTEGER ( KIND = I8B ), PARAMETER :: Div1E8 = 100000000_I8B ! multiplier and shift for 19 digits and divisor of 1.0E8 INTEGER ( KIND = I8B ), PARAMETER :: M90 = INT ( Z 'ABCC77118461CEFD' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: S90 = 90 - 64 ! multiplier for 11 digits and divisor of 1.0E8 INTEGER ( KIND = I8B ), PARAMETER :: M64 = INT ( Z '0000002AF31DC462' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I8B ) :: NxtNum , RemNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 1000000000_I8B ) THEN ! utilize I32_ToChar_CC routine cStr = I32_ToChar_CC ( INT ( Number , KIND = I4B )) RETURN ELSE ! compute NxtNum = PosNum/100000000 NxtNum = SHIFTR ( U128_Multiply_High ( PosNum , M90 ), S90 ) ! compute RemNum = MOD(PosNum, 100000000) RemNum = PosNum - NxtNum * Div1E8 ! convert the remainder to a working string CALL Write_8_Digits ( INT ( RemNum , KIND = I4B ), wStr ( 12 : 19 )) PosNum = NxtNum IF ( PosNum > Div1E8 ) THEN ! compute NxtNum = PosNum/100000000 NxtNum = U128_Multiply_High ( PosNum , M64 ) ! compute RemNum = MOD(PosNum, 100000000) RemNum = PosNum - NxtNum * Div1E8 ! convert the remainder to a working string CALL Write_8_Digits ( INT ( RemNum , KIND = I4B ), wStr ( 4 : 11 )) ! convert the rest IF ( NxtNum < 10 ) THEN wStr ( 3 : 3 ) = Char2Digits ( NxtNum )( 2 : 2 ) Start = 3 ELSEIF ( NxtNum < 100 ) THEN wStr ( 2 : 3 ) = Char2Digits ( NxtNum ) Start = 2 ELSE wStr ( 1 : 3 ) = Char4Digits ( NxtNum )( 2 : 4 ) Start = 1 END IF ELSE ! convert the rest Start = 3 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 4 : 11 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: ! multiplier and shift for 4-byte integer and divisor of 10000 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosNum , NxtNum , RemNum !** FLOW ! set working number PosNum = Number ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = PosNum - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) ! convert the rest cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE PARAMETER DECLARATIONS: ! multiplier and shift for 4-byte integer and divisor of 10000 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosNum , NxtNum , RemNum !** FLOW PosNum = Number IF ( PosNum < 10000 ) THEN IF ( PosNum < 100 ) THEN cStr ( 7 : 8 ) = Char2Digits ( PosNum ) Start = 7 IF ( cStr ( Start : Start ) == '0' ) Start = 8 ELSE cStr ( 5 : 8 ) = Char4Digits ( PosNum ) Start = 5 IF ( cStr ( Start : Start ) == '0' ) Start = 6 END IF ELSE ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = PosNum - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) IF ( NxtNum < 100 ) THEN cStr ( 3 : 4 ) = Char2Digits ( NxtNum ) Start = 3 IF ( cStr ( Start : Start ) == '0' ) Start = 4 ELSE cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) Start = 2 END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** END FUNCTION I64_ToChar_CC !****************************************************************************** FUNCTION I64_ToChar_YY ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using YY algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum , TmpNum , HiNum , LoNum , MidNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start conversion and store digits in working string IF ( PosNum < 100000000_I8B ) THEN ! 1-8 digits Start = 12 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 13 : 20 )) ELSEIF ( PosNum < 10000000000000000_I8B ) THEN ! 9-16 digits HiNum = PosNum / 100000000_I8B LoNum = PosNum - HiNum * 100000000_I8B ! MOD(PosNum, 100000000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) Start = 4 + Write_1_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 5 : 12 )) ELSE ! 17-20 digits TmpNum = PosNum / 100000000_I8B LoNum = PosNum - TmpNum * 100000000_I8B ! MOD(PosNum, 100000000) HiNum = TmpNum / 10000_I8B MidNum = TmpNum - HiNum * 10000_I8B ! MOD(TmpNum, 10000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) CALL Write_4_Digits ( INT ( MidNum , KIND = I4B ), wStr ( 9 : 12 )) Start = Write_5_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 1 : 8 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB ! working indices !** FLOW AA = SHIFTR ( Number * 5243 , 19 ) ! Number / 100 BB = Number - AA * 100 ! MOD(Number, 100) cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD ! working variables !** FLOW IF ( Number < 100 ) THEN ! 1-2 digits AA = Number IF ( AA < 10 ) THEN cStr ( 8 : 8 ) = Char2Digits ( AA )( 2 : 2 ) Start = 8 ELSE cStr ( 7 : 8 ) = Char2Digits ( AA ) Start = 7 END IF ELSEIF ( Number < 10000 ) THEN ! 3-4 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 5243_I8B , 19 ), KIND = I4B ) ! Number / 100 BB = Number - AA * 100 ! MOD(Number, 100) IF ( AA < 10 ) THEN cStr ( 6 : 6 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 7 : 8 ) = Char2Digits ( BB ) Start = 6 ELSE cStr ( 5 : 6 ) = Char2Digits ( AA ) cStr ( 7 : 8 ) = Char2Digits ( BB ) Start = 5 END IF ELSEIF ( Number < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 429497_I8B , 32 ), KIND = I4B ) ! Number / 10000 BBCC = Number - AA * 10000 ! MOD(Number, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) IF ( AA < 10 ) THEN cStr ( 4 : 4 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 4 ELSE cStr ( 3 : 4 ) = Char2Digits ( AA ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 3 END IF ELSEIF ( Number < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) IF ( AA < 10 ) THEN cStr ( 2 : 2 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 2 ELSE cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 1 END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** FUNCTION Write_5_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_5_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 5 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD ! working variables !** FLOW IF ( Number < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 429497_I8B , 32 ), KIND = I4B ) ! Number / 10000 BBCC = Number - AA * 10000 ! MOD(Number, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) IF ( AA < 10 ) THEN cStr ( 4 : 4 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 4 ELSE cStr ( 3 : 4 ) = Char2Digits ( AA ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 3 END IF ELSEIF ( Number < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) IF ( AA < 10 ) THEN cStr ( 2 : 2 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 2 ELSE cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 1 END IF END IF RETURN END FUNCTION Write_5_to_8_Digits !************************************************************************** END FUNCTION I64_ToChar_YY !****************************************************************************** FUNCTION I64_ToChar_YYLL ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using YY algorithm with large table IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum , TmpNum , HiNum , LoNum , MidNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start conversion and store digits in working string IF ( PosNum < 100000000_I8B ) THEN ! 1-8 digits Start = 12 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 13 : 20 )) ELSEIF ( PosNum < 10000000000000000_I8B ) THEN ! 9-16 digits HiNum = PosNum / 100000000_I8B LoNum = PosNum - HiNum * 100000000_I8B ! MOD(PosNum, 100000000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) Start = 4 + Write_1_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 5 : 12 )) ELSE ! 17-20 digits TmpNum = PosNum / 100000000_I8B LoNum = PosNum - TmpNum * 100000000_I8B ! MOD(PosNum, 100000000) HiNum = TmpNum / 10000_I8B MidNum = TmpNum - HiNum * 10000_I8B ! MOD(TmpNum, 10000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) CALL Write_4_Digits ( INT ( MidNum , KIND = I4B ), wStr ( 9 : 12 )) Start = Write_5_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 1 : 8 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW cStr ( 1 : 4 ) = Char4Digits ( Number ) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD !** FLOW IF ( Number < 10000 ) THEN ! 1-4 digits cStr ( 5 : 8 ) = Char4Digits ( Number ) Start = 5 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 6 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 7 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 8 END IF END IF END IF ELSE ! 5-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 2 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 3 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 4 END IF END IF END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** FUNCTION Write_5_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_5_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 5 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 2 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 3 IF ( cStr ( Start : Start ) == '0' ) THEN Start = 4 END IF END IF END IF RETURN END FUNCTION Write_5_to_8_Digits !************************************************************************** END FUNCTION I64_ToChar_YYLL !****************************************************************************** FUNCTION I64_ToChar_JEA ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit integer to a decimal string using JEA algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 REAL ( KIND = QP ), PARAMETER :: R1 = 1.0_QP REAL ( KIND = QP ), PARAMETER :: R2 = 2.0_QP INTEGER ( KIND = I8B ), PARAMETER :: K24 = INT ( R2 ** 24 / 1.0E2_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K32 = INT ( R2 ** 32 / 1.0E4_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K48 = INT ( R2 ** 48 / 1.0E6_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K57 = INT ( R2 ** 57 / 1.0E8_QP + R1 , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M24 = SHIFTL ( 1_I8B , 24 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M32 = SHIFTL ( 1_I8B , 32 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: M57 = SHIFTL ( 1_I8B , 57 ) - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: MaxU32 = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) !  4,294,967,296 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I8B ) :: F0 , F2 , F4 , F6 , F8 INTEGER ( KIND = I8B ) :: Z , Y !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 1000000_I8B ) THEN ! 3-6 digits IF ( PosNum < 10000_I8B ) THEN ! 3-4 digits CALL Write_4_Digits ( PosNum , wStr ( 1 : 4 )) Finish = 4 ELSE ! 5-6 digits CALL Write_6_Digits ( PosNum , wStr ( 1 : 6 )) Finish = 6 END IF ELSEIF ( PosNum < MaxU32 ) THEN ! 7-10 digits IF ( PosNum < 100000000_I8B ) THEN ! 7-8 digits CALL Write_8_Digits ( PosNum , wStr ( 1 : 8 )) Finish = 8 ELSE ! 9-10 digits CALL Write_10_Digits ( PosNum , wStr ( 1 : 10 )) Finish = 10 END IF ELSE Z = MOD ( PosNum , 100000000_I8B ) PosNum = PosNum / 100000000_I8B IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Start = 3 ELSEIF ( PosNum < 1000000_I8B ) THEN ! 3-6 digits IF ( PosNum < 10000_I8B ) THEN ! 3-4 digits CALL Write_4_Digits ( PosNum , wStr ( 1 : 4 )) Start = 5 ELSE ! 5-6 digits CALL Write_6_Digits ( PosNum , wStr ( 1 : 6 )) Start = 7 END IF ELSEIF ( PosNum < 100000000_I8B ) THEN ! 7-8 digits CALL Write_8_Digits ( PosNum , wStr ( 1 : 8 )) Start = 9 ELSEIF ( PosNum < MaxU32 ) THEN ! 9-10 digits CALL Write_10_Digits ( PosNum , wStr ( 1 : 10 )) Start = 11 ELSE Y = MOD ( PosNum , 100000000_I8B ) PosNum = PosNum / 100000000_I8B ! n is 2, 3, or 4 digits (if n < 10 it would have been handled above) IF ( PosNum < 100_I8B ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Start = 3 ELSE F0 = K24 * PosNum F2 = IAND ( F0 , M24 ) * 100_I8B wStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 24 )) wStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 24 )) Start = 5 END IF ! do 8 digits Finish = Start + 7 CALL Write_8_Digits ( Y , wStr ( Start : Finish )) Start = Finish + 1 END IF ! do 8 digits Finish = Start + 7 CALL Write_8_Digits ( Z , wStr ( Start : Finish )) END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MinI64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN CONTAINS SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F0 = K24 * Number F2 = IAND ( F0 , M24 ) * 100_I8B cStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 24 )) cStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 24 )) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** SUBROUTINE Write_6_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_6_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 6 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F0 = K32 * Number F2 = IAND ( F0 , M32 ) * 100_I8B F4 = IAND ( F2 , M32 ) * 100_I8B cStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 32 )) cStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 32 )) cStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 32 )) RETURN END SUBROUTINE Write_6_Digits !************************************************************************** SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( Number * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = INT ( Number - AABB * 10000 , KIND = I4B ) ! MOD(Number, 10000) cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) ! Note: the following statements (original code by JEA algorithm) !       do not write correct numbers sometimes !        F0 = SHIFTR(K48*Number, 16) !        F2 = IAND(F0, M32)*100_I8B !        F4 = IAND(F2, M32)*100_I8B !        F6 = IAND(F4, M32)*100_I8B !        cStr(1:2) = Char2Digits(SHIFTR(F0, 32)) !        cStr(3:4) = Char2Digits(SHIFTR(F2, 32)) !        cStr(5:6) = Char2Digits(SHIFTR(F4, 32)) !        cStr(7:8) = Char2Digits(SHIFTR(F6, 32)) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_10_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_10_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F0 = K57 * Number F2 = IAND ( F0 , M57 ) * 100_I8B F4 = IAND ( F2 , M57 ) * 100_I8B F6 = IAND ( F4 , M57 ) * 100_I8B F8 = IAND ( F6 , M57 ) * 100_I8B cStr ( 1 : 2 ) = Char2Digits ( SHIFTR ( F0 , 57 )) cStr ( 3 : 4 ) = Char2Digits ( SHIFTR ( F2 , 57 )) cStr ( 5 : 6 ) = Char2Digits ( SHIFTR ( F4 , 57 )) cStr ( 7 : 8 ) = Char2Digits ( SHIFTR ( F6 , 57 )) cStr ( 9 : 10 ) = Char2Digits ( SHIFTR ( F8 , 57 )) RETURN END SUBROUTINE Write_10_Digits !************************************************************************** END FUNCTION I64_ToChar_JEA !****************************************************************************** END MODULE ModBase_Integer_ToChar !******************************************************************************","tags":"","loc":"sourcefile\\modbase - integer - tochar.f90.html"},{"title":"ModBase - Common.f90 – FortCharConv","text":"Source Code MODULE ModBase_Common !&#94; **PURPOSE OF THIS MODULE**: ! contains parameters and derived types commonly used !** USE STATEMENTS: USE , INTRINSIC :: ISO_FORTRAN_ENV , ONLY : INT8 , INT16 , INT32 , INT64 , REAL32 , REAL64 , REAL128 USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_PTR , C_NULL_PTR IMPLICIT NONE ! Enforce explicit typing of all variables PUBLIC ! By default, all parameters which are placed in this data-only ! module should be available to other modules and routines. ! Thus, all parameters in this module must be PUBLIC. !** MODULE PARAMETERS: ! symbolic names for kind types of 8-, 4-, 2-, and 1-byte integers: INTEGER , PARAMETER :: I8B = INT64 !! kind for 64-bit or 8-byte integer INTEGER , PARAMETER :: I4B = INT32 !! kind for 32-bit or 4-byte integer INTEGER , PARAMETER :: I2B = INT16 !! kind for 16-bit or 2-byte integer INTEGER , PARAMETER :: I1B = INT8 !! kind for  8-bit or 1-byte integer ! symbolic names for kind types of quadruple-, double-, and single-precision reals: INTEGER , PARAMETER :: QP = REAL128 !! kind for 128-bit floating point (real) number INTEGER , PARAMETER :: DP = REAL64 !! kind for  64-bit floating point (real) number INTEGER , PARAMETER :: SP = REAL32 !! kind for  32-bit floating point (real) number ! true and false values LOGICAL , PARAMETER :: TrueVal = . TRUE . !! LOGICAL , PARAMETER :: FalseVal = . FALSE . !! ! kinds of numeric precision INTEGER , PARAMETER :: IP = I4B !! kind of indices INTEGER , PARAMETER :: FP = DP !! kind of default floating point (real) number ! angle unit flag INTEGER , PARAMETER :: Degree = 1 !! INTEGER , PARAMETER :: Radian = 2 !! ! commonly used numeric constants (i.e. whole real number) REAL ( KIND = FP ), PARAMETER :: Zero = 0.0_FP !! REAL ( KIND = FP ), PARAMETER :: One = 1.0_FP !! REAL ( KIND = FP ), PARAMETER :: Two = 2.0_FP !! REAL ( KIND = FP ), PARAMETER :: Three = 3.0_FP !! REAL ( KIND = FP ), PARAMETER :: Four = 4.0_FP !! REAL ( KIND = FP ), PARAMETER :: Five = 5.0_FP !! REAL ( KIND = FP ), PARAMETER :: Six = 6.0_FP !! REAL ( KIND = FP ), PARAMETER :: Seven = 7.0_FP !! REAL ( KIND = FP ), PARAMETER :: Eight = 8.0_FP !! REAL ( KIND = FP ), PARAMETER :: Nine = 9.0_FP !! REAL ( KIND = FP ), PARAMETER :: Ten = 1 0.0_FP !! REAL ( KIND = FP ), PARAMETER :: Hundred = 10 0.0_FP !! REAL ( KIND = FP ), PARAMETER :: Thousand = 100 0.0_FP !! REAL ( KIND = FP ), PARAMETER :: Million = 100000 0.0_FP !! REAL ( KIND = FP ), PARAMETER :: Billion = 100000000 0.0_FP !! ! common fractions REAL ( KIND = FP ), PARAMETER :: Quater = 0.25_FP !! REAL ( KIND = FP ), PARAMETER :: Half = 0.5_FP !! REAL ( KIND = FP ), PARAMETER :: ThreeQuater = 0.75_FP !! REAL ( KIND = FP ), PARAMETER :: OneThird = One / Three !! REAL ( KIND = FP ), PARAMETER :: TwoThird = Two / Three !! ! frequently used mathematical constants (with precision to spare): REAL ( KIND = FP ), PARAMETER :: Pi = 3.141592653589793238462643383279502884197169399375105820974944592307_FP !! REAL ( KIND = FP ), PARAMETER :: PiOvr2 = Half * Pi !! REAL ( KIND = FP ), PARAMETER :: Pi3Ovr2 = 1.5_FP * Pi !! REAL ( KIND = FP ), PARAMETER :: TwoPi = Two * Pi !! ! defined tolerance value REAL ( KIND = FP ), PARAMETER :: Zero01 = 1.0E-1_FP !! REAL ( KIND = FP ), PARAMETER :: Zero02 = 1.0E-2_FP !! REAL ( KIND = FP ), PARAMETER :: Zero03 = 1.0E-3_FP !! REAL ( KIND = FP ), PARAMETER :: Zero04 = 1.0E-4_FP !! REAL ( KIND = FP ), PARAMETER :: Zero05 = 1.0E-5_FP !! REAL ( KIND = FP ), PARAMETER :: Zero06 = 1.0E-6_FP !! REAL ( KIND = FP ), PARAMETER :: Zero07 = 1.0E-7_FP !! REAL ( KIND = FP ), PARAMETER :: Zero08 = 1.0E-8_FP !! REAL ( KIND = FP ), PARAMETER :: Zero09 = 1.0E-9_FP !! REAL ( KIND = FP ), PARAMETER :: Zero10 = 1.0E-10_FP !! REAL ( KIND = FP ), PARAMETER :: Zero11 = 1.0E-11_FP !! REAL ( KIND = FP ), PARAMETER :: Zero12 = 1.0E-12_FP !! REAL ( KIND = FP ), PARAMETER :: Zero13 = 1.0E-13_FP !! REAL ( KIND = FP ), PARAMETER :: Zero14 = 1.0E-14_FP !! REAL ( KIND = FP ), PARAMETER :: Zero15 = 1.0E-15_FP !! REAL ( KIND = FP ), PARAMETER :: Zero16 = 1.0E-16_FP !! REAL ( KIND = FP ), PARAMETER :: Zero17 = 1.0E-17_FP !! ! machine dependent parameters REAL ( KIND = FP ), PARAMETER :: MachineEps = EPSILON ( One ) !! machine epsilon REAL ( KIND = FP ), PARAMETER :: Small = TINY ( One ) !! the smallest positive number REAL ( KIND = FP ), PARAMETER :: Large = HUGE ( One ) !! the largest positive number REAL ( KIND = FP ), PARAMETER :: SqrtEps = SQRT ( MachineEps ) !! square root of MachineEps ! huge (maximum) numbers for intrinsic types used to prevent overflow INTEGER ( KIND = I1B ), PARAMETER :: Huge_I1B = HUGE ( 1_I1B ) !! = 127 INTEGER ( KIND = I2B ), PARAMETER :: Huge_I2B = HUGE ( 1_I2B ) !! = 32767 INTEGER ( KIND = I4B ), PARAMETER :: Huge_I4B = HUGE ( 1_I4B ) !! = 2147483647 INTEGER ( KIND = I8B ), PARAMETER :: Huge_I8B = HUGE ( 1_I8B ) !! = 9223372036854775807 REAL ( KIND = SP ), PARAMETER :: Huge_RSP = HUGE ( 1.0_SP ) !! = 3.4028235E+38 REAL ( KIND = DP ), PARAMETER :: Huge_RDP = HUGE ( 1.0_DP ) !! = 1.797693134862316E+308 REAL ( KIND = QP ), PARAMETER :: Huge_RQP = HUGE ( 1.0_QP ) !! = 1.189731495357231765085759326628007E+4932 ! tiny (positive minimum) numbers for floating point types used to prevent underflow (normal range) REAL ( KIND = SP ), PARAMETER :: Tiny_RSP = TINY ( 1.0_SP ) !! = 1.1754944E-38 REAL ( KIND = DP ), PARAMETER :: Tiny_RDP = TINY ( 1.0_DP ) !! = 2.225073858507201E-308 REAL ( KIND = QP ), PARAMETER :: Tiny_RQP = TINY ( 1.0_QP ) !! = 3.362103143112093506262677817321753E-4932 ! machine epsilon numbers for floating point types used to check accuracy tolerance REAL ( KIND = SP ), PARAMETER :: Eps_RSP = EPSILON ( 1.0_SP ) !! = 1.1920929E-07 REAL ( KIND = DP ), PARAMETER :: Eps_RDP = EPSILON ( 1.0_DP ) !! = 2.220446049250313E-016 REAL ( KIND = QP ), PARAMETER :: Eps_RQP = EPSILON ( 1.0_QP ) !! = 1.925929944387235853055977942584927E-0034 ! miscellaneous CHARACTER ( LEN =* ), PARAMETER :: LibName = \"XPFLib\" !! library name !** DERIVED TYPE DEFINITIONS TYPE Equation !&#94; an equation type that can be used to parse strings/texts expressing !   mathematical expressions to 'FunctionParser' so that a system of !   equations can be evaluated at runtime. INTEGER ( KIND = IP ) :: NEQ !! number of equations INTEGER ( KIND = IP ) :: NVR !! number of variables CHARACTER ( LEN = 256 ), ALLOCATABLE :: EQText (:) !! texts expressing equations CHARACTER ( LEN = 30 ), ALLOCATABLE :: VarText (:) !! texts expressing variable names REAL ( KIND = FP ), ALLOCATABLE :: Values (:) !! values of variables END TYPE Equation TYPE UserParam !! a user parameter type used to modernize legacy code INTEGER ( KIND = IP ) :: NR !! number of real parameters INTEGER ( KIND = IP ) :: NI !! number of integer parameters REAL ( KIND = FP ), ALLOCATABLE :: RPar (:) !! real parameters INTEGER ( KIND = IP ), ALLOCATABLE :: IPar (:) !! integer parameters END TYPE UserParam TYPE WorkSpace !! a workspace type used to modernize legacy code INTEGER ( KIND = IP ) :: LRW !! number of real workspace variables INTEGER ( KIND = IP ) :: LIW !! number of integer workspace variables REAL ( KIND = FP ), ALLOCATABLE :: RVar (:) !! real workspace variables INTEGER ( KIND = IP ), ALLOCATABLE :: IVar (:) !! integer workspace variables END TYPE WorkSpace TYPE SharePar ( NR , NI ) !! a share parameter type used to modernize common block of legacy code INTEGER ( KIND = IP ), LEN :: NR , NI !! number of real and integer parameters REAL ( KIND = FP ) :: RPar ( NR ) !! real parameters INTEGER ( KIND = IP ) :: IPar ( NI ) !! integer parameters END TYPE SharePar TYPE SaveVar ( NR , NI , NL ) !! a saved variable type used to modernize legacy code INTEGER ( KIND = IP ), LEN :: NR , NI , NL !! number of real, integer and logical parameters REAL ( KIND = FP ) :: RVar ( NR ) !! number of real parameters INTEGER ( KIND = IP ) :: IVar ( NI ) !! number of integer parameters LOGICAL :: LVar ( NL ) !! number of logical parameters END TYPE SaveVar TYPE , BIND ( C ) :: Container !! container type that utilize 'c' pointer (C_PTR) type TYPE ( C_PTR ) :: Store = C_NULL_PTR END TYPE Container !** MODULE VARIABLE DECLARATIONS: ! na END MODULE ModBase_Common !******************************************************************************","tags":"","loc":"sourcefile\\modbase - common.f90.html"},{"title":"ModBase - RealDP - CharConv.f90 – FortCharConv","text":"Source Code MODULE ModBase_RealDP_CharConv !&#94; **PURPOSE OF THIS MODULE**: ! This module contains routines that perform a conversion between a 64-bit !   floating point number and a string. ! !&#94; **REFERENCE TECHNICAL ARTICLES**: ! [1]  Junekey Jeon.  [Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm](https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf) ! [2]  Ulf Adams.  [Ryu: Fast Float-to-String Conversion](https://dl.acm.org/doi/10.1145/3192366.3192369) ! [3]  Raffaello Giulietti.  [The Schubfach way to render doubles](https://drive.google.com/open?id=1luHhyQF9zKlM8yJ1nebU0OgVYhfC6CBN) ! [4]  Clinger WD. [How to Read Floating Point Numbers Accurately](https://doi.org/10.1145/989393.989430), !   SIGPLAN Not 2004 Apr;39(4):360–371. ! [5]  Daniel Lemire.  [Number Parsing at a Gigabyte per Second](https://arxiv.org/abs/2101.11408), !   Software: Practice and Experience 51 (8), 2021. ! [6]  Noble Mushtak and Daniel Lemire.  [Fast Number Parsing Without Fallback](https://arxiv.org/abs/2212.06644), !   Software: Practice and Experience 53 (7), 2023. ! [7]  Bouvier & Zimmermann.  [Division-Free Binary-to-Decimal Conversion](https://hal.inria.fr/hal-00864293v1/document) ! [8]  Hacker's Delight, 2nd Edition. ! [9]  Nigel Tao.  [The Eisel-Lemire ParseNumberF64 Algorithm](https://nigeltao.github.io/blog/2020/eisel-lemire.html) ! [10] Nigel Tao.  [ParseNumberF64 by Simple Decimal Conversion](https://nigeltao.github.io/blog/2020/parse-number-f64-simple.html) ! !&#94; **REFERENCE CODE IMPLEMENTATION**: ! [11] [DragonBox: C++ reference implementation](https://github.com/jk-jeon/dragonbox) ! [12] [Ryu: C reference implementation](https://github.com/ulfjack/ryu) ! [13] [Schubfach: Java reference implementation](https://github.com/c4f7fcce9cb06515/Schubfach) ! [14] [Drachennest: Different algorithms for converting binary to decimal floating-point numbers](https://github.com/abolz/Drachennest) ! [15] [Number Conversion Benchmark in C](https://github.com/ibireme/c_numconv_benchmark) ! [16] [fast_float number parsing library: 4x faster than strtod](https://github.com/fastfloat/fast_float) ! [17] [fast_double_parser: 4x faster than strtod](https://github.com/lemire/fast_double_parser) ! [18] [The LLVM Project: LibC Support](https://github.com/llvm/llvm-project/tree/main/libc/src/__support) ! [19] [Double Conversion: Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles](https://github.com/google/double-conversion) ! [20] [fmt: A modern formatting library](https://github.com/fmtlib/fmt) ! !&#94; **TECHNICAL AND IMPLEMENTATION NOTES**: ! ***On the output to string***: ! 1) Three routines are available to convert a real (floating-point) number into a string. !    - \"RealToString_DragonBox\" is based on the Dragonbox binary-to-decimal conversion algorithm [1] !      and the reference implementation [11, 14, 20] !    - \"RealToString_Ryu\" is based on the Ryu binary-to-decimal conversion algorithm [2] !      and the reference implementation [12, 14] !    - \"RealToString_Schubfach\" is based on the Schubfach binary-to-decimal conversion algorithm [3] !      and the reference implementation [13, 14, 15] ! 2) All three binary-to-decimal conversion algorithms employed here produce the so-called shortest !    output representation that provide an error-free write-read cycle.  This means that any correct !    parsers (e.g. RealFromString routines) will read in the output string and return the original !    real (floating-poing) number. ! 3) Although the DragonBox reference implementation provides several modes of rounding, only the !    round-to-nearest mode is implemented here (the other two algorithms also use this mode). ! 4) Although the Ryu reference implementation provides several conversion output formats (Shortest, !    Scientific, Fixed), only the shortest representation (as mentioned above) is implemented. !    Therefore, all three routines will produces the output string in a format similar to \"G0\" format !    specification in Fortran. ! 5) Actually, the RealToString routines have an optional \"format\" argument that we can use to specify !    whether to output the string in \"General (G)\" or \"Scientific (ES)\" format.  However, because they !    always produce the shortest output, no input argument to the routines is provided to specify !    the desired number of significant digits as typically done in Fortran format specifications. ! ***On the input from string***: ! 1) Four routines are available to convert a string into a real (floating-point) number.  All four !    routines utilize the so-call Clinger's fast-path algorithm [4].  Three of them (except \"YY\") employ !    the so-call Eisel-Lemire decimal-to-binary conversion algorithm [5, 9] but are based on different !    reference implementation.  When the Eisel-Lemire (or YY's fast-path) algorithm is NOT valid, three !    of the routines (except \"LibC\") use multi-precision (unsigned) integer arithmetic (i.e. BigUInt) !    whereas \"LibC\" employs the so-call Simple Decimal Conversion algorithm [10]. !    - \"RealFromString_FastFloat\" is based on the reference implementation [16] !    - \"RealFromString_LibC\" is based on the reference implementation [18] !    - \"RealFromString_YY\" is based on the reference implementation [15, 19] !    - \"RealFromString_Lemire\" is based on the reference implementation [17, 19] ! 2) The RealFromString routines have an optional \"parsing\" argument that we can use to specify how !    the routines interpret the input string. ! 3) The \"Parse_Fortran_String\" routine is called when the optional \"parsing\" argument is not specified !    (i.e. the default option) or \"FortNum (or 1)\" value is supplied as the parsing argument.  The routine !    will interpret the input string as a valid Fortran real (floating point) number if it has one of !    the two following forms: !    <1> A number without exponent part -> [S]N[N...] !    <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] !       where !       [ ] indicates an optional field !       S is a sign indicator (required if negative '-', optional if positive '+'). !       N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere !           after the sign (but before the exponent). !       E is an exponent indicator (either 'e' or 'E') !    The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. !    - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. !    - The optional kind parameter (e.g. 10.0_DP) is not allowed here. !    Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered !    valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\" !    is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement !    where spaces inside the valid number are allowed. However, this can easily be done by adding an !    optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or 'ignored'. !    Then, the input will be pre-processed according to the flag.  Nonetheless, this routine neglects !    this optional input because it will make the routine much less efficient due to the fact that !    we will need to scan the whole string twice and we will also need to copy the input string into !    a buffer string and working with the buffer instead of directly handling the input string. ! 4) The \"Parse_FPlus_String\" routine is called when \"FPlusNum (or 2)\" value is supplied as the parsing !    argument.  The routine will parse a valid Fortran real (floating point) number with more relaxed !    rules than those used in \"Parse_Fortran_Number\" routine. The relaxed rules consider the following !    numbers as valid: !    - a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' !      in place of 'e' or 'E'. !    - a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to !      be expressed in a valid number expressed in the scientific format. !    - digits before any invalid character encountered are treated as a valid number !      and any characters after the first encounter (including the first invalid one) !      are neglected.  therefore, for example, a '12.56ax-300' is considered to be !      a valid number with a value of 12.56. ! 5) The \"Parse_JSON_String\" routine is called when \"JsonNum (or 3)\" value is supplied as the parsing !    argument.  The routine will parse a valid JSON floating point number where its differences from !    from Fortran number are as follows: !    - leading and trailing spaces are not allowed. !    - a plus sign as the first character is not allowed. !    - leading zero(s) is not allowed (if 0 is the first character, the second one !      must either be a period or an exponent indicator.) !    - a period must be followed by at least one digit. ! !&#94; **USAGE**: ! ***On the output to string***: ! => cStr = RealXP_ToString_DragonBox(Number, IsScientific) ! => cStr = RealXP_ToString_Ryu(Number, IsScientific) ! => cStr = RealXP_ToString_Schubfach(Number, IsScientific) !   where !   \"cStr\" is an \"allocatable\" character string representing the output string !   \"Number\" is a real number representing the floating point value !   \"IsScientific\" is a logical flag (optional argument) indicating whether !       the output string is in \"General\" or \"Scientific\" format. !       If present and true, the output string is in \"Scientific\" format. !       Otherwise, the output string is in \"General\" format. ! ***On the input from string***: ! => Number = RealXP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) !   where !   \"Number\" is a real number representing the floating point value if the input string is valid !   \"cStr\" is a character string representing the floating-point number string !   \"ParseOpt\" is an integer input flag (optional) indicating how to interpret the input string. !       The valid value is FortNum (1), FPlusNum (2) or JsonNum (3). !       If not specified and invalid, the routines will interpret the input string as a Fortran number. !   \"ErrFlag\" is a logical output flag (optional) indicating whether there is an error in parsing !       the input string.  True if the string represents a valid number.  False, otherwise. !   \"ErrMsg\" is an allocatable output character string (optional) that returns a message that describe !       the result of parsing the input string. ! **NOTE**: \"XP\" in the routine names shown above indicate the precision of the real number. !   The actual name will either be \"RealSP_...\", \"RealDP_...\" or \"RealQP_...\" for single-precision, !   double-precision and quadruple-precision number, respectively. !** USE STATEMENTS: USE ModBase_Common USE ModBase_SIntUtil USE ModBase_UIntUtil USE ModBase_UInt128 USE ModBase_Tables_CharConv USE , INTRINSIC :: IEEE_ARITHMETIC IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! Real-To-String PUBLIC :: RealDP_ToString_DragonBox PUBLIC :: RealDP_ToString_Ryu PUBLIC :: RealDP_ToString_Schubfach ! Real-From-String PUBLIC :: RealDP_FromString_FastFloat PUBLIC :: RealDP_FromString_LibC PUBLIC :: RealDP_FromString_YY PUBLIC :: RealDP_FromString_Lemire PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! options for type of number to be parsed INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: FortNum = 1 !! strict fortran number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: FPlusNum = 2 !! relaxed fortran number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: JsonNum = 3 !! json number ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ parameters used to convert bit widths to whole decimal digits +++ INTEGER ( KIND = I8B ), PARAMETER :: LB2To10_M1 = 301029995664_I8B ! LogBaseTenOfTwoTimesTenToThe12th INTEGER ( KIND = I8B ), PARAMETER :: LB2To10_M2 = 1000000000000_I8B ! TenToThe12th ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ Characteristics of IEEE-754 & related binary floating-point numbers +++ INTEGER ( KIND = I4B ), PARAMETER :: RealKind = 8 INTEGER ( KIND = I4B ), PARAMETER :: BinaryPrecision = 53 INTEGER ( KIND = I4B ), PARAMETER :: TotalBits = 64 INTEGER ( KIND = I4B ), PARAMETER :: SignBits = TotalBits - 1 ! 63 INTEGER ( KIND = I4B ), PARAMETER :: SignificandBits = BinaryPrecision - 1 ! 52 INTEGER ( KIND = I4B ), PARAMETER :: ExponentBits = TotalBits - BinaryPrecision ! 11 INTEGER ( KIND = I4B ), PARAMETER :: MaxExponent = SHIFTL ( 1 , ExponentBits ) - 1 ! 2047 INTEGER ( KIND = I4B ), PARAMETER :: ExponentBias = SHIFTL ( 1 , ExponentBits - 1 ) - 1 ! 1023 INTEGER ( KIND = I4B ), PARAMETER :: DecimalPrecision = INT (( SignificandBits * LB2To10_M1 ) / LB2To10_M2 , KIND = I4B ) ! 15 INTEGER ( KIND = I4B ), PARAMETER :: DecimalRange = INT ((( ExponentBias - 1 ) * LB2To10_M1 ) / LB2To10_M2 , KIND = I4B ) ! 307 INTEGER ( KIND = I4B ), PARAMETER :: MaxDecimalConversionDigits = 767 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ masking parameters +++ INTEGER ( KIND = I8B ), PARAMETER :: SigHidBitMask = SHIFTL ( 1_I8B , SignificandBits ) INTEGER ( KIND = I8B ), PARAMETER :: SignificandMask = SigHidBitMask - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: SignMask = SHIFTL ( 1_I8B , SignBits ) INTEGER ( KIND = I8B ), PARAMETER :: ExponentMask = NOT ( IOR ( SignMask , SignificandMask )) INTEGER ( KIND = I8B ), PARAMETER :: ExpMantMask = SignificandMask + ExponentMask ! = NOT(SignMask) INTEGER ( KIND = I8B ), PARAMETER :: QuietNaNMask = SHIFTL ( 1_I8B , SignificandBits - 1 ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Exceptional exponent value for NaN or Infinity INTEGER ( KIND = I4B ), PARAMETER :: ExceptionalExponent = INT ( Z '7FFFFFFF' , KIND = I4B ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ maximum and minimum (positive) parameters +++ ! note:  These parameters are stored in an integer data type that have the same number of bits to !        a real data type of the floating point number. !# minimum value of subnormal floating point number INTEGER ( KIND = I8B ), PARAMETER , PUBLIC :: MinSubnormal = 1_I8B !# maximum value of subnormal floating point number INTEGER ( KIND = I8B ), PARAMETER , PUBLIC :: MaxSubnormal = SHIFTL ( 1_I8B , SignificandBits ) - 1_I8B !# minimum value of normal floating point number INTEGER ( KIND = I8B ), PARAMETER , PUBLIC :: MinNormal = SHIFTL ( 1_I8B , SignificandBits ) !# maximum value of normal floating point number INTEGER ( KIND = I8B ), PARAMETER , PUBLIC :: MaxNormal = IOR ( SHIFTL ( INT ( MaxExponent - 1 , KIND = I8B ), & SignificandBits ), MaxSubnormal ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------------------------------- ! -----   parameters for high-precision decmial conversion algorithm  ----- ! ------------------------------------------------------------------------- ! 600 is an arbitrary number of digits, but should be large enough for any practical number. ! Important note: a number of digits large enough to represent the smallest subnormal ! for double-precision number is about 1109 (= 342 + 767). INTEGER ( KIND = I4B ), PARAMETER :: MAX_NUM_DIGITS = 600 ! The maximum amount we can shift is the number of bits used in the Accumulator, ! minus the number of bits needed to represent the base (in this case 4). INTEGER ( KIND = I4B ), PARAMETER :: MAX_SHIFT_AMOUNT = 4 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------------------- ! -----   parameters for BigUInt of FastFloat algorithm  ----- ! ----------------------------------------------------------- ! the number of bits of 'Digit' of BigUInt. INTEGER ( KIND = I4B ), PARAMETER :: DigitBits = 64 ! the total number of bits of a BigUInt that needs to be at least the number of bits ! required to store the largest BigUInt, which is Log2(10**(MaxDigits + MaxExp10)), or ! Log2(10**(767 + 342))`, or ~3684 bits, so we round to 3712. INTEGER ( KIND = I4B ), PARAMETER :: BigUIntBits = 3712 ! the (fixed) capacity of a BigUInt INTEGER ( KIND = I4B ), PARAMETER :: BigCapacity = BigUIntBits / DigitBits ! = 58 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INTEGER ( KIND = I8B ), PARAMETER :: DivBase = 10_I8B INTEGER ( KIND = I8B ), PARAMETER :: MaxDivbyBase = 1844674407370955161_I8B ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ number parameters +++ INTEGER ( KIND = I8B ), PARAMETER :: TwoUInt = 2_I8B INTEGER ( KIND = I8B ), PARAMETER :: ThreeUInt = 3_I8B INTEGER ( KIND = I8B ), PARAMETER :: FourUInt = 4_I8B INTEGER ( KIND = I8B ), PARAMETER :: FiveUInt = 5_I8B INTEGER ( KIND = I8B ), PARAMETER :: FortyUInt = 40_I8B INTEGER ( KIND = I8B ), PARAMETER :: TenUInt = 10_I8B INTEGER ( KIND = I8B ), PARAMETER :: HundredUInt = 100_I8B INTEGER ( KIND = I8B ), PARAMETER :: TenThousandUInt = 10000_I8B ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ---------------------------------------------------- ! -----   Simple-Decimal-Algorithm' parameters   ----- ! ---------------------------------------------------- ! The nth item in Powers_Of_Two represents the greatest power of two less than ! 10&#94;n. This tells us how much we can safely shift without overshooting. INTEGER ( KIND = I1B ), PARAMETER :: Powers_Of_Two ( 0 : 18 ) = & [ 0 , 3 , 6 , 9 , 13 , 16 , 19 , 23 , 26 , 29 , 33 , 36 , 39 , 43 , 46 , 49 , 53 , 56 , 59 ] INTEGER ( KIND = I4B ), PARAMETER :: Num_Powers_Of_Two = SIZE ( Powers_Of_Two ) ! = 19 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! -------------------------------------------------- ! -----   Eisel-Lemire-Algorithm' parameters   ----- ! -------------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: LowBits = TotalBits - SignificandBits - 3 ! = 9 ! The halfway constant is used to check if the bits that will be shifted away intially are all 1. INTEGER ( KIND = I8B ), PARAMETER :: HalfWay = SHIFTL ( 1_I8B , LowBits ) - 1_I8B ! = 511 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! -------------------------------------------------- ! -----   Clinger-Algorithm' parameters   ----- ! -------------------------------------------------- INTEGER ( KIND = I4B ) :: Idx REAL ( KIND = DP ), PARAMETER :: Powers_Of_Ten ( 0 : 22 ) = [( 1 0.0D0 ** Idx , Idx = 0 , 22 )] INTEGER ( KIND = I4B ), PARAMETER :: Num_Exact_Pow10 = 22 INTEGER ( KIND = I4B ), PARAMETER :: Num_Mantissa_Digits = 15 REAL ( KIND = DP ), PARAMETER :: Max_Exact_Integer = 900719925474099 1.0_DP ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INTEGER ( KIND = I4B ), PARAMETER :: Exponent_UppBound = 309 ! = 308 + 1 INTEGER ( KIND = I4B ), PARAMETER :: Exponent_LowBound = - 343 ! = (-324) - 19 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Dragonbox-Algorithm' parameters   ----- ! ----------------------------------------------- ! parameters for main routine INTEGER ( KIND = I4B ), PARAMETER :: Kappa = 2 INTEGER ( KIND = I4B ), PARAMETER :: Big_Divisor = 10 ** ( Kappa + 1 ) ! 1000 INTEGER ( KIND = I4B ), PARAMETER :: Small_Divisor = Big_Divisor / 10 ! 100 INTEGER ( KIND = I4B ), PARAMETER :: Half_Small_Divisor = Small_Divisor / 2 ! 50 INTEGER ( KIND = I4B ), PARAMETER :: Divisibility_Check_By_5_Threshold = 86 INTEGER ( KIND = I4B ), PARAMETER :: Case_Fc_Pm_Half_Lower_Threshold = - 2 ! parameters for short interval case INTEGER ( KIND = I4B ), PARAMETER :: Case_Shorter_Interval_Left_Endpoint_Lower_Threshold = 2 INTEGER ( KIND = I4B ), PARAMETER :: Case_Shorter_Interval_Left_Endpoint_Upper_Threshold = 3 INTEGER ( KIND = I4B ), PARAMETER :: Shorter_Interval_Tie_Lower_Threshold = - 77 INTEGER ( KIND = I4B ), PARAMETER :: Shorter_Interval_Tie_Upper_Threshold = - 77 ! parameters for Is_Divisible_By_Pow10 routine INTEGER ( KIND = I4B ), PARAMETER :: Info_Shift_Amount = 20 INTEGER ( KIND = I4B ), PARAMETER :: OneShiftL = SHIFTL ( 1 , Info_Shift_Amount ) INTEGER ( KIND = I4B ), PARAMETER :: Comparison_Mask = OneShiftL - 1 INTEGER ( KIND = I4B ), PARAMETER :: Magic_Number = OneShiftL / Small_Divisor + 1 ! parameters for Divide_By_10_To_Kappa_Plus_1 INTEGER ( KIND = I8B ), PARAMETER :: DivM = 2361183241434822607_I8B INTEGER ( KIND = I4B ), PARAMETER :: DivS = 7 ! 71 - 64 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Ryu-Algorithm' parameters   ----- ! ----------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: BitsPerPow5 = 128 INTEGER ( KIND = I4B ), PARAMETER :: MaxExp_ModInv5 = 27 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Schubfach-Algorithm' parameters   ----- ! ----------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: Pow10_Min_Exact_Exp = 0 INTEGER ( KIND = I4B ), PARAMETER :: Pow10_Max_Exact_Exp = 55 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   FastFloat-Algorithm' parameters   ----- ! ----------------------------------------------- ! Bias so we can get the real exponent with an invalid adjusted_mantissa INTEGER ( KIND = I4B ), PARAMETER :: Invalid_AM_Bias = - INT ( Z '00008000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: Mantissa_Explicit_Bits = SignificandBits INTEGER ( KIND = I4B ), PARAMETER :: Minimum_Exponent = - ExponentBias INTEGER ( KIND = I4B ), PARAMETER :: Infinite_Power = MaxExponent INTEGER ( KIND = I4B ), PARAMETER :: Sign_Index = SignBits INTEGER ( KIND = I4B ), PARAMETER :: MantTotalBits = 64 ! see section 6 in 'Number Parsing at a Gigabyte per Second' paper for ! how the following two numbers can be obtained INTEGER ( KIND = I4B ), PARAMETER :: Max_Exponent_Round_To_Even = 23 INTEGER ( KIND = I4B ), PARAMETER :: Min_Exponent_Round_To_Even = - 4 INTEGER ( KIND = I4B ), PARAMETER :: Largest_Power_of_Ten = Exponent_UppBound - 1 INTEGER ( KIND = I4B ), PARAMETER :: Smallest_Power_of_Ten = Exponent_LowBound + 1 INTEGER ( KIND = I4B ), PARAMETER :: Max_Digits = MaxDecimalConversionDigits + 2 INTEGER ( KIND = I8B ), PARAMETER :: OneMant = 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: Max_Mantissa_Fast_Path = SHIFTL ( 2_I8B , Mantissa_Explicit_Bits ) INTEGER ( KIND = I8B ), PARAMETER :: Exponent_Mask = ExponentMask INTEGER ( KIND = I8B ), PARAMETER :: Mantissa_Mask = SignificandMask INTEGER ( KIND = I8B ), PARAMETER :: Hidden_Bit_Mask = SigHidBitMask INTEGER ( KIND = I8B ), PARAMETER :: MaxMant = MAX_U64 INTEGER ( KIND = I8B ), PARAMETER :: NotOneMant = NOT ( 1_I8B ) INTEGER ( KIND = I8B ), PARAMETER :: NotSigHidBitMask = NOT ( SHIFTL ( 1_I8B , SignificandBits )) INTEGER ( KIND = I8B ), PARAMETER :: Powers_of_Ten_Uint64 ( 0 : 19 ) = & [ 0_I8B , & 10_I8B , & 100_I8B , & 1000_I8B , & 10000_I8B , & 100000_I8B , & 1000000_I8B , & 10000000_I8B , & 100000000_I8B , & 1000000000_I8B , & 10000000000_I8B , & 100000000000_I8B , & 1000000000000_I8B , & 10000000000000_I8B , & 100000000000000_I8B , & 1000000000000000_I8B , & 10000000000000000_I8B , & 100000000000000000_I8B , & 1000000000000000000_I8B , & - 8446744073709551616_I8B ] ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------ ! -----   YY/Lemire-Algorithm's parameters   ----- ! ------------------------------------------------ INTEGER ( KIND = I8B ), PARAMETER :: MaxU64 = MAX_U64 INTEGER ( KIND = I8B ), PARAMETER :: BitMask = SHIFTL ( 1_I8B , LowBits ) - 1_I8B ! = Halfway INTEGER ( KIND = I8B ), PARAMETER :: BitMaskMinus1 = BitMask - 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: AddRound = SHIFTL ( 1_I8B , ExponentBits - 1 ) INTEGER ( KIND = I8B ), PARAMETER :: MaxUInt = MaxU64 INTEGER ( KIND = I8B ), PARAMETER :: FpRawInf = INT ( Z '7FF0000000000000' , KIND = I8B ) ! = ExponentMask INTEGER ( KIND = I4B ), PARAMETER :: MaxExpBin = 1024 INTEGER ( KIND = I4B ), PARAMETER :: MinExpBin = - 1021 INTEGER ( KIND = I4B ), PARAMETER :: UIntSafeDigits = 19 INTEGER ( KIND = I4B ), PARAMETER :: MaxDecDigits = MaxDecimalConversionDigits + 1 INTEGER ( KIND = I8B ), PARAMETER :: MaxMantissa = SHIFTL ( 1_I8B , BinaryPrecision ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !** DERIVED TYPE DEFINITIONS ! ---------------------------------------------------------------------------- ! auxiliary string information ! ---------------------------------------------------------------------------- TYPE StringAux INTEGER ( KIND = I4B ) :: Start ! starting position that exclude the leading spaces INTEGER ( KIND = I4B ) :: SigCut ! position after the string is truncated ! = zero if Truncated = False; non-zero if Truncated = True INTEGER ( KIND = I4B ) :: Indices ( 4 ) ! positions of characters representing the ! significand in the string LOGICAL :: Truncated ! flag indicating whether the computed decimal ! significand is based on a truncated string END TYPE StringAux ! ---------------------------------------------------------------------------- ! -----   derived types for high-precision decmial conversion algorithm  ----- ! ---------------------------------------------------------------------------- TYPE HPDecimal INTEGER ( KIND = I4B ) :: NumDigits = 0 INTEGER ( KIND = I4B ) :: DecimalPoint = 0 LOGICAL :: Truncated = FalseVal INTEGER ( KIND = I1B ) :: Digits ( 0 : MAX_NUM_DIGITS - 1 ) CONTAINS PROCEDURE :: ShouldRoundUp => HPDec_Should_Round_Up PROCEDURE :: GetNumNewDigits => HPDec_Get_Num_New_Digits PROCEDURE :: TrimTrailingZeroes => HPDec_Trim_Trailing_Zeroes PROCEDURE :: RightShift => HPDec_Right_Shift PROCEDURE :: LeftShift => HPDec_Left_Shift PROCEDURE :: Construct => HPDec_Construct PROCEDURE :: Shift => HPDec_Shift PROCEDURE :: RoundToUIntType => HPDec_Round_To_UInt END TYPE HPDecimal ! ---------------------------------------------------------------------------- ! -----   derived types for FastFloat algorithm                          ----- ! ---------------------------------------------------------------------------- ! a multiprecision (fixed capacity) unsigned integer where its representation are: ! - Base is 2**64. ! - Magnitude as array in little endian order. ! - The 'Length' first 'Digit' count as the number. ! ---------------------------------------------------------------------------- TYPE BigUInt INTEGER ( KIND = I8B ) :: Digit ( 0 : BigCapacity - 1 ) INTEGER ( KIND = I4B ) :: Length = 0 ! number of digit currently stored CONTAINS PROCEDURE :: IsEmpty => BigUInt_IsEmpty PROCEDURE :: IsNonZero => BigUInt_IsNonZero PROCEDURE :: Push => BigUInt_Push PROCEDURE :: Extend => BigUInt_Extend PROCEDURE :: Normalize => BigUInt_Normalize PROCEDURE :: FromU64 => BigUInt_From_U64 PROCEDURE :: Hi64 => BigUInt_Get_Hi64 PROCEDURE :: Compare => BigUInt_Compare PROCEDURE :: ShiftL => BigUInt_ShiftL PROCEDURE :: LeadZ => BigUInt_LeadZ PROCEDURE :: BitLen => BigUInt_BitLen PROCEDURE :: SmallMul => BigUInt_SmallMul PROCEDURE :: LongMul => BigUInt_LongMul PROCEDURE :: Add => BigUInt_Add PROCEDURE :: Pow2 => BigUInt_Pow2 PROCEDURE :: Pow5 => BigUInt_Pow5 PROCEDURE :: Pow10 => BigUInt_Pow10 END TYPE BigUInt ! parsed number information TYPE Parsed_Number_Info INTEGER ( KIND = I4B ) :: Exp ! base-10 exponent INTEGER ( KIND = I8B ) :: Sig ! base-10 significand INTEGER ( KIND = I4B ) :: IntegralStart ! starting index of integral part of the significand INTEGER ( KIND = I4B ) :: IntegralEnd ! ending index of integral part of the significand INTEGER ( KIND = I4B ) :: FractionStart ! starting index of fractional part of the significand INTEGER ( KIND = I4B ) :: FractionEnd ! ending index of fractional part of the significand END TYPE ! ---------------------------------------------------------------------------- ! binary floating-point representation in base 2 ! --> ((-1)**S) * M * (2**E) ! ---------------------------------------------------------------------------- TYPE BinRep INTEGER ( KIND = I8B ) :: Significand ! significand/mantissa (M) INTEGER ( KIND = I4B ) :: Exponent ! exponent (E); negative value is invalid LOGICAL :: Negative ! negative sign flag; true if the value is negative END TYPE BinRep ! ---------------------------------------------------------------------------- !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE/GENERIC DEFINITIONS: ! interfaces to routines used by FastFloat algorithm ABSTRACT INTERFACE SUBROUTINE CB_Round ( E , M , Min ) IMPORT INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M INTEGER ( KIND = I4B ), INTENT ( IN ) :: Min END SUBROUTINE FUNCTION CB_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) IMPORT LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag END FUNCTION END INTERFACE CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                       REAL64-TO-STRING MAIN ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RealDP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a double-precision floating-point value to a character (decimal) string ! using the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I8B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = DP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I8B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I8B )) THEN ! zero SigDec = 0_I8B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealDP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealDP_ToString_DragonBox !****************************************************************************** FUNCTION RealDP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a double-precision floating-point value to a character (decimal) string ! using the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I8B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = DP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I8B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I8B )) THEN ! zero SigDec = 0_I8B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealDP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealDP_ToString_Ryu !****************************************************************************** FUNCTION RealDP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a double-precision floating-point value to a character (decimal) string ! using the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I8B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = DP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I8B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I8B )) THEN ! zero SigDec = 0_I8B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealDP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealDP_ToString_Schubfach !------------------------------------------------------------------------------ ! !                       REAL64-FROM-STRING MAIN ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RealDP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the FastFloat algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using FastFloat algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , Aux % Truncated , Aux % Indices , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_FastFloat !****************************************************************************** FUNCTION RealDP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the LibC algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using LibC algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_LibC ( SigDec , ExpDec , cStr , Aux % Start , Aux % Truncated , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_LibC !****************************************************************************** FUNCTION RealDP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the YY algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using YY's algorithm +++ RawVal = Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_YY !****************************************************************************** FUNCTION RealDP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a double-precision floating-point value ! using the Lemire algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = DP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux INTEGER ( KIND = I8B ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I8B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I8B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using Lemire's algorithm +++ RawVal = Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealDP_FromString_Lemire !------------------------------------------------------------------------------ ! !                           COMMON AND GENERIC ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Eight_Digits_Unrolled ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits_Unrolled !** PURPOSE OF THIS SUBROUTINE: ! To parse eight digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: K1 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K2 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K3 = INT ( Z '0000FFFF0000FFFF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M1 = 2561_I8B INTEGER ( KIND = I8B ), PARAMETER :: M2 = 6553601_I8B INTEGER ( KIND = I8B ), PARAMETER :: M3 = 42949672960001_I8B ! parameters for alternative implementation !    INTEGER(KIND=I8B), PARAMETER  :: Mask = INT(Z'000000FF000000FF', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: Mul1 = INT(Z'000F424000000064', KIND=I8B)   ! 100 + (1000000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Mul2 = INT(Z'0000271000000001', KIND=I8B)   ! 1 + (10000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Sub  = INT(Z'3030303030303030', KIND=I8B) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = SHIFTR ( IAND ( SHIFTR ( IAND ( SHIFTR ( IAND ( InVal , K1 ) * M1 , 8 ), K2 ) * M2 , 16 ), K3 ) * M3 , 32 ) ! alternative implementation !    OutVal = InVal - Sub !    OutVal = (OutVal*10) + SHIFTR(OutVal, 8)    ! OutVal = (OutVal * 2561) >> 8 !    OutVal = SHIFTR(((IAND(OutVal, Mask)*Mul1) + (IAND(SHIFTR(OutVal, 16), Mask)*Mul2)), 32) RETURN END FUNCTION Parse_Eight_Digits_Unrolled !****************************************************************************** FUNCTION Is_Made_Of_Eight_Digits ( InVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Made_Of_Eight_Digits !** PURPOSE OF THIS SUBROUTINE: ! To check whether we can process eight digits immediately IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: C1 = INT ( Z 'F0F0F0F0F0F0F0F0' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C2 = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C3 = INT ( Z '0606060606060606' , KIND = I8B ) !    INTEGER(KIND=I8B), PARAMETER  :: K1 = INT(Z'4646464646464646', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: K2 = INT(Z'3030303030303030', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: K3 = INT(Z'8080808080808080', KIND=I8B) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IOR ( IAND ( InVal , C1 ), SHIFTR ( IAND (( InVal + C3 ), C1 ), 4 )) == C2 ! alternative implementations !    Flag = (IAND(InVal, C1) == K2).AND.(IAND(InVal + C3, C1) ==  K2) !    Flag = (IAND(IOR((InVal + K1), (InVal - K2)), K3) == 0_I8B) !    Flag = IAND(IAND(InVal, InVal + C3), C1) == C2 RETURN END FUNCTION Is_Made_Of_Eight_Digits !****************************************************************************** FUNCTION Floor_Log10_ThreeQuartersPow2 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_ThreeQuartersPow2 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = FLOOR(LOG10((3/4)*(2**E))) where -2956395 <= E <= 2500325 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! base-2 exponent INTEGER ( KIND = I4B ) :: K ! base-10 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG10(2) * 2**Shift) ! Addend     = FLOOR(LOG10(3/4) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 41 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 661971961083_I8B INTEGER ( KIND = I8B ), PARAMETER :: Addend = - 274743187321_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW K = INT ( SHIFTA ( INT ( E , KIND = I8B ) * Multiplier + Addend , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_ThreeQuartersPow2 !****************************************************************************** FUNCTION Floor_Log10_Pow2 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_Pow2 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = FLOOR(LOG10(2**E)) where -5456721 <= E <= 5456721 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! base-2 exponent INTEGER ( KIND = I4B ) :: K ! base-10 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG10(2) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 41 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 661971961083_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW K = INT ( SHIFTA ( INT ( E , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_Pow2 !****************************************************************************** FUNCTION Floor_Log2_Pow10 ( K ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log2_Pow10 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = FLOOR(LOG2(10**K)) where -1838394 <= K <= 1838394 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! base-10 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG2(10) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 38 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 913124641741_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = INT ( SHIFTA ( INT ( K , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log2_Pow10 !****************************************************************************** FUNCTION Floor_Log2_Pow5 ( P ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log2_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = FLOOR(LOG2(5**P)) where -32768 <= Exp <= 32768 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! base-5 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG2(5) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 46 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 163391164108059_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = INT ( SHIFTA ( INT ( P , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log2_Pow5 !****************************************************************************** FUNCTION Floor_Log10_Pow5 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = Floor(Log10(5**E)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! ! 0 <= Exp <= 2**15 INTEGER ( KIND = I4B ) :: K !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Shift = 48 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 196742565691928_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The first value this approximation fails for is 5&#94;2621 which is just greater than 10&#94;1832. K = INT ( SHIFTR ( INT ( E , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_Pow5 !****************************************************************************** FUNCTION Ceiling_Log2_Pow5 ( P ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Ceiling_Log2_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = CEILING(LOG2(5**P)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! base-5 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = Floor_Log2_Pow5 ( P ) + 1 RETURN END FUNCTION Ceiling_Log2_Pow5 !****************************************************************************** FUNCTION Pow5Bits ( Exp ) RESULT ( Pow5 ) !DIR$ ATTRIBUTES FORCEINLINE :: Pow5Bits !** PURPOSE OF THIS SUBROUTINE: ! To compute Pow5 = Ceiling(Log2(5**Exp)). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! 0 <= Exp <= 32768 INTEGER ( KIND = I4B ) :: Pow5 !** SUBROUTINE ARGUMENT DECLARATIONS: ! Multiplier = FLOOR(LOG2(5) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 46 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 163391164108059_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! note: this is similar to 'Ceiling_Log2_Pow5' but only for positive Exp Pow5 = INT ( SHIFTR ( Exp * Multiplier , Shift ) + 1_I8B , KIND = I4B ) RETURN END FUNCTION Pow5Bits !************************************************************************** SUBROUTINE MultiplyBasic ( X , XLen , Y , YLen , Z ) !DIR$ ATTRIBUTES INLINE :: MultiplyBasic !** PURPOSE OF THIS SUBROUTINE: ! To multiply two magnitude arrays and return the result using grade-school algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: XLen ! The length of the first array INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ( 0 : XLen - 1 ) ! The first magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: YLen ! The length of the second array INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ( 0 : YLen - 1 ) ! The second magnitude array INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Z ( 0 : XLen + YLen - 1 ) ! The result array !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! min signed 64-bit !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry64 , ProductHi , ProductLo , Sum INTEGER ( KIND = I4B ) :: I , J !** FLOW Carry64 = 0_I8B DO J = 0 , YLen - 1 CALL UMul128 ( X ( 0 ), Y ( J ), ProductHi , ProductLo ) Z ( J ) = ProductLo + Carry64 IF ( IEOR ( Z ( J ), MinI64 ) < IEOR ( ProductLo , MinI64 )) THEN Carry64 = ProductHi + 1_I8B ELSE Carry64 = ProductHi END IF END DO Z ( YLen ) = Carry64 DO I = 1 , XLen - 1 Carry64 = 0_I8B DO J = 0 , YLen - 1 CALL UMul128 ( X ( I ), Y ( J ), ProductHi , ProductLo ) Sum = ProductLo + Z ( I + J ) IF ( IEOR ( Sum , MinI64 ) < IEOR ( ProductLo , MinI64 )) ProductHi = ProductHi + 1_I8B Z ( I + J ) = Sum + Carry64 IF ( IEOR ( Z ( I + J ), MinI64 ) < IEOR ( Sum , MinI64 )) THEN Carry64 = ProductHi + 1_I8B ELSE Carry64 = ProductHi END IF END DO Z ( I + YLen ) = Carry64 END DO RETURN END SUBROUTINE MultiplyBasic !****************************************************************************** SUBROUTINE ShiftRight ( X , ShiftPos ) !DIR$ ATTRIBUTES INLINE :: ShiftRight !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by the specified amount IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LargeShift , SmallShift !** FLOW IF ( ShiftPos == 0 ) RETURN LargeShift = SHIFTR ( ShiftPos , 6 ) IF ( LargeShift >= SIZE ( X )) THEN X = 0_I8B ELSE SmallShift = IAND ( ShiftPos , 63 ) IF ( LargeShift > 0 ) CALL ShiftLarge ( X , LargeShift ) IF ( SmallShift > 0 ) CALL ShiftSmall ( X , SmallShift ) END IF RETURN CONTAINS SUBROUTINE ShiftSmall ( X , Shift ) !DIR$ ATTRIBUTES FORCEINLINE :: ShiftSmall !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by the given amount (less than 64). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: I , XLen INTEGER ( KIND = I8B ) :: Nxt !** FLOW XLen = SIZE ( X ) Nxt = X ( 0 ) DO I = 0 , XLen - 2 X ( I ) = IOR ( SHIFTR ( Nxt , Shift ), SHIFTL ( X ( I + 1 ), 64 - Shift )) Nxt = X ( I + 1 ) END DO X ( XLen - 1 ) = SHIFTR ( X ( XLen - 1 ), Shift ) RETURN END SUBROUTINE ShiftSmall !****************************************************************************** SUBROUTINE ShiftLarge ( X , Shift ) !DIR$ ATTRIBUTES FORCEINLINE :: ShiftLarge !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by 64*shift, i.e. moves each ! element of the array shift positions to the right. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index , XLen !** FLOW XLen = SIZE ( X ) DO Index = 0 , XLen - Shift - 1 X ( Index ) = X ( Shift + Index ) END DO X ( XLen - Shift :) = 0_I8B RETURN END SUBROUTINE ShiftLarge !****************************************************************************** END SUBROUTINE ShiftRight !****************************************************************************** SUBROUTINE Multiply_N_ShiftRight ( X , XLen , Y , YLen , Shift , Z ) !DIR$ ATTRIBUTES INLINE :: Multiply_N_ShiftRight !** PURPOSE OF THIS SUBROUTINE: ! To perform multiplication and then rigth shift IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: XLen ! The length of the first array INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ( 0 : XLen - 1 ) ! The first magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: YLen ! The length of the second array INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ( 0 : YLen - 1 ) ! The second magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! shift position of bits in the result array INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Z ( 0 : XLen + YLen - 1 ) ! The result array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL MultiplyBasic ( X , XLen , Y , YLen , Z ) CALL ShiftRight ( Z , Shift ) RETURN END SUBROUTINE Multiply_N_ShiftRight !****************************************************************************** SUBROUTINE Increment_Value ( X ) !DIR$ ATTRIBUTES INLINE :: Increment_Value !** PURPOSE OF THIS SUBROUTINE: ! To increase value of the input by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: XLen , I INTEGER ( KIND = I8B ) :: Sum , Carry !** FLOW XLen = SIZE ( X ) Sum = X ( 0 ) + 1_I8B Carry = SHIFTR ( IOR ( IAND ( X ( 0 ), 1_I8B ), IAND ( IOR ( X ( 0 ), 1_I8B ), NOT ( Sum ))), 63 ) X ( 0 ) = Sum IF ( Carry /= 0_I8B ) THEN I = 1_I4B DO X ( I ) = X ( I ) + 1_I8B IF (. NOT .(( I < XLen ). AND .( X ( I ) == 0 ))) EXIT I = I + 1_I4B END DO END IF RETURN END SUBROUTINE Increment_Value !****************************************************************************** FUNCTION Get_Pow10_128Bits ( K ) RESULT ( Pow10 ) !DIR$ ATTRIBUTES FORCEINLINE :: Get_Pow10_128Bits !** PURPOSE OF THIS SUBROUTINE: ! To get the 128-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power TYPE ( UInt128 ) :: Pow10 ! the power of ten !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10Cache ( 0 : 1 ) ! the power of ten in little-endian order !** FLOW IF (( K >= Pow10_256_Small_MinExp ). AND .( K <= Pow10_256_Small_MaxExp )) THEN ! get only the upper 128 bits Pow10Cache ( 0 : 1 ) = Pow10_256_Small_Table ( 2 : 3 , K ) ELSE CALL Compute_Pow10_128Bits ( K , Pow10Cache ) END IF Pow10 = UInt128 ( Pow10Cache ( 1 ), Pow10Cache ( 0 )) RETURN END FUNCTION Get_Pow10_128Bits !****************************************************************************** SUBROUTINE Compute_Pow10_128Bits ( K , Pow10 ) !DIR$ ATTRIBUTES INLINE :: Compute_Pow10_128Bits !** PURPOSE OF THIS SUBROUTINE: ! To compute the 128-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Pow10 ( 0 : 1 ) ! the power of ten in little-endian order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pow10_Index , KBase , Offset , Alpha INTEGER ( KIND = I8B ) :: Pow10_Cache ( 0 : 1 ), Pow5 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Pow10_256 ( 0 : 3 ) !** FLOW ! compute essential indices Pow10_Index = ( K - Pow10_256_Compressed_MinExp ) / Pow5_128_Size KBase = Pow10_Index * Pow5_128_Size + Pow10_256_Compressed_MinExp Offset = K - KBase ! get base cache (only upper 128 bits) where table data is stored in little-endian ! order (i.e. the least significant byte is 0 and the most significant byte is 3) Pow10_Cache ( 0 : 1 ) = Pow10_256_Compressed_Table ( 2 : 3 , Pow10_Index ) IF ( Offset == 0 ) THEN Pow10 = Pow10_Cache RETURN END IF ! compute the required amount of bit-shift where Alpha should be in the range (0, 128) Alpha = Floor_Log2_Pow10 ( KBase + Offset ) - Floor_Log2_Pow10 ( KBase ) - Offset ! compute the approximation for the specified power K Pow5 = Pow5_128_Table (:, Offset ) CALL Multiply_N_ShiftRight ( Pow10_Cache , 2 , Pow5 , 2 , Alpha , Pow10_256 ) Pow10 ( 0 : 1 ) = Pow10_256 ( 0 : 1 ) CALL Increment_Value ( Pow10 ) RETURN END SUBROUTINE Compute_Pow10_128Bits !****************************************************************************** FUNCTION Handle_Invalid_String ( cStr , Start , Negative ) RESULT ( RealNum ) !** PURPOSE OF THIS SUBROUTINE: ! To handle invalid input string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start LOGICAL , INTENT ( IN ) :: Negative REAL ( KIND = DP ) :: RealNum !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Finish INTEGER ( KIND = I4B ) :: Ptr , Q !** FLOW ! Could not parse a decimal floating-point number.  Start has been ! advanced over any leading spaces. Ptr = Start Finish = LEN_TRIM ( cStr ) IF ( Start > Finish ) THEN ! empty string RealNum = IEEE_VALUE ( 0.0_DP , IEEE_QUIET_NAN ) ELSEIF ( Finish == Ptr + 2 ) THEN IF (( ToUpper ( cStr ( Ptr : Ptr )) == 'N' ). AND .( ToUpper ( cStr ( Ptr + 1 : Ptr + 1 )) == 'A' ). AND . & ( ToUpper ( cStr ( Ptr + 2 : Ptr + 2 )) == 'N' )) THEN ! Exact NAN RealNum = IEEE_VALUE ( 0.0_DP , IEEE_QUIET_NAN ) ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_DP , IEEE_SIGNALING_NAN ) END IF ELSE ! Try to parse Inf, maybe with a sign Q = Ptr IF ( Q <= Finish ) THEN IF ( Is_Character_Sign ( cStr ( Q : Q ))) Q = Q + 1 END IF IF ( Finish == Q + 2 ) THEN IF (( ToUpper ( cStr ( Q : Q )) == 'I' ). AND .( ToUpper ( cStr ( Q + 1 : Q + 1 )) == 'N' ). AND . & ( ToUpper ( cStr ( Q + 2 : Q + 2 )) == 'F' )) THEN IF ( Negative ) THEN RealNum = IEEE_VALUE ( 1.0_DP , IEEE_NEGATIVE_INF ) ELSE RealNum = IEEE_VALUE ( 1.0_DP , IEEE_POSITIVE_INF ) END IF ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_DP , IEEE_SIGNALING_NAN ) END IF ELSEIF ( Finish == Q + 7 ) THEN IF (( ToUpper ( cStr ( Q : Q )) == 'I' ). AND .( ToUpper ( cStr ( Q + 1 : Q + 1 )) == 'N' ). AND . & ( ToUpper ( cStr ( Q + 2 : Q + 2 )) == 'F' ). AND .( ToUpper ( cStr ( Q + 3 : Q + 3 )) == 'I' ). AND . & ( ToUpper ( cStr ( Q + 4 : Q + 4 )) == 'N' ). AND .( ToUpper ( cStr ( Q + 5 : Q + 5 )) == 'I' ). AND . & ( ToUpper ( cStr ( Q + 6 : Q + 6 )) == 'T' ). AND .( ToUpper ( cStr ( Q + 7 : Q + 7 )) == 'Y' )) THEN IF ( Negative ) THEN RealNum = IEEE_VALUE ( 1.0_DP , IEEE_NEGATIVE_INF ) ELSE RealNum = IEEE_VALUE ( 1.0_DP , IEEE_POSITIVE_INF ) END IF ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_DP , IEEE_SIGNALING_NAN ) END IF ELSE ! Invalid input RealNum = IEEE_VALUE ( 0.0_DP , IEEE_SIGNALING_NAN ) END IF END IF RETURN CONTAINS FUNCTION Is_Character_Sign ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is a 'sign' character IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN =* ), PARAMETER :: SET_SIGNS = '+-' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_SIGNS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Sign !************************************************************************** FUNCTION ToUpper ( ChrIn ) RESULT ( ChrOut ) !** PURPOSE OF THIS SUBROUTINE: ! To change case of the input character to upper case if applicable IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: ChrIn CHARACTER ( LEN = 1 ) :: ChrOut !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN =* ), PARAMETER :: SET_ALPHABETS_LOWER = 'abcdefghijklmnopqrstuvwxyz' CHARACTER ( LEN =* ), PARAMETER :: SET_ALPHABETS_UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ID !** FLOW: ID = INDEX ( SET_ALPHABETS_LOWER , ChrIn ) IF ( ID > 0 ) THEN ChrOut = SET_ALPHABETS_UPPER ( ID : ID ) ELSE ChrOut = ChrIn END IF RETURN END FUNCTION ToUpper !************************************************************************** END FUNCTION Handle_Invalid_String !****************************************************************************** !------------------------------------------------------------------------------ ! !           (RAW) FLOATING-POINT BINARY REPRESENTATION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RawFP_BiasedExponent ( RawVal ) RESULT ( BiasedExponent ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_BiasedExponent !** PURPOSE OF THIS SUBROUTINE: ! To determine the biased exponent of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I4B ) :: BiasedExponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BiasedExponent = INT ( SHIFTR ( IAND ( RawVal , ExponentMask ), SignificandBits ), KIND = I4B ) RETURN END FUNCTION RawFP_BiasedExponent !****************************************************************************** FUNCTION RawFP_UnbiasedExponent ( RawVal ) RESULT ( UnbiasedExponent ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_UnbiasedExponent !** PURPOSE OF THIS SUBROUTINE: ! To determine the unbiased exponent of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I4B ) :: UnbiasedExponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: BiasedExponent !** FLOW BiasedExponent = RawFP_BiasedExponent ( RawVal ) UnbiasedExponent = BiasedExponent - ExponentBias IF ( BiasedExponent == 0 ) UnbiasedExponent = UnbiasedExponent + 1 RETURN END FUNCTION RawFP_UnbiasedExponent !****************************************************************************** FUNCTION RawFP_Significand ( RawVal ) RESULT ( Significand ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Significand !** PURPOSE OF THIS SUBROUTINE: ! To determine the significand of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I8B ) :: Significand !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Significand = IAND ( RawVal , SignificandMask ) RETURN END FUNCTION RawFP_Significand !****************************************************************************** FUNCTION RawFP_Fraction ( RawVal ) RESULT ( Fraction ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Fraction !** PURPOSE OF THIS SUBROUTINE: ! To determine the fraction part of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I8B ) :: Fraction !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Fraction = RawFP_Significand ( RawVal ) IF ( RawFP_BiasedExponent ( RawVal ) > 0 ) Fraction = IOR ( Fraction , SigHidBitMask ) RETURN END FUNCTION RawFP_Fraction !****************************************************************************** FUNCTION RawFP_IsZero ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsZero !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is zero IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! Remove sign bit by shift Flag = SHIFTL ( RawVal , 1 ) == 0_I8B RETURN END FUNCTION RawFP_IsZero !****************************************************************************** FUNCTION RawFP_IsNaN ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsNaN !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is not a number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( RawFP_BiasedExponent ( RawVal ) == MaxExponent ). AND . & ( RawFP_Significand ( RawVal ) /= 0_I8B ) RETURN END FUNCTION RawFP_IsNaN !****************************************************************************** FUNCTION RawFP_IsQuietNaN ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsQuietNaN !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is a quiet NaN IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IAND ( RawVal , ExpMantMask ) == IOR ( ExponentMask , QuietNaNMask ) RETURN END FUNCTION RawFP_IsQuietNaN !****************************************************************************** FUNCTION RawFP_IsInfinite ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsInfinite !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is infinite IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( RawFP_BiasedExponent ( RawVal ) == MaxExponent ). AND . & ( RawFP_Significand ( RawVal ) == 0_I8B ) RETURN END FUNCTION RawFP_IsInfinite !****************************************************************************** FUNCTION RawFP_IsInfOrNaN ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsInfOrNaN !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is infinite or NaN IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IAND ( RawVal , ExponentMask ) == ExponentMask RETURN END FUNCTION RawFP_IsInfOrNaN !****************************************************************************** FUNCTION RawFP_IsMaximalFiniteMagnitude ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsMaximalFiniteMagnitude !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is equal to the maximal finite magnitude IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( RawFP_BiasedExponent ( RawVal ) == ( MaxExponent - 1 )). AND . & ( RawFP_Significand ( RawVal ) == SignificandMask ) RETURN END FUNCTION RawFP_IsMaximalFiniteMagnitude !****************************************************************************** FUNCTION RawFP_IsNegative ( RawVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_IsNegative !** PURPOSE OF THIS SUBROUTINE: ! To determine whether the input value is negative IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IAND ( RawVal , SignMask ) /= 0_I8B RETURN END FUNCTION RawFP_IsNegative !****************************************************************************** FUNCTION RawFP_Negate ( InRaw ) RESULT ( OutRaw ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Negate !** PURPOSE OF THIS SUBROUTINE: ! To negate the input value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InRaw INTEGER ( KIND = I8B ) :: OutRaw !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutRaw = IEOR ( InRaw , SignMask ) RETURN END FUNCTION RawFP_Negate !****************************************************************************** FUNCTION RawFP_NeighborLow ( InRaw ) RESULT ( OutRaw ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_NeighborLow !** PURPOSE OF THIS SUBROUTINE: ! To determine the nearest floating point value that is smaller than the input value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InRaw INTEGER ( KIND = I8B ) :: OutRaw !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutRaw = InRaw - 1_I8B RETURN END FUNCTION RawFP_NeighborLow !****************************************************************************** FUNCTION RawFP_NeighborHigh ( InRaw ) RESULT ( OutRaw ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_NeighborHigh !** PURPOSE OF THIS SUBROUTINE: ! To determine the nearest floating point value that is greater than the input value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InRaw INTEGER ( KIND = I8B ) :: OutRaw !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutRaw = InRaw + 1_I8B RETURN END FUNCTION RawFP_NeighborHigh !****************************************************************************** FUNCTION RawFP_Construct ( FpBin ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Construct !** PURPOSE OF THIS SUBROUTINE: ! To construct a raw binary floating point number based on ! its three parts IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BinRep ), INTENT ( IN ) :: FpBin INTEGER ( KIND = I8B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! set sign bit IF ( FpBin % Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( ToUnsignedLong ( FpBin % Exponent ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( FpBin % Significand , SignificandMask )) RETURN END FUNCTION RawFP_Construct !****************************************************************************** FUNCTION RawFP_Decompose ( RawVal ) RESULT ( FpBin ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Decompose !** PURPOSE OF THIS SUBROUTINE: ! To decompose a raw binary floating point number into ! its three parts IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal TYPE ( BinRep ) :: FpBin !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! set sign FpBin % Negative = IAND ( RawVal , SignMask ) /= 0_I8B ! set significand FpBin % Significand = RawFP_Significand ( RawVal ) ! set exponent FpBin % Exponent = RawFP_BiasedExponent ( RawVal ) RETURN END FUNCTION RawFP_Decompose !****************************************************************************** FUNCTION RawFP_FromFloat ( RealVal ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_FromFloat !** PURPOSE OF THIS SUBROUTINE: ! To construct a raw binary floating point number based on ! the specified real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: RealVal INTEGER ( KIND = I8B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IntVal REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW FloatVal = RealVal RawVal = IntVal RETURN END FUNCTION RawFP_FromFloat !****************************************************************************** FUNCTION RawFP_ToFloat ( RawVal ) RESULT ( RealVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_ToFloat !** PURPOSE OF THIS SUBROUTINE: ! To convert a raw binary floating point number into ! its equivalent real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: RawVal REAL ( KIND = DP ) :: RealVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IntVal REAL ( KIND = DP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW IntVal = RawVal RealVal = FloatVal RETURN END FUNCTION RawFP_ToFloat !****************************************************************************** FUNCTION RawFP_SetZero ( Negative ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetZero !** PURPOSE OF THIS SUBROUTINE: ! To set value to zero IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I8B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I8B END IF RETURN END FUNCTION RawFP_SetZero !****************************************************************************** FUNCTION RawFP_SetInfinity ( Negative ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetInfinity !** PURPOSE OF THIS SUBROUTINE: ! To set value to infinity IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I8B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Exponent !** FLOW ! set sign of infinity RawVal = RawFP_SetZero ( Negative ) ! set infinity biased exponent Exponent = IAND ( SHIFTL ( ToUnsignedLong ( MaxExponent ), SignificandBits ), ExponentMask ) RawVal = IAND ( RawVal , NOT ( ExponentMask )) RawVal = IOR ( RawVal , Exponent ) RETURN END FUNCTION RawFP_SetInfinity !****************************************************************************** FUNCTION RawFP_SetNaN ( Quiet ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetNaN !** PURPOSE OF THIS SUBROUTINE: ! To set value to NaN IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Quiet INTEGER ( KIND = I8B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Mantissa !** FLOW ! set infinity biased exponent RawVal = RawFP_SetInfinity ( FalseVal ) ! set NaN significand RawVal = IOR ( RawVal , SHIFTL ( 1_I8B , SignificandBits - 2 )) IF ( Quiet ) THEN Mantissa = IAND ( QuietNaNMask , SignificandMask ) RawVal = IAND ( RawVal , NOT ( SignificandMask )) RawVal = IOR ( RawVal , Mantissa ) END IF RETURN END FUNCTION RawFP_SetNaN !****************************************************************************** !------------------------------------------------------------------------------ ! !               HIGH-PRECISION DECIMAL (HPDECIMAL) ROUTINES ! !------------------------------------------------------------------------------ FUNCTION HPDec_Should_Round_Up ( HP , RoundToDigit ) RESULT ( Flag ) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: RoundToDigit LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( RoundToDigit < 0 ). OR .( RoundToDigit >= HP % NumDigits )) THEN Flag = FalseVal RETURN END IF ! If we're right in the middle and there are no extra digits IF (( HP % Digits ( RoundToDigit ) == 5 ) . AND .( RoundToDigit + 1 == HP % NumDigits )) THEN ! Round up if we've truncated (since that means the result is slightly ! higher than what's represented.) IF ( HP % Truncated ) THEN Flag = TrueVal RETURN END IF ! If this exactly halfway, round to even. IF ( RoundToDigit == 0 ) THEN ! When the input is \".5\". Flag = FalseVal RETURN END IF Flag = MOD ( HP % Digits ( RoundToDigit - 1 ), 2 ) /= 0 RETURN END IF ! If there are digits after roundToDigit, they must be non-zero since we ! trim trailing zeroes after all operations that change digits. Flag = HP % Digits ( RoundToDigit ) >= 5 RETURN END FUNCTION HPDec_Should_Round_Up !****************************************************************************** FUNCTION HPDec_Get_Num_New_Digits ( HP , LShiftAmount ) RESULT ( NewDigits ) ! Takes an amount to left shift and returns the number of new digits needed ! to store the result based on LEFT_SHIFT_DIGIT_TABLE. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: LShiftAmount INTEGER ( KIND = I4B ) :: NewDigits !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = :), ALLOCATABLE :: PowerOfFive INTEGER ( KIND = I1B ) :: CurDigit , P5Digit INTEGER ( KIND = I4B ) :: Indx INTEGER ( KIND = I4B ) :: Length !** FLOW Length = LShift_Length ( LShiftAmount ) PowerOfFive = LShift_PowFive ( LShiftAmount )( 1 : Length ) NewDigits = LShift_Digits ( LShiftAmount ) Indx = 1 DO WHILE ( Indx <= Length ) IF ( Indx > HP % NumDigits ) THEN NewDigits = NewDigits - 1 RETURN END IF P5Digit = INT ( IACHAR ( PowerOfFive ( Indx : Indx )) - A0 , KIND = I1B ) CurDigit = HP % Digits ( Indx - 1 ) IF ( CurDigit /= P5Digit ) THEN IF ( CurDigit < P5Digit ) NewDigits = NewDigits - 1 RETURN END IF Indx = Indx + 1 END DO RETURN END FUNCTION HPDec_Get_Num_New_Digits !****************************************************************************** SUBROUTINE HPDec_Trim_Trailing_Zeroes ( HP ) ! Trim all trailing 0s !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW DO WHILE (( HP % NumDigits > 0 ). AND .( HP % Digits ( HP % NumDigits - 1 ) == 0 )) HP % NumDigits = HP % NumDigits - 1 END DO IF ( HP % NumDigits == 0 ) THEN HP % DecimalPoint = 0 END IF RETURN END SUBROUTINE HPDec_Trim_Trailing_Zeroes !****************************************************************************** SUBROUTINE HPDec_Right_Shift ( HP , ShiftAmount ) ! Perform a digitwise binary non-rounding right shift on this value by ShiftAmount. ! The ShiftAmount can't be more than MAX_SHIFT_AMOUNT to prevent overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftAmount !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ReadIndx INTEGER ( KIND = I4B ) :: WriteIndx INTEGER ( KIND = I8B ) :: Accumulator INTEGER ( KIND = I8B ) :: ShiftMask INTEGER ( KIND = I8B ) :: ReadDigit INTEGER ( KIND = I8B ) :: WriteDigit !** FLOW ! initialize ReadIndx = 0 WriteIndx = 0 Accumulator = 0_I8B ShiftMask = SHIFTL ( 1_I8B , ShiftAmount ) - 1_I8B ! Warm Up phase: we don't have enough digits to start writing, so just ! read them into the Accumulator. DO WHILE ( SHIFTR ( Accumulator , ShiftAmount ) == 0_I8B ) ReadDigit = 0_I8B ! If there are still digits to read, read the next one, else the digit is ! assumed to be 0. IF ( ReadIndx < HP % NumDigits ) ReadDigit = HP % Digits ( ReadIndx ) Accumulator = Accumulator * 10_I8B + ReadDigit ReadIndx = ReadIndx + 1 END DO ! Shift the decimal point by the number of digits it took to fill the ! Accumulator. HP % DecimalPoint = HP % DecimalPoint - ( ReadIndx - 1 ) ! Middle phase: we have enough digits to write, as well as more digits to ! read. Keep reading until we run out of digits. DO WHILE ( ReadIndx < HP % NumDigits ) ReadDigit = HP % Digits ( ReadIndx ) WriteDigit = SHIFTR ( Accumulator , ShiftAmount ) Accumulator = IAND ( Accumulator , ShiftMask ) HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) Accumulator = Accumulator * 10_I8B + ReadDigit ReadIndx = ReadIndx + 1 WriteIndx = WriteIndx + 1 END DO ! Cool Down phase: All of the readable digits have been read, so just write ! the remainder, DO WHILE treating any more digits as 0. ! DO WHILE (Accumulator > 0_I8B) DO WHILE ( Accumulator /= 0_I8B ) ! +++ unsigned comparison +++ WriteDigit = SHIFTR ( Accumulator , ShiftAmount ) Accumulator = IAND ( Accumulator , ShiftMask ) IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) WriteIndx = WriteIndx + 1 ELSEIF ( WriteDigit /= 0_I8B ) THEN ! +++ unsigned comparison +++ HP % Truncated = TrueVal END IF Accumulator = Accumulator * 10_I8B END DO HP % NumDigits = WriteIndx CALL HP % TrimTrailingZeroes () RETURN END SUBROUTINE HPDec_Right_Shift !****************************************************************************** SUBROUTINE HPDec_Left_Shift ( HP , ShiftAmount ) ! Perform a digitwise binary non-rounding left shift on this value by ShiftAmount. ! The ShiftAmount can't be more than MAX_SHIFT_AMOUNT to prevent overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftAmount !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NewDigits INTEGER ( KIND = I4B ) :: ReadIndx INTEGER ( KIND = I4B ) :: WriteIndx INTEGER ( KIND = I8B ) :: Accumulator INTEGER ( KIND = I8B ) :: NextAccumulator INTEGER ( KIND = I8B ) :: WriteDigit !** FLOW ! initialize NewDigits = HP % GetNumNewDigits ( ShiftAmount ) ReadIndx = HP % NumDigits - 1 WriteIndx = HP % NumDigits + NewDigits Accumulator = 0_I8B ! No Warm Up phase. Since we're putting digits in at the top and taking ! digits from the bottom we don't have to wait for the Accumulator to fill. ! Middle phase: while we have more digits to read, keep reading as well as ! writing. DO WHILE ( ReadIndx >= 0 ) Accumulator = Accumulator + SHIFTL ( INT ( HP % Digits ( ReadIndx ), KIND = I8B ), ShiftAmount ) ! +++ unsigned division and modulation +++ ! NextAccumulator = Accumulator / 10_I8B ! WriteDigit = Accumulator - (10_I8B * NextAccumulator) CALL UDivMod ( Accumulator , 10_I8B , NextAccumulator , WriteDigit ) WriteIndx = WriteIndx - 1 IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) ELSEIF ( WriteDigit /= 0_I8B ) THEN HP % Truncated = TrueVal END IF Accumulator = NextAccumulator ReadIndx = ReadIndx - 1 END DO ! Cool Down phase: there are no more digits to read, so just write the ! remaining digits in the Accumulator. ! DO WHILE (Accumulator > 0_I8B) DO WHILE ( Accumulator /= 0_I8B ) ! +++ unsigned comparison +++ ! +++ unsigned division and modulation +++ ! NextAccumulator = Accumulator / 10_I8B ! WriteDigit = Accumulator - (10_I8B * NextAccumulator) CALL UDivMod ( Accumulator , 10_I8B , NextAccumulator , WriteDigit ) WriteIndx = WriteIndx - 1 IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) ELSEIF ( WriteDigit /= 0_I8B ) THEN HP % Truncated = TrueVal END IF Accumulator = NextAccumulator END DO HP % NumDigits = HP % NumDigits + NewDigits IF ( HP % NumDigits > MAX_NUM_DIGITS ) THEN HP % NumDigits = MAX_NUM_DIGITS END IF HP % DecimalPoint = HP % DecimalPoint + NewDigits CALL HP % TrimTrailingZeroes () RETURN END SUBROUTINE HPDec_Left_Shift !****************************************************************************** SUBROUTINE HPDec_Construct ( HP , cStr , Start , Finish ) ! To construct 'HPDecimal' based on input string (cStr) where !   - Start is the index of the first valid numeric character, and !   - Finish is the index of the last valid character (== length of the input !     string excluding trailing space(s)) ! The routine assumes that cStr is a 'VALID' floating point string and ! Start is less than Finish. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start INTEGER ( KIND = I4B ), INTENT ( IN ) :: Finish !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) CHARACTER ( LEN =* ), PARAMETER :: SET_DIGITS = '0123456789' CHARACTER ( LEN =* ), PARAMETER :: SET_EXPONENTS = 'EeDdQq' CHARACTER ( LEN =* ), PARAMETER :: SET_SIGNS = '+-' CHARACTER ( LEN =* ), PARAMETER :: SET_INTEGERS = SET_DIGITS // SET_SIGNS !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Ptr INTEGER ( KIND = I4B ) :: Add2Exp LOGICAL :: SawDot INTEGER ( KIND = I4B ) :: TotalDigits ! This counts the digits in the number, even if ! there isn't space to store them all. !** FLOW ! initialize Ptr = Start SawDot = FalseVal TotalDigits = 0 DO WHILE (( Is_Character_Digit ( cStr ( Ptr : Ptr ))). OR .( cStr ( Ptr : Ptr ) == '.' )) IF ( cStr ( Ptr : Ptr ) == '.' ) THEN IF ( SawDot ) EXIT HP % DecimalPoint = TotalDigits SawDot = TrueVal ELSE IF (( cStr ( Ptr : Ptr ) == '0' ). AND .( HP % NumDigits == 0 )) THEN HP % DecimalPoint = HP % DecimalPoint - 1 Ptr = Ptr + 1 IF ( Ptr <= Finish ) THEN CYCLE ELSE EXIT END IF END IF TotalDigits = TotalDigits + 1 IF ( HP % NumDigits < MAX_NUM_DIGITS ) THEN HP % Digits ( HP % NumDigits ) = INT ( IACHAR ( cStr ( Ptr : Ptr )) - A0 , KIND = I1B ) HP % NumDigits = HP % NumDigits + 1 ELSEIF ( cStr ( Ptr : Ptr ) /= '0' ) THEN HP % Truncated = TrueVal END IF END IF Ptr = Ptr + 1 IF ( Ptr > Finish ) EXIT END DO IF (. NOT . SawDot ) HP % DecimalPoint = TotalDigits IF ( Ptr <= Finish ) THEN IF ( Is_Character_Exponent ( cStr ( Ptr : Ptr ))) THEN Ptr = Ptr + 1 IF ( Ptr <= Finish ) THEN IF ( Is_Character_Integer ( cStr ( Ptr : Ptr ))) THEN Add2Exp = I32_FromChar ( cStr ( Ptr :)) IF ( Add2Exp > 100000 ) THEN Add2Exp = 100000 ELSEIF ( Add2Exp < - 100000 ) THEN Add2Exp = - 100000 END IF HP % DecimalPoint = HP % DecimalPoint + Add2Exp END IF END IF ELSEIF ( Is_Character_Sign ( cStr ( Ptr : Ptr ))) THEN Add2Exp = I32_FromChar ( cStr ( Ptr :)) IF ( Add2Exp > 100000 ) THEN Add2Exp = 100000 ELSEIF ( Add2Exp < - 100000 ) THEN Add2Exp = - 100000 END IF HP % DecimalPoint = HP % DecimalPoint + Add2Exp END IF END IF CALL HP % TrimTrailingZeroes () RETURN CONTAINS FUNCTION Is_Character_Digit ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'DIGIT' set IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_DIGITS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Digit !************************************************************************** FUNCTION Is_Character_Exponent ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is an 'exponent' character IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_EXPONENTS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Exponent !************************************************************************** FUNCTION Is_Character_Integer ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'INTEGER' set IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_INTEGERS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Integer !************************************************************************** FUNCTION Is_Character_Sign ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'SIGN' set !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_SIGNS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Sign !************************************************************************** END SUBROUTINE HPDec_Construct !****************************************************************************** SUBROUTINE HPDec_Shift ( HP , Shift ) ! Binary shift left (ShiftAmount > 0) or right (ShiftAmount < 0) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftAmount !** FLOW ShiftAmount = Shift IF ( ShiftAmount > 0 ) THEN ! Left shift DO WHILE ( ShiftAmount > MAX_SHIFT_AMOUNT ) CALL HP % LeftShift ( MAX_SHIFT_AMOUNT ) ShiftAmount = ShiftAmount - MAX_SHIFT_AMOUNT END DO CALL HP % LeftShift ( ShiftAmount ) ELSEIF ( ShiftAmount < 0 ) THEN ! Right shift DO WHILE ( ShiftAmount < - MAX_SHIFT_AMOUNT ) CALL HP % RightShift ( MAX_SHIFT_AMOUNT ) ShiftAmount = ShiftAmount + MAX_SHIFT_AMOUNT END DO CALL HP % RightShift ( - ShiftAmount ) END IF RETURN END SUBROUTINE HPDec_Shift !****************************************************************************** SUBROUTINE HPDec_Round_To_UInt ( HP , ResVal ) ! Round the number represented to the closest value of UIntType. ! This is done ignoring overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I8B ), INTENT ( OUT ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: CurDigit !** FLOW ResVal = 0_I8B CurDigit = 0 DO WHILE (( CurDigit < HP % DecimalPoint ). AND .( CurDigit < HP % NumDigits )) ResVal = ResVal * 10_I8B + INT ( HP % Digits ( CurDigit ), KIND = I8B ) CurDigit = CurDigit + 1 END DO ! If there are implicit 0s at the end of the number, include those. DO WHILE ( CurDigit < HP % DecimalPoint ) ResVal = ResVal * 10_I8B CurDigit = CurDigit + 1 END DO IF ( HP % ShouldRoundUp ( HP % DecimalPoint )) THEN ResVal = ResVal + 1_I8B END IF RETURN END SUBROUTINE HPDec_Round_To_UInt !****************************************************************************** !------------------------------------------------------------------------------ ! !            MULTI-PRECISION UNSIGNED INTEGER (BIGUINT) ROUTINES ! !------------------------------------------------------------------------------ ! ----------------------------------------------------------------------------- ! -----   BigUInt Routines for FastFloat Algorithms                       ----- ! ----------------------------------------------------------------------------- FUNCTION Empty_Hi64 ( Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: Empty_Hi64 !** PURPOSE OF THIS SUBROUTINE: ! To return empty value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Truncated = FalseVal Val = 0_I8B RETURN END FUNCTION Empty_Hi64 !****************************************************************************** FUNCTION UInt64_Hi64_I ( R0 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Hi64_I !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW Truncated = FalseVal ShiftPos = LEADZ ( R0 ) Val = SHIFTL ( R0 , ShiftPos ) RETURN END FUNCTION UInt64_Hi64_I !****************************************************************************** FUNCTION UInt64_Hi64_II ( R0 , R1 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Hi64_II !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 values. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 , R1 LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW ShiftPos = LEADZ ( R0 ) IF ( ShiftPos == 0 ) THEN Truncated = R1 /= 0_I8B Val = R0 ELSE Truncated = SHIFTL ( R1 , ShiftPos ) /= 0_I8B Val = IOR ( SHIFTL ( R0 , ShiftPos ), SHIFTR ( R1 , 64 - ShiftPos )) END IF RETURN END FUNCTION UInt64_Hi64_II !****************************************************************************** FUNCTION BigUInt_IsEmpty ( Big ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether BigUInt is empty or not. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL :: Flag ! true if empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Big % Length == 0 RETURN END FUNCTION BigUInt_IsEmpty !****************************************************************************** FUNCTION BigUInt_IsNonZero ( Big , Index ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check if any limbs are non-zero after the given index. ! this needs to be done in reverse order, since the index ! is relative to the most significant limbs. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big ! BigUInt object INTEGER ( KIND = I4B ), INTENT ( IN ) :: Index ! the specified index LOGICAL :: Flag ! true if the stack is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: I , RIndex !** FLOW I = Index DO WHILE ( I < Big % Length ) RIndex = Big % Length - I - 1 IF ( Big % Digit ( RIndex ) /= 0_I8B ) THEN Flag = TrueVal RETURN END IF I = I + 1 END DO Flag = FalseVal RETURN END FUNCTION BigUInt_IsNonZero !****************************************************************************** SUBROUTINE BigUInt_Push ( Big , Value ) !** PURPOSE OF THIS SUBROUTINE: ! To append the item to the BigUInt IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value ! item to be appended !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Big % Digit ( Big % Length ) = Value Big % Length = Big % Length + 1 RETURN END SUBROUTINE BigUInt_Push !****************************************************************************** SUBROUTINE BigUInt_Extend ( Big , Span ) !** PURPOSE OF THIS SUBROUTINE: ! To append a span of items to the stack IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Span ( 0 :) ! span of items to be appended !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SpanLen ! FLOW SpanLen = SIZE ( Span ) Big % Digit ( Big % Length : Big % Length + SpanLen - 1 ) = Span ( 0 : SpanLen - 1 ) Big % Length = Big % Length + SpanLen RETURN END SUBROUTINE BigUInt_Extend !****************************************************************************** SUBROUTINE BigUInt_Normalize ( Big ) !** PURPOSE OF THIS SUBROUTINE: ! To normalize the BigUInt, so most-significant zero digits are removed. IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex ! FLOW RIndex = Big % Length - 1 IF ( RIndex >= 0 ) THEN DO WHILE ( Big % Digit ( RIndex ) == 0_I8B ) Big % Length = Big % Length - 1 RIndex = Big % Length - 1 IF ( RIndex < 0 ) EXIT END DO END IF RETURN END SUBROUTINE BigUInt_Normalize !****************************************************************************** FUNCTION ScalarAdd ( X , Y , Overflow ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To add two small integers, checking for overflow. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y LOGICAL , INTENT ( OUT ) :: Overflow INTEGER ( KIND = I8B ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! add value Z = X + Y ! check overflow Overflow = Z . ULT . X RETURN END FUNCTION ScalarAdd !****************************************************************************** FUNCTION ScalarMul ( X , Y , Carry ) RESULT ( Z_Low ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply two small integers, getting both the high and low bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Carry INTEGER ( KIND = I8B ) :: Z_Low !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Z_Hi LOGICAL :: Overflow !** FLOW CALL UMul128 ( X , Y , Z_Hi , Z_Low ) Z_Low = ScalarAdd ( Z_Low , Carry , Overflow ) IF ( Overflow ) Z_Hi = Z_Hi + 1_I8B ! cannot overflow Carry = Z_Hi RETURN END FUNCTION ScalarMul !****************************************************************************** SUBROUTINE BigUInt_SmallMul ( Big , Y ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply BigUInt by scalar value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ! value to be added !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index INTEGER ( KIND = I8B ) :: Carry !** FLOW Carry = 0_I8B DO Index = 0 , Big % Length - 1 Big % Digit ( Index ) = ScalarMul ( Big % Digit ( Index ), Y , Carry ) END DO IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_SmallMul !****************************************************************************** SUBROUTINE BigUInt_LongMul ( Big , Span ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply BigUInt and BigUInt using grade-school multiplication algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Span ( 0 :) ! span of values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SpanLen INTEGER ( KIND = I8B ) :: Z ( 0 : Big % Length + SIZE ( Span ) - 1 ) !** FLOW SpanLen = SIZE ( Span ) IF ( SpanLen /= 0 ) THEN ! perform multiplication CALL MultiplyBasic ( Big % Digit , Big % Length , Span , SpanLen , Z ) ! transfer output from the buffer back to the stack Big % Length = Big % Length + SpanLen Big % Digit ( 0 : Big % Length - 1 ) = Z ( 0 : Big % Length - 1 ) END IF CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_LongMul !****************************************************************************** SUBROUTINE BigUInt_From_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To create BigUInt from a unsigned 64-bit integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Push ( Val ) CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_From_U64 !****************************************************************************** FUNCTION BigUInt_Get_Hi64 ( Big , Truncated ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To get the high 64 bits from the vector, and if bits were truncated. ! this is to get the significant digits for the float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex !** FLOW IF ( Big % Length == 0 ) THEN Val = Empty_Hi64 ( Truncated ) ELSEIF ( Big % Length == 1 ) THEN RIndex = Big % Length - 1 Val = Uint64_Hi64_I ( Big % Digit ( RIndex ), Truncated ) ELSE RIndex = Big % Length - 1 Val = Uint64_Hi64_II ( Big % Digit ( RIndex ), Big % Digit ( RIndex - 1 ), Truncated ) Truncated = Truncated . OR . Big % IsNonZero ( 2 ) END IF RETURN END FUNCTION BigUInt_Get_Hi64 !****************************************************************************** FUNCTION BigUInt_Compare ( Big , Other ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare two big integers, returning the large value. ! assumes both are normalized. if the return value is ! negative, other is larger, if the return value is ! positive, this is larger, otherwise they are equal. ! the limbs are stored in little-endian order, so we ! must compare the limbs in ever order. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big , Other INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index !** FLOW IF ( Big % Length > Other % Length ) THEN Flag = 1 ELSEIF ( Big % Length < Other % Length ) THEN Flag = - 1 ELSE DO Index = Big % Length - 1 , 0 , - 1 ASSOCIATE ( XI => Big % Digit ( Index ), YI => Other % Digit ( Index )) IF ( XI . UGT . YI ) THEN Flag = 1 RETURN ELSEIF ( XI . ULT . YI ) THEN Flag = - 1 RETURN END IF END ASSOCIATE END DO Flag = 0 END IF RETURN END FUNCTION BigUInt_Compare !****************************************************************************** SUBROUTINE BigUInt_ShiftL ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To move the limbs left by `n` bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE PARAMETER DECLARATIONS: ! these parameters are for DigitBits = 64 INTEGER ( KIND = I4B ), PARAMETER :: LargePos = 6 INTEGER ( KIND = I4B ), PARAMETER :: SmallMask = 63 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LargeShift , SmallShift !** FLOW LargeShift = SHIFTR ( N , LargePos ) SmallShift = IAND ( N , SmallMask ) IF ( LargeShift > 0 ) CALL BigUInt_ShiftL_Limbs ( Big , LargeShift ) IF ( SmallShift > 0 ) CALL BigUInt_ShiftL_Bits ( Big , SmallShift ) RETURN CONTAINS SUBROUTINE BigUInt_ShiftL_Bits ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To shift left each limb n bits, carrying over to the new limb ! returns true if we were able to shift all the digits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index , Shl , Shr INTEGER ( KIND = I8B ) :: XI , Carry , Prev !** FLOW ! Internally, for each item, we shift left by n, and add the previous ! right shifted limb-bits. ! For example, we transform (for u8) shifted left 2, to: !      b10100100 b01000010 !      b10 b10010001 b00001000 ! ASSERT(n /= 0) ! ASSERT(n < sizeof(limb) * 8) Shl = N Shr = DigitBits - Shl Prev = 0_I8B DO Index = 0 , Big % Length - 1 XI = Big % Digit ( Index ) Big % Digit ( Index ) = IOR ( SHIFTL ( XI , Shl ), SHIFTR ( Prev , Shr )) Prev = XI END DO Carry = SHIFTR ( Prev , Shr ) IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_ShiftL_Bits !************************************************************************** SUBROUTINE BigUInt_ShiftL_Limbs ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To move the limbs left by `n` limbs. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Buffer ( 0 : Big % Length - 1 ) !** FLOW IF (. NOT . Big % IsEmpty ()) THEN ! move limbs by first copy source to buffer Buffer ( 0 : Big % Length - 1 ) = Big % Digit ( 0 : Big % Length - 1 ) ! then copy from the buffer to the destination Big % Digit ( N : Big % Length + N - 1 ) = Buffer ( 0 : Big % Length - 1 ) ! fill in empty limbs Big % Digit ( 0 : N - 1 ) = 0_I8B ! set length Big % Length = Big % Length + N END IF RETURN END SUBROUTINE BigUInt_ShiftL_Limbs !************************************************************************** END SUBROUTINE BigUInt_ShiftL !****************************************************************************** FUNCTION BigUInt_LeadZ ( Big ) RESULT ( N ) !** PURPOSE OF THIS SUBROUTINE: ! To get the number of leading zeros in the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big INTEGER ( KIND = I4B ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Big % IsEmpty ()) THEN N = 0 ELSE N = LEADZ ( Big % Digit ( Big % Length - 1 )) END IF RETURN END FUNCTION BigUInt_LeadZ !****************************************************************************** FUNCTION BigUInt_BitLen ( Big ) RESULT ( N ) !** PURPOSE OF THIS SUBROUTINE: ! To get the number of bits in the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big INTEGER ( KIND = I4B ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ !** FLOW LZ = Big % LeadZ () N = DigitBits * Big % Length - LZ RETURN END FUNCTION BigUInt_BitLen !****************************************************************************** SUBROUTINE BigUInt_Add ( Big , Y ) !** PURPOSE OF THIS SUBROUTINE: ! To add a long number to the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index INTEGER ( KIND = I8B ) :: Carry LOGICAL :: Overflow !** FLOW Index = 0 Carry = Y DO WHILE (( Carry /= 0_I8B ). AND .( Index < Big % Length )) Big % Digit ( Index ) = ScalarAdd ( Big % Digit ( Index ), Carry , Overflow ) IF ( Overflow ) THEN Carry = 1_I8B ELSE Carry = 0_I8B END IF Index = Index + 1 END DO IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_Add !****************************************************************************** SUBROUTINE BigUInt_Pow2 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 2 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % ShiftL ( Exp ) RETURN END SUBROUTINE BigUInt_Pow2 !****************************************************************************** SUBROUTINE BigUInt_Pow5 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 5 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE PARAMETER DECLARATIONS: ! multiply by a power of 5 INTEGER ( KIND = I4B ), PARAMETER :: Large_Step = 135 INTEGER ( KIND = I4B ), PARAMETER :: Small_Step = 27 INTEGER ( KIND = I4B ), PARAMETER :: Large_Length = 5 INTEGER ( KIND = I8B ), PARAMETER :: Small_Power_of_5 ( 0 : Small_Step ) = [ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '0000000000000005' , KIND = I8B ), & INT ( Z '0000000000000019' , KIND = I8B ), INT ( Z '000000000000007D' , KIND = I8B ), & INT ( Z '0000000000000271' , KIND = I8B ), INT ( Z '0000000000000C35' , KIND = I8B ), & INT ( Z '0000000000003D09' , KIND = I8B ), INT ( Z '000000000001312D' , KIND = I8B ), & INT ( Z '000000000005F5E1' , KIND = I8B ), INT ( Z '00000000001DCD65' , KIND = I8B ), & INT ( Z '00000000009502F9' , KIND = I8B ), INT ( Z '0000000002E90EDD' , KIND = I8B ), & INT ( Z '000000000E8D4A51' , KIND = I8B ), INT ( Z '0000000048C27395' , KIND = I8B ), & INT ( Z '000000016BCC41E9' , KIND = I8B ), INT ( Z '000000071AFD498D' , KIND = I8B ), & INT ( Z '0000002386F26FC1' , KIND = I8B ), INT ( Z '000000B1A2BC2EC5' , KIND = I8B ), & INT ( Z '000003782DACE9D9' , KIND = I8B ), INT ( Z '00001158E460913D' , KIND = I8B ), & INT ( Z '000056BC75E2D631' , KIND = I8B ), INT ( Z '0001B1AE4D6E2EF5' , KIND = I8B ), & INT ( Z '000878678326EAC9' , KIND = I8B ), INT ( Z '002A5A058FC295ED' , KIND = I8B ), & INT ( Z '00D3C21BCECCEDA1' , KIND = I8B ), INT ( Z '0422CA8B0A00A425' , KIND = I8B ), & INT ( Z '14ADF4B7320334B9' , KIND = I8B ), INT ( Z '6765C793FA10079D' , KIND = I8B )] INTEGER ( KIND = I8B ), PARAMETER :: Max_Native = Small_Power_of_5 ( Small_Step ) ! 7450580596923828125_I8B INTEGER ( KIND = I8B ), PARAMETER :: Large_Power_of_5 ( 0 : Large_Length - 1 ) = [ & INT ( Z '13A1D71CFF1B172D' , KIND = I8B ), INT ( Z '7F682D3DEFA07617' , KIND = I8B ), & INT ( Z '3F0131E7FF8C90C0' , KIND = I8B ), INT ( Z '917B01773FDCB9FE' , KIND = I8B ), & INT ( Z '2C06B9D16C407A7' , KIND = I8B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: IExp !** FLOW IExp = Exp ! multiply Big by 5**Large_Step DO WHILE ( IExp >= Large_Step ) CALL Big % LongMul ( Large_Power_of_5 ) IExp = IExp - Large_Step END DO ! multiply Big by 5**Small_Step DO WHILE ( IExp >= Small_Step ) CALL Big % SmallMul ( Max_Native ) IExp = IExp - Small_Step END DO ! multiply Big by 5**IExp IF ( IExp /= 0 ) CALL Big % SmallMul ( Small_Power_of_5 ( IExp )) RETURN END SUBROUTINE BigUInt_Pow5 !****************************************************************************** SUBROUTINE BigUInt_Pow10 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 10 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Pow5 ( Exp ) CALL Big % Pow2 ( Exp ) RETURN END SUBROUTINE BigUInt_Pow10 ! ----------------------------------------------------------------------------- ! -----   BigUInt Routines for YY Algorithms                              ----- ! ----------------------------------------------------------------------------- SUBROUTINE BigInt_Add_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big + Val'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx , Max INTEGER ( KIND = I8B ) :: Num , Add !** FLOW Num = Big % Digit ( 0 ) Add = Num + Val Big % Digit ( 0 ) = Add IF (( Add . UGE . Num ). OR .( Add . UGE . Val )) RETURN ! add digit Max = Big % Length DO Idx = 1 , Max - 1 IF ( Big % Digit ( Idx ) /= MaxU64 ) THEN Big % Digit ( Idx ) = Big % Digit ( Idx ) + 1_I8B RETURN END IF Big % Digit ( Idx ) = 0_I8B END DO Big % Digit ( Big % Length ) = 1_I8B Big % Length = Big % Length + 1 RETURN END SUBROUTINE BigInt_Add_U64 !****************************************************************************** SUBROUTINE BigInt_Mul_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * Val'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (cannot be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx , Max INTEGER ( KIND = I8B ) :: Hi , Lo , Carry !** FLOW ! initialize Idx = 0 Max = Big % Length Carry = 0_I8B DO WHILE ( Idx < Max ) IF ( Big % Digit ( Idx ) /= 0_I8B ) EXIT Idx = Idx + 1 END DO DO WHILE ( Idx < Max ) CALL UMul128_N_Add ( Big % Digit ( Idx ), Val , Carry , Hi , Lo ) Big % Digit ( Idx ) = Lo Carry = Hi Idx = Idx + 1 END DO IF ( Carry /= 0_I8B ) THEN Big % Digit ( Big % Length ) = Carry Big % Length = Big % Length + 1 END IF RETURN END SUBROUTINE BigInt_Mul_U64 !****************************************************************************** SUBROUTINE BigInt_Mul_Pow2 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * (2**Exp)'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! an exponent integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift , Move , Idx INTEGER ( KIND = I8B ) :: Num !** FLOW ! initialize Shift = IAND ( Exp , 63 ) ! small shift == MOD(Exp, 64) Move = SHIFTR ( Exp , 6 ) ! large shift == Exp / 64 Idx = Big % Length IF ( Shift == 0 ) THEN DO WHILE ( Idx > 0 ) Big % Digit ( Idx + Move - 1 ) = Big % Digit ( Idx - 1 ) Idx = Idx - 1 END DO Big % Length = Big % Length + Move DO WHILE ( Move /= 0 ) Move = Move - 1 Big % Digit ( Move ) = 0_I8B END DO ELSE Big % Digit ( Idx ) = 0_I8B DO WHILE ( Idx > 0 ) Num = SHIFTL ( Big % Digit ( Idx ), Shift ) Num = IOR ( Num , SHIFTR ( Big % Digit ( Idx - 1 ), ( 64 - Shift ))) Big % Digit ( Idx + Move ) = Num Idx = Idx - 1 END DO Big % Digit ( Move ) = SHIFTL ( Big % Digit ( 0 ), Shift ) IF ( Big % Digit ( Big % Length + Move ) /= 0_I8B ) THEN Big % Length = Big % Length + ( Move + 1 ) ELSE Big % Length = Big % Length + Move END IF DO WHILE ( Move /= 0 ) Move = Move - 1 Big % Digit ( Move ) = 0_I8B END DO END IF RETURN END SUBROUTINE BigInt_Mul_Pow2 !****************************************************************************** SUBROUTINE BigInt_Mul_Pow10 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * (10**Exp)'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! an exponent integer (cannot be 0) !** SUBROUTINE PARAMETER DECLARATIONS: ! Maximum exponent of exact pow10 INTEGER ( KIND = I4B ), PARAMETER :: U64_POW10_MAX_EXP = 19 ! Table: [ 10&#94;0, ..., 10&#94;19 ] INTEGER ( KIND = I8B ), PARAMETER :: U64_Pow10_Table ( 0 : U64_POW10_MAX_EXP ) = [ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B ), & INT ( Z '0000000000000064' , KIND = I8B ), INT ( Z '00000000000003E8' , KIND = I8B ), & INT ( Z '0000000000002710' , KIND = I8B ), INT ( Z '00000000000186A0' , KIND = I8B ), & INT ( Z '00000000000F4240' , KIND = I8B ), INT ( Z '0000000000989680' , KIND = I8B ), & INT ( Z '0000000005F5E100' , KIND = I8B ), INT ( Z '000000003B9ACA00' , KIND = I8B ), & INT ( Z '00000002540BE400' , KIND = I8B ), INT ( Z '000000174876E800' , KIND = I8B ), & INT ( Z '000000E8D4A51000' , KIND = I8B ), INT ( Z '000009184E72A000' , KIND = I8B ), & INT ( Z '00005AF3107A4000' , KIND = I8B ), INT ( Z '00038D7EA4C68000' , KIND = I8B ), & INT ( Z '002386F26FC10000' , KIND = I8B ), INT ( Z '016345785D8A0000' , KIND = I8B ), & INT ( Z '0DE0B6B3A7640000' , KIND = I8B ), INT ( Z '8AC7230489E80000' , KIND = I8B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Xpn !** FLOW ! initialize Xpn = Exp DO WHILE ( Xpn >= U64_POW10_MAX_EXP ) CALL BigInt_Mul_U64 ( Big , U64_Pow10_Table ( U64_POW10_MAX_EXP )) Xpn = Xpn - U64_POW10_MAX_EXP END DO IF ( Xpn /= 0 ) CALL BigInt_Mul_U64 ( Big , U64_Pow10_Table ( Xpn )) RETURN END SUBROUTINE BigInt_Mul_Pow10 !****************************************************************************** FUNCTION BigInt_Compare ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare two BigUInt. ! return -1 if 'a < b', +1 if 'a > b', 0 if 'a == b'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( IN ) :: A TYPE ( BigUInt ), INTENT ( IN ) :: B INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx !** FLOW ! first check Length components IF ( A % Length < B % Length ) THEN Flag = - 1 RETURN END IF IF ( A % Length > B % Length ) THEN Flag = + 1 RETURN END IF ! next check Digit components Idx = A % Length DO WHILE ( Idx > 0 ) Idx = Idx - 1 ASSOCIATE ( Av => A % Digit ( Idx ), Bv => B % Digit ( Idx )) IF ( Av . ULT . Bv ) THEN Flag = - 1 RETURN END IF IF ( Av . UGT . Bv ) THEN Flag = + 1 RETURN END IF END ASSOCIATE END DO Flag = 0 RETURN END FUNCTION BigInt_Compare !****************************************************************************** SUBROUTINE BigInt_Set_UIntType ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To set 'Big' with the specified unsigned integer value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Big % Length = 1 Big % Digit ( 0 ) = Val RETURN END SUBROUTINE BigInt_Set_UIntType !****************************************************************************** SUBROUTINE BigInt_Set_String ( Big , SigDec , ExpDec , cStr , Aux ) !** PURPOSE OF THIS SUBROUTINE: ! To set 'Big' with the specified floating point number string and its related information. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: ExpDec ! exponent in base 10 CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (. NOT . Aux % Truncated ) THEN ! no digit cut, set significant part only CALL BigInt_Set_UIntType ( Big , SigDec ) RETURN END IF ! some digits were cut, read them from 'SigCut' to 'SigEnd' BLOCK ! +++ local variables +++ INTEGER ( KIND = I4B ) :: Header , SigEnd , CurIdx , Length , DigitTotLen , DotPos INTEGER ( KIND = I8B ) :: CurVal LOGICAL :: DigitCut , HasDot ! +++ execution +++ ! initialize and process auxiliary string information needed Header = Aux % SigCut SigEnd = Aux % Indices ( 4 ) CurIdx = Header Length = 0 CurVal = 0_I8B DigitCut = FalseVal HasDot = TrueVal DotPos = Aux % Indices ( 3 ) - 1 IF ( SigEnd == 0 ) THEN SigEnd = Aux % Indices ( 2 ) HasDot = FalseVal DotPos = 0 END IF DigitTotLen = UIntSafeDigits + ( SigEnd - Header ) IF ( HasDot ) DigitTotLen = DigitTotLen + 1 IF ( DigitTotLen > MaxDecDigits ) THEN DigitCut = TrueVal SigEnd = SigEnd - ( DigitTotLen - ( MaxDecDigits + 1 )) SigEnd = SigEnd - ( Aux % Indices ( 3 ) == Aux % Indices ( 4 )) DigitTotLen = ( MaxDecDigits + 1 ) END IF ExpDec = ExpDec - ( DigitTotLen - UIntSafeDigits ) ! set the truncated significand CALL BigInt_Set_UIntType ( Big , SigDec ) IF ( HasDot ) THEN ! SigCut occurred before encountering the period so we must check ! whether the current position is at the period DO WHILE ( CurIdx <= SigEnd ) IF ( CurIdx /= DotPos ) THEN CurVal = CurVal * IBase + ( IACHAR ( cStr ( CurIdx : CurIdx )) - A0 ) CurIdx = CurIdx + 1 Length = Length + 1 IF (( CurIdx > SigEnd ). AND .( DigitCut )) THEN ! The last digit must be non-zero, set it to '1' for correct rounding. CurVal = CurVal - UMOD ( CurVal , 10_I8B ) + 1_I8B END IF IF (( Length == UIntSafeDigits ). OR .( CurIdx > SigEnd )) THEN CALL Bigint_Mul_Pow10 ( Big , Length ) CALL Bigint_Add_U64 ( Big , CurVal ) CurVal = 0_I8B Length = 0 END IF ELSE CurIdx = CurIdx + 1 END IF END DO ELSE ! SigCut occurred after encountering the period so we do not need to check ! whether the current position is at the period DO WHILE ( CurIdx <= SigEnd ) CurVal = CurVal * IBase + ( IACHAR ( cStr ( CurIdx : CurIdx )) - A0 ) CurIdx = CurIdx + 1 Length = Length + 1 IF (( CurIdx > SigEnd ). AND .( DigitCut )) THEN ! The last digit must be non-zero, set it to '1' for correct rounding. CurVal = CurVal - UMOD ( CurVal , 10_I8B ) + 1_I8B END IF IF (( Length == UIntSafeDigits ). OR .( CurIdx > SigEnd )) THEN CALL Bigint_Mul_Pow10 ( Big , Length ) CALL Bigint_Add_U64 ( Big , CurVal ) CurVal = 0_I8B Length = 0 END IF END DO END IF END BLOCK RETURN END SUBROUTINE BigInt_Set_String !****************************************************************************** !------------------------------------------------------------------------------ ! !            PARSING FLOATING-POINT-NUMBER STRING ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Fortran_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid Fortran real (floating point) number that has one of the two following forms: ! 1. A number without exponent part -> [S]N[N...] ! 2. A number with exponent part    -> [S]N[N...]E[S]N[N...] !   Where !   [ ] indicates an optional field !   S is a sign indicator (required if negative '-', optional if positive '+'). !   N is a decimal digit (0 through 9). A decimal point may appear anywhere !       after the sign (but before the exponent). !   E is an exponent indicator (either 'e' or 'E') ! The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. ! 1. A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. ! 2. The optional kind parameter (_k) is not allowed here. ! ! Note: Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" !   and \"1.23   \" are considered valid.  However, no space is allowed inside !   the supposedly valid number.  For instance, \"1 .2 3\" is considered NOT valid. !   Therefore, this routine is not totally compatible with Fortran READ statement !   where spaces inside the valid number are allowed. !   However, this can easily be done by adding an optional 'Inside Space' flag that !   provide an interpretation of the spaces as 'zero' or 'ignored'.  Then, the input !   will be pre-processed according to the flag.  Nonetheless, this routine neglects !   this optional input because it will make the routine much less efficient due to !   the fact that we will need to scan the whole string twice and we will also need !   to copy the input string into a buffer string and working with the buffer instead !   of directly handling the input string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 19 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigLimit INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: AtLeastOneDigit , Truncated !** FLOW ! initialize SigDec = 0_I8B ExpDec = 0 Valid = FalseVal AtLeastOneDigit = FalseVal Truncated = FalseVal StrLen = LEN_TRIM ( cStr ) ! get valid string length by removing the trailing space(s) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF END IF ! check for sign of the significand NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or a dot CurChr => cStr ( Indx : Indx ) IF ((( CurChr < '0' ). OR .( CurChr > '9' )). AND .( CurChr /= '.' )) THEN ! current character is neither a digit nor a dot Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit or the dot.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN AtLeastOneDigit = TrueVal ! the current digit is zero so loop through the following ! characters until a non-zero character is found DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF ! compute for the significand in the integral part IntegralStart = 0 IntegralEnd = 0 SigCount = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal IntegralStart = Indx DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN IF ( AtLeastOneDigit ) THEN Valid = TrueVal ELSE ! this happens when not a number is encountered (i.e. the first non-blank character ! is not a sign, a digit or a period) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid input: the first non-blank character is not a sign, a digit or a period.' END IF RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (. NOT .(( CurChr == 'e' ). OR .( CurChr == 'E' ))) THEN ! the current character is NOT an exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: invalid character after a digit.' RETURN END IF Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr == '+' ). OR .( CurChr == '-' )) THEN IF ( CurChr == '-' ) ESign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ! check whether the following character is a digit CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ELSE IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent indicator.' RETURN END IF END IF ! here the current character is a digit so this is likely a valid number ExpDec = ( IACHAR ( CurChr ) - A0 ) DO Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! there is a non-integer character after the exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: not a digit after the exponent(+sign) indicator(s).' RETURN END IF ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT END DO END IF END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = 0_I8B SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_Fortran_String !****************************************************************************** FUNCTION Parse_JSON_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid JSON real (floating point) number where its differences ! from Fortran number are as follows: !   1. leading and trailing spaces are not allowed. !   2. a plus sign as the first character is not allowed. !   3. leading zero(s) is not allowed (if 0 is the first character, the second one !      must either be a period or an exponent indicator.) !   4. a period must be followed by at least one digit. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 19 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigLimit INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: Truncated !** FLOW ! initialize SigDec = 0_I8B ExpDec = 0 Valid = FalseVal Truncated = FalseVal StrLen = LEN ( cStr ) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check for sign of the significand NegSign = FalseVal Indx = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the current (leading) digit is zero Indx = Indx + 1 IF ( Indx > StrLen ) THEN ! only a zero digit encountered Valid = TrueVal RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN ! leading zero cannot be followed by an integer (i.e. no leading zeros) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is/are not allowed.' RETURN END IF IntegralStart = 0 IntegralEnd = 0 SigCount = 0 ELSE ! check whether the current character is a non-zero digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! must start with an integer IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a leading character is not a digit.' RETURN END IF ! compute for the significand in the integral part IntegralStart = Indx SigDec = IACHAR ( cStr ( Indx : Indx )) - A0 Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN ! this should not happen here since the algorithm implemented above should take care of this already? IF ( PRESENT ( ErrMsg )) ErrMsg = 'There must be something wrong with the implementation.' RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (. NOT .(( CurChr == 'e' ). OR .( CurChr == 'E' ))) THEN ! the current character is NOT an exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: invalid character after a digit.' RETURN END IF Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr == '+' ). OR .( CurChr == '-' )) THEN IF ( CurChr == '-' ) ESign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ! check whether the following character is a digit CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ELSE IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent indicator.' RETURN END IF END IF ! here the current character is a digit so this is likely a valid number ExpDec = ( IACHAR ( CurChr ) - A0 ) DO Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! there is a non-integer character after the exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: not a digit after the exponent(+sign) indicator(s).' RETURN END IF ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT END DO END IF END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = 0_I8B SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_JSON_String !****************************************************************************** FUNCTION Parse_FPlus_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid Fortran real (floating point) number with more relaxed rules than ! those used in \"Parse_Fortran_Number\" routine. ! The relaxed rules consider the following numbers as valid: !   1. a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' !      in place of 'e' or 'E'. !   2. a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to !      be expressed in a valid number expressed in the scientific format !   3. digits before any invalid character encountered are treated as a valid number !      and any characters after the first encounter (including the first invalid one) !      are neglected.  therefore, for example, a '12.56ax-300' is considered to be !      a valid number with value of 12.56. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 19 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigLimit INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: AtLeastOneDigit , Truncated !** FLOW ! initialize SigDec = 0_I8B ExpDec = 0 Valid = FalseVal AtLeastOneDigit = FalseVal Truncated = FalseVal StrLen = LEN_TRIM ( cStr ) ! get valid string length by removing the trailing space(s) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF END IF ! check for sign of the significand NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or a dot CurChr => cStr ( Indx : Indx ) IF ((( CurChr < '0' ). OR .( CurChr > '9' )). AND .( CurChr /= '.' )) THEN ! current character is neither a digit nor a dot Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit or the dot.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN AtLeastOneDigit = TrueVal ! the current digit is zero so loop through the following ! characters until a non-zero character is found DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF ! compute for the significand in the integral part IntegralStart = 0 IntegralEnd = 0 SigCount = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal IntegralStart = Indx DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN IF ( AtLeastOneDigit ) THEN Valid = TrueVal ELSE ! this happens when not a number is encountered (i.e. the first non-blank character ! is not a sign, a digit or a period) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid input: the first non-blank character is not a sign, a digit or a period.' END IF RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN DO SELECT CASE ( cStr ( Indx : Indx )) CASE ( 'e' , 'E' , 'd' , 'D' , 'q' , 'Q' ) Indx = Indx + 1 ! check for a sign of the exponent IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF ( CurChr == '-' ) THEN ESign = - 1 Indx = Indx + 1 ELSEIF ( CurChr == '+' ) THEN Indx = Indx + 1 END IF ELSE EXIT END IF CASE ( '-' ) ESign = - 1 Indx = Indx + 1 CASE ( '+' ) Indx = Indx + 1 CASE DEFAULT EXIT END SELECT IF ( Indx <= StrLen ) THEN DO CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT Indx = Indx + 1 IF ( Indx > StrLen ) EXIT END DO END IF EXIT END DO END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = 0_I8B SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_FPlus_String !****************************************************************************** !------------------------------------------------------------------------------ ! !                       BINARY-TO-DECIMAL CONVERSION ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10 LOGICAL :: Include_Left_Endpoint , Include_Right_Endpoint INTEGER ( KIND = I4B ) :: Minus_K , Beta INTEGER ( KIND = I4B ) :: DeltaI , R , Dist INTEGER ( KIND = I8B ) :: Two_Fl , Two_Fc INTEGER ( KIND = I8B ) :: ZMul_Val LOGICAL :: ZMul_IsInteger LOGICAL :: XMul_IsInteger , XMul_Parity LOGICAL :: YMul_IsInteger , Approx_Y_Parity LOGICAL :: Divisible_By_Small_Divisor !** FLOW: ! Step 1: integer promotion & Schubfach multiplier calculation. ! Check if normal. IF (( ExpRaw /= 0 ). AND .( SigRaw == 0_I8B )) THEN CALL Shorter_Interval_Case ( ExpBin , SigDec , ExpDec ) RETURN END IF Include_Left_Endpoint = ( IAND ( SigBin , 1_I8B ) == 0_I8B ) Include_Right_Endpoint = Include_Left_Endpoint ! Compute K and Beta as well as get cached data Minus_K = Floor_Log10_Pow2 ( ExpBin ) - Kappa Beta = ExpBin + Floor_Log2_Pow10 ( - Minus_K ) Pow10 = Get_Pow10_128Bits ( - Minus_K ) IF ( Minus_K > 0 ) Pow10 % Low = Pow10 % Low + 1_I8B ! Compute Zi and Deltai. ! 10**Kappa <= Deltai < 10**(Kappa + 1) DeltaI = Compute_Delta ( Pow10 , Beta ) Two_Fc = SHIFTL ( SigBin , 1 ) ! For the case of binary32, the result of integer check is not correct for ! 29711844 * 2&#94;-82 ! = 6.1442653300000000008655037797566933477355632930994033813476... * 10&#94;-18 ! and 29711844 * 2&#94;-81 ! = 1.2288530660000000001731007559513386695471126586198806762695... * 10&#94;-17, ! and they are the unique counterexamples. However, since 29711844 is even, ! this does not cause any problem for the endpoints calculations; it can only ! cause a problem when we need to perform integer check for the center. ! Fortunately, with these inputs, that branch is never executed, so we are ! fine. CALL Compute_Mul ( SHIFTL ( IOR ( Two_Fc , 1_I8B ), Beta ), Pow10 , ZMul_Val , ZMul_IsInteger ) ! Step 2: Try larger divisor; remove trailing zeros if necessary. ! Using an upper bound on zi, we might be able to optimize the division ! better than the compiler; we are computing zi / big_divisor here. SigDec = Divide_By_10_To_Kappa_Plus_1 ( ZMul_Val ) R = ZMul_Val - Big_Divisor * SigDec ! implicit conversion if necessary IF ( R . ULT . DeltaI ) THEN ! Exclude the right endpoint if necessary. IF (( R == 0 ). AND . ZMul_IsInteger . AND .(. NOT . Include_Right_Endpoint )) THEN SigDec = SigDec - 1_I8B R = Big_Divisor ! must perform Step 3 ELSE ExpDec = Minus_K + Kappa + 1 RETURN END IF ELSEIF ( R == DeltaI ) THEN ! r == deltai; compare fractional parts. Two_Fl = Two_Fc - 1_I8B XMul_Parity = Compute_Mul_Parity ( Two_Fl , Pow10 , Beta , XMul_IsInteger ) IF ((. NOT . Include_Left_Endpoint ). OR .( ExpBin < Case_Fc_Pm_Half_Lower_Threshold ). OR . & ( ExpBin > Divisibility_Check_By_5_Threshold )) THEN ! If the left endpoint is not included, the condition for ! success is z&#94;(f) < delta&#94;(f) (odd parity). ! Otherwise, the inequalities on exponent ensure that ! x is not an integer, so if z&#94;(f) >= delta&#94;(f) (even parity), we in fact ! have strict inequality. IF ( XMul_Parity ) THEN ExpDec = Minus_K + Kappa + 1 RETURN END IF ! must perform Step 3 ELSE IF ( XMul_Parity . OR . XMul_IsInteger ) THEN ExpDec = Minus_K + Kappa + 1 RETURN END IF ! must perform Step 3 END IF ELSE ! must perform Step 3 END IF ! Step 3: Find the significand with the smaller divisor SigDec = SigDec * TenUInt ExpDec = Minus_K + Kappa Dist = R - SHIFTR ( DeltaI , 1 ) + Half_Small_Divisor Approx_Y_Parity = IAND ( IEOR ( Dist , Half_Small_Divisor ), 1 ) /= 0 Divisible_By_Small_Divisor = Is_Divisible_By_Pow10 ( Dist ) ! Add dist / 10&#94;kappa to the significand. SigDec = SigDec + Dist ! Is dist divisible by 10&#94;kappa? IF ( Divisible_By_Small_Divisor ) THEN ! Check z&#94;(f) >= epsilon&#94;(f). ! We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1, ! where yi == zi - epsiloni if and only if z&#94;(f) >= epsilon&#94;(f) ! Since there are only 2 possibilities, we only need to care about the ! parity. Also, zi and r should have the same parity since the divisor ! is an even number. IF ( Compute_Mul_Parity ( Two_Fc , Pow10 , Beta , YMul_IsInteger ) . NEQV . Approx_Y_Parity ) THEN SigDec = SigDec - 1_I8B ELSE ! If z&#94;(f) >= epsilon&#94;(f), we might have a tie ! when z&#94;(f) == epsilon&#94;(f), or equivalently, when y is an integer IF ( YMul_IsInteger ) THEN IF ( IAND ( SigDec , 1_I8B ) /= 0_I8B ) SigDec = SigDec - 1_I8B END IF END IF END IF RETURN CONTAINS SUBROUTINE Compute_Mul ( U , Pow10 , ResHi , IsInteger ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the multiplication of U and Pow10 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: U TYPE ( UInt128 ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: ResHi LOGICAL , INTENT ( OUT ) :: IsInteger !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: ResLo !** FLOW CALL UMul192_Upper128 ( U , Pow10 % High , Pow10 % Low , ResHi , ResLo ) IsInteger = ResLo == 0_I8B RETURN END SUBROUTINE Compute_Mul !************************************************************************** FUNCTION Compute_Mul_Parity ( Two_F , Pow10 , Beta , IsInteger ) RESULT ( Parity ) !** PURPOSE OF THIS SUBROUTINE: ! To check multiplication parity IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Two_F TYPE ( UInt128 ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta LOGICAL , INTENT ( OUT ) :: IsInteger LOGICAL :: Parity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: U128Hi , U128Lo !** FLOW CALL UMul192_Lower128 ( Two_F , Pow10 % High , Pow10 % Low , U128Hi , U128Lo ) Parity = IAND ( SHIFTR ( U128Hi , ( 64 - Beta )), 1_I8B ) /= 0_I8B IsInteger = IOR ( SHIFTL ( U128Hi , Beta ), SHIFTR ( U128Lo , ( 64 - Beta ))) == 0_I8B RETURN END FUNCTION Compute_Mul_Parity !************************************************************************** FUNCTION Is_Divisible_By_Pow10 ( N ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To replace N by Floor(N / Pow(10, M)) returning true if and only if N is ! divisible by pow(10, M). ! Precondition: N <= Pow(10, M + 1). ! Note: M = Kappa IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: N LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The numbers below are chosen such that: !   1. floor(n/d) = floor(nm / 2&#94;k) where d=10 or d=100, !   2. nm mod 2&#94;k < m if and only if n is divisible by d, ! where m is magic_number, k is shift_amount ! and d is divisor. ! ! Item 1 is a common technique of replacing division by a constant with ! multiplication, see e.g. \"Division by Invariant Integers Using ! Multiplication\" by Granlund and Montgomery (1994). magic_number (m) is set ! to ceil(2&#94;k/d) for large enough k. ! The idea for item 2 originates from Schubfach. N = N * Magic_Number Flag = IAND ( N , Comparison_Mask ) . ULT . Magic_Number N = SHIFTR ( N , Info_Shift_Amount ) RETURN END FUNCTION Is_Divisible_By_Pow10 !************************************************************************** FUNCTION Divide_By_10_To_Kappa_Plus_1 ( N ) RESULT ( M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute M = Floor(N / 10**(Kappa + 1)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: N INTEGER ( KIND = I8B ) :: M !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW M = SHIFTR ( UMul128_Upper64 ( N , DivM ), DivS ) RETURN END FUNCTION Divide_By_10_To_Kappa_Plus_1 !************************************************************************** FUNCTION Compute_Delta ( Pow10 , Beta ) RESULT ( Delta ) !** PURPOSE OF THIS SUBROUTINE: ! To compute Delta IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I4B ) :: Delta !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Delta = INT ( IAND ( SHIFTR ( Pow10 % High , ( 64 - 1 - Beta )), INT ( Z '00000000FFFFFFFF' , KIND = I8B )), KIND = I4B ) RETURN END FUNCTION Compute_Delta !************************************************************************** SUBROUTINE Shorter_Interval_Case ( Exponent , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the decimal representation ! for shorter interval case. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exponent ! The decoded value of exponent in binary INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Minus_K , Beta INTEGER ( KIND = I8B ) :: Xi , Zi TYPE ( UInt128 ) :: Pow10 !** FLOW: ! Compute k and beta Minus_K = Floor_Log10_ThreeQuartersPow2 ( Exponent ) Beta = Exponent + Floor_Log2_Pow10 ( - Minus_K ) ! Compute Xi and Zi Pow10 = Get_Pow10_128Bits ( - Minus_K ) IF ( Minus_K > 0 ) Pow10 % Low = Pow10 % Low + 1_I8B Xi = Compute_Left_Endpoint ( Pow10 , Beta ) Zi = Compute_Right_Endpoint ( Pow10 , Beta ) ! If the left endpoint is not an integer, increase it IF (. NOT . Is_Left_Endpoint_Integer ( Exponent )) Xi = Xi + 1_I8B ! Try bigger divisor SigDec = Zi . UDIV . TenUInt ! If succeed, remove trailing zeros if necessary and return IF ( SigDec * TenUInt . UGE . Xi ) THEN ExpDec = Minus_K + 1 ExpDec = ExpDec RETURN END IF ! Otherwise, compute the round-up of y SigDec = Compute_Round_Up ( Pow10 , Beta ) ExpDec = Minus_K ! When tie occurs, choose one of them according to the rule IF ( Exponent >= Shorter_Interval_Tie_Lower_Threshold . AND . & Exponent <= Shorter_Interval_Tie_Upper_Threshold ) THEN IF ( IAND ( SigDec , 1_I8B ) /= 0_I8B ) SigDec = SigDec - 1_I8B ! Round to even. ELSEIF ( SigDec . ULT . Xi ) THEN SigDec = SigDec + 1_I8B END IF RETURN END SUBROUTINE Shorter_Interval_Case !************************************************************************** FUNCTION Compute_Left_Endpoint ( Pow10 , Beta ) RESULT ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the left end point (Xi) for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I8B ) :: X !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW X = SHIFTR (( Pow10 % High - SHIFTR ( Pow10 % High , ( SignificandBits + 2 ))), & ( TotalBits - SignificandBits - 1 - Beta )) RETURN END FUNCTION Compute_Left_Endpoint !************************************************************************** FUNCTION Compute_Right_Endpoint ( Pow10 , Beta ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the right end point (Zi) for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I8B ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Z = SHIFTR (( Pow10 % High + SHIFTR ( Pow10 % High , ( SignificandBits + 1 ))), & ( TotalBits - SignificandBits - 1 - Beta )) RETURN END FUNCTION Compute_Right_Endpoint !************************************************************************** FUNCTION Compute_Round_Up ( Pow10 , Beta ) RESULT ( Y ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the rounded-up value of Yi for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I8B ) :: Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Y = SHIFTR ( SHIFTR ( Pow10 % High , ( TotalBits - SignificandBits - 2 - Beta )) + 1_I8B , 1 ) RETURN END FUNCTION Compute_Round_Up !************************************************************************** FUNCTION Is_Left_Endpoint_Integer ( E ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To chaeck whether the left end point (Xi) is an integer for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = (( E >= Case_Shorter_Interval_Left_Endpoint_Lower_Threshold ) . AND . & ( E <= Case_Shorter_Interval_Left_Endpoint_Upper_Threshold )) RETURN END FUNCTION Is_Left_Endpoint_Integer !************************************************************************** END SUBROUTINE Bin2Dec_DragonBox !****************************************************************************** SUBROUTINE Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: REAL ( KIND = DP ), PARAMETER :: Log2Base5 = LOG ( 2.0_DP ) / LOG ( 5.0_DP ) INTEGER ( KIND = I4B ), PARAMETER :: QLimit = FLOOR ( Log2Base5 * BinaryPrecision ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: E2 INTEGER ( KIND = I8B ) :: M2 LOGICAL :: Even , AcceptBounds INTEGER ( KIND = I8B ) :: MV , MP , MM INTEGER ( KIND = I8B ) :: Vr , Vp , Vm INTEGER ( KIND = I8B ) :: VrDiv10 , VpDiv10 , VmDiv10 INTEGER ( KIND = I8B ) :: VrMod10 , VmMod10 INTEGER ( KIND = I4B ) :: E10 , Q LOGICAL :: VmIsTrailingZeros , VrIsTrailingZeros , DecrementVp INTEGER ( KIND = I4B ) :: Removed , LastRemovedDigit !** FLOW ! We subtract 2 in all cases so that the bounds computation has 2 additional bits. E2 = ExpBin - 2 M2 = SigBin Even = IAND ( M2 , 1_I8B ) == 0_I8B AcceptBounds = Even ! Step 2: Determine the interval of legal decimal representations. ! Implicit bool -> int conversion. True is 1, false is 0. MV = M2 * FourUInt MP = MV + TwoUInt ! check whether Cb is closer to the lower bound IF (( SigRaw == 0_I8B ). AND .( ExpRaw > 1 )) THEN ! closer to the lower bound; irregular spacing MM = MV - 1_I8B ELSE ! not closer to the lower bound; regular spacing MM = MV - TwoUInt END IF ! Step 3: Convert to a decimal power base using 128-bit arithmetic. VmIsTrailingZeros = FalseVal VrIsTrailingZeros = FalseVal DecrementVp = FalseVal IF ( E2 >= 0 ) THEN ! We need (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 ! and we need to remove at least Q' = LOG10(2**E2) digits from the ! scaled values Vm, Vr, Vp, i.e. we want to compute !  (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**Q' !               = (MM, MV, MP) * 2**E2 / 10**(E10) !               = (MM, MV, MP) * 5**(-E10) / 2**(E10 - E2) ! However, to correctly round the result we need to know the value of ! the last removed digit.  We therefore remove only Q = Q' - 1 digits in ! the first step and make sure that we execute the loop below at least ! once and determine the correct value of the last removed digit. Q = Floor_Log10_Pow2 ( E2 ) IF ( E2 > 3 ) Q = Q - 1 ! == MAX(0, Q' - 1) E10 = Q ! Determine whether all the removed digits are 0. ! ! Z(X, E2, Q) = MOD((X * 2**E2), 10**Q) == 0 !             = P10(X * 2**E2) >= Q !             = MIN(P2(X) + P2(E2), P5(X)) >= Q !             = P2(X) + E2 >= Q and P5(x) >= Q !             = P5(X) >= Q !             = MOD(X, 5**Q) == 0 ! QLimit = FLOOR(LOG5(2**BinaryPrecision)) IF ( Q <= QLimit ) THEN ! Only one of MP, MV, and MM can be a multiple of 5, if any. IF ( UMOD ( MV , FiveUInt ) == 0_I8B ) THEN VrIsTrailingZeros = Is_Multiple_Of_Pow5 ( MV , Q - 1 ) ELSEIF ( AcceptBounds ) THEN ! Same as min(E2 + (~MM & 1), Pow5Factor(MM)) >= Q ! <=> E2 + (~MM & 1) >= Q && Pow5Factor(MM) >= Q ! <=> true && Pow5Factor(MM) >= Q, since E2 >= Q. VmIsTrailingZeros = Is_Multiple_Of_Pow5 ( MM , Q ) ELSE ! Same as min(E2 + 1, Pow5Factor(MP)) >= Q. ! Vp -= Is_Multiple_Of_Pow5(MP, Q) DecrementVp = Is_Multiple_Of_Pow5 ( MP , Q ) END IF END IF ELSE ! We need (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**E2 ! and we need to remove at least Q' = LOG10(5**-E2) digits from the ! scaled values Vm, Vr, Vp, i.e. we want to compute !  (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**(E2 + Q') !               = (MM, MV, MP) * 2**E2 / 10**(E10), !               = (MM, MV, MP) * 5**(-E10) / 2**(E10 - E2) Q = Floor_Log10_Pow5 ( - E2 ) IF ( - E2 > 1 ) Q = Q - 1 ! == MAX(0, Q' - 1) E10 = Q + E2 ! Determine whether all the removed digits are 0. ! ! Z(X, E2, Q) = MOD((X * 5**-E2), 10**Q) == 0 !             = MIN(P2(X), P5(X) - E2) >= Q !             = P2(X) >= Q and P5(X) - E2 >= Q !             = P2(X) >= Q !             = MOD(X, 2**Q) == 0 IF ( Q <= 1 ) THEN ! {Vr,Vp,Vm} is trailing zeros if {MV,MP,MM} has at least Q trailing 0 bits. ! MV = 4 M2, so it always has at least two trailing 0 bits. VrIsTrailingZeros = TrueVal IF ( AcceptBounds ) THEN ! MM = MV - 1 - MMShift, so it has 1 trailing 0 bit iff MMShift == 1. VmIsTrailingZeros = ( MM == ( MV - TwoUInt )) ELSE ! MP = MV + 2, so it always has at least one trailing 0 bit. DecrementVp = TrueVal END IF ELSEIF ( Q < ( TotalBits - 1 )) THEN ! TODO(ulfjack): Use a tighter bound here. ! We need to compute min(ntz(MV), Pow5Factor(MV) - E2) >= Q-1 ! <=> ntz(MV) >= Q-1  &&  Pow5Factor(MV) - E2 >= Q-1 ! <=> ntz(MV) >= Q-1    (E2 is negative and -E2 >= Q) ! <=> (MV & ((1 << (Q-1)) - 1)) == 0 ! We also need to make sure that the left shift does not overflow. VrIsTrailingZeros = Is_Multiple_Of_Pow2 ( MV , Q ) END IF END IF CALL MulPow5DivPow2 ( MM , MV , MP , - E10 , E10 - E2 , Vm , Vr , Vp ) IF ( DecrementVp ) Vp = Vp - 1_I8B ! Step 4: Find the shortest decimal representation in the interval of legal representations. Removed = 0 LastRemovedDigit = 0 VpDiv10 = Divide_By_Pow10Factor ( Vp , 10 ) CALL DivMod_By_Pow10Factor ( Vm , 10 , VmDiv10 , VmMod10 ) DO WHILE ( VpDiv10 . UGT . VmDiv10 ) VmIsTrailingZeros = VmIsTrailingZeros . AND . ( VmMod10 == 0_I8B ) VrIsTrailingZeros = VrIsTrailingZeros . AND . ( LastRemovedDigit == 0 ) CALL DivMod_By_Pow10Factor ( Vr , 10 , VrDiv10 , VrMod10 ) LastRemovedDigit = VrMod10 Vr = VrDiv10 Vp = VpDiv10 VpDiv10 = Divide_By_Pow10Factor ( Vp , 10 ) Vm = VmDiv10 CALL DivMod_By_Pow10Factor ( Vm , 10 , VmDiv10 , VmMod10 ) Removed = Removed + 1 END DO IF ( VmIsTrailingZeros ) THEN DO WHILE ( Mod_By_Pow10Factor ( Vm , 10 ) == 0_I8B ) VrIsTrailingZeros = VrIsTrailingZeros . AND . ( LastRemovedDigit == 0 ) CALL DivMod_By_Pow10Factor ( Vr , 10 , VrDiv10 , VrMod10 ) LastRemovedDigit = VrMod10 Vr = VrDiv10 Vp = Divide_By_Pow10Factor ( Vp , 10 ) Vm = Divide_By_Pow10Factor ( Vm , 10 ) Removed = Removed + 1 END DO END IF IF ( VrIsTrailingZeros . AND .( LastRemovedDigit == 5 ). AND .( Mod_By_Pow10Factor ( Vr , 2 ) == 0_I8B )) THEN ! Round even if the exact numbers is .....50..0. LastRemovedDigit = 4 END IF ! We need to take Vr+1 if Vr is outside bounds or we need to round up. SigDec = Vr IF ((( Vr == Vm ). AND .((. NOT . AcceptBounds ). OR .(. NOT . VmIsTrailingZeros ))) & . OR .( LastRemovedDigit >= 5 )) THEN SigDec = SigDec + 1_I8B END IF ExpDec = E10 + Removed RETURN CONTAINS SUBROUTINE MulPow5DivPow2 ( U , V , W , E5 , E2 , A , B , C ) !** PURPOSE OF THIS SUBROUTINE: ! To perform multipy by power of 5 and divide by power of 2 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: U , V , W INTEGER ( KIND = I4B ), INTENT ( IN ) :: E5 , E2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: A , B , C !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift INTEGER ( KIND = I8B ) :: U64 ( 0 : 0 ), V64 ( 0 : 0 ), W64 ( 0 : 0 ) INTEGER ( KIND = I8B ) :: Pow5 ( 0 : 1 ) ! in little endian order; most significant byte is 1 TYPE ( UInt128 ) :: Pow5_128 INTEGER ( KIND = I8B ) :: A64 ( 0 : 2 ), B64 ( 0 : 2 ), C64 ( 0 : 2 ) !** FLOW Shift = E2 - ( Floor_Log2_Pow5 ( E5 ) + 1 - BitsPerPow5 ) Pow5_128 = Get_Pow10_128Bits ( E5 ) Pow5 ( 0 ) = Pow5_128 % Low Pow5 ( 1 ) = Pow5_128 % High IF (( E5 < Pow10_Min_Exact_Exp ). OR .( E5 > Pow10_Max_Exact_Exp )) Pow5 ( 0 ) = Pow5 ( 0 ) + 1_I8B U64 ( 0 ) = U CALL Multiply_N_ShiftRight ( U64 , 1 , Pow5 , 2 , Shift , A64 ) A = A64 ( 0 ) V64 ( 0 ) = V CALL Multiply_N_ShiftRight ( V64 , 1 , Pow5 , 2 , Shift , B64 ) B = B64 ( 0 ) W64 ( 0 ) = W CALL Multiply_N_ShiftRight ( W64 , 1 , Pow5 , 2 , Shift , C64 ) C = C64 ( 0 ) RETURN END SUBROUTINE MulPow5DivPow2 !************************************************************************** FUNCTION Is_Multiple_Of_Pow5 ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Multiple_Of_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 5**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Exp <= MaxExp_ModInv5 ) THEN Flag = IsMultipleOfPow5_64Bits ( Value , Exp ) ELSE Flag = Pow5Factor_64Bits ( Value ) . UGE . Exp END IF RETURN END FUNCTION Is_Multiple_Of_Pow5 !************************************************************************** FUNCTION Is_Multiple_Of_Pow2 ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Multiple_Of_Pow2 !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 2**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IAND ( Value , SHIFTL ( 1_I8B , Exp ) - 1_I8B ) == 0_I8B RETURN END FUNCTION Is_Multiple_Of_Pow2 !************************************************************************** SUBROUTINE DivMod_By_Pow10Factor ( X , Y , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division by 5 or 10 (i.e. Y is 5 or 10). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 5 or 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Quotient INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Remainder !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Long_BitSize = BIT_SIZE ( 1_I8B ) ! 64 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Q , R !** FLOW ! The following algorithm actually can be used for all positive divisor (Y) Q = SHIFTL ( SHIFTR ( X , 1 ) / Y , 1 ) R = X - Q * Y Quotient = Q + SHIFTR ( IOR ( R , NOT ( R - Y )), ( Long_BitSize - 1 )) ! Here, 0 <= r < 2 * divisor ! (1) When 0 <= r < divisor, the remainder is simply r. ! (2) Otherwise the remainder is r - divisor. ! ! In case (1), r - divisor < 0. Applying ~ produces a long with ! sign bit 0, so >> produces 0. The returned value is thus r. ! ! In case (2), a similar reasoning shows that >> produces -1, ! so the returned value is r - divisor. Remainder = R - IAND ( SHIFTA ( NOT ( R - Y ), ( Long_BitSize - 1 )), Y ) RETURN END SUBROUTINE DivMod_By_Pow10Factor !************************************************************************** FUNCTION Divide_By_Pow10Factor ( X , Y ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division by 5 or 10. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 5 or 10 INTEGER ( KIND = I8B ) :: Quotient !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Long_BitSize = BIT_SIZE ( 1_I8B ) ! 64 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Q , R !** FLOW ! The following algorithm actually can be used for all positive divisor (Y) Q = SHIFTL ( SHIFTR ( X , 1 ) / Y , 1 ) R = X - Q * Y Quotient = Q + SHIFTR ( IOR ( R , NOT ( R - Y )), ( Long_BitSize - 1 )) RETURN END FUNCTION Divide_By_Pow10Factor !************************************************************************** FUNCTION Mod_By_Pow10Factor ( X , Y ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform modulus of 2, 5 or 10 (i.e. Y is 2 or 5 or 10. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 2, 5 or 10 INTEGER ( KIND = I8B ) :: Remainder !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Long_BitSize = BIT_SIZE ( 1_I8B ) ! 64 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Q , R !** FLOW ! The following algorithm actually can be used for all positive divisor (Y) Q = SHIFTL ( SHIFTR ( X , 1 ) / Y , 1 ) R = X - Q * Y ! Here, 0 <= r < 2 * divisor ! (1) When 0 <= r < divisor, the remainder is simply r. ! (2) Otherwise the remainder is r - divisor. ! ! In case (1), r - divisor < 0. Applying ~ produces a long with ! sign bit 0, so >> produces 0. The returned value is thus r. ! ! In case (2), a similar reasoning shows that >> produces -1, ! so the returned value is r - divisor. Remainder = R - IAND ( SHIFTA ( NOT ( R - Y ), ( Long_BitSize - 1 )), Y ) RETURN END FUNCTION Mod_By_Pow10Factor !************************************************************************** FUNCTION Pow5Factor_64Bits ( Value ) RESULT ( Count ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the factor of power of 5 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ) :: Count !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MInv5 = INT ( Z 'CCCCCCCCCCCCCCCD' , KIND = I8B ) ! 14757395258967641293_I8B INTEGER ( KIND = I8B ), PARAMETER :: NDiv5 = INT ( Z '3333333333333333' , KIND = I8B ) ! 3689348814741910323_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Dividend !** FLOW Count = 0 IF ( Value == 0_I8B ) RETURN Dividend = Value DO Dividend = Dividend * MInv5 IF ( Dividend . UGT . NDiv5 ) RETURN Count = Count + 1 END DO RETURN END FUNCTION Pow5Factor_64Bits !************************************************************************** FUNCTION IsMultipleOfPow5_64Bits ( Value , Exp ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 5**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: ModInv5 ( 0 : 1 , 0 : MaxExp_ModInv5 ) = [ & [ INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z 'FFFFFFFFFFFFFFFF' , KIND = I8B )], & [ INT ( Z 'CCCCCCCCCCCCCCCD' , KIND = I8B ), INT ( Z '3333333333333333' , KIND = I8B )], & [ INT ( Z '8F5C28F5C28F5C29' , KIND = I8B ), INT ( Z '0A3D70A3D70A3D70' , KIND = I8B )], & [ INT ( Z '1CAC083126E978D5' , KIND = I8B ), INT ( Z '020C49BA5E353F7C' , KIND = I8B )], & [ INT ( Z 'D288CE703AFB7E91' , KIND = I8B ), INT ( Z '0068DB8BAC710CB2' , KIND = I8B )], & [ INT ( Z '5D4E8FB00BCBE61D' , KIND = I8B ), INT ( Z '0014F8B588E368F0' , KIND = I8B )], & [ INT ( Z '790FB65668C26139' , KIND = I8B ), INT ( Z '000431BDE82D7B63' , KIND = I8B )], & [ INT ( Z 'E5032477AE8D46A5' , KIND = I8B ), INT ( Z '0000D6BF94D5E57A' , KIND = I8B )], & [ INT ( Z 'C767074B22E90E21' , KIND = I8B ), INT ( Z '00002AF31DC46118' , KIND = I8B )], & [ INT ( Z '8E47CE423A2E9C6D' , KIND = I8B ), INT ( Z '0000089705F4136B' , KIND = I8B )], & [ INT ( Z '4FA7F60D3ED61F49' , KIND = I8B ), INT ( Z '000001B7CDFD9D7B' , KIND = I8B )], & [ INT ( Z '0FEE64690C913975' , KIND = I8B ), INT ( Z '00000057F5FF85E5' , KIND = I8B )], & [ INT ( Z '3662E0E1CF503EB1' , KIND = I8B ), INT ( Z '000000119799812D' , KIND = I8B )], & [ INT ( Z 'A47A2CF9F6433FBD' , KIND = I8B ), INT ( Z '0000000384B84D09' , KIND = I8B )], & [ INT ( Z '54186F653140A659' , KIND = I8B ), INT ( Z '00000000B424DC35' , KIND = I8B )], & [ INT ( Z '7738164770402145' , KIND = I8B ), INT ( Z '0000000024075F3D' , KIND = I8B )], & [ INT ( Z 'E4A4D1417CD9A041' , KIND = I8B ), INT ( Z '000000000734ACA5' , KIND = I8B )], & [ INT ( Z 'C75429D9E5C5200D' , KIND = I8B ), INT ( Z '000000000170EF54' , KIND = I8B )], & [ INT ( Z 'C1773B91FAC10669' , KIND = I8B ), INT ( Z '000000000049C977' , KIND = I8B )], & [ INT ( Z '26B172506559CE15' , KIND = I8B ), INT ( Z '00000000000EC1E4' , KIND = I8B )], & [ INT ( Z 'D489E3A9ADDEC2D1' , KIND = I8B ), INT ( Z '000000000002F394' , KIND = I8B )], & [ INT ( Z '90E860BB892C8D5D' , KIND = I8B ), INT ( Z '000000000000971D' , KIND = I8B )], & [ INT ( Z '502E79BF1B6F4F79' , KIND = I8B ), INT ( Z '0000000000001E39' , KIND = I8B )], & [ INT ( Z 'DCD618596BE30FE5' , KIND = I8B ), INT ( Z '000000000000060B' , KIND = I8B )], & [ INT ( Z '2C2AD1AB7BFA3661' , KIND = I8B ), INT ( Z '0000000000000135' , KIND = I8B )], & [ INT ( Z '08D55D224BFED7AD' , KIND = I8B ), INT ( Z '000000000000003D' , KIND = I8B )], & [ INT ( Z '01C445D3A8CC9189' , KIND = I8B ), INT ( Z '000000000000000C' , KIND = I8B )], & [ INT ( Z 'CD27412A54F5B6B5' , KIND = I8B ), INT ( Z '0000000000000002' , KIND = I8B )]] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Cache ( 0 : 1 ) INTEGER ( KIND = I8B ) :: ModInverse , MaxQuotient !** FLOW Cache = ModInv5 (:, Exp ) ModInverse = Cache ( 0 ) MaxQuotient = Cache ( 1 ) Flag = Value * ModInverse . ULE . MaxQuotient RETURN END FUNCTION IsMultipleOfPow5_64Bits !************************************************************************** END SUBROUTINE Bin2Dec_Ryu !****************************************************************************** SUBROUTINE Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10 INTEGER ( KIND = I8B ) :: Cb , Cbl , Cbr , Vb , Vbl , Vbr INTEGER ( KIND = I4B ) :: kExp , hExp , Exp10 LOGICAL :: uInside , wInside INTEGER ( KIND = I8B ) :: Sx , Sx4 , Sp INTEGER ( KIND = I8B ) :: Upper , Lower , Middle !** FLOW: Cb = SHIFTL ( SigBin , 2 ) Cbr = Cb + TwoUInt ! check whether Cb is closer to the lower bound IF (( SigRaw == 0_I8B ). AND .( ExpRaw > 1 )) THEN ! closer to the lower bound; irregular spacing Cbl = Cb - 1_I8B kExp = Floor_Log10_ThreeQuartersPow2 ( ExpBin ) ELSE ! not closer to the lower bound; regular spacing Cbl = Cb - TwoUInt kExp = Floor_Log10_Pow2 ( ExpBin ) END IF ! compute Exp10 and shift Exp10 = - kExp hExp = ExpBin + Floor_Log2_Pow10 ( Exp10 ) + 1 ! get the cached pow10 value from Pow10_Sig_Table or compute it Pow10 = Get_Pow10_128Bits ( Exp10 ) IF (( Exp10 < Pow10_Min_Exact_Exp ). OR .( Exp10 > Pow10_Max_Exact_Exp )) THEN Pow10 % Low = Pow10 % Low + 1_I8B END IF ! To perform integer multiplications and get upper bits of rounded values Vbl = Round2Odd ( Pow10 , SHIFTL ( Cbl , hExp )) Vb = Round2Odd ( Pow10 , SHIFTL ( Cb , hExp )) Vbr = Round2Odd ( Pow10 , SHIFTL ( Cbr , hExp )) IF ( IAND ( SigBin , 1_I8B ) == 0_I8B ) THEN Lower = Vbl Upper = Vbr ELSE Lower = Vbl + 1_I8B Upper = Vbr - 1_I8B END IF Sx = SHIFTR ( Vb , 2 ) ! Sx = Vb / 4 IF ( Sx . UGE . TenUInt ) THEN ! Vb >= 40 Sp = Sx . UDIV . TenUInt ! Vb / 40 Sx4 = FortyUInt * Sp uInside = ( Lower . ULE . Sx4 ) wInside = ( Upper . UGE . ( Sx4 + FortyUInt )) IF ( uInside . NEQV . wInside ) THEN IF ( wInside ) THEN SigDec = Sp + 1_I8B ELSE SigDec = Sp END IF ExpDec = kExp + 1 RETURN END IF END IF Sx4 = SHIFTL ( Sx , 2 ) uInside = ( Lower . ULE . Sx4 ) wInside = ( Upper . UGE . ( Sx4 + FourUInt )) ExpDec = kExp SigDec = Sx IF ( uInside . NEQV . wInside ) THEN IF ( wInside ) SigDec = SigDec + 1_I8B RETURN END IF Middle = Sx4 + TwoUInt IF (( Vb . UGT . Middle ). OR .(( Vb == Middle ). AND .( IAND ( Sx , 1_I8B ) /= 0_I8B ))) THEN SigDec = SigDec + 1_I8B END IF RETURN CONTAINS FUNCTION Round2Odd ( G , Cx ) RESULT ( Vx ) !** PURPOSE OF THIS SUBROUTINE: ! To perform the rounding of input IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: G INTEGER ( KIND = I8B ), INTENT ( IN ) :: Cx INTEGER ( KIND = I8B ) :: Vx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Hi , Y_Lo !** FLOW ! perform Cp * G%Lo and get the upper 64 bits of the result X_Hi = UMul128_Upper64 ( Cx , G % Low ) ! perform Cp * G%Hi + X_Hi and return Vx as the upper 64 bits of the result CALL UMul128_N_AddU64 ( Cx , G % High , X_Hi , Vx , Y_Lo ) IF ( Y_Lo . UGT . 1_I8B ) Vx = IOR ( Vx , 1_I8B ) RETURN END FUNCTION Round2Odd !************************************************************************** SUBROUTINE UMul128_N_AddU64 ( A , B , C , U128Hi , U128Lo ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply two 64-bit unsigned integers and add a 64-bit unsigned integer ! (A*B + C), and then return the 128-bit result as U128Hi, U128Lo. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: A , B , C INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: H , L , Carry !** FLOW ! multiply A and B CALL UMul128 ( A , B , H , L ) ! add carry Carry = 0_I8B CALL AddU64_WithCarry ( L , C , Carry , U128Lo ) U128Hi = H + Carry RETURN END SUBROUTINE UMul128_N_AddU64 !************************************************************************** SUBROUTINE AddU64_WithCarry ( X , Y , Carry , Sum ) !** PURPOSE OF THIS SUBROUTINE: ! To return the sum with carry of X, Y and CarryIn: Sum = X + Y + CarryIn. ! The carry input must be 0 or 1; otherwise the behavior is undefined. ! The carry output is guaranteed to be 0 or 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Carry INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Sum !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Sum = X + Y + Carry ! The sum will overflow if both top bits are set (x & y) or if one of them ! is (x | y), and a carry from the lower place happened. If such a carry ! happens, the top bit will be 1 + 0 + 1 = 0 (&&#94; sum). Carry = SHIFTR ( IOR ( IAND ( X , Y ), IAND ( IOR ( X , Y ), NOT ( Sum ))), 63 ) RETURN END SUBROUTINE AddU64_WithCarry !************************************************************************** END SUBROUTINE Bin2Dec_Schubfach !****************************************************************************** !------------------------------------------------------------------------------ ! !                       DECIMAL-TO-BINARY CONVERSION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Valid ) ! To convert decimal floating point representation into its exact ! binary floating point representation using the Clinger algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Valid ! true if conversion can be done !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: RawFP INTEGER ( KIND = I4B ) :: Exp10 REAL ( KIND = DP ) :: FloatMantissa !** FLOW IF ( SHIFTR ( SigDec , SignificandBits ) /= 0_I8B ) THEN Valid = FalseVal RETURN END IF FloatMantissa = REAL ( SigDec , KIND = DP ) Exp10 = ExpDec IF ( Exp10 == 0 ) THEN RawFP = RawFP_FromFloat ( FloatMantissa ) END IF IF ( Exp10 > 0 ) THEN IF ( Exp10 > Num_Exact_Pow10 + Num_Mantissa_Digits ) THEN Valid = FalseVal RETURN END IF IF ( Exp10 > Num_Exact_Pow10 ) THEN FloatMantissa = FloatMantissa * Powers_Of_Ten ( Exp10 - Num_Exact_Pow10 ) Exp10 = Num_Exact_Pow10 END IF IF ( FloatMantissa > Max_Exact_Integer ) THEN Valid = FalseVal RETURN END  IF RawFP = RawFP_FromFloat ( FloatMantissa * Powers_Of_Ten ( Exp10 )) ELSEIF ( Exp10 < 0 ) THEN IF ( - Exp10 > Num_Exact_Pow10 ) THEN Valid = FalseVal RETURN END IF RawFP = RawFP_FromFloat ( FloatMantissa / Powers_Of_Ten ( - Exp10 )) END IF SigBin = RawFP_Significand ( RawFP ) ExpBin = RawFP_BiasedExponent ( RawFP ) Valid = TrueVal RETURN END FUNCTION Dec2Bin_Clinger !****************************************************************************** SUBROUTINE Dec2Bin_LibC ( SigDec , ExpDec , cStr , Start , Truncated , SigBin , ExpBin ) !** PURPOSE OF THIS SUBROUTINE: ! To use LibC algorithm to convert string to real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start LOGICAL , INTENT ( IN ) :: Truncated INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: FirstSigBin INTEGER ( KIND = I4B ) :: FirstExpBin !** FLOW ! try the Eisel-Lemire's algorithm IF ( Eisel_Lemire ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! the Eisel-Lemire's algorithm is possibly valid IF (. NOT . Truncated ) RETURN ! If the mantissa is truncated, then the result may be off by the LSB, so ! check if rounding the mantissa up changes the result. If not, then it's ! safe, else use the fallback. FirstSigBin = SigBin FirstExpBin = ExpBin IF ( Eisel_Lemire ( SigDec + 1_I8B , ExpDec , SigBin , ExpBin )) THEN ! check if the Eisel-Lemire's algorithm is definitely valid IF (( SigBin == FirstSigBin ). AND .( ExpBin == FirstExpBin )) RETURN END IF END IF ! use the slow Simple Decimal Conversion algorithm CALL Simple_Decimal_Conversion ( cStr , Start , LEN_TRIM ( cStr ), SigBin , ExpBin ) RETURN CONTAINS FUNCTION Eisel_Lemire ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Valid ) ! To convert decimal floating point representation into its closest ! binary floating point representation using the Eisel-Lemire algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Valid ! true if conversion can be done !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp2 INTEGER ( KIND = I4B ) :: CLZ INTEGER ( KIND = I8B ) :: HighU64 , Mantissa TYPE ( UInt128 ) :: PowTen TYPE ( UInt128 ) :: FirstApprox , FinalApprox , LowBits , SecondApprox INTEGER ( KIND = I8B ) :: FinalMantissa INTEGER ( KIND = I4B ) :: MSB !** FLOW ! normalization CLZ = LEADZ ( SigDec ) Mantissa = SHIFTL ( SigDec , CLZ ) Exp2 = Floor_Log2_Pow10 ( ExpDec ) + TotalBits + ExponentBias - CLZ ! multiplication PowTen = Get_Pow10_128Bits ( ExpDec ) FirstApprox = UInt128 ( 0_I8B , Mantissa ) * PowTen % High ! Wider Approximation IF (( IAND ( FirstApprox % High , HalfWay ) == HalfWay ). AND . & ( FirstApprox % Low + Mantissa . ULT . Mantissa )) THEN LowBits = UInt128 ( 0_I8B , Mantissa ) * PowTen % Low SecondApprox = FirstApprox + UInt128 ( 0_I8B , LowBits % High ) IF (( IAND ( SecondApprox % High , HalfWay ) == HalfWay ). AND . & ( SecondApprox % Low + 1_I8B == 0_I8B ). AND . & ( LowBits % Low + Mantissa . ULT . Mantissa )) THEN Valid = FalseVal RETURN END IF FinalApprox = SecondApprox ELSE FinalApprox = FirstApprox END IF ! Shifting to 54 bits for doubles HighU64 = FinalApprox % High MSB = INT ( SHIFTR ( HighU64 , TotalBits - 1 ), KIND = I4B ) FinalMantissa = SHIFTR ( HighU64 , ( MSB + TotalBits - ( SignificandBits + 3 ))) Exp2 = Exp2 - IEOR ( 1 , MSB ) ! same as NOT(MSB) ! Half-way ambiguity IF (( FinalApprox % Low == 0_I8B ). AND .( IAND ( HighU64 , HalfWay ) == 0_I8B ) & . AND .( IAND ( FinalMantissa , 3_I8B ) == 1_I8B )) THEN Valid = FalseVal RETURN END IF ! From 54 to 53 bits for doubles FinalMantissa = FinalMantissa + IAND ( FinalMantissa , 1_I8B ) FinalMantissa = SHIFTR ( FinalMantissa , 1 ) IF ( SHIFTR ( FinalMantissa , ( SignificandBits + 1 )) /= 0_I8B ) THEN FinalMantissa = SHIFTR ( FinalMantissa , 1 ) Exp2 = Exp2 + 1 END IF ! check exponent validity IF (( Exp2 < 1 ). OR .( Exp2 > ( MaxExponent - 1 ))) THEN Valid = FalseVal RETURN END IF SigBin = FinalMantissa ! implicit conversion if type is mismatch ExpBin = Exp2 Valid = TrueVal RETURN END FUNCTION Eisel_Lemire !****************************************************************************** SUBROUTINE Simple_Decimal_Conversion ( cStr , Start , Finish , SigBin , ExpBin ) ! To convert decimal string into its closest floating point binary representation ! using the Simple Decimal Conversion algorithm. ! The routine assumes that cStr is a 'VALID' floating point string and ! Start is less than Finish where !   - Start is the index of the first valid numeric character, and !   - Finish is the index of the last valid character (== length of the input !     string excluding trailing space(s)) !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start INTEGER ( KIND = I4B ), INTENT ( IN ) :: Finish INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( HPDecimal ) :: HP INTEGER ( KIND = I8B ) :: FinalMantissa INTEGER ( KIND = I4B ) :: Exp2 INTEGER ( KIND = I4B ) :: ShiftAmount !** FLOW ! initialize Exp2 = 0 ! construct HPDecimal object CALL HP % Construct ( cStr , Start , Finish ) IF ( HP % NumDigits == 0 ) THEN SigBin = 0_I8B ExpBin = 0 RETURN END IF ! If the exponent is too large and can't be represented in this size of ! float, return inf. IF (( HP % DecimalPoint > 0 ). AND .( Floor_Log2_Pow10 ( HP % DecimalPoint - 1 ) > ExponentBias )) THEN SigBin = 0_I8B ExpBin = MaxExponent RETURN END IF ! If the exponent is too small even for a subnormal, return 0. IF (( HP % DecimalPoint < 0 ). AND . & ( Floor_Log2_Pow10 ( - HP % DecimalPoint ) > ( ExponentBias + SignificandBits ))) THEN SigBin = 0_I8B ExpBin = 0 RETURN END IF ! Right shift until the number is smaller than 1. DO WHILE ( HP % DecimalPoint > 0 ) ShiftAmount = 0 IF ( HP % DecimalPoint >= Num_Powers_Of_Two ) THEN ShiftAmount = 60 ELSE ShiftAmount = Powers_Of_Two ( HP % DecimalPoint ) END IF Exp2 = Exp2 + ShiftAmount CALL HP % Shift ( - ShiftAmount ) END DO ! Left shift until the number is between 1/2 and 1 DO WHILE (( HP % DecimalPoint < 0 ). OR .(( HP % DecimalPoint == 0 ). AND .( HP % Digits ( 0 ) < 5 ))) ShiftAmount = 0 IF ( - HP % DecimalPoint >= Num_Powers_Of_Two ) THEN ShiftAmount = 60 ELSEIF ( HP % DecimalPoint /= 0 ) THEN ShiftAmount = Powers_Of_Two ( - HP % DecimalPoint ) ELSE ! This handles the case of the number being between .1 and .5 ShiftAmount = 1 END IF Exp2 = Exp2 - ShiftAmount CALL HP % Shift ( ShiftAmount ) END DO ! Left shift once so that the number is between 1 and 2 Exp2 = Exp2 - 1 CALL HP % Shift ( 1 ) ! Get the biased exponent Exp2 = Exp2 + ExponentBias ! Handle the exponent being too large (and return inf). IF ( Exp2 >= MaxExponent ) THEN SigBin = 0 ExpBin = MaxExponent RETURN END IF ! Shift left to fill the mantissa CALL HP % Shift ( SignificandBits ) CALL HP % RoundToUIntType ( FinalMantissa ) ! Handle subnormals IF ( Exp2 <= 0 ) THEN ! Shift right until there is a valid exponent DO WHILE ( Exp2 < 0 ) CALL HP % Shift ( - 1 ) Exp2 = Exp2 + 1 END DO ! Shift right one more time to compensate for the left shift to get it ! between 1 and 2. CALL HP % Shift ( - 1 ) CALL HP % RoundToUIntType ( FinalMantissa ) ! Check if by shifting right we've caused this to round to a normal number. IF ( SHIFTR ( FinalMantissa , SignificandBits ) /= 0_I8B ) THEN Exp2 = Exp2 + 1 END IF END IF ! Check if rounding added a bit, and shift down if that's the case. IF ( FinalMantissa == SHIFTL ( ToUnsignedLong ( 2 ), SignificandBits )) THEN FinalMantissa = SHIFTR ( FinalMantissa , 1 ) Exp2 = Exp2 + 1 ! Check if this rounding causes Exp2 to go out of range and make the result ! INF. If this is the case, then finalMantissa and Exp2 are already the ! correct values for an INF result. IF ( Exp2 >= MaxExponent ) THEN ! report error if applicable END IF END IF IF ( Exp2 == 0 ) THEN ! report error if applicable END IF SigBin = FinalMantissa ExpBin = Exp2 RETURN END SUBROUTINE Simple_Decimal_Conversion !****************************************************************************** END SUBROUTINE Dec2Bin_LibC !****************************************************************************** SUBROUTINE Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , SigCut , Indices , SigBin , ExpBin ) !** PURPOSE OF THIS SUBROUTINE: ! To use FastFloat algorithm to convert string to real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr LOGICAL , INTENT ( IN ) :: SigCut INTEGER ( KIND = I4B ), INTENT ( IN ) :: Indices ( 4 ) INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: EBase INTEGER ( KIND = I4B ) :: ECmp INTEGER ( KIND = I8B ) :: MBase INTEGER ( KIND = I8B ) :: MCmp !** FLOW ! compute float CALL Compute_Float ( ExpDec , SigDec , EBase , MBase ) IF ( SigCut . AND . EBase >= 0 ) THEN CALL Compute_Float ( ExpDec , SigDec + OneMant , ECmp , MCmp ) IF ( Is_AdjustedMantissa_NE ( EBase , MBase , ECmp , MCmp )) THEN CALL Compute_Error ( ExpDec , SigDec , EBase , MBase ) END IF END IF ! If we have an invalid power (EBase < 0), then we need to go ! the long way around again. This is very uncommon. IF ( EBase < 0 ) THEN BLOCK TYPE ( Parsed_Number_Info ) :: NumInfo ! set NumInfo NumInfo % Exp = ExpDec NumInfo % Sig = SigDec NumInfo % IntegralStart = Indices ( 1 ) NumInfo % IntegralEnd = Indices ( 2 ) NumInfo % FractionStart = Indices ( 3 ) NumInfo % FractionEnd = Indices ( 4 ) ECmp = EBase MCmp = MBase ! compare digits CALL Digit_Comparision ( cStr , NumInfo , ECmp , MCmp , EBase , MBase ) END BLOCK END IF SigBin = MBase ExpBin = EBase RETURN CONTAINS SUBROUTINE Compute_Product_Approximation ( Q , W , ProductHi , ProductLo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute or rather approximate W * 5**Q and return a pair of 64-bit words ! approximating the result, with the \"high\" part corresponding to the most ! significant bits and the low part corresponding to the least significant bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! mantissa INTEGER ( KIND = I8B ) :: ProductHi , ProductLo ! product approximation !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: BitPrecision INTEGER ( KIND = I8B ) :: PrecisionMask , SecondProductHi TYPE ( UInt128 ) :: Pow10 !** FLOW ! The required precision is Mantissa_Explicit_Bits + 3 because ! 1. We need the implicit bit ! 2. We need an extra bit for rounding purposes ! 3. We might lose a bit due to the \"UpperBit\" (result too small, requiring a shift) ! BitPrecision = 26 for 32-bit number and 55 for 64-bit number BitPrecision = Mantissa_Explicit_Bits + 3 ! compute precision mask PrecisionMask = SHIFTR ( MaxMant , BitPrecision ) ! get 128-bit approximation of power of ten (or power of five) Pow10 = Get_Pow10_128Bits ( Q ) ! For small values of Q, e.g., Q in [0,27], the product is always exact. CALL UMul128 ( W , Pow10 % High , ProductHi , ProductLo ) IF ( IAND ( ProductHi , PrecisionMask ) == PrecisionMask ) THEN ! could further guard with  (ProductLo + W < ProductLo) ! regarding the second product, we only need the upper bits of the product. SecondProductHi = UMul128_Upper64 ( W , Pow10 % Low ) ProductLo = ProductLo + SecondProductHi IF ( SecondProductHi . UGT . ProductLo ) ProductHi = ProductHi + 1_I8B END IF RETURN END SUBROUTINE Compute_Product_Approximation !************************************************************************** FUNCTION Power ( Q ) RESULT ( E ) !** PURPOSE OF THIS SUBROUTINE: ! To compute power in base 2 based on the power in base 10 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! power in base 10 INTEGER ( KIND = I4B ) :: E ! power in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = Floor_Log2_Pow10 ( Q ) + MantTotalBits - 1 RETURN END FUNCTION Power !************************************************************************** SUBROUTINE Compute_Error_Scaled ( Q , W , LZ , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To create an adjusted mantissa, biased by the invalid power2 ! for significant digits already multiplied by 10 ** Q. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LZ ! leading zeros in W INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! significand in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: HiLZ , Bias !** FLOW HiLZ = IEOR ( INT ( SHIFTR ( W , MantTotalBits - 1 ), KIND = I4B ), 1 ) Bias = Mantissa_Explicit_Bits - Minimum_Exponent M = SHIFTL ( W , HiLZ ) E = Power ( Q ) + Bias - HiLZ - LZ - ( MantTotalBits - 2 ) + Invalid_AM_Bias RETURN END SUBROUTINE Compute_Error_Scaled !************************************************************************** SUBROUTINE Compute_Error ( Q , W , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute W * 10 ** Q, without rounding the representation up. ! the power2 in the exponent will be adjusted by Invalid_AM_Bias. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! significand in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ INTEGER ( KIND = I8B ) :: LocalW INTEGER ( KIND = I8B ) :: ProductHi , ProductLo !** FLOW ! perform normalization LZ = LEADZ ( W ) LocalW = SHIFTL ( W , LZ ) ! compute the product approximation CALL Compute_Product_Approximation ( Q , LocalW , ProductHi , ProductLo ) ! compute the adjusted mantissa biased by the invalid power2 CALL Compute_Error_Scaled ( Q , ProductHi , LZ , E , M ) RETURN END SUBROUTINE Compute_Error !************************************************************************** SUBROUTINE Compute_Float ( Q , W , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute W * 10 ** Q ! The returned value should be a valid ieee64 number that simply need to be packed. ! However, in some very rare cases, the computation will fail. In such cases, we ! return an adjusted_mantissa with a negative power of 2: the caller should recompute ! in such cases. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! significand in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ , UpperBit INTEGER ( KIND = I8B ) :: LocalW INTEGER ( KIND = I8B ) :: ProductHi , ProductLo !** FLOW ! check for special cases (may not be needed since it is taken care of in the caller?) IF (( W == 0_I8B ) . OR . ( Q < Smallest_Power_of_Ten )) THEN E = 0 M = 0_I8B ! result should be zero RETURN END IF IF ( Q > Largest_Power_of_Ten ) THEN ! we want to get infinity: E = Infinite_Power M = 0_I8B RETURN END IF ! At this point in time Q is in [Smallest_Power_of_Ten, Largest_Power_of_Ten]. ! We want the most significant bit of i to be 1. Shift if needed. ! (i.e. perform normalization) LZ = LEADZ ( W ) LocalW = SHIFTL ( W , LZ ) ! compute the product approximation CALL Compute_Product_Approximation ( Q , LocalW , ProductHi , ProductLo ) ! The computed product is always sufficient. ! See mathematical proof in the following reference: ! Noble Mushtak, Daniel Lemire, Fast Number Parsing Without Fallback, !       Software: Practice and Experience 53 (7), 2023. ! Shifting to Mantissa_Explicit_Bits + 2 bits UpperBit = INT ( SHIFTR ( ProductHi , MantTotalBits - 1 ), KIND = I4B ) M = SHIFTR ( ProductHi , ( UpperBit + MantTotalBits - Mantissa_Explicit_Bits - 3 )) E = Power ( Q ) + UpperBit - LZ - Minimum_Exponent IF ( E <= 0 ) THEN ! we have a subnormal? ! Here have that E <= 0 so -E >= 0 IF ( - E + 1 >= MantTotalBits ) THEN ! if we have more than 'MantTotalBits' bits below the minimum exponent, you have a zero for sure. E = 0 M = 0_I8B ! result should be zero RETURN END IF ! next line is safe because -E + 1 < MantTotalBits M = SHIFTR ( M , - E + 1 ) ! Thankfully, we can't have both \"round-to-even\" and subnormals because ! \"round-to-even\" only occurs for powers close to 0. M = M + IAND ( M , OneMant ) ! round up M = SHIFTR ( M , 1 ) ! There is a weird scenario where we don't have a subnormal but just. ! Suppose we start with 2.2250738585072013e-308, we end up ! with 0x3fffffffffffff x 2&#94;-1023-53 which is technically subnormal ! whereas 0x40000000000000 x 2&#94;-1023-53  is normal. Now, we need to round ! up 0x3fffffffffffff x 2&#94;-1023-53  and once we do, we are no longer ! subnormal, but we can only know this after rounding. ! So we only declare a subnormal if we are smaller than the threshold. ! IF (M .ULT. SHIFTL(OneMant, Mantissa_Explicit_Bits)) THEN IF ( M . ULT . Hidden_Bit_Mask ) THEN E = 0 ELSE E = 1 END IF RETURN END IF ! usually, we round *up*, but if we fall right in between and and we have an ! even basis, we need to round down ! We are only concerned with the cases where 5**Q fits in single 64-bit word. IF (( ProductLo . ULE . OneMant ) . AND . ( Q >= Min_Exponent_Round_To_Even ) . AND . & ( Q <= Max_Exponent_Round_To_Even ) . AND . & ( IAND ( M , ThreeUInt ) == OneMant )) THEN ! we may fall between two floats! ! To be in-between two floats we need that in doing !   M = ProductHi >> (UpperBit + 64 - Mantissa_Explicit_Bits - 3) ! ... we dropped out only zeroes. But if this happened, then we can go back!!! IF ( SHIFTL ( M , ( UpperBit + MantTotalBits - Mantissa_Explicit_Bits - 3 )) == & ProductHi ) THEN M = IAND ( M , NotOneMant ) ! flip it so that we do not round up END IF END IF M = M + IAND ( M , OneMant ) ! round up M = SHIFTR ( M , 1 ) IF ( M . UGE . Max_Mantissa_Fast_Path ) THEN M = SHIFTL ( OneMant , Mantissa_Explicit_Bits ) E = E + 1 ! undo previous addition END IF M = IAND ( M , NotSigHidBitMask ) IF ( E >= Infinite_Power ) THEN ! infinity E = Infinite_Power M = 0_I8B END IF RETURN END SUBROUTINE Compute_Float !************************************************************************** FUNCTION Scientific_Exponent ( Number ) RESULT ( Exponent ) !** PURPOSE OF THIS SUBROUTINE: ! To calculate the exponent, in scientific notation, of the number. ! this algorithm is not even close to optimized, but it has no practical ! effect on performance: in order to have a faster algorithm, we'd need ! to slow down performance for faster algorithms, and this is still fast. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: Number INTEGER ( KIND = I4B ) :: Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Mantissa !** FLOW Mantissa = Number % Sig ! implicit narrow conversion for 32-bit Exponent = Number % Exp DO WHILE ( Mantissa . UGE . TenThousandUInt ) Mantissa = DivByPow10 ( Mantissa , 4 ) Exponent = Exponent + 4 END DO DO WHILE ( Mantissa . UGE . HundredUInt ) Mantissa = DivByPow10 ( Mantissa , 2 ) Exponent = Exponent + 2 END DO DO WHILE ( Mantissa . UGE . TenUInt ) Mantissa = DivByPow10 ( Mantissa , 1 ) Exponent = Exponent + 1 END DO RETURN END FUNCTION Scientific_Exponent !************************************************************************** SUBROUTINE Digit_Comparision ( cStr , NumInfo , EIn , MIn , EOut , MOut ) !** PURPOSE OF THIS SUBROUTINE: ! To parse the significant digits as a big integer to unambiguously round the ! the significant digits. here, we are trying to determine how to round ! an extended float representation close to `b+h`, halfway between `b` ! (the float rounded-down) and `b+u`, the next positive float. this ! algorithm is always correct, and uses one of two approaches. when ! the exponent is positive relative to the significant digits (such as ! 1234), we create a big-integer representation, get the high 64-bits, ! determine if any lower bits are truncated, and use that to direct ! rounding. in case of a negative exponent relative to the significant ! digits (such as 1.2345), we create a theoretical representation of ! `b` as a big-integer type, scaled to the same binary exponent as ! the actual digits. we then compare the big integer representations ! of both, and use that to direct rounding. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: NumInfo INTEGER ( KIND = I4B ), INTENT ( IN ) :: EIn INTEGER ( KIND = I4B ), INTENT ( OUT ) :: EOut INTEGER ( KIND = I8B ), INTENT ( IN ) :: MIn INTEGER ( KIND = I8B ), INTENT ( OUT ) :: MOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BigUInt ) :: Big INTEGER ( KIND = I4B ) :: Sci_Exp , Digits , Exponent INTEGER ( KIND = I4B ) :: EIn2 !** FLOW ! remove the invalid exponent bias EIn2 = EIn - Invalid_AM_Bias Sci_Exp = Scientific_Exponent ( NumInfo ) Digits = 0 CALL Parse_Mantissa ( cStr , Big , NumInfo , Max_Digits , Digits ) ! can't underflow, since digits is at most max_digits. Exponent = Sci_Exp + 1 - Digits IF ( Exponent >= 0 ) THEN CALL Positive_Digit_Comparision ( Big , Exponent , EOut , MOut ) ELSE CALL Negative_Digit_Comparision ( Big , EIn2 , MIn , Exponent , EOut , MOut ) END IF RETURN END SUBROUTINE Digit_Comparision !************************************************************************** FUNCTION Is_AdjustedMantissa_NE ( ELhs , MLhs , ERhs , MRhs ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare whether LHS /= RHS. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: ELhs INTEGER ( KIND = I4B ), INTENT ( IN ) :: ERhs INTEGER ( KIND = I8B ), INTENT ( IN ) :: MLhs INTEGER ( KIND = I8B ), INTENT ( IN ) :: MRhs LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( MLhs /= MRhs ). OR .( ELhs /= ERhs ) RETURN END FUNCTION Is_AdjustedMantissa_NE !************************************************************************** END SUBROUTINE Dec2Bin_FastFloat !****************************************************************************** SUBROUTINE Round ( E , M , CB ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float to the nearest machine float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 PROCEDURE ( CB_Round ) :: CB ! actual procedure that perform rounding !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Mantissa_Shift , Shift !** FLOW Mantissa_Shift = MantTotalBits - Mantissa_Explicit_Bits - 1 IF ( - E >= Mantissa_Shift ) THEN ! have a denormal float Shift = - E + 1 CALL CB ( E , M , MIN ( Shift , MantTotalBits )) ! check for round-up: if rounding-nearest carried us to the hidden bit. IF ( M . ULT . Hidden_Bit_Mask ) THEN E = 0 ELSE E = 1 END IF RETURN END IF ! have a normal float, use the default shift. CALL CB ( E , M , Mantissa_Shift ) ! check for carry IF ( M . UGE . Max_Mantissa_Fast_Path ) THEN M = Hidden_Bit_Mask E = E + 1 END IF ! check for infinite: we could have carried to an infinite power M = IAND ( M , NotSigHidBitMask ) IF ( E >= Infinite_Power ) THEN E = Infinite_Power M = 0_I8B END IF RETURN END SUBROUTINE Round !****************************************************************************** SUBROUTINE Round_Nearest_Tie_Even ( E , M , Shift , CB ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float to the nearest tie to even. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift PROCEDURE ( CB_Round_Nearest ) :: CB !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Mask , Halfway , Truncated_Bits LOGICAL :: Is_Above , Is_Halfway , Is_Odd !** FLOW IF ( Shift == MantTotalBits ) THEN Mask = MaxMant ELSE Mask = SHIFTL ( OneMant , Shift ) - OneMant END IF IF ( Shift == 0 ) THEN Halfway = 0_I8B ELSE Halfway = SHIFTL ( OneMant , ( Shift - 1 )) END IF Truncated_Bits = IAND ( M , Mask ) Is_Above = Truncated_Bits . UGT . Halfway Is_Halfway = Truncated_Bits == Halfway ! shift digits into position IF ( Shift == MantTotalBits ) THEN M = 0_I8B ELSE M = SHIFTR ( M , Shift ) END IF E = E + Shift Is_Odd = IAND ( M , OneMant ) == OneMant IF ( CB ( Is_Odd , Is_Halfway , Is_Above )) M = M + OneMant RETURN END SUBROUTINE Round_Nearest_Tie_Even !****************************************************************************** SUBROUTINE Parse_Mantissa ( cStr , Big , NumInfo , Max_Digits , Digits ) !** PURPOSE OF THIS SUBROUTINE: ! To parse the significant digits into a BigUInt IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr TYPE ( BigUInt ), INTENT ( INOUT ) :: Big TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: NumInfo INTEGER ( KIND = I4B ), INTENT ( IN ) :: Max_Digits INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Digits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IEnd INTEGER ( KIND = I4B ) :: Counter , Step INTEGER ( KIND = I8B ) :: Value LOGICAL :: Truncated !** FLOW ! try to minimize the number of big integer and scalar multiplication. ! therefore, try to parse 8 digits at a time, and multiply by the largest ! scalar value (19 digits) for each step. Counter = 0 Digits = 0 Value = 0_I8B Step = 19 ! process all integer digits. IF ( NumInfo % IntegralStart /= 0 ) THEN Indx = NumInfo % IntegralStart IEnd = NumInfo % IntegralEnd CALL Skip_Zeros ( cStr , Indx , IEnd ) ! process all digits, in increments of step per loop DO WHILE ( Indx <= IEnd ) DO WHILE (( Indx + 7 <= IEnd ). AND .( Step - Counter >= 8 ). AND .( Max_Digits - Digits >= 8 )) CALL Parse_Eight_Digits ( cStr , Indx , Value , Counter , Digits ) END DO DO WHILE (( Counter < Step ). AND .( Indx <= IEnd ). AND .( Digits < Max_Digits )) CALL Parse_One_Digit ( cStr , Indx , Value , Counter , Digits ) END DO IF ( Digits == Max_Digits ) THEN ! add the temporary value, then check if we've truncated any digits CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Truncated = Is_Truncated ( cStr , Indx , IEnd ) IF ( NumInfo % FractionStart /= 0 ) THEN Truncated = Truncated . OR . Is_Truncated ( cStr , NumInfo % FractionStart , NumInfo % FractionEnd ) END IF IF ( Truncated ) THEN CALL Round_Up_BigUInt ( Big , Digits ) END IF RETURN ELSE CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Counter = 0 Value = 0_I8B END IF END DO END IF ! add our fraction digits, if they're available. IF ( NumInfo % FractionStart /= 0 ) THEN Indx = NumInfo % FractionStart IEnd = NumInfo % FractionEnd IF ( Digits == 0 ) THEN CALL Skip_Zeros ( cStr , Indx , IEnd ) END IF ! process all digits, in increments of step per loop DO WHILE ( Indx <= IEnd ) DO WHILE (( Indx + 7 <= IEnd ). AND .( Step - Counter >= 8 ). AND .( Max_Digits - Digits >= 8 )) CALL Parse_Eight_Digits ( cStr , Indx , Value , Counter , Digits ) END DO DO WHILE (( Counter < Step ). AND .( Indx <= IEnd ). AND .( Digits < Max_Digits )) CALL Parse_One_Digit ( cStr , Indx , Value , Counter , Digits ) END DO IF ( Digits == Max_Digits ) THEN ! add the temporary value, then check if we've truncated any digits CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) IF ( Is_Truncated ( cStr , Indx , IEnd )) THEN CALL Round_Up_BigUInt ( Big , Digits ) END IF RETURN ELSE CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Counter = 0 Value = 0_I8B END IF END DO END IF IF ( Counter /= 0 ) THEN CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) END IF RETURN CONTAINS SUBROUTINE Skip_Zeros ( cStr , IStart , IEnd ) !DIR$ ATTRIBUTES FORCEINLINE :: Skip_Zeros !** PURPOSE OF THIS SUBROUTINE: ! To find IStart by skipping zeros. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: IStart INTEGER ( KIND = I4B ), INTENT ( IN ) :: IEnd !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MConst = INT ( Z '3030303030303030' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW DO WHILE ( IStart + 7 <= IEnd ) wStr = cStr ( IStart : IStart + 7 ) IF ( wVal /= MConst ) EXIT IStart = IStart + 8 END DO DO WHILE ( IStart <= IEnd ) IF ( cStr ( IStart : IStart ) /= '0' ) EXIT IStart = IStart + 1 END DO RETURN END SUBROUTINE Skip_Zeros !************************************************************************** FUNCTION Is_Truncated ( cStr , IStart , IEnd ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Truncated !** PURPOSE OF THIS SUBROUTINE: ! To determine if any non-zero digits were truncated. ! all characters must be valid digits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: IStart INTEGER ( KIND = I4B ), INTENT ( IN ) :: IEnd LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MConst = INT ( Z '3030303030303030' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW ! initialize Indx = IStart Flag = TrueVal ! do 8-bit optimizations, can just compare to 8 literal 0s. DO WHILE ( Indx + 7 <= IEnd ) wStr = cStr ( Indx : Indx + 7 ) IF ( wVal /= MConst ) RETURN Indx = Indx + 8 END DO DO WHILE ( Indx <= IEnd ) IF ( cStr ( Indx : Indx ) /= '0' ) RETURN Indx = Indx + 1 END DO Flag = FalseVal RETURN END FUNCTION Is_Truncated !************************************************************************** SUBROUTINE Parse_Eight_Digits ( cStr , Indx , Value , Counter , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits !** PURPOSE OF THIS SUBROUTINE: ! To parse 8 digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx , Counter , Count INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW wStr = cStr ( Indx : Indx + 7 ) Value = Value * 100000000_I8B + Parse_Eight_Digits_Unrolled ( wVal ) Indx = Indx + 8 Counter = Counter + 8 Count = Count + 8 RETURN END SUBROUTINE Parse_Eight_Digits !************************************************************************** SUBROUTINE Parse_One_Digit ( cStr , Indx , Value , Counter , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_One_Digit !** PURPOSE OF THIS SUBROUTINE: ! To parse 1 digit IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx , Counter , Count INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Value !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Value = Value * 10_I8B + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 Counter = Counter + 1 Count = Count + 1 RETURN END SUBROUTINE Parse_One_Digit !************************************************************************** SUBROUTINE Add_Native ( Big , Power , Value ) !DIR$ ATTRIBUTES FORCEINLINE :: Add_Native !** PURPOSE OF THIS SUBROUTINE: ! To add value to BigUInt IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Power , Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % SmallMul ( Power ) CALL Big % Add ( Value ) RETURN END SUBROUTINE Add_Native !************************************************************************** SUBROUTINE Round_Up_BigUInt ( Big , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Round_Up_BigUInt !** PURPOSE OF THIS SUBROUTINE: ! To round BigUInt up IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Count !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! need to round-up the digits, but need to avoid rounding ! ....9999 to ...10000, which could cause a false halfway point. CALL Add_Native ( Big , 10_I8B , 1_I8B ) Count = Count + 1 RETURN END SUBROUTINE Round_Up_BigUInt !************************************************************************** END SUBROUTINE Parse_Mantissa !****************************************************************************** SUBROUTINE Positive_Digit_Comparision ( Big , Exp , E2 , M2 ) !** PURPOSE OF THIS SUBROUTINE: ! To compare BigInt for positive exponent. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E2 ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M2 ! adjusted significand in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Offset = Mantissa_Explicit_Bits - Minimum_Exponent - MantTotalBits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: Truncated !** FLOW CALL Big % Pow10 ( Exp ) M2 = Big % Hi64 ( Truncated ) E2 = Big % BitLen () + Offset CALL Round ( E2 , M2 , Callback_Round ) RETURN CONTAINS SUBROUTINE Callback_Round ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Nearest_Tie_Even ( E , M , Shift , Callback_Round_Nearest ) RETURN END SUBROUTINE !************************************************************************** FUNCTION Callback_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) ! arguments LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag ! execution Flag = IsAbove . OR .( IsHalfway . AND . Truncated ). OR .( IsOdd . AND . IsHalfway ) RETURN END FUNCTION !************************************************************************** END SUBROUTINE Positive_Digit_Comparision !****************************************************************************** SUBROUTINE Negative_Digit_Comparision ( Big , EIn , MIn , Exp , EOut , MOut ) !** PURPOSE OF THIS SUBROUTINE: ! To compare BigInt for negative exponent. ! ! The scaling here is quite simple: we have, for the real digits `m * 10&#94;e`, ! and for the theoretical digits `n * 2&#94;f`. Since `e` is always negative, ! to scale them identically, we do `n * 2&#94;f * 5&#94;-f`, so we now have `m * 2&#94;e`. ! we then need to scale by `2&#94;(f- e)`, and then the two significant digits ! are of the same magnitude. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), TARGET , INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: EIn INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp INTEGER ( KIND = I4B ), INTENT ( OUT ) :: EOut INTEGER ( KIND = I8B ), INTENT ( IN ) :: MIn INTEGER ( KIND = I8B ), INTENT ( OUT ) :: MOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BigUInt ), POINTER :: RealDigits => NULL () TYPE ( BigUInt ) :: TheoryDigits INTEGER ( KIND = I4B ) :: RealExp , TheoryExp INTEGER ( KIND = I4B ) :: Pow2_Exp , Pow5_Exp INTEGER ( KIND = I4B ) :: Ord REAL ( KIND = DP ) :: FloatBase INTEGER ( KIND = I4B ) :: EBase INTEGER ( KIND = I4B ) :: ETheory INTEGER ( KIND = I8B ) :: MBase INTEGER ( KIND = I8B ) :: MTheory !** FLOW ! set working variables RealDigits => Big RealExp = Exp ! get the value of `b`, rounded down, and get a bigint representation of b+h EBase = EIn MBase = MIn CALL Round ( EBase , MBase , CBRound ) CALL To_Float ( FalseVal , EBase , MBase , FloatBase ) CALL To_Extended_Halfway ( FloatBase , ETheory , MTheory ) CALL TheoryDigits % FromU64 ( MTheory ) TheoryExp = ETheory ! scale real digits and theor digits to be same power. Pow2_Exp = TheoryExp - RealExp Pow5_Exp = - RealExp IF ( Pow5_Exp /= 0 ) THEN CALL TheoryDigits % Pow5 ( Pow5_Exp ) END IF IF ( Pow2_Exp > 0 ) THEN CALL TheoryDigits % Pow2 ( Pow2_Exp ) ELSEIF ( Pow2_Exp < 0 ) THEN CALL RealDigits % Pow2 ( - Pow2_Exp ) END IF ! compare digits, and use it to director rounding Ord = RealDigits % Compare ( TheoryDigits ) EOut = EIn MOut = MIn CALL Round ( EOut , MOut , Callback_Round ) ! free pointer NULLIFY ( RealDigits ) RETURN CONTAINS SUBROUTINE CBRound ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Down ( E , M , Shift ) RETURN END SUBROUTINE !************************************************************************** SUBROUTINE Callback_Round ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Nearest_Tie_Even ( E , M , Shift , Callback_Round_Nearest ) RETURN END SUBROUTINE !************************************************************************** FUNCTION Callback_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) ! arguments LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag ! execution IF ( Ord > 0 ) THEN Flag = TrueVal ELSEIF ( Ord < 0 ) THEN Flag = FalseVal ELSE Flag = IsOdd END IF RETURN END FUNCTION !************************************************************************** SUBROUTINE To_Extended ( Value , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a native floating-point number to an extended-precision float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Bias = Mantissa_Explicit_Bits - Minimum_Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Bits !** FLOW Bits = RawFP_FromFloat ( Value ) IF ( IAND ( Bits , Exponent_Mask ) == 0_I8B ) THEN ! denormal E = 1 - Bias M = IAND ( Bits , Mantissa_Mask ) ELSE ! normal E = INT ( SHIFTR ( IAND ( Bits , Exponent_Mask ), Mantissa_Explicit_Bits ), KIND = I4B ) - Bias M = IOR ( IAND ( Bits , Mantissa_Mask ), Hidden_Bit_Mask ) END IF RETURN END SUBROUTINE To_Extended !************************************************************************** SUBROUTINE To_Extended_Halfway ( Value , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To get the extended precision value of the halfway point between b and b+u. ! we are given a native float that represents b, so we need to adjust it ! halfway between b and b+u. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL To_Extended ( Value , E , M ) M = SHIFTL ( M , 1 ) + OneMant E = E - 1 RETURN END SUBROUTINE To_Extended_Halfway !************************************************************************** SUBROUTINE Round_Down ( E , M , Shift ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float down. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Shift == MantTotalBits ) THEN M = 0_I8B ELSE M = SHIFTR ( M , Shift ) END IF E = E + Shift RETURN END SUBROUTINE Round_Down !************************************************************************** SUBROUTINE To_Float ( Negative , E , M , Value ) !** PURPOSE OF THIS SUBROUTINE: ! To convert adjusted mantissa to double-precision value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: M ! adjusted significand in base 2 REAL ( KIND = DP ), INTENT ( OUT ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BinRep ) :: FpBin INTEGER ( KIND = I8B ) :: Word !** FLOW ! get input FpBin % Negative = Negative FpBin % Exponent = E FpBin % Significand = M ! implicit narrowing conversion for 32 bit ! compose the component parts into word Word = RawFP_Construct ( FpBin ) ! convert word to real number Value = RawFP_ToFloat ( Word ) RETURN END SUBROUTINE To_Float !************************************************************************** END SUBROUTINE Negative_Digit_Comparision !****************************************************************************** FUNCTION Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use YY's algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand, base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent, base 10 LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information INTEGER ( KIND = I8B ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange - UIntSafeDigits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigBin ! significand, base 2 INTEGER ( KIND = I4B ) :: ExpBin ! exponent, base 2 !** FLOW ! check whether to use YY's fast path IF ((. NOT . Aux % Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN IF ( D2B_YY_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! YY's fast path is success so set sign bit IF ( Negative ) THEN RawFP = SignMask ELSE RawFP = 0_I8B END IF ! then, add exponent bits RawFP = IOR ( RawFP , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! finally, add (both implicit and explicit) significand bits RawFP = IOR ( RawFP , IAND ( SigBin , SignificandMask )) RETURN END IF END IF ! perform decimal to binary conversion using YY's slow path RawFP = D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RETURN CONTAINS FUNCTION D2B_YY_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_YY_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use YY's fast path algorithm to convert from decimal representation ! to binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10 INTEGER ( KIND = I8B ) :: Sig2 , Sig2_Ext INTEGER ( KIND = I8B ) :: Hi , Lo , Hi2 INTEGER ( KIND = I8B ) :: Sig1 , Add , Bits INTEGER ( KIND = I4B ) :: Exp2 , Lz LOGICAL :: Exact !** FLOW ! To keep it simple, we only accept normal number here, ! let the slow path handle subnormal and infinity number. ! The result value is exactly equal to (SigDec * 10**ExpDec), ! the exponent part (10**ExpDec) can be converted to (Sig2 * 2**Exp2). ! The Sig2 can be an infinite length number, only the highest 256 bits ! is cached in the Pow10_Sig_Table. ! (Quad uses 256 bits, Double uses 128 bits, and Single uses 64 bits) ! Now we have these bits: ! Sig1 (normalized 128/64/32 bit)   : aaaaaaaaaaaaaaaa ! Sig2 (higher 128/64/32 bit)       : bbbbbbbbbbbbbbbb ! Sig2_Ext (lower 128/64/32 bit)    : cccccccccccccccc ! Sig2_Cut (extra unknown bits)     : dddddddddddddddddddddddd.... ! And the calculation process is: ! ------------------------------------------------------------- !         aaaaaaaaaaaaaaaa * !         bbbbbbbbbbbbbbbbccccccccccccccccdddddddddddd.... ! ------------------------------------------------------------- ! abababababababababababababababab + !         acacacacacacacacacacacacacacacac + !                 adadadadadadadadadadadadadadadadadadadad.... ! ------------------------------------------------------------- ! [Hi____][Lo____] + !         [Hi2___][Lo2___] + !                 [unknown___________....] ! ------------------------------------------------------------- ! The addition with carry may affect higher bits, but if there is a 0 ! in higher bits, the bits higher than 0 will not be affected. ! 'Lo2' + 'unknown' may get a carry bit and may affect 'Hi2', the max value ! of 'Hi2' is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE/0xFFFFFFFFFFFFFFFE/0xFFFFFFFE, ! so 'Hi2' will not overflow. ! 'Lo' + 'Hi2' may alse get a carry bit and may affect 'Hi', but only ! the highest significant 113/53/24 bits of 'Hi' is needed. If there is a 0 ! in the lower bits of 'Hi', then all the following bits can be dropped. ! To convert the result to IEEE-754 double number, we need to perform ! correct rounding: ! 1. if bit 114/54/25 is 0, round down, ! 2. if bit 114/54/25 is 1 and any bit beyond bit 114/54/25 is 1, round up, ! 3. if bit 114/54/25 is 1 and all bits beyond bit 114/54/25 are 0, round to even, !    as the extra bits is unknown, this case will not be handled here. ! initialize Exact = FalseVal Success = FalseVal ! convert (10*ExpDec) to (Sig2 * 2**Exp2) Pow10 = Get_Pow10_128Bits ( ExpDec ) Sig2 = Pow10 % High Sig2_Ext = Pow10 % Low Exp2 = Floor_Log2_Pow10 ( ExpDec ) - SignBits ! normalize and multiply Lz = LEADZ ( SigDec ) Sig1 = SHIFTL ( SigDec , Lz ) Exp2 = Exp2 - Lz CALL UMul128 ( Sig1 , Sig2 , Hi , Lo ) ! To get normalized value, 'Hi' should be shifted to the left by 0 or 1. ! The highest significant 113/53/24 bits is used by IEEE-754 double number, ! and the bit 114/54/25 is used to detect rounding direction. ! The lowest 13 (= 128 - 114 - 1) / 9 (= 64 - 54 - 1) / 6 (= 32 - 25 - 1) bits (LowBits) ! is used to check whether it contains 0. ! Note: BitMask = SHIFTL(1, LowBits) - 1 Bits = IAND ( Hi , BitMask ) IF (( Bits /= 0_I8B ). AND .( Bits /= BitMask )) THEN ! The 'Bits' is not zero, so we don't need to check 'round to even' case. ! The 'Bits' contains bit '0', so we can drop the extra bits after '0'. Exact = TrueVal ELSE ! The 'Bits' is filled with all '0' or all '1', so we need to check ! more lower bits with another multiplication. Hi2 = UMul128_Upper64 ( Sig1 , Sig2_Ext ) Add = Lo + Hi2 IF (( Add /= 0_I8B ). AND .( Add /= MaxUInt )) THEN ! The 'Add' is not zero, so we don't need to check 'round to even' case. ! The 'Add' contains bit '0', so we can drop the extra bits after '0'. ! The 'Hi' cannot be MaxUInt, so it will not overflow. IF (( Add . ULT . Lo ). OR .( Add . ULT . Hi2 )) Hi = Hi + 1_I8B Exact = TrueVal END IF END IF IF ( Exact ) THEN ! normalize IF ( Hi . ULT . SignMask ) THEN Hi = SHIFTL ( Hi , 1 ) Exp2 = Exp2 - 1 END IF Exp2 = Exp2 + TotalBits ! test the bit 114 and get rounding direction IF ( IAND ( Hi , AddRound ) /= 0_I8B ) Hi = Hi + AddRound ! test overflow IF ( Hi . ULT . AddRound ) THEN Hi = SignMask Exp2 = Exp2 + 1 END IF ! This is a normal number, convert it to binary representation. SigBin = SHIFTR ( Hi , ExponentBits ) ExpBin = Exp2 + ( ExponentBits + SignificandBits ) + ExponentBias Success = TrueVal END IF RETURN END FUNCTION D2B_YY_FastPath !************************************************************************** END FUNCTION Dec2Bin_YY !****************************************************************************** FUNCTION D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use YY's slow path algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information INTEGER ( KIND = I8B ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: ERR_ULP_LOG = 3 INTEGER ( KIND = I4B ), PARAMETER :: ERR_ULP = SHIFTL ( 1 , ERR_ULP_LOG ) INTEGER ( KIND = I4B ), PARAMETER :: ERR_CACHED_POW = ERR_ULP / 2 INTEGER ( KIND = I4B ), PARAMETER :: ERR_MUL_FIXED = ERR_ULP / 2 INTEGER ( KIND = I4B ), PARAMETER :: DIY_SIG_BITS = TotalBits INTEGER ( KIND = I4B ), PARAMETER :: EXP_BIAS = ExponentBias + SignificandBits INTEGER ( KIND = I4B ), PARAMETER :: EXP_SUBNORMAL = - EXP_BIAS + 1 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE DERIVED TYPE DEFINITIONS ! \"Do It Yourself Floating Point\" TYPE Diy_Fp INTEGER ( KIND = I8B ) :: Sig ! significand INTEGER ( KIND = I4B ) :: Exp ! exponent, base 2 END TYPE ! ---------------------------------------------------------------------------- !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I8B ) :: FpErr , PrecisionBits , HalfWay INTEGER ( KIND = I4B ) :: Bits INTEGER ( KIND = I4B ) :: Order_of_Magnitude , Effective_Significand_Size INTEGER ( KIND = I4B ) :: PrecisionDigitsCount , Cmp , Exp10 TYPE ( Diy_Fp ) :: Fp , FpUpper TYPE ( BigUInt ) :: BigFull , BigComp !** FLOW ! Slow path: read floating-point number exactly with diyfp. ! 1. Use cached diyfp to get an approximation value. ! 2. Use bigcomp to check the approximation value if needed. ! This algorithm refers to google's double-conversion project: ! https://github.com/google/double-conversion ! initialize IF ( Negative ) THEN Sign = 1_I8B ELSE Sign = 0_I8B END IF Fp % Sig = SigDec Fp % Exp = 0 IF ( Aux % Truncated ) THEN FpErr = ToUnsignedLong ( ERR_ULP / 2 ) ! round up if the next digit after the cut is more than or equal to 5 IF (( IACHAR ( cStr ( Aux % SigCut : Aux % SigCut )) - A0 ) >= 5 ) Fp % Sig = Fp % Sig + 1_I8B ELSE FpErr = 0_I8B END IF ! normalize Bits = LEADZ ( Fp % Sig ) Fp % Sig = SHIFTL ( Fp % Sig , Bits ) Fp % Exp = Fp % Exp - Bits FpErr = SHIFTL ( FpErr , Bits ) ! multiply and add error Fp = Diy_Fp_Mul ( Fp , Diy_Fp_Get_Cached_Pow10 ( ExpDec )) IF ( FpErr == 0_I8B ) THEN FpErr = FpErr + ToUnsignedLong ( ERR_CACHED_POW + ERR_MUL_FIXED ) ELSE FpErr = FpErr + ToUnsignedLong ( ERR_CACHED_POW + ERR_MUL_FIXED + 1 ) END IF ! normalize Bits = LEADZ ( Fp % Sig ) Fp % Sig = SHIFTL ( Fp % Sig , Bits ) Fp % Exp = Fp % Exp - Bits FpErr = SHIFTL ( FpErr , Bits ) ! effective significand Order_of_Magnitude = DIY_SIG_BITS + Fp % Exp IF ( Order_of_Magnitude >= EXP_SUBNORMAL + BinaryPrecision ) THEN Effective_Significand_Size = BinaryPrecision ELSEIF ( Order_of_Magnitude <= EXP_SUBNORMAL ) THEN Effective_Significand_Size = 0 ELSE Effective_Significand_Size = Order_of_Magnitude - EXP_SUBNORMAL END IF ! precision digits count PrecisionDigitsCount = DIY_SIG_BITS - Effective_Significand_Size IF ( PrecisionDigitsCount + ERR_ULP_LOG >= DIY_SIG_BITS ) THEN BLOCK INTEGER ( KIND = I4B ) :: Shr Shr = ( PrecisionDigitsCount + ERR_ULP_LOG ) - DIY_SIG_BITS + 1 Fp % Sig = SHIFTR ( Fp % Sig , Shr ) Fp % Exp = Fp % Exp + Shr FpErr = SHIFTR ( FpErr , Shr ) + ToUnsignedLong ( 1 + ERR_ULP ) PrecisionDigitsCount = PrecisionDigitsCount - Shr END BLOCK END IF ! half way PrecisionBits = IAND ( Fp % Sig , ( SHIFTL ( 1_I8B , PrecisionDigitsCount ) - 1_I8B )) PrecisionBits = PrecisionBits * ERR_ULP HalfWay = SHIFTL ( 1_I8B , ( PrecisionDigitsCount - 1 )) HalfWay = HalfWay * ERR_ULP ! rounding Fp % Sig = SHIFTR ( Fp % Sig , PrecisionDigitsCount ) IF ( PrecisionBits . UGE . HalfWay + FpErr ) Fp % Sig = Fp % Sig + 1_I8B Fp % Exp = Fp % Exp + PrecisionDigitsCount ! get IEEE raw value RawFP = Diy_Fp_To_IEEE_Raw ( Fp ) IF ( RawFP == FpRawInf ) THEN RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN END IF IF (( PrecisionBits . ULE . HalfWay - FpErr ). OR .( PrecisionBits . UGE . HalfWay + FpErr )) THEN ! number is accurate RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN END IF ! ------------------------------------------------------------------------- ! now the number is the correct value, or the next lower value ! ------------------------------------------------------------------------- ! upper boundary IF ( IAND ( RawFP , ExponentMask ) /= 0_I8B ) THEN FpUpper % Sig = IAND ( RawFP , SignificandMask ) + SHIFTL ( 1_I8B , SignificandBits ) FpUpper % Exp = INT ( SHIFTR ( IAND ( RawFP , ExponentMask ), SignificandBits ), KIND = I4B ) ELSE FpUpper % Sig = IAND ( RawFP , SignificandMask ) FpUpper % Exp = 1 END IF FpUpper % Exp = FpUpper % Exp - ( ExponentBias + SignificandBits ) FpUpper % Sig = SHIFTL ( FpUpper % Sig , 1 ) FpUpper % Exp = FpUpper % Exp - 1 FpUpper % Sig = FpUpper % Sig + 1 ! add half ulp ! compare with BigInt Exp10 = ExpDec CALL BigInt_Set_String ( BigFull , SigDec , Exp10 , cStr , Aux ) CALL BigInt_Set_UIntType ( BigComp , FpUpper % Sig ) IF ( Exp10 >= 0 ) THEN CALL BigInt_Mul_Pow10 ( BigFull , + Exp10 ) ELSE CALL BigInt_Mul_Pow10 ( BigComp , - Exp10 ) END IF IF ( FpUpper % Exp > 0 ) THEN CALL BigInt_Mul_Pow2 ( BigComp , + FpUpper % Exp ) ELSE CALL BigInt_Mul_Pow2 ( BigFull , - FpUpper % Exp ) END IF Cmp = BigInt_Compare ( BigFull , BigComp ) IF ( Cmp /= 0 ) THEN ! round down or round up IF ( Cmp > 0 ) RawFP = RawFP + 1_I8B ELSE ! falls midway, round to even IF ( IAND ( RawFP , 1_I8B ) /= 0_I8B ) RawFP = RawFP + 1_I8B END IF RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN CONTAINS FUNCTION Diy_Fp_Get_Cached_Pow10 ( Exp10 ) RESULT ( Fp ) !** PURPOSE OF THIS SUBROUTINE: ! To get cached rounded diy_fp with pow(10, e). The input value must in range ! [POW10_SIG_TABLE_MIN_EXP, POW10_SIG_TABLE_MAX_EXP]. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp10 ! an exponent TYPE ( Diy_Fp ) :: Fp ! Diy_Fp data !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10 INTEGER ( KIND = I8B ) :: Sig_Ext !** FLOW Pow10 = Get_Pow10_128Bits ( Exp10 ) Fp % Sig = Pow10 % High Sig_Ext = Pow10 % Low Fp % Exp = Floor_Log2_Pow10 ( Exp10 ) - SignBits Fp % Sig = Fp % Sig + SHIFTR ( Sig_Ext , SignBits ) RETURN END FUNCTION Diy_Fp_Get_Cached_Pow10 !************************************************************************** FUNCTION Diy_Fp_Mul ( Fp1 , Fp2 ) RESULT ( Fp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'fp1 * fp2'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Diy_Fp ), INTENT ( IN ) :: Fp1 , Fp2 TYPE ( Diy_Fp ) :: Fp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Hi , Lo !** FLOW CALL UMul128 ( Fp1 % Sig , Fp2 % Sig , Hi , Lo ) Fp % Sig = Hi + SHIFTR ( Lo , SignBits ) Fp % Exp = Fp1 % Exp + Fp2 % Exp + TotalBits RETURN END FUNCTION Diy_Fp_Mul !************************************************************************** FUNCTION Diy_Fp_To_IEEE_Raw ( Fp ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To convert diy_fp to IEEE-754 raw value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Diy_Fp ), INTENT ( IN ) :: Fp INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Sig INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I4B ) :: Lz_Bits !** FLOW ! initialize Sig = Fp % Sig Exp = Fp % Exp Val = 0_I8B IF ( Sig == 0_I8B ) RETURN ! compute significand and exponent Lz_Bits = LEADZ ( Sig ) Sig = SHIFTL ( Sig , Lz_Bits ) Sig = SHIFTR ( Sig , ExponentBits ) Exp = Exp - Lz_Bits + ExponentBits + SignificandBits ! check which range the result falls IF ( Exp >= MaxExpBin ) THEN ! overflow Val = RawFP_SetInfinity ( FalseVal ) ELSEIF ( Exp >= ( MinExpBin - 1 )) THEN ! normal Exp = Exp + ExponentBias Val = IOR ( SHIFTL ( ToUnsignedLong ( Exp ), SignificandBits ), IAND ( Sig , SignificandMask )) ELSEIF ( Exp >= ( MinExpBin - BinaryPrecision )) THEN ! subnormal Val = SHIFTR ( Sig , ( MinExpBin - Exp - 1 )) ELSE ! underflow Val = 0_I8B END IF RETURN END FUNCTION Diy_Fp_To_IEEE_Raw !************************************************************************** END FUNCTION D2B_YY_SlowPath !****************************************************************************** FUNCTION Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand, base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent, base 10 LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information INTEGER ( KIND = I8B ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange - UIntSafeDigits + 1 INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange + 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: SigBin ! significand, base 2 INTEGER ( KIND = I4B ) :: ExpBin ! exponent, base 2 !** FLOW ! check whether to use Lemire's fast path IF ((. NOT . Aux % Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN IF ( D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! Lemire's fast path is success so set sign bit IF ( Negative ) THEN RawFP = SignMask ELSE RawFP = 0_I8B END IF ! then, add exponent bits RawFP = IOR ( RawFP , SHIFTL ( ToUnsignedLong ( ExpBin ), SignificandBits )) ! finally, add (both implicit and explicit) significand bits RawFP = IOR ( RawFP , IAND ( SigBin , SignificandMask )) RETURN END IF END IF ! perform decimal to binary conversion using YY's slow path RawFP = D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RETURN CONTAINS FUNCTION D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_Lemire_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's fast path algorithm to convert from decimal to binary representation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10 INTEGER ( KIND = I4B ) :: LZ INTEGER ( KIND = I4B ) :: Upperbit INTEGER ( KIND = I8B ) :: Significand INTEGER ( KIND = I8B ) :: Lower , Upper INTEGER ( KIND = I4B ) :: Exponent !** FLOW ! get 256/128/64-bit approximation of power of 10 (or power of 5) Pow10 = Get_Pow10_128Bits ( ExpDec ) ! compute the exponent Exponent = Floor_Log2_Pow10 ( ExpDec ) + MaxExpBin + SignBits ! +++ normalize the significand +++ ! We want the most significant bit of Significand to be 1. Shift if needed. LZ = LEADZ ( SigDec ) Significand = SHIFTL ( SigDec , LZ ) ! +++ perform multiplication +++ ! We want the most significant 128/64/32 bits of the product. We know this will be non-zero ! because the most significant bit of Significand is 1. CALL UMul128 ( Significand , Pow10 % High , Upper , Lower ) ! We know that Upper has at most one leading zero because both Significand and  Pow10 have a leading one. ! As long as the first 13/9/6 bits of \"upper\" are not \"1\", then we know that we have an exact computed ! value for the leading 125/55/26 bits because any imprecision would play out as a +1, in the worst case. ! Having 125/55/26 bits is necessary because we need 123/53/24 bits for the mantissa but we have to have ! one rounding bit and we can waste a bit if the most significant bit of the product is zero. We expect ! this next branch to be rarely taken (say 1% of the time). When (Upper & BitMask) == BitMask, ! it can be common for Lower + Significand < Lower to be true (proba. much higher than 1%). ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ IF (( IAND ( Upper , BitMask ) == BitMask ). AND .(( Lower + Significand ) . ULT . Lower )) THEN BLOCK ! --- declaration --- INTEGER ( KIND = I8B ) :: Product_Low , Product_High INTEGER ( KIND = I8B ) :: Product_Middle , Product_Middle1 , Product_Middle2 ! --- execution --- ! perform multiplication CALL UMul128 ( Significand , Pow10 % Low , Product_Middle2 , Product_Low ) Product_Middle1 = Lower Product_High = Upper Product_Middle = Product_Middle1 + Product_Middle2 ! overflow carry IF ( Product_Middle . ULT . Product_Middle1 ) Product_High = Product_High + 1_I8B ! we want to check whether Pow10*Significand + Significand would affect our result ! This does happen, e.g. with 7.3177701707893310E+15 (for double-precision) IF ((( Product_Middle + 1_I8B == 0_I8B ). AND .( IAND ( Product_High , BitMask ) == BitMask ) & . AND .( Product_Low + Significand . ULT . Product_Low ))) THEN ! let us be prudent and bail out. Success = FalseVal RETURN END IF Lower = Product_Middle Upper = Product_High END BLOCK END IF ! The final mantissa should be 123/53/24 (BinaryPrecision) bits with a leading 1. ! We shift it so that it occupies 124/54/25 (BinaryPrecision+1) bits with a leading 1. Upperbit = INT ( SHIFTR ( Upper , SignBits ), KIND = I4B ) SigBin = SHIFTR ( Upper , ( Upperbit + LowBits )) LZ = LZ + IEOR ( 1 , Upperbit ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision+1). ! We have to round to even. The \"to even\" part ! is only a problem when we are right in between two floats ! which we guard against. ! If we have lots of trailing zeros, we may fall right between two ! floating-point values. IF (( Lower == 0_I8B ). AND .( IAND ( Upper , BitMask ) == 0_I8B ). AND . & ( IAND ( SigBin , ThreeUInt ) == 1_I8B )) THEN ! if IAND(SigBin, 1) == 1 we might need to round up. ! Scenarios: ! 1. We are not in the middle. Then we should round up. ! 2. We are right in the middle. Whether we round up depends on the last significant !    bit: if it is \"one\" then we round up (round to even) otherwise, we do not. ! So if the last significant bit is 1, we can safely round up.  Hence we only need ! to bail out if IAND(SigBin, 3) == 1.  Otherwise we may need more accuracy or analysis ! to determine whether we are exactly between two floating-point numbers. ! It can be triggered with 1E23. ! Note: because the factor_mantissa and factor_mantissa_low are almost always rounded !       down (except for small positive powers), almost always should round up. Success = FalseVal RETURN END IF SigBin = SHIFTR ( SigBin + IAND ( SigBin , 1_I8B ), 1 ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision), unless there was an overflow IF ( SigBin . UGE . MaxMantissa ) THEN ! This will happen when parsing values such as 7.2057594037927933E+16 SigBin = SigHidBitMask ! undo previous addition LZ = LZ - 1 END IF SigBin = IAND ( SigBin , NOT ( SigHidBitMask )) ExpBin = Exponent - LZ ! we have to check that ExpBin is in range, otherwise we bail out IF (( ExpBin < 1 ). OR .( ExpBin > ( MaxExponent - 1 ))) THEN Success = FalseVal ELSE Success = TrueVal END IF RETURN END FUNCTION D2B_Lemire_FastPath !************************************************************************** END FUNCTION Dec2Bin_Lemire !****************************************************************************** !------------------------------------------------------------------------------ ! !                           REAL64 AUXILIARY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION DivByPow10 ( X , P ) RESULT ( Y ) !** PURPOSE OF THIS SUBROUTINE: ! To compute Y = X .UDIV. (10**P) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ! X <= 10**20 INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! 1 <= P <= 10 INTEGER ( KIND = I8B ) :: Y !** SUBROUTINE IPARAMETER DECLARATIONS: ! Parameters for division by power of 10 applicable for N <= 20 digits ! (i.e. used for division of the 'Significand') ! Note: elements in the row are in little-endian order ! (i.e. element 0 is the least significant byte and element 1 is the most one) INTEGER ( KIND = I8B ), PARAMETER :: MagicM ( 0 : 1 , 1 : 10 ) = [ & [ INT ( Z '6666666666666667' , KIND = I8B ), INT ( Z '0000000000000006' , KIND = I8B )], & [ INT ( Z '3D70A3D70A3D70A4' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B )], & [ INT ( Z '3126E978D4FDF3B7' , KIND = I8B ), INT ( Z '0000000000000008' , KIND = I8B )], & [ INT ( Z '8DB8BAC710CB295F' , KIND = I8B ), INT ( Z '0000000000000006' , KIND = I8B )], & [ INT ( Z '7C5AC471B4784231' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B )], & [ INT ( Z '637BD05AF6C69B5B' , KIND = I8B ), INT ( Z '0000000000000008' , KIND = I8B )], & [ INT ( Z 'B5FCA6AF2BD215E2' , KIND = I8B ), INT ( Z '0000000000000006' , KIND = I8B )], & [ INT ( Z 'BCC77118461CEFD0' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B )], & [ INT ( Z '9705F4136B4A5974' , KIND = I8B ), INT ( Z '0000000000000008' , KIND = I8B )], & [ INT ( Z 'DF37F675EF6EADF6' , KIND = I8B ), INT ( Z '0000000000000006' , KIND = I8B )]] INTEGER ( KIND = I4B ), PARAMETER :: MagicS ( 1 : 10 ) = [ 70 , 74 , 77 , 80 , 84 , 87 , 90 , 94 , 97 , 100 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: MulProduct ( 0 : 2 ) INTEGER ( KIND = I8B ) :: Input ( 0 : 0 ) INTEGER ( KIND = I8B ) :: Multiplier ( 0 : 1 ) INTEGER ( KIND = I4B ) :: Shift !** FLOW Input ( 0 ) = X Multiplier = MagicM (:, P ) Shift = MagicS ( P ) CALL Multiply_N_ShiftRight ( Input , 1 , Multiplier , 2 , Shift , MulProduct ) Y = MulProduct ( 0 ) RETURN END FUNCTION DivByPow10 !****************************************************************************** FUNCTION Write_RealDP ( Fp , Ep , cStr , IsScientific ) RESULT ( sLen ) !DIR$ ATTRIBUTES INLINE :: Write_RealDP !** PURPOSE OF THIS SUBROUTINE: ! To format the decimal F*10**E IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Fp ! significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: Ep ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE PARAMETER DECLARATIONS: ! maximum number of significant digits (i.e. the maximum decimal precision !   that guarantees an error-free write-read cycle.) INTEGER ( KIND = I4B ), PARAMETER :: H = 17 ! shift and multiplier parameters (i.e. magic number) for integer division INTEGER ( KIND = I4B ), PARAMETER :: S98 = 57 INTEGER ( KIND = I8B ), PARAMETER :: M98 = 1441151881_I8B INTEGER ( KIND = I4B ), PARAMETER :: S178 = 20 ! = 84-64 INTEGER ( KIND = I8B ), PARAMETER :: M178 = 193428131138340668_I8B INTEGER ( KIND = I8B ), PARAMETER :: DivE8 = 100000000_I8B ! The first powers of 10. The last entry must be 10&#94;H. INTEGER ( KIND = I4B ) :: I INTEGER ( KIND = I8B ), PARAMETER :: Pow10 ( 0 : H ) = [( 10_I8B ** I , I = 0 , H )] ! Used for left-to-tight digit extraction. INTEGER ( KIND = I4B ), PARAMETER :: MASK_28 = SHIFTL ( 1 , 28 ) - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: F , HM INTEGER ( KIND = I4B ) :: E , HF , MF , LF LOGICAL :: IsGeneral ! true if to write the given number in general format !** FLOW ! check for special cases IF ( Ep == ExceptionalExponent ) THEN ! either NaN or Infinity IF ( Fp /= 0_I8B ) THEN cStr ( 1 : 3 ) = 'NaN' sLen = 3 ELSE cStr ( 1 : 8 ) = 'Infinity' sLen = 8 END IF RETURN END IF IF ( Fp == 0_I8B ) THEN ! zero cStr ( 1 : 3 ) = '0.0' sLen = 3 RETURN END IF ! For details not discussed here see section 10 of [3]. ! Determine sLen such that 10**(sLen-1) <= F < 10**sLen sLen = Floor_Log10_Pow2 ( 64 - LEADZ ( Fp )) IF ( Fp >= Pow10 ( sLen )) sLen = sLen + 1 ! Let Fp and Ep be the original F and E, respectively. ! Transform F and E to ensure !    10**(H-1) <= F < 10**H !    Fp*10**Ep = F*10**(E-H) = 0.F*10**E F = Fp * Pow10 ( H - sLen ) E = Ep + sLen ! ToChars perform digits extraction using integers, ! provided that the arguments are limited to 8 digits. ! Therefore, split the H = 17 digits of F into: !     HF = the most significant digit of F !     MF = the next 8 most significant digits of F !     LF = the last 8, least significant digits of F ! ! For N = 17, M = 8 the table in section 10 of [2] shows !     Floor(F/10**8) = Floor(193,428,131,138,340,668*F/2**84) = !     Floor(Floor(193,428,131,138,340,668*F/2**64) / 2**20) ! and for N = 9, M = 8 !     Floor(HM/10**8) = Floor(1,441,151,881*HM/2**57) ! HM = SHIFTR ( UMul128_Upper64 ( F , M178 ), S178 ) LF = INT ( F - DivE8 * HM , KIND = I4B ) HF = INT ( SHIFTR ( HM * M98 , S98 ), KIND = I4B ) MF = INT ( HM - DivE8 * INT ( HF , KIND = I8B ), KIND = I4B ) ! set format flag IsGeneral = TrueVal IF ( PRESENT ( IsScientific )) IsGeneral = . NOT . IsScientific ! write output IF ( IsGeneral ) THEN IF (( 0 < E ). AND .( E <= 7 )) THEN ! plain format without leading zeroes sLen = ToChar_Plain_Without_LZ ( HF , MF , LF , E , cStr ) ELSEIF (( - 3 < E ). AND .( E <= 0 )) THEN ! plain format with leading zeroes sLen = ToChar_Plain_With_LZ ( HF , MF , LF , E , cStr ) ELSE ! scientific notation sLen = ToChar_Scientific ( HF , MF , LF , E , cStr ) END IF ELSE ! scientific notation sLen = ToChar_Scientific ( HF , MF , LF , E , cStr ) END IF RETURN CONTAINS FUNCTION ToChar_Plain_Without_LZ ( H , M , L , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Plain_Without_LZ !** PURPOSE OF THIS SUBROUTINE: ! For 0 < E <= 7, plain format without leading zeroes. ! Left-to-right digits extraction: ! algorithm 1 in [7], with b = 10, k = 8, n = 28. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: H ! high digit INTEGER ( KIND = I4B ), INTENT ( IN ) :: M ! middle digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: L ! low digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Y , T , I , Pos !** FLOW cStr ( 1 : 1 ) = Char1Digit ( H ) Pos = 2 ! Algorithm 1 in [7] needs computation of floor((a + 1) 2&#94;n / b&#94;k) - 1 ! with a < 10&#94;8, b = 10, k = 8, n = 28. ! Noting that (a + 1) 2&#94;n <= 10&#94;8 2&#94;28 < 10&#94;17 ! For n = 17, m = 8 the table in section 10 of [3] leads to: Y = INT ( SHIFTR ( UMul128_Upper64 ( SHIFTL ( INT ( M + 1 , KIND = I8B ), 28 ), M178 ), S178 ), KIND = I4B ) - 1 I = 1 DO WHILE ( I < E ) T = 10 * Y ! append digit cStr ( Pos : Pos ) = Char1Digit ( SHIFTR ( T , 28 )) Pos = Pos + 1 Y = IAND ( T , MASK_28 ) I = I + 1 END DO ! append period cStr ( Pos : Pos ) = '.' Pos = Pos + 1 DO WHILE ( I <= 8 ) T = 10 * Y ! append digit cStr ( Pos : Pos ) = Char1Digit ( SHIFTR ( T , 28 )) Pos = Pos + 1 Y = IAND ( T , MASK_28 ) I = I + 1 END DO ! append L Pos = Pos + Write_I32_8_Digits ( L , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! set length sLen = Pos RETURN END FUNCTION ToChar_Plain_Without_LZ !************************************************************************** FUNCTION ToChar_Plain_With_LZ ( H , M , L , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Plain_With_LZ !** PURPOSE OF THIS SUBROUTINE: ! For -3 < E <= 0: plain format with leading zeroes. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: H ! high digit INTEGER ( KIND = I4B ), INTENT ( IN ) :: M ! middle digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: L ! low digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Y , T , I , Pos !** FLOW ! fill the first 4 characters cStr ( 1 : 4 ) = '0.00' ! compute Pos Pos = 3 - E ! append H cStr ( Pos : Pos ) = Char1Digit ( H ) Pos = Pos + 1 ! append M and L Pos = Pos + Write_2I32_16_Digits ( M , L , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! set length sLen = Pos RETURN END FUNCTION ToChar_Plain_With_LZ !************************************************************************** FUNCTION ToChar_Scientific ( H , M , L , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Scientific !** PURPOSE OF THIS SUBROUTINE: ! For E <= -3 or E > 7: computerized scientific notation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: H ! high digit INTEGER ( KIND = I4B ), INTENT ( IN ) :: M ! middle digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: L ! low digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Y , T , I , Pos !** FLOW ! append H cStr ( 1 : 1 ) = Char1Digit ( H ) ! append period cStr ( 2 : 2 ) = '.' Pos = 3 ! append M and L Pos = Pos + Write_2I32_16_Digits ( M , L , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! append exponent Pos = Pos + 1 cStr ( Pos : Pos ) = 'E' sLen = Pos + Write_I32_Exponent ( E - 1 , cStr ( Pos + 1 :)) RETURN END FUNCTION ToChar_Scientific !************************************************************************** FUNCTION Write_I32_8_Digits ( Number , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_I32_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 digits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE PARAMETER DECLARATIONS: ! shift and multiplier parameters (i.e. magic number) for integer division INTEGER ( KIND = I4B ), PARAMETER :: Shf78 = 40 INTEGER ( KIND = I8B ), PARAMETER :: Mul78 = 109951163_I8B INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NxtNum , RemNum !** FLOW ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * Mul78 , Shf78 ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = Number - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) ! convert the rest (NxtNum) cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) sLen = 8 RETURN END FUNCTION Write_I32_8_Digits !************************************************************************** FUNCTION Write_2I32_16_Digits ( FirstNum , SecondNum , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_2I32_16_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write two (unsigned) integer numbers with a length of 16 digits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: FirstNum ! first number INTEGER ( KIND = I4B ), INTENT ( IN ) :: SecondNum ! first number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: DumLen !** FLOW ! write first number DumLen = Write_I32_8_Digits ( FirstNum , cStr ( 1 : 8 )) ! write second number DumLen = Write_I32_8_Digits ( SecondNum , cStr ( 9 : 16 )) ! set length sLen = 16 RETURN END FUNCTION Write_2I32_16_Digits !************************************************************************** FUNCTION Write_I32_Exponent ( Exp , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_I32_Exponent !** PURPOSE OF THIS SUBROUTINE: ! To write a signed integer in the range -324 to 308 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! exponent number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosExp !** FLOW IF ( Exp < 0 ) THEN cStr ( 1 : 1 ) = '-' ELSE cStr ( 1 : 1 ) = '+' END IF PosExp = ABS ( Exp ) IF ( PosExp < 100 ) THEN IF ( PosExp < 10 ) THEN ! 1 digit cStr ( 2 : 2 ) = Char1Digit ( PosExp ) sLen = 2 ELSE ! 2 digits cStr ( 2 : 3 ) = Char2Digits ( PosExp ) sLen = 3 END IF ELSE ! 3 digits cStr ( 2 : 4 ) = Char4Digits ( PosExp )( 2 : 4 ) sLen = 4 END IF RETURN END FUNCTION Write_I32_Exponent !************************************************************************** END FUNCTION Write_RealDP !****************************************************************************** END MODULE ModBase_RealDP_CharConv !******************************************************************************","tags":"","loc":"sourcefile\\modbase - realdp - charconv.f90.html"},{"title":"ModBase - SIntUtil.f90 – FortCharConv","text":"Source Code MODULE ModBase_SIntUtil !&#94; **PURPOSE OF THIS MODULE**: ! This module contains various utility routines relating to (signed) integers. !** USE STATEMENTS: USE ModBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! parameters PUBLIC :: MAX_I8 , MAX_I16 , MAX_I32 , MAX_I64 PUBLIC :: MIN_I8 , MIN_I16 , MIN_I32 , MIN_I64 ! procedures PUBLIC :: Compare PUBLIC :: HighestOneBit PUBLIC :: LowestOneBit PUBLIC :: ReverseBits PUBLIC :: ReverseBytes PUBLIC :: SigNum PUBLIC :: ToHexStrSigned PUBLIC :: ToDecStrSigned PUBLIC :: I32_FromChar PUBLIC :: I64_FromChar PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! maximum values INTEGER ( KIND = I1B ), PARAMETER :: MAX_I8 = INT ( Z '7F' , KIND = I1B ) !! 127 INTEGER ( KIND = I2B ), PARAMETER :: MAX_I16 = INT ( Z '7FFF' , KIND = I2B ) !! 32767 INTEGER ( KIND = I4B ), PARAMETER :: MAX_I32 = INT ( Z '7FFFFFFF' , KIND = I4B ) !! 2147483647 INTEGER ( KIND = I8B ), PARAMETER :: MAX_I64 = INT ( Z '7FFFFFFFFFFFFFFF' , KIND = I8B ) !! 9223372036854775807 ! minimum values INTEGER ( KIND = I1B ), PARAMETER :: MIN_I8 = INT ( Z '80' , KIND = I1B ) !! -128 INTEGER ( KIND = I2B ), PARAMETER :: MIN_I16 = INT ( Z '8000' , KIND = I2B ) !! -32768 INTEGER ( KIND = I4B ), PARAMETER :: MIN_I32 = INT ( Z '80000000' , KIND = I4B ) !! -2147483648 INTEGER ( KIND = I8B ), PARAMETER :: MIN_I64 = INT ( Z '8000000000000000' , KIND = I8B ) !! -9223372036854775808 ! tables of digit characters CHARACTER ( LEN = 2 ), PARAMETER :: Char2Digits ( 0 : 99 ) = [ & '00' , '01' , '02' , '03' , '04' , '05' , '06' , '07' , '08' , '09' , & '10' , '11' , '12' , '13' , '14' , '15' , '16' , '17' , '18' , '19' , & '20' , '21' , '22' , '23' , '24' , '25' , '26' , '27' , '28' , '29' , & '30' , '31' , '32' , '33' , '34' , '35' , '36' , '37' , '38' , '39' , & '40' , '41' , '42' , '43' , '44' , '45' , '46' , '47' , '48' , '49' , & '50' , '51' , '52' , '53' , '54' , '55' , '56' , '57' , '58' , '59' , & '60' , '61' , '62' , '63' , '64' , '65' , '66' , '67' , '68' , '69' , & '70' , '71' , '72' , '73' , '74' , '75' , '76' , '77' , '78' , '79' , & '80' , '81' , '82' , '83' , '84' , '85' , '86' , '87' , '88' , '89' , & '90' , '91' , '92' , '93' , '94' , '95' , '96' , '97' , '98' , '99' ] !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE/GENERIC DEFINITIONS: INTERFACE Compare !&#94; **Function Interface**: Compare !  **Purpose**:  To compare two signed integers of the same kind and return !   -1 if LHS < RHS !    0 if LHS == RHS !    1 if LHS > RHS !  **Usage**: !   --->    Flag = Compare(LHS, RHS) !   --->    IF (Compare(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE I8_Compare MODULE PROCEDURE I16_Compare MODULE PROCEDURE I32_Compare MODULE PROCEDURE I64_Compare END INTERFACE INTERFACE HighestOneBit !&#94; **Function Interface**: HighestOneBit !  **Purpose**:  To return an integer value (same kind as the specified integer value) with at most !   a single one-bit, in the position of the highest-order (leftmost) one-bit in the input. !  **Usage**: !   --->    OUTPUT = HighestOneBit(INPUT) MODULE PROCEDURE I32_HighestOneBit MODULE PROCEDURE I64_HighestOneBit END INTERFACE INTERFACE LowestOneBit !&#94; **Function Interface**: LowestOneBit !  **Purpose**:  To return an integer value (same kind as the specified integer value) with at most !   a single one-bit, in the position of the lowest-order (rightmost) one-bit in the input. !  **Usage**: !   --->    OUTPUT = LowestOneBit(INPUT) MODULE PROCEDURE I32_LowestOneBit MODULE PROCEDURE I64_LowestOneBit END INTERFACE INTERFACE ReverseBits !&#94; **Function Interface**: ReverseBits !  **Purpose**:  To return an integer value (same kind as the specified integer value) obtained by !    reversing the order of the bits in the two's complement binary representation of the input. !  **Usage**: !   --->    OUTPUT = ReverseBits(INPUT) MODULE PROCEDURE I32_ReverseBits MODULE PROCEDURE I64_ReverseBits END INTERFACE INTERFACE ReverseBytes !&#94; **Function Interface**: ReverseBits !  **Purpose**:  To return an integer value (same kind as the specified integer value) obtained by !    reversing the order of the bytes in the two's complement binary representation of the input. !  **Usage**: !   --->    OUTPUT = ReverseBytes(INPUT) MODULE PROCEDURE I32_ReverseBytes MODULE PROCEDURE I64_ReverseBytes END INTERFACE INTERFACE SigNum !&#94; **Function Interface**: SigNum !  **Purpose**:  To return the sign of the specified input where the return value is !   -1 if the specified value is negative !    0 if the specified value is zero !    1 if the specified value is positive !  **Usage**: !   --->    SignFlag = SigNum(INPUT) MODULE PROCEDURE I32_SigNum MODULE PROCEDURE I64_SigNum END INTERFACE INTERFACE ToHexStrSigned !&#94; **Function Interface**: ToHexStrSigned !  **Purpose**:  To convert a signed integer to a hexadecimal string !  **Usage**: !   --->    Str = ToHexStrSigned(I32) MODULE PROCEDURE I32_ToHexString MODULE PROCEDURE I64_ToHexString END INTERFACE INTERFACE ToDecStrSigned !&#94; **Function Interface**: ToDecStrSigned !  **Purpose**:  To convert a signed integer to a decimal string !  **Usage**: !   --->    Str = ToDecStrSigned(I64) MODULE PROCEDURE I32_ToDecString MODULE PROCEDURE I64_ToDecString END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES or FUNCTIONS: !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                               comparison !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION I8_Compare ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: I8_Compare !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS < RHS ) THEN Flag = - 1 ELSEIF ( LHS > RHS ) THEN Flag = + 1 ELSE Flag = 0 END IF RETURN END FUNCTION I8_Compare !****************************************************************************** PURE FUNCTION I16_Compare ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: I16_Compare !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS < RHS ) THEN Flag = - 1 ELSEIF ( LHS > RHS ) THEN Flag = + 1 ELSE Flag = 0 END IF RETURN END FUNCTION I16_Compare !****************************************************************************** PURE FUNCTION I32_Compare ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: I32_Compare !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS < RHS ) THEN Flag = - 1 ELSEIF ( LHS > RHS ) THEN Flag = + 1 ELSE Flag = 0 END IF RETURN END FUNCTION I32_Compare !****************************************************************************** PURE FUNCTION I64_Compare ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: I64_Compare !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS < RHS ) THEN Flag = - 1 ELSEIF ( LHS > RHS ) THEN Flag = + 1 ELSE Flag = 0 END IF RETURN END FUNCTION I64_Compare !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                      Bitwise-Related Procedures !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION I64_HighestOneBit ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I64_HighestOneBit !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 64-bit integer value with at most a single one-bit, in the ! position of the highest-order (leftmost) one-bit in the specified ! 64-bit integer value.  To return zero if the specified value has no ! one-bits in its two's complement binary representation, that is, if it ! is equal to zero. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( InVal , SHIFTR ( MIN_I64 , LEADZ ( InVal ))) RETURN END FUNCTION I64_HighestOneBit !****************************************************************************** PURE FUNCTION I32_HighestOneBit ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I32_HighestOneBit !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 32-bit integer value with at most a single one-bit, in the ! position of the highest-order (leftmost) one-bit in the specified ! 32-bit integer value.  To return zero if the specified value has no ! one-bits in its two's complement binary representation, that is, if it ! is equal to zero. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( InVal , SHIFTR ( MIN_I32 , LEADZ ( InVal ))) RETURN END FUNCTION I32_HighestOneBit !****************************************************************************** PURE FUNCTION I64_LowestOneBit ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I64_LowestOneBit !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 64-bit integer value with at most a single one-bit, in the ! position of the lowest-order (rightmost) one-bit in the specified ! 64-bit integer value.  To return zero if the specified value has no ! one-bits in its two's complement binary representation, that is, if it ! is equal to zero. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( InVal , - InVal ) RETURN END FUNCTION I64_LowestOneBit !****************************************************************************** PURE FUNCTION I32_LowestOneBit ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I32_LowestOneBit !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 32-bit integer value with at most a single one-bit, in the ! position of the lowest-order (rightmost) one-bit in the specified ! 32-bit integer value.  To return zero if the specified value has no ! one-bits in its two's complement binary representation, that is, if it ! is equal to zero. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( InVal , - InVal ) RETURN END FUNCTION I32_LowestOneBit !****************************************************************************** PURE FUNCTION I64_ReverseBits ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I64_ReverseBits !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 64-bit integer value obtained by reversing the order of the ! bits in the two's complement binary representation of the specified value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: C1 = INT ( Z '5555555555555555' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C2 = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C3 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IOR ( SHIFTL ( IAND ( InVal , C1 ), 1 ), IAND ( SHIFTR ( InVal , 1 ), C1 )) OutVal = IOR ( SHIFTL ( IAND ( OutVal , C2 ), 2 ), IAND ( SHIFTR ( OutVal , 2 ), C2 )) OutVal = IOR ( SHIFTL ( IAND ( OutVal , C3 ), 4 ), IAND ( SHIFTR ( OutVal , 4 ), C3 )) OutVal = ReverseBytes ( OutVal ) RETURN END FUNCTION I64_ReverseBits !****************************************************************************** PURE FUNCTION I32_ReverseBits ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I32_ReverseBits !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 32-bit integer value obtained by reversing the order of the ! bits in the two's complement binary representation of the specified value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: C1 = INT ( Z '55555555' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: C2 = INT ( Z '33333333' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: C3 = INT ( Z '0F0F0F0F' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IOR ( SHIFTL ( IAND ( InVal , C1 ), 1 ), IAND ( SHIFTR ( InVal , 1 ), C1 )) OutVal = IOR ( SHIFTL ( IAND ( OutVal , C2 ), 2 ), IAND ( SHIFTR ( OutVal , 2 ), C2 )) OutVal = IOR ( SHIFTL ( IAND ( OutVal , C3 ), 4 ), IAND ( SHIFTR ( OutVal , 4 ), C3 )) OutVal = ReverseBytes ( OutVal ) RETURN END FUNCTION I32_ReverseBits !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                      Miscellaneous Procedures !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION I64_ReverseBytes ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I64_ReverseBytes !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 64-bit integer value obtained by reversing the order of the ! bytes in the two's complement representation of the specified value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: C1 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C2 = INT ( Z '00000000FFFF0000' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IOR ( SHIFTL ( IAND ( InVal , C1 ), 8 ), IAND ( SHIFTR ( InVal , 8 ), C1 )) OutVal = IOR ( IOR ( IOR ( SHIFTL ( OutVal , 48 ), SHIFTL ( IAND ( OutVal , C2 ), 16 )), & IAND ( SHIFTR ( OutVal , 16 ), C2 )), SHIFTR ( OutVal , 48 )) ! alternative implementation !    OutVal = 0 !    CALL MVBITS(InVal, 56, 8, OutVal,  0) !    CALL MVBITS(InVal, 48, 8, OutVal,  8) !    CALL MVBITS(InVal, 40, 8, OutVal, 16) !    CALL MVBITS(InVal, 32, 8, OutVal, 24) !    CALL MVBITS(InVal, 24, 8, OutVal, 32) !    CALL MVBITS(InVal, 16, 8, OutVal, 40) !    CALL MVBITS(InVal,  8, 8, OutVal, 48) !    CALL MVBITS(InVal,  0, 8, OutVal, 56) RETURN END FUNCTION I64_ReverseBytes !****************************************************************************** PURE FUNCTION I32_ReverseBytes ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: I32_ReverseBytes !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an 32-bit integer value obtained by reversing the order of the ! bytes in the two's complement representation of the specified value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: C = INT ( Z '0000FF00' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IOR ( IOR ( IOR ( SHIFTL ( InVal , 24 ), SHIFTL ( IAND ( InVal , C ), 8 )), & IAND ( SHIFTR ( InVal , 8 ), C )), SHIFTR ( InVal , 24 )) ! alternative implementation !    OutVal = 0 !    CALL MVBITS(InVal, 24, 8, OutVal,  0) !    CALL MVBITS(InVal, 16, 8, OutVal,  8) !    CALL MVBITS(InVal,  8, 8, OutVal, 16) !    CALL MVBITS(InVal,  0, 8, OutVal, 24) RETURN END FUNCTION I32_ReverseBytes !****************************************************************************** PURE FUNCTION I64_SigNum ( Val ) RESULT ( Sign ) !DIR$ ATTRIBUTES FORCEINLINE :: I64_SigNum !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the sign of the specified input where the return value is !   -1 if the specified value is negative !    0 if the specified value is zero !    1 if the specified value is positive. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val INTEGER ( KIND = I4B ) :: Sign !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Sign = INT ( IOR ( SHIFTA ( Val , 63 ), SHIFTR ( - Val , 63 )), KIND = I4B ) RETURN END FUNCTION I64_SigNum !****************************************************************************** PURE FUNCTION I32_SigNum ( Val ) RESULT ( Sign ) !DIR$ ATTRIBUTES FORCEINLINE :: I32_SigNum !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the sign of the specified input where the return value is !   -1 if the specified value is negative !    0 if the specified value is zero !    1 if the specified value is positive. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Val INTEGER ( KIND = I4B ) :: Sign !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Sign = IOR ( SHIFTA ( Val , 31 ), SHIFTR ( - Val , 31 )) RETURN END FUNCTION I32_SigNum !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   Conversion To Hexadecimal String !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION I64_ToHexString ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 64-bit integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! hexadecimal string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 16 INTEGER ( KIND = I8B ), PARAMETER :: Base = 16_I8B INTEGER ( KIND = I4B ), PARAMETER :: Shift = 4 CHARACTER ( LEN =* ), PARAMETER :: NumStr ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , & '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I8B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I8B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I8B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0_I8B ) THEN cStr = '0' RETURN END IF IF ( Number < 0_I8B ) THEN IF ( Number == MIN_I64 ) THEN cStr = '-8000000000000000' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = SHIFTR ( PosNum , Shift ) ! compute the remainder RemNum = CurNum - SHIFTL ( PosNum , Shift ) ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0_I8B ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0_I8B ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I64_ToHexString !****************************************************************************** PURE FUNCTION I32_ToHexString ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 32-bit integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! hexadecimal string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 8 INTEGER ( KIND = I4B ), PARAMETER :: Base = 16 INTEGER ( KIND = I4B ), PARAMETER :: Shift = 4 CHARACTER ( LEN =* ), PARAMETER :: NumStr ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , & '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I4B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I4B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I4B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0 ) THEN cStr = '0' RETURN END IF IF ( Number < 0 ) THEN IF ( Number == MIN_I32 ) THEN cStr = '-80000000' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = SHIFTR ( PosNum , Shift ) ! compute the remainder RemNum = CurNum - SHIFTL ( PosNum , Shift ) ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0 ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0 ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I32_ToHexString !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   Conversion To Decimal String !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION I32_ToDecString ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an integer number to decimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I4B ) :: PosNum INTEGER ( KIND = I4B ) :: Finish , Start INTEGER ( KIND = I4B ) :: AA , BB , CC , DD INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD INTEGER ( KIND = I4B ) :: AABBCC , DDEE , EE !** FLOW ! set positive number PosNum = ABS ( Number ) ! start the conversion IF ( PosNum < 100 ) THEN ! 1-2 digits wStr ( 1 : 2 ) = Char2Digits ( PosNum ) Finish = 2 ELSEIF ( PosNum < 10000 ) THEN ! 3-4 digits AA = INT ( SHIFTR ( PosNum * 5243 , 19 ), KIND = I4B ) ! PosNum / 100 BB = PosNum - AA * 100 ! MOD(PosNum, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) Finish = 4 ELSEIF ( PosNum < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( PosNum * 429497_I8B , 32 ), KIND = I4B ) ! PosNum / 10000 BBCC = PosNum - AA * 10000 ! MOD(PosNum, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) Finish = 6 ELSEIF ( PosNum < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( PosNum * 109951163_I8B , 40 ), KIND = I4B ) ! PosNum / 10000 CCDD = PosNum - AABB * 10000 ! MOD(PosNum, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) wStr ( 7 : 8 ) = Char2Digits ( DD ) Finish = 8 ELSE ! 9-10 digits AABBCC = INT ( SHIFTR ( PosNum * 3518437209_I8B , 45 ), KIND = I4B ) ! PosNum / 10000 AA = INT ( SHIFTR ( AABBCC * 429497_I8B , 32 ), KIND = I4B ) ! AABBCC / 10000 DDEE = PosNum - AABBCC * 10000 ! MOD(PosNum, 10000) BBCC = AABBCC - AA * 10000 ! MOD(AABBCC, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 DD = SHIFTR ( DDEE * 5243 , 19 ) ! DDEE / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) EE = DDEE - DD * 100 ! MOD(DDEE, 100) wStr ( 1 : 2 ) = Char2Digits ( AA ) wStr ( 3 : 4 ) = Char2Digits ( BB ) wStr ( 5 : 6 ) = Char2Digits ( CC ) wStr ( 7 : 8 ) = Char2Digits ( DD ) wStr ( 9 : 10 ) = Char2Digits ( EE ) Finish = 10 END IF Start = 1 IF ( wStr ( 1 : 1 ) == '0' ) Start = 2 IF ( Number < 0 ) THEN IF ( Number == MIN_I32 ) THEN cStr = '-2147483648' RETURN END IF cStr = '-' // wStr ( Start : Finish ) ELSE cStr = wStr ( Start : Finish ) END IF RETURN END FUNCTION I32_ToDecString !****************************************************************************** FUNCTION I64_ToDecString ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an integer number to decimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 20 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum , TmpNum , HiNum , LoNum , MidNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! set positive number PosNum = ABS ( Number ) ! start conversion and store digits in working string IF ( PosNum < 100000000_I8B ) THEN ! 1-8 digits Start = 12 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 13 : 20 )) ELSEIF ( PosNum < 10000000000000000_I8B ) THEN ! 9-16 digits HiNum = PosNum / 100000000_I8B LoNum = PosNum - HiNum * 100000000_I8B ! MOD(PosNum, 100000000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) Start = 4 + Write_1_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 5 : 12 )) ELSE ! 17-20 digits TmpNum = PosNum / 100000000_I8B LoNum = PosNum - TmpNum * 100000000_I8B ! MOD(PosNum, 100000000) HiNum = TmpNum / 10000_I8B MidNum = TmpNum - HiNum * 10000_I8B ! MOD(TmpNum, 10000) CALL Write_8_Digits ( INT ( LoNum , KIND = I4B ), wStr ( 13 : 20 )) CALL Write_4_Digits ( INT ( MidNum , KIND = I4B ), wStr ( 9 : 12 )) Start = Write_5_to_8_Digits ( INT ( HiNum , KIND = I4B ), wStr ( 1 : 8 )) END IF ! transfer to output string IF ( Number < 0_I8B ) THEN IF ( Number == MIN_I64 ) THEN cStr = '-9223372036854775808' RETURN END IF cStr = '-' // wStr ( Start : MaxLen ) ELSE cStr = wStr ( Start : MaxLen ) END IF RETURN CONTAINS SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , CCDD ! working variables !** FLOW AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** SUBROUTINE Write_4_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_4_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB ! working indices !** FLOW AA = SHIFTR ( Number * 5243 , 19 ) ! Number / 100 BB = Number - AA * 100 ! MOD(Number, 100) cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) RETURN END SUBROUTINE Write_4_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD ! working variables !** FLOW IF ( Number < 100 ) THEN ! 1-2 digits AA = Number IF ( AA < 10 ) THEN cStr ( 8 : 8 ) = Char2Digits ( AA )( 2 : 2 ) Start = 8 ELSE cStr ( 7 : 8 ) = Char2Digits ( AA ) Start = 7 END IF ELSEIF ( Number < 10000 ) THEN ! 3-4 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 5243_I8B , 19 ), KIND = I4B ) ! Number / 100 BB = Number - AA * 100 ! MOD(Number, 100) IF ( AA < 10 ) THEN cStr ( 6 : 6 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 7 : 8 ) = Char2Digits ( BB ) Start = 6 ELSE cStr ( 5 : 6 ) = Char2Digits ( AA ) cStr ( 7 : 8 ) = Char2Digits ( BB ) Start = 5 END IF ELSEIF ( Number < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 429497_I8B , 32 ), KIND = I4B ) ! Number / 10000 BBCC = Number - AA * 10000 ! MOD(Number, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) IF ( AA < 10 ) THEN cStr ( 4 : 4 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 4 ELSE cStr ( 3 : 4 ) = Char2Digits ( AA ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 3 END IF ELSEIF ( Number < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) IF ( AA < 10 ) THEN cStr ( 2 : 2 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 2 ELSE cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 1 END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** FUNCTION Write_5_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_5_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 5 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AA , BB , CC , DD ! working indices INTEGER ( KIND = I4B ) :: AABB , BBCC , CCDD ! working variables !** FLOW IF ( Number < 1000000 ) THEN ! 5-6 digits AA = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 429497_I8B , 32 ), KIND = I4B ) ! Number / 10000 BBCC = Number - AA * 10000 ! MOD(Number, 10000) BB = SHIFTR ( BBCC * 5243 , 19 ) ! BBCC / 100 CC = BBCC - BB * 100 ! MOD(BBCC, 100) IF ( AA < 10 ) THEN cStr ( 4 : 4 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 4 ELSE cStr ( 3 : 4 ) = Char2Digits ( AA ) cStr ( 5 : 6 ) = Char2Digits ( BB ) cStr ( 7 : 8 ) = Char2Digits ( CC ) Start = 3 END IF ELSEIF ( Number < 100000000 ) THEN ! 7-8 digits AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! Number / 10000 CCDD = Number - AABB * 10000 ! MOD(Number, 10000) AA = SHIFTR ( AABB * 5243 , 19 ) ! AABB / 100 CC = SHIFTR ( CCDD * 5243 , 19 ) ! CCDD / 100 BB = AABB - AA * 100 ! MOD(AABB, 100) DD = CCDD - CC * 100 ! MOD(CCDD, 100) IF ( AA < 10 ) THEN cStr ( 2 : 2 ) = Char2Digits ( AA )( 2 : 2 ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 2 ELSE cStr ( 1 : 2 ) = Char2Digits ( AA ) cStr ( 3 : 4 ) = Char2Digits ( BB ) cStr ( 5 : 6 ) = Char2Digits ( CC ) cStr ( 7 : 8 ) = Char2Digits ( DD ) Start = 1 END IF END IF RETURN END FUNCTION Write_5_to_8_Digits !************************************************************************** END FUNCTION I64_ToDecString !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   Conversion From Decimal String !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION I32_FromChar ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to an integer value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxDigit = 10 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF END IF ! check for leading zero(s) Number = 0 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I32 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigit ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigit ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MIN_I32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MAX_I32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MIN_I32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar !****************************************************************************** FUNCTION I64_FromChar ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to an integer value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxDigit = 19 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I8B ), PARAMETER :: LBase = 10_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MIN_I64 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigit ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigit ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MIN_I64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MAX_I64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MIN_I64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar !****************************************************************************** END MODULE ModBase_SIntUtil !******************************************************************************","tags":"","loc":"sourcefile\\modbase - sintutil.f90.html"},{"title":"ModBase - SInt128.f90 – FortCharConv","text":"Source Code MODULE ModBase_SInt128 !&#94; **PURPOSE OF THIS MODULE**: !\tThis module contains a derived type and basic operations for a 128-bit signed integer. !  The application interface (API) for the 128-bit signed integer follows Fortran intrinsic !  integer types as close as practical.  Also, the implementation should provide behavior !  closely similar to the behavior of Fortran intrinsic integer types. !  ***Important Note***: !   (1) For arithmetic operations, various types of signed integer types (32-, 64- and 128-bit) !   are allowed.  However, the use of signed and unsigned integers in the same operation is NOT !   allowed.  Unsigned integer types must be explicitly converted to signed types before using !   in the arithmetic operations. !   (2) For comparison and bitwise operations that require two input arguments, both arguments must !   only be the 128-bit signed integer type.  All other types must be explicitly converted to !   this type before using in the comparison and bitwise operations. ! !&#94; **REFERENCES**: !\t[1] [Absl's Numeric Library](https://github.com/abseil/abseil-cpp/tree/master/absl/numeric) !\t[2] [Fast 128-bit math library for Java](https://github.com/martint/int128/) !\t[3] [Extended precision integer C++ library](https://github.com/chfast/intx) !** USE STATEMENTS: USE ModBase_Common USE ModBase_Error_Handlers USE ModBase_SIntUtil USE ModBase_UIntUtil USE ModBase_UInt128 USE , INTRINSIC :: IEEE_ARITHMETIC USE , INTRINSIC :: ISO_FORTRAN_ENV , ONLY : OUTPUT_UNIT IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type + constructor PUBLIC :: SInt128 ! assignment + conversion PUBLIC :: ASSIGNMENT ( = ) PUBLIC :: ToR32 , ToR64 , ToR128 PUBLIC :: ToU32 , ToU64 , ToU128 PUBLIC :: ToDecString , ToHexString ! comparison PUBLIC :: OPERATOR ( == ), OPERATOR ( /= ) PUBLIC :: OPERATOR ( < ), OPERATOR ( <= ) PUBLIC :: OPERATOR ( > ), OPERATOR ( >= ) PUBLIC :: Compare ! arithmetic PUBLIC :: OPERATOR ( + ), OPERATOR ( - ) PUBLIC :: OPERATOR ( * ), OPERATOR ( / ) PUBLIC :: Increment , Decrement , Add , Subtract PUBLIC :: Multiply , Divide , MOD , DivMod ! bitwise PUBLIC :: SHIFTL , SHIFTR , SHIFTA , ISHFT , ISHFTC PUBLIC :: IOR , IEOR , IAND , NOT , LEADZ , TRAILZ PUBLIC :: POPCNT , POPPAR , IBSET , IBCLR PUBLIC :: IBCHNG , BTEST , IBITS PUBLIC :: MoveBits ! == MVBITS ! bitwise (specialized) PUBLIC :: ShiftLOnce , ShiftROnce , ShiftAOnce PUBLIC :: ShiftL64 , ShiftR64 , ShiftA64 PUBLIC :: ShiftL63Down , ShiftR63Down , ShiftA63Down PUBLIC :: ShiftL64Up , ShiftR64Up , ShiftA64Up ! inquiry PUBLIC :: IsPositive , IsNegative , IsZero ! auxiliary PUBLIC :: ABS PUBLIC :: Display PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! module name CHARACTER ( LEN =* ), PARAMETER :: ModName = 'ModBase_SInt128' ! unsigned limit parameters INTEGER ( KIND = I8B ), PARAMETER :: MaxU64 = INT ( Z 'FFFFFFFFFFFFFFFF' , KIND = I8B ) ! max unsigned 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MinU64 = INT ( Z '0000000000000000' , KIND = I8B ) ! min unsigned 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MaxU32 = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) ! max unsigned 32-bit INTEGER ( KIND = I8B ), PARAMETER :: MinU32 = INT ( Z '0000000000000000' , KIND = I8B ) ! min unsigned 32-bit ! signed limit parameters INTEGER ( KIND = I8B ), PARAMETER :: MaxI64 = INT ( Z '7FFFFFFFFFFFFFFF' , KIND = I8B ) ! max signed 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! min signed 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MaxI32 = INT ( Z '000000007FFFFFFF' , KIND = I8B ) ! max signed 32-bit INTEGER ( KIND = I8B ), PARAMETER :: MinI32 = INT ( Z '0000000080000000' , KIND = I8B ) ! min signed 32-bit ! miscellaneous INTEGER ( KIND = I8B ), PARAMETER :: Mask32 = MaxU32 INTEGER ( KIND = I8B ), PARAMETER :: TopBit = SHIFTL ( 1_I8B , 63 ) LOGICAL , PARAMETER :: Positive = FalseVal !** DERIVED TYPE DEFINITIONS !# a 128-bit signed integer type where the base of its components is 2**64. TYPE SInt128 INTEGER ( KIND = I8B ) :: High !! upper 64 bits treated as signed integer INTEGER ( KIND = I8B ) :: Low !! lower 64 bits treated as unsigned integer END TYPE SInt128 !** MODULE PARAMETERS (PART 2): !# 128-bit signed parameter with maximum value TYPE ( SInt128 ), PARAMETER , PUBLIC :: MaxI128 = SInt128 ( MaxI64 , MaxU64 ) !# 128-bit signed parameter with minimum value TYPE ( SInt128 ), PARAMETER , PUBLIC :: MinI128 = SInt128 ( MinI64 , MinU64 ) !# 128-bit signed parameter with value of one TYPE ( SInt128 ), PARAMETER , PUBLIC :: OneI128 = SInt128 ( 0_I8B , 1_I8B ) !# 128-bit signed parameter with value of zero TYPE ( SInt128 ), PARAMETER , PUBLIC :: ZeroI128 = SInt128 ( 0_I8B , 0_I8B ) TYPE ( SInt128 ), PARAMETER :: TenI128 = SInt128 ( 0_I8B , 10_I8B ) !** INTERFACE DEFINITIONS: ! na !** GENERIC DEFINITIONS: !----------------------------------------------- !----- \t        conversion operations \t   ----- !----------------------------------------------- INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) !  **Purpose**:  To convert between a 128-bit signed integer and !   other signed integers (32- and 64-bit integers) !  **Usage**: !   --->    I128 = OtherType MODULE PROCEDURE I128_From_I32 MODULE PROCEDURE I128_From_I64 MODULE PROCEDURE I128_To_I32 MODULE PROCEDURE I128_To_I64 END INTERFACE INTERFACE SInt128 !&#94; **Constructor Interface**: SInt128 !  **Purpose**:  To construct a 128-bit signed integer from !   other Fortran intrinsic types or 32- and 64-bit unsigned integers !  **Usage**: !   --->    I128 = SInt128(IntrinsicType)   ! constructor for Fortran intrinsic types !   --->    I128 = SInt128(UType, Negative) ! 32- and 64-bit unsigned integers where I128 has negative value if 'Negative' is true !  **Note**:  The different between 32-bit signed (I32) and unsigned (U32) integer types !             is that I32 is treated as signed while U32 is treated as unsigned although !             both are actually the 32-bit Fortran intrinsic integer type. MODULE PROCEDURE I32_To_I128 MODULE PROCEDURE I64_To_I128 MODULE PROCEDURE U32_To_I128 MODULE PROCEDURE U64_To_I128 MODULE PROCEDURE R32_To_I128 MODULE PROCEDURE R64_To_I128 MODULE PROCEDURE R128_To_I128 MODULE PROCEDURE DecString_To_I128 END INTERFACE INTERFACE ToU32 !&#94; **Function Interface**: ToU32 !  **Purpose**:  To convert a 128-bit signed integer to a !   32-bit unsigned integer !  **Usage**: !   --->    U32 = ToU32(I128) MODULE PROCEDURE U32_From_I128 END INTERFACE INTERFACE ToU64 !&#94; **Function Interface**: ToU64 !  **Purpose**:  To convert a 128-bit signed integer to a !   64-bit unsigned integer !  **Usage**: !   --->    U64 = ToU64(I128) MODULE PROCEDURE U64_From_I128 END INTERFACE INTERFACE ToU128 !&#94; **Function Interface**: ToU128 !  **Purpose**:  To convert a 128-bit signed integer to a !   128-bit unsigned integer !  **Usage**: !   --->    U128 = ToU128(I128) MODULE PROCEDURE U128_From_I128 END INTERFACE INTERFACE ToR32 !&#94; **Function Interface**: ToR32 !  **Purpose**:  To convert a 128-bit signed integer to !   a 32-bit floating point (real) number !  **Usage**: !   --->    R32 = ToR32(I128) MODULE PROCEDURE R32_From_I128 END INTERFACE INTERFACE ToR64 !&#94; **Function Interface**: ToR64 !  **Purpose**:  To convert a 128-bit signed integer to !   a 64-bit floating point (real) number !  **Usage**: !   --->    R64 = ToR64(I128) MODULE PROCEDURE R64_From_I128 END INTERFACE INTERFACE ToR128 !&#94; **Function Interface**: ToR128 !  **Purpose**:  To convert a 128-bit signed integer to !   a 128-bit floating point (real) number !  **Usage**: !   --->    R128 = ToR128(I128) MODULE PROCEDURE R128_From_I128 END INTERFACE INTERFACE ToDecString !&#94; **Function Interface**: ToDecString !  **Purpose**:  To convert a 128-bit signed integer to !   a decimal string !  **Usage**: !   --->    Str = ToDecString(I128) MODULE PROCEDURE DecString_From_I128 END INTERFACE INTERFACE ToHexString !&#94; **Function Interface**: ToHexString !  **Purpose**:  To convert a 128-bit signed integer to !   a hexadecimal string !  **Usage**: !   --->    Str = ToHexString(I128) MODULE PROCEDURE HexString_From_I128 END INTERFACE !----------------------------------------------- !----- \t\t    comparison operations\t       ----- !----------------------------------------------- INTERFACE OPERATOR ( == ) !&#94; **Operator Overload**: OPERATOR(==) !  **Purpose**:  To check if values of two 128-bit signed integers are equal !   return .TRUE. if both values are equal; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS == RHS !   --->    IF (LHS .EQ. RHS) DoSomething MODULE PROCEDURE I128_Equal END INTERFACE INTERFACE OPERATOR ( /= ) !&#94; **Operator Overload**: OPERATOR(/=) !  **Purpose**:  To check if values of two 128-bit signed integers are not equal !   return .TRUE. if both values are NOT equal; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS /= RHS !   --->    IF (LHS .NE. RHS) DoSomething MODULE PROCEDURE I128_NotEqual END INTERFACE INTERFACE OPERATOR ( < ) !&#94; **Operator Overload**: OPERATOR(<) !  **Purpose**:  To check if the LHS value is less than the RHS value !   return .TRUE. if LHS < RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS < RHS !   --->    IF (LHS .LT. RHS) DoSomething MODULE PROCEDURE I128_LessThan END INTERFACE INTERFACE OPERATOR ( <= ) !&#94; **Operator Overload**: OPERATOR(<=) !  **Purpose**:  To check if the LHS value is less than or equal to the RHS value !   return .TRUE. if LHS <= RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS <= RHS !   --->    IF (LHS .LE. RHS) DoSomething MODULE PROCEDURE I128_LessEqual END INTERFACE INTERFACE OPERATOR ( > ) !&#94; **Operator Overload**: OPERATOR(>) !  **Purpose**:  To check if the LHS value is greater than the RHS value !   return .TRUE. if LHS > RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS > RHS !   --->    IF (LHS .GT. RHS) DoSomething MODULE PROCEDURE I128_GreaterThan END INTERFACE INTERFACE OPERATOR ( >= ) !&#94; **Operator Overload**: OPERATOR(>=) !  **Purpose**:  To check if the LHS value is greater than or equal to the RHS value !   return .TRUE. if LHS >= RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS >= RHS !   --->    IF (LHS .GE. RHS) DoSomething MODULE PROCEDURE I128_GreaterEqual END INTERFACE INTERFACE Compare !&#94; **Function Interface**: Compare !  **Purpose**:  To compare two 128-bit signed integers and return !   -1 if LHS < RHS !    0 if LHS == RHS !    1 if LHS > RHS !  **Usage**: !   --->    Flag = Compare(LHS, RHS) !   --->    IF (Compare(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE I128_Compare END INTERFACE !----------------------------------------------- !----- \t\t arithmetic operations          ----- !----------------------------------------------- INTERFACE OPERATOR ( + ) !&#94; **Operator Overload**: OPERATOR(+) !  **Purpose**:  To perform a summation of two signed integers !   (at least one of which is a 128-bit signed integer) or !   to add a unary plus sign to a 128-bit signed integer !   (which has no effect on the signed integer) !  **Usage**: !   --->    OUTPUT = +INPUT !   --->    OUTPUT = FIRST_IN + SECOND_IN MODULE PROCEDURE I128_UnaryPlus MODULE PROCEDURE I128_Plus_I128 MODULE PROCEDURE I128_Plus_I32 MODULE PROCEDURE I32_Plus_I128 MODULE PROCEDURE I128_Plus_I64 MODULE PROCEDURE I64_Plus_I128 END INTERFACE INTERFACE OPERATOR ( - ) !&#94; **Operator Overload**: OPERATOR(-) !  **Purpose**:  To perform a subtraction of two signed integers !   (at least one of which is a 128-bit signed integer) or !   to perform a negation of a 128-bit signed integer !  **Usage**: !   --->    OUTPUT = -INPUT !   --->    OUTPUT = FIRST_IN - SECOND_IN !  ***Important Note***:  For subtraction of signed integers (unlike unsigned one), !   value of FIRST_IN can be less than SECOND_IN. MODULE PROCEDURE I128_Negate MODULE PROCEDURE I128_Minus_I128 MODULE PROCEDURE I128_Minus_I32 MODULE PROCEDURE I32_Minus_I128 MODULE PROCEDURE I128_Minus_I64 MODULE PROCEDURE I64_Minus_I128 END INTERFACE INTERFACE OPERATOR ( * ) !&#94; **Operator Overload**: OPERATOR( * ) !  **Purpose**:  To perform a multiplication of two signed integers !   (at least one of which is a 128-bit signed integer) !  **Usage**: !   --->    OUTPUT = FIRST_IN * SECOND_IN MODULE PROCEDURE I128_Multiply_I128 MODULE PROCEDURE I128_Multiply_I32 MODULE PROCEDURE I32_Multiply_I128 MODULE PROCEDURE I128_Multiply_I64 MODULE PROCEDURE I64_Multiply_I128 END INTERFACE INTERFACE OPERATOR ( / ) !&#94; **Operator Overload**: OPERATOR(/) !  **Purpose**:  To return the quotient of a division of two signed integers, !   where the dividend (numerator) is a 128-bit signed integer and the !   divisor (denominator) can be 32-, 64- or 128-bit signed integer !  **Usage**: !   --->    QUOT = NUMER / DENOM MODULE PROCEDURE I128_Divide_I32 MODULE PROCEDURE I128_Divide_I64 MODULE PROCEDURE I128_Divide_I128 END INTERFACE INTERFACE MOD !&#94; **Function Interface**: MOD !  **Purpose**:  To return the remainder of a division of two signed integers, !   where the dividend (numerator) is a 128-bit signed integer and the !   divisor (denominator) can be 32-, 64- or 128-bit signed integer !  **Usage**: !   --->    REM = MOD(NUMER, DENOM) MODULE PROCEDURE I128_Mod_I32 MODULE PROCEDURE I128_Mod_I64 MODULE PROCEDURE I128_Mod_I128 END INTERFACE INTERFACE DivMod !&#94; **Subroutine Interface**: DivMod !  **Purpose**:  To perform a division of two signed integers (where the !   dividend (numerator) is a 128-bit signed integer and the divisor !   (denominator) can be 32-, 64- or 128-bit signed integer) and !   to return both the quotient and the remainder !  **Usage**: !   --->    CALL DivMod(NUMER, DENOM, QUOT, REM) MODULE PROCEDURE I128_DivMod_I32 MODULE PROCEDURE I128_DivMod_I64 MODULE PROCEDURE I128_DivMod_I128 END INTERFACE INTERFACE Increment !&#94; **Subroutine Interface**: Increment !  **Purpose**:  To increase value of a 128-bit signed integer by one !  **Usage**: !   --->    CALL Increment(I128) MODULE PROCEDURE I128_Increment END INTERFACE INTERFACE Decrement !&#94; **Subroutine Interface**: Decrement !  **Purpose**:  To decrease value of a 128-bit signed integer by one !  **Usage**: !   --->    CALL Decrement(I128) MODULE PROCEDURE I128_Decrement END INTERFACE INTERFACE Add !&#94; **Subroutine Interface**: Add !  **Purpose**:  To add a signed integer to a 128-bit signed integer !  **Usage**: !   --->    CALL Add(This, Other) MODULE PROCEDURE I128_Add_I32 MODULE PROCEDURE I128_Add_I64 MODULE PROCEDURE I128_Add_I128 END INTERFACE INTERFACE Subtract !&#94; **Subroutine Interface**: Subtract !  **Purpose**:  To subtract a signed integer from a 128-bit signed integer !  **Usage**: !   --->    CALL Subtract(This, Other) !  ***Important Note***:  For subtraction of signed integers (unlike unsigned one), !   value of This can be less than Other. MODULE PROCEDURE I128_Subtract_I32 MODULE PROCEDURE I128_Subtract_I64 MODULE PROCEDURE I128_Subtract_I128 END INTERFACE INTERFACE Multiply !&#94; **Subroutine Interface**: Multiply !  **Purpose**:  To multiply a 128-bit signed integer by a signed integer !  **Usage**: !   --->    CALL Multiply(This, Other) MODULE PROCEDURE I128_Times_I32 MODULE PROCEDURE I128_Times_I64 MODULE PROCEDURE I128_Times_I128 END INTERFACE INTERFACE Divide !&#94; **Subroutine Interface**: Divide !  **Purpose**:  To divide a 128-bit signed integer by a signed integer !  **Usage**: !   --->    CALL Divide(This, Other) MODULE PROCEDURE I128_Over_I32 MODULE PROCEDURE I128_Over_I64 MODULE PROCEDURE I128_Over_I128 END INTERFACE !----------------------------------------------- !----- \t\t    bitwise operations \t\t   ----- !----------------------------------------------- INTERFACE ShiftLOnce !&#94; **Function Interface**: ShiftLOnce !  **Purpose**:  To perform logical left shift by 1 !  **Usage**: !   --->    OUT = ShiftLOnce(IN) MODULE PROCEDURE I128_ShiftL_Once END INTERFACE INTERFACE ShiftROnce !&#94; **Function Interface**: ShiftROnce !  **Purpose**:  To perform logical right shift by 1 !  **Usage**: !   --->    OUT = ShiftROnce(IN) MODULE PROCEDURE I128_ShiftR_Once END INTERFACE INTERFACE ShiftAOnce !&#94; **Function Interface**: ShiftAOnce !  **Purpose**:  To perform arithmetic right shift by 1 !  **Usage**: !   --->    OUT = ShiftAOnce(IN) MODULE PROCEDURE I128_ShiftA_Once END INTERFACE INTERFACE ShiftL64 !&#94; **Function Interface**: ShiftL64 !  **Purpose**:  To perform logical left shift by 64 !  **Usage**: !   --->    OUT = ShiftL64(IN) MODULE PROCEDURE I128_ShiftL_64 END INTERFACE INTERFACE ShiftR64 !&#94; **Function Interface**: ShiftR64 !  **Purpose**:  To perform logical right shift by 64 !  **Usage**: !   --->    OUT = ShiftR64(IN) MODULE PROCEDURE I128_ShiftR_64 END INTERFACE INTERFACE ShiftA64 !&#94; **Function Interface**: ShiftA64 !  **Purpose**:  To perform arithmetic right shift by 64 !  **Usage**: !   --->    OUT = ShiftA64(IN) MODULE PROCEDURE I128_ShiftA_64 END INTERFACE INTERFACE ShiftL63Down !&#94; **Function Interface**: ShiftL63Down !  **Purpose**:  To perform logical left shift by 63 or less !  **Usage**: !   --->    OUT = ShiftL63Down(IN, 11) MODULE PROCEDURE I128_ShiftL_63Down END INTERFACE INTERFACE ShiftR63Down !&#94; **Function Interface**: ShiftR63Down !  **Purpose**:  To perform logical right shift by 63 or less !  **Usage**: !   --->    OUT = ShiftR63Down(IN, 53) MODULE PROCEDURE I128_ShiftR_63Down END INTERFACE INTERFACE ShiftA63Down !&#94; **Function Interface**: ShiftA63Down !  **Purpose**:  To perform arithmetic right shift by 63 or less !  **Usage**: !   --->    OUT = ShiftA63Down(IN, 53) MODULE PROCEDURE I128_ShiftA_63Down END INTERFACE INTERFACE ShiftL64Up !&#94; **Function Interface**: ShiftL64Up !  **Purpose**:  To perform logical left shift by 64 or more (<= 128) !  **Usage**: !   --->    OUT = ShiftL64Up(IN, 111) MODULE PROCEDURE I128_ShiftL_64Up END INTERFACE INTERFACE ShiftR64Up !&#94; **Function Interface**: ShiftR64Up !  **Purpose**:  To perform logical right shift by 64 or more (<= 128) !  **Usage**: !   --->    OUT = ShiftR64Up(IN, 84) MODULE PROCEDURE I128_ShiftR_64Up END INTERFACE INTERFACE ShiftA64Up !&#94; **Function Interface**: ShiftA64Up !  **Purpose**:  To perform arithmetic right shift by 64 or more (<= 128) !  **Usage**: !   --->    OUT = ShiftA64Up(IN, 84) MODULE PROCEDURE I128_ShiftA_64Up END INTERFACE INTERFACE SHIFTL !&#94; **Function Interface**: SHIFTL !  **Purpose**:  To perform logical left shift with 0 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = SHIFTL(IN, 127) MODULE PROCEDURE I128_ShiftLeft END INTERFACE INTERFACE SHIFTA !&#94; **Function Interface**: SHIFTA !  **Purpose**:  To perform arithmetic right shift with 0 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = SHIFTA(IN, 33) MODULE PROCEDURE I128_ShiftRightArithmetic END INTERFACE INTERFACE SHIFTR !&#94; **Function Interface**: SHIFTR !  **Purpose**:  To perform logical right shift with 0 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = SHIFTR(IN, 33) MODULE PROCEDURE I128_ShiftRightLogical END INTERFACE INTERFACE ISHFT !&#94; **Function Interface**: ISHFT !  **Purpose**:  To perform logical shift with -128 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 !   --->    OUT = ISHFT(IN, -24)   ! a logical right shift by 24 MODULE PROCEDURE I128_ShiftLogical END INTERFACE INTERFACE ISHFTC !&#94; **Function Interface**: ISHFTC !  **Purpose**:  To perform circular shift with -128 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 !   --->    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24 MODULE PROCEDURE I128_Rotate END INTERFACE INTERFACE NOT !&#94; **Function Interface**: NOT !  **Purpose**:  To return the bitwise logical complement of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = NOT(IN) MODULE PROCEDURE I128_Not END INTERFACE INTERFACE IOR !&#94; **Function Interface**: IOR !  **Purpose**:  To perform an inclusive OR on corresponding bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IOR(LHSIN, RHSIN) MODULE PROCEDURE I128_Ior END INTERFACE INTERFACE IEOR !&#94; **Function Interface**: IEOR !  **Purpose**:  To perform an exclusive OR on corresponding bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IEOR(LHSIN, RHSIN) MODULE PROCEDURE I128_Ieor END INTERFACE INTERFACE IAND !&#94; **Function Interface**: IAND !  **Purpose**:  To perform a logical AND on corresponding bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IAND(LHSIN, RHSIN) MODULE PROCEDURE I128_Iand END INTERFACE INTERFACE LEADZ !&#94; **Function Interface**: LEADZ !  **Purpose**:  To count the number of leading zero bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumLZ = LEADZ(INPUT) MODULE PROCEDURE I128_LeadingZeros END INTERFACE INTERFACE TRAILZ !&#94; **Function Interface**: TRAILZ !  **Purpose**:  To count the number of trailing zero bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumTZ = TRAILZ(INPUT) MODULE PROCEDURE I128_TrailingZeros END INTERFACE INTERFACE POPCNT !&#94; **Function Interface**: POPCNT !  **Purpose**:  To count the number of 1 bits in the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumBits = POPCNT(INPUT) MODULE PROCEDURE I128_Count1Bits END INTERFACE INTERFACE POPPAR !&#94; **Function Interface**: POPPAR !  **Purpose**:  To determine the parity of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumPar = POPPAR(INPUT) MODULE PROCEDURE I128_Parity END INTERFACE INTERFACE IBSET !&#94; **Function Interface**: IBSET !  **Purpose**:  To set the bit at the specified position to 1 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBSET(IN, Pos) MODULE PROCEDURE I128_SetBit END INTERFACE INTERFACE IBCLR !&#94; **Function Interface**: IBCLR !  **Purpose**:  To set the bit at the specified position to 0 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBCLR(IN, Pos) MODULE PROCEDURE I128_ClearBit END INTERFACE INTERFACE IBCHNG !&#94; **Function Interface**: IBCHNG !  **Purpose**:  To reverse the bit at the specified position !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBCHNG(IN, Pos) MODULE PROCEDURE I128_FlipBit END INTERFACE INTERFACE BTEST !&#94; **Function Interface**: BTEST !  **Purpose**:  To check whether the bit at the specified position is 0 (False) or 1 (True) !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    Flag = BTEST(IN, Pos) MODULE PROCEDURE I128_TestBit END INTERFACE INTERFACE IBITS !&#94; **Function Interface**: IBITS !  **Purpose**:  To extract a sequence of bits according to the specified input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBITS(IN, Pos, Len) MODULE PROCEDURE I128_ExtractBits END INTERFACE INTERFACE MoveBits !&#94; **Subroutine Interface**: MoveBits !  **Purpose**:  To copy a sequence of bits (a bit field) from one location to another !   (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS') !  **Usage**: !   --->    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos) MODULE PROCEDURE I128_MoveBits END INTERFACE !----------------------------------------------- !----- \t        Inquiry Routine \t       ----- !----------------------------------------------- INTERFACE IsPositive !&#94; **Function Interface**: IsPositive !  **Purpose**:  To check whether the input value is positive or not !  **Usage**: !   --->    Flag = IsPositive(INPUT) !   --->    IF (IsPositive(INPUT)) DoSomeThing MODULE PROCEDURE I128_Is_Positive END INTERFACE INTERFACE IsNegative !&#94; **Function Interface**: IsNegative !  **Purpose**:  To check whether the input value is negative or not !  **Usage**: !   --->    Flag = IsNegative(INPUT) !   --->    IF (IsNegative(INPUT)) DoSomeThing MODULE PROCEDURE I128_Is_Negative END INTERFACE INTERFACE IsZero !&#94; **Function Interface**: IsZero !  **Purpose**:  To check whether the input value is zero or not !  **Usage**: !   --->    Flag = IsZero(INPUT) !   --->    IF (IsZero(INPUT)) DoSomeThing MODULE PROCEDURE I128_Is_Zero END INTERFACE !----------------------------------------------- !----- \t        Auxiliary Routine \t       ----- !----------------------------------------------- INTERFACE BitCastToSigned ! private function interface MODULE PROCEDURE U64_To_I64 END INTERFACE INTERFACE UABS ! private function interface MODULE PROCEDURE I128_UnsignedAbsolute END INTERFACE INTERFACE ABS !&#94; **Function Interface**: ABS !  **Purpose**:  To return the absolute value of the input !  **Usage**: !   --->    OUTPUT = ABS(INPUT) MODULE PROCEDURE I128_Absolute END INTERFACE INTERFACE Display !&#94; **Subroutine Interface**: Display !  **Purpose**:  To write/display the 'SInt128' object to the screen (or the specified unit) !  **Usage**: !   To display (signed) value of I128 as a decimal string to the screen !   --->    CALL Display(I128) !   To display (signed) value of I128 as a decimal string to the output logical unit !   --->    CALL Display(I128, 11) !   To display (signed) value of I128 as a decimal string to the output logical unit !   with input/output status and message !   --->    CALL Display(I128, 11, IOStat, IOMsg) !   To display (signed) values of components of U128 as a decimal string to the screen !   --->    CALL Display(I128, ShowComponent=.TRUE.) !   To display (signed) value of I128 as a decimal string to the screen with a prefix string !   --->    CALL Display(I128, Prefix='Unsigned value of U128') MODULE PROCEDURE I128_Write END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                           ASSIGNMENT ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE I128_From_I32 ( I128 , I32 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 32-bit integer number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( OUT ) :: I128 INTEGER ( KIND = I4B ), INTENT ( IN ) :: I32 !! number treated as signed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I128 % High = SHIFTA ( INT ( I32 , KIND = I8B ), 63 ) I128 % Low = INT ( I32 , KIND = I8B ) RETURN END SUBROUTINE I128_From_I32 !****************************************************************************** SUBROUTINE I128_From_I64 ( I128 , I64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 64-bit integer number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( OUT ) :: I128 INTEGER ( KIND = I8B ), INTENT ( IN ) :: I64 !! number treated as signed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I128 % High = SHIFTA ( I64 , 63 ) I128 % Low = I64 RETURN END SUBROUTINE I128_From_I64 !****************************************************************************** SUBROUTINE I128_To_I32 ( I32 , I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to a signed 32-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( OUT ) :: I32 !! number treated as signed TYPE ( SInt128 ), INTENT ( IN ) :: I128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I32 = INT ( BitCastToSigned ( I128 % Low ), KIND = I4B ) RETURN END SUBROUTINE I128_To_I32 !****************************************************************************** SUBROUTINE I128_To_I64 ( I64 , I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to a signed 64-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( OUT ) :: I64 !! number treated as signed TYPE ( SInt128 ), INTENT ( IN ) :: I128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I64 = BitCastToSigned ( I128 % Low ) RETURN END SUBROUTINE I128_To_I64 !------------------------------------------------------------------------------ ! !                           CONSTRUCTOR ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I32_To_I128 ( I32 ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 32-bit integer number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: I32 !! number treated as signed TYPE ( SInt128 ) :: I128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I128 % High = SHIFTA ( INT ( I32 , KIND = I8B ), 63 ) I128 % Low = INT ( I32 , KIND = I8B ) RETURN END FUNCTION I32_To_I128 !****************************************************************************** FUNCTION I64_To_I128 ( I64 ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 64-bit integer number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: I64 !! number treated as signed TYPE ( SInt128 ) :: I128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I128 % High = SHIFTA ( I64 , 63 ) I128 % Low = I64 RETURN END FUNCTION I64_To_I128 !****************************************************************************** FUNCTION U32_To_I128 ( U32 , Negative ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an unsigned 32-bit integer number to a signed 128-bit integer number ! where the sign flag is used to indicate whether the 128-bit integer value is ! positive or negative IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: U32 !! number treated as unsigned LOGICAL , INTENT ( IN ) :: Negative !&#94; true if the 128-bit integer value is negative ! otherwise, the 128-bit integer value is positive TYPE ( SInt128 ) :: I128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: Mask = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: U32L !** FLOW IF ( Negative ) THEN I128 % High = MaxU64 ! MaxU64 = NOT(0_I8B) U32L = IAND ( INT ( U32 , KIND = I8B ), Mask ) IF ( U32L == 0_I8B ) I128 % High = I128 % High + 1_I8B I128 % Low = NOT ( U32L ) + 1_I8B ELSE I128 % High = 0_I8B I128 % Low = IAND ( INT ( U32 , KIND = I8B ), Mask ) END IF RETURN END FUNCTION U32_To_I128 !****************************************************************************** FUNCTION U64_To_I128 ( U64 , Negative ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an unsigned 64-bit integer number to a signed 128-bit integer number ! where the sign flag is used to indicate whether the 128-bit integer value is ! positive or negative IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: U64 !! number treated as unsigned LOGICAL , INTENT ( IN ) :: Negative !&#94; true if the 128-bit integer value is negative ! otherwise, the 128-bit integer value is positive TYPE ( SInt128 ) :: I128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Negative ) THEN I128 % High = MaxU64 ! MaxU64 = NOT(0_I8B) IF ( U64 == 0_I8B ) I128 % High = I128 % High + 1_I8B I128 % Low = NOT ( U64 ) + 1_I8B ELSE I128 % High = 0_I8B I128 % Low = U64 END IF RETURN END FUNCTION U64_To_I128 !****************************************************************************** FUNCTION R32_To_I128 ( R32 ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit floating point number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: R32 TYPE ( SInt128 ) :: I128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '000000FF' , KIND = I4B ) ! 255 INTEGER ( KIND = I4B ), PARAMETER :: C1 = SHIFTL ( 1 , 23 ) ! 2**23 INTEGER ( KIND = I4B ), PARAMETER :: C2 = C1 - 1 ! 2**23 - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I4B ) :: IBits REAL ( KIND = SP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! rounding behavior is towards zero. ! undefined behavior if R32 is NaN or cannot fit into I128. IF (. NOT . IEEE_IS_FINITE ( R32 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R32_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R32 is NOT finite.' ) I128 = MaxI128 RETURN ELSEIF ( R32 < - 2.0_SP ** 127 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R32_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R32 < I128Min.' ) I128 = MinI128 RETURN ELSEIF ( R32 >= 2.0_SP ** 127 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R32_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R32 > I128Max.' ) I128 = MaxI128 RETURN END IF ! get absolute value and transfer bits from real to integer RBits = ABS ( R32 ) ! determine exponent bits Exp = IAND ( SHIFTR ( IBits , 23 ), Mask ) - 150 ! 150 = 127 + 23 ! determine significand bits IBits = IOR ( IAND ( IBits , C2 ), C1 ) ! convert to SInt128 ! I128 = IBits ! add exponent bits ! I128 = ISHFT(I128, Exp) IF ( Exp < 0 ) THEN Exp = - Exp IF ( Exp >= 64 ) THEN I128 = SInt128 ( 0_I8B , 0_I8B ) ELSE I128 = SInt128 ( 0_I8B , SHIFTR ( INT ( IBits , KIND = I8B ), Exp )) END IF ELSE IF ( Exp >= 128 ) THEN I128 = SInt128 ( 0_I8B , 0_I8B ) ELSEIF ( Exp >= 64 ) THEN I128 = SInt128 ( SHIFTL ( INT ( IBits , KIND = I8B ), Exp - 64 ), 0_I8B ) ELSE I128 = SInt128 ( SHIFTR ( INT ( IBits , KIND = I8B ), 64 - Exp ), SHIFTL ( INT ( IBits , KIND = I8B ), Exp )) END IF END IF ! add sign bit IF ( R32 < 0.0_SP ) THEN !  I128 = -I128 I128 % High = NOT ( I128 % High ) IF ( I128 % Low == 0_I8B ) I128 % High = I128 % High + 1_I8B I128 % Low = NOT ( I128 % Low ) + 1_I8B END IF RETURN END FUNCTION R32_To_I128 !****************************************************************************** FUNCTION R64_To_I128 ( R64 ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit floating point number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: R64 TYPE ( SInt128 ) :: I128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: Mask = INT ( Z '00000000000007FF' , KIND = I8B ) ! 2047 INTEGER ( KIND = I8B ), PARAMETER :: C1 = SHIFTL ( 1_I8B , 52 ) ! 2**52 INTEGER ( KIND = I8B ), PARAMETER :: C2 = C1 - 1_I8B ! 2**52 - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I8B ) :: IBits REAL ( KIND = DP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! rounding behavior is towards zero. ! undefined behavior if R64 is NaN or cannot fit into I128. IF (. NOT . IEEE_IS_FINITE ( R64 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R64_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R64 is NOT finite.' ) I128 = MaxI128 RETURN ELSEIF ( R64 < - 2.0_DP ** 127 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R64_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R64 < I128Min.' ) I128 = MinI128 RETURN ELSEIF ( R64 >= 2.0_DP ** 127 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R64_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R64 > I128Max.' ) I128 = MaxI128 RETURN END IF ! get absolute value and transfer bits from real to integer RBits = ABS ( R64 ) ! determine exponent bits Exp = INT ( IAND ( SHIFTR ( IBits , 52 ), Mask ), KIND = I4B ) - 1075 ! 1075 = 1023 + 52 ! determine significand bits IBits = IOR ( IAND ( IBits , C2 ), C1 ) ! convert to SInt128 ! I128 = SInt128(0_I8B, IBits) ! add exponent bits ! I128 = ISHFT(I128, Exp) IF ( Exp < 0 ) THEN Exp = - Exp IF ( Exp >= 64 ) THEN I128 = SInt128 ( 0_I8B , 0_I8B ) ELSE I128 = SInt128 ( 0_I8B , SHIFTR ( IBits , Exp )) END IF ELSE IF ( Exp >= 128 ) THEN I128 = SInt128 ( 0_I8B , 0_I8B ) ELSEIF ( Exp >= 64 ) THEN I128 = SInt128 ( SHIFTL ( IBits , Exp - 64 ), 0_I8B ) ELSE I128 = SInt128 ( SHIFTR ( IBits , 64 - Exp ), SHIFTL ( IBits , Exp )) END IF END IF ! add sign bit IF ( R64 < 0.0_DP ) THEN !  I128 = -I128 I128 % High = NOT ( I128 % High ) IF ( I128 % Low == 0_I8B ) I128 % High = I128 % High + 1_I8B I128 % Low = NOT ( I128 % Low ) + 1_I8B END IF RETURN END FUNCTION R64_To_I128 !****************************************************************************** FUNCTION R128_To_I128 ( R128 ) RESULT ( I128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 128-bit floating point number to a signed 128-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: R128 TYPE ( SInt128 ) :: I128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '00007FFF' , KIND = I4B ) ! 32767 INTEGER ( KIND = I8B ), PARAMETER :: C1 ( 2 ) = [ 0_I8B , 281474976710656_I8B ] ! 2**112 = SHIFTL(1, 112) INTEGER ( KIND = I8B ), PARAMETER :: C2 ( 2 ) = [ - 1_I8B , 281474976710655_I8B ] ! 2**112 - 1 = SHIFTL(1, 112) - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I8B ) :: ExpL INTEGER ( KIND = I8B ) :: IBits ( 2 ) REAL ( KIND = QP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! rounding behavior is towards zero. ! undefined behavior if R128 is NaN or cannot fit into I128. IF (. NOT . IEEE_IS_FINITE ( R128 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R128_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R128 is NOT finite.' ) RETURN ELSEIF ( R128 < - 2.0_QP ** 127 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R128_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R128 < I128Min.' ) RETURN ELSEIF ( R128 >= 2.0_QP ** 127 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R128_To_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R128 > I128Max.' ) RETURN END IF ! get absolute value and transfer bits from real to integer RBits = ABS ( R128 ) ! determine exponent bits ExpL = SHIFTR ( IBits ( 2 ), 48 ) ! 48 = 112-64 Exp = IAND ( INT ( ExpL , KIND = I4B ), Mask ) - 16495 ! 16495 = 16383 + 112 ! determine significand bits and convert to SInt128 I128 % Low = IOR ( IAND ( IBits ( 1 ), C2 ( 1 )), C1 ( 1 )) I128 % High = IOR ( IAND ( IBits ( 2 ), C2 ( 2 )), C1 ( 2 )) ! add exponent bits ! I128 = ISHFT(I128, Exp) IF ( Exp < 0 ) THEN I128 = SHIFTR ( I128 , - Exp ) ELSE I128 = SHIFTL ( I128 , Exp ) END IF ! add sign bit IF ( R128 < 0.0_QP ) THEN !  I128 = -I128 I128 % High = NOT ( I128 % High ) IF ( I128 % Low == 0_I8B ) I128 % High = I128 % High + 1_I8B I128 % Low = NOT ( I128 % Low ) + 1_I8B END IF RETURN END FUNCTION R128_To_I128 !****************************************************************************** FUNCTION DecString_To_I128 ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a signed 128-bit integer value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid TYPE ( SInt128 ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I4B ), PARAMETER :: A9 = IACHAR ( '9' ) INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI32 = 10 INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI64 = 19 INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI128 = 39 TYPE ( SInt128 ), PARAMETER :: I128Base = TenI128 CHARACTER ( LEN =* ), PARAMETER :: MaxStr = '170141183460469231731687303715884105727' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen , DigitLen INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart , IndxP7 CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: NegSign LOGICAL :: Overflow CHARACTER ( LEN = :), ALLOCATABLE , TARGET :: CurStr LOGICAL :: ErrorFlag ! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE :: ErrorMsg ! message if input is not invalid INTEGER ( KIND = I4B ) :: I32Val INTEGER ( KIND = I8B ) :: I64Val CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI128 RETURN END IF END IF ! check for sign NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI128 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI128 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute the length of digits DigitLen = StrLen - Indx + 1 ! return quickly if possible IF ( DigitLen < MaxDigitI32 ) THEN I32Val = I32_FromChar ( cStr ( Indx : StrLen ), ErrorFlag , ErrorMsg ) IF ( ErrorFlag ) THEN Number = MinI128 ELSE IF ( NegSign ) THEN Number = - I32Val ELSE Number = I32Val END IF END IF IF ( PRESENT ( ErrMsg )) ErrMsg = ErrorMsg IF ( PRESENT ( ErrFlag )) ErrFlag = ErrorFlag RETURN ELSEIF ( DigitLen < MaxDigitI64 ) THEN I64Val = I64_FromChar ( cStr ( Indx : StrLen ), ErrorFlag , ErrorMsg ) IF ( ErrorFlag ) THEN Number = MinI128 ELSE IF ( NegSign ) THEN Number = - I64Val ELSE Number = I64Val END IF END IF IF ( PRESENT ( ErrMsg )) ErrMsg = ErrorMsg IF ( PRESENT ( ErrFlag )) ErrFlag = ErrorFlag RETURN END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx IndxP7 = Indx + 7 DO WHILE ( IndxP7 <= StrLen ) wStr = cStr ( Indx : IndxP7 ) IF ( Is8Digits ( WVal )) THEN ! process 8 digits at once ! Number = Number*100000000 + Parse8Digits(wVal) CALL Multiply ( Number , 100000000 ) CALL Add ( Number , Parse8Digits ( wVal )) ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI128 RETURN END IF Indx = Indx + 8 IndxP7 = Indx + 7 END DO IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid ! Number = Number*10 + (IACHAR(CurChr)-A0) CALL Multiply ( Number , 10 ) CALL Add ( Number , ( IACHAR ( CurChr ) - A0 )) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI128 RETURN END IF END DO END IF NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI128 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI128 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI128 ) THEN ! value might be in the applicable range IF ( IsNegative ( Number )) THEN ! overflow likely occurs Overflow = TrueVal IF (( NegSign ). AND .( Number == MinI128 )) THEN ! actually not overflow CurStr = '-' // cStr ( IStart : StrLen ) IF ( ToDecString ( MinI128 ) == CurStr ) THEN Overflow = FalseVal NegSign = FalseVal END IF END IF ELSE ! positive value so check overflow CurStr = cStr ( IStart : StrLen ) Overflow = FalseVal DO Indx = 1 , MaxDigitI128 CurChr => CurStr ( Indx : Indx ) IF ( IACHAR ( CurChr ) < IACHAR ( MaxStr ( Indx : Indx ))) THEN EXIT ELSEIF ( IACHAR ( CurChr ) > IACHAR ( MaxStr ( Indx : Indx ))) THEN Overflow = TrueVal EXIT END IF END DO END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( NegSign ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI128 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI128 END IF ELSE IF ( NegSign ) Number = - Number END IF RETURN CONTAINS FUNCTION Parse8Digits ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse8Digits !** PURPOSE OF THIS SUBROUTINE: ! To parse eight digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: K1 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K2 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K3 = INT ( Z '0000FFFF0000FFFF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M1 = 2561_I8B INTEGER ( KIND = I8B ), PARAMETER :: M2 = 6553601_I8B INTEGER ( KIND = I8B ), PARAMETER :: M3 = 42949672960001_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = SHIFTR ( IAND ( SHIFTR ( IAND ( SHIFTR ( IAND ( InVal , K1 ) * M1 , 8 ), K2 ) * M2 , 16 ), K3 ) * M3 , 32 ) RETURN END FUNCTION Parse8Digits !****************************************************************************** FUNCTION Is8Digits ( InVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is8Digits !** PURPOSE OF THIS SUBROUTINE: ! To check whether we can process eight digits immediately IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: C1 = INT ( Z 'F0F0F0F0F0F0F0F0' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C2 = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C3 = INT ( Z '0606060606060606' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IOR ( IAND ( InVal , C1 ), SHIFTR ( IAND (( InVal + C3 ), C1 ), 4 )) == C2 RETURN END FUNCTION Is8Digits !****************************************************************************** END FUNCTION DecString_To_I128 !------------------------------------------------------------------------------ ! !                           CONVERSION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION U32_From_I128 ( I128 ) RESULT ( U32 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to an unsigned 32-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I4B ) :: U32 !! number treated as unsigned !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U32 = INT ( I128 % Low , KIND = I4B ) RETURN END FUNCTION U32_From_I128 !****************************************************************************** FUNCTION U64_From_I128 ( I128 ) RESULT ( U64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to an unsigned 64-bit integer number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I8B ) :: U64 !! number treated as unsigned !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U64 = I128 % Low RETURN END FUNCTION U64_From_I128 !****************************************************************************** FUNCTION R32_From_I128 ( I128 ) RESULT ( R32 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to a 32-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 REAL ( KIND = SP ) :: R32 !** SUBROUTINE PARAMETER DECLARATIONS: REAL ( KIND = SP ), PARAMETER :: TwoPow64 = 2.0_SP ** 64 INTEGER ( KIND = I4B ), PARAMETER :: TwoPow23 = SHIFTL ( 1 , 23 ) INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '000000FF' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: Negative INTEGER ( KIND = I8B ) :: High INTEGER ( KIND = I8B ) :: Low INTEGER ( KIND = I4B ) :: S , Exp INTEGER ( KIND = I4B ) :: IBits REAL ( KIND = SP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! get sign flag and absolute values of components Negative = ( I128 % High < 0_I8B ) IF ( Negative ) THEN High = NOT ( I128 % High ) IF ( I128 % Low == 0_I8B ) High = High + 1_I8B Low = NOT ( I128 % Low ) + 1_I8B ELSE High = I128 % High Low = I128 % Low END IF IF ( High == 0_I8B ) THEN R32 = U64_To_R32 ( Low ) IF ( IsNegative ( I128 )) R32 = - R32 RETURN END IF S = LEADZ ( High ) ! Mask out the 24 MSBits ! Also, the leading bit is implicit so cancel it out to get the significand IF ( S <= 40 ) THEN IBits = IEOR ( INT ( SHIFTR ( High , 40 - S ), KIND = I4B ), TwoPow23 ) ELSE ! S-40 == additional bits we need IBits = IEOR ( INT ( IOR ( SHIFTL ( High , S - 40 ), SHIFTR ( Low , 104 - S )), KIND = I4B ), TwoPow23 ) END IF ! get the binary exponent Exp = IAND ( 254 - S , Mask ) ! 254 = 64 + 64 + 127 - 1 ! Add the exponent IBits = IOR ( IBits , SHIFTL ( Exp , 23 )) ! transfer output (RBits mapped to IBits using equivalence) R32 = RBits ! check and add sign if needed IF ( Negative ) R32 = - R32 RETURN CONTAINS FUNCTION U64_To_R32 ( LongVal ) RESULT ( SingleVal ) !DIR$ ATTRIBUTES FORCEINLINE :: U64_To_R32 !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned 64-bit integer number to a 32-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LongVal ! integer number treated as unsigned one REAL ( KIND = SP ) :: SingleVal ! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LongVal >= 0_I8B ) THEN SingleVal = REAL ( LongVal , KIND = SP ) ELSE SingleVal = TwoPow64 + REAL ( LongVal , KIND = SP ) END IF RETURN END FUNCTION U64_To_R32 !****************************************************************************** END FUNCTION R32_From_I128 !****************************************************************************** FUNCTION R64_From_I128 ( I128 ) RESULT ( R64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to a 64-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 REAL ( KIND = DP ) :: R64 !** SUBROUTINE PARAMETER DECLARATIONS: REAL ( KIND = DP ), PARAMETER :: TwoPow64 = 2.0_DP ** 64 INTEGER ( KIND = I8B ), PARAMETER :: TwoPow52 = SHIFTL ( 1_I8B , 52 ) INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '000007FF' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: Negative INTEGER ( KIND = I8B ) :: High INTEGER ( KIND = I8B ) :: Low INTEGER ( KIND = I4B ) :: S INTEGER ( KIND = I8B ) :: IBits , Exp REAL ( KIND = DP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! get sign flag and absolute values of components Negative = ( I128 % High < 0_I8B ) IF ( Negative ) THEN High = NOT ( I128 % High ) IF ( I128 % Low == 0_I8B ) High = High + 1_I8B Low = NOT ( I128 % Low ) + 1_I8B ELSE High = I128 % High Low = I128 % Low END IF IF ( High == 0_I8B ) THEN R64 = U64_To_R64 ( Low ) IF ( Negative ) R64 = - R64 RETURN END IF S = LEADZ ( High ) ! Mask out the 53 MSBits ! Also, the leading bit is implicit so cancel it out to get the significand IF ( S <= 11 ) THEN IBits = IEOR ( SHIFTR ( High , 11 - S ), TwoPow52 ) ELSE ! S-11 == additional bits we need IBits = IEOR ( IOR ( SHIFTL ( High , S - 11 ), SHIFTR ( Low , 75 - S )), TwoPow52 ) END IF ! get the binary exponent Exp = INT ( IAND ( 1150 - S , Mask ), KIND = I8B ) ! 1150 = 64 + 64 + 1023 - 1 ! Add the exponent IBits = IOR ( IBits , SHIFTL ( Exp , 52 )) ! transfer output (RBits mapped to IBits using equivalence) R64 = RBits ! check and add sign if needed IF ( Negative ) R64 = - R64 RETURN CONTAINS FUNCTION U64_To_R64 ( LongVal ) RESULT ( DoubleVal ) !DIR$ ATTRIBUTES FORCEINLINE :: U64_To_R64 !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned 64-bit integer number to a 64-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LongVal ! integer number treated as unsigned one REAL ( KIND = DP ) :: DoubleVal ! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LongVal >= 0_I8B ) THEN DoubleVal = REAL ( LongVal , KIND = DP ) ELSE DoubleVal = TwoPow64 + REAL ( LongVal , KIND = DP ) END IF RETURN END FUNCTION U64_To_R64 !****************************************************************************** END FUNCTION R64_From_I128 !****************************************************************************** FUNCTION R128_From_I128 ( I128 ) RESULT ( R128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to a 128-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 REAL ( KIND = QP ) :: R128 !** SUBROUTINE PARAMETER DECLARATIONS: REAL ( KIND = QP ), PARAMETER :: TwoPow64 = 2.0_QP ** 64 INTEGER ( KIND = I8B ), PARAMETER :: TwoPow112 ( 2 ) = [ 0_I8B , 281474976710656_I8B ] ! SHIFTL(1, 112) INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '00007FFF' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: Negative INTEGER ( KIND = I8B ) :: High INTEGER ( KIND = I8B ) :: Low INTEGER ( KIND = I4B ) :: S , Shift INTEGER ( KIND = I8B ) :: Exp INTEGER ( KIND = I8B ) :: IBits ( 2 ) REAL ( KIND = QP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! get sign flag and absolute values of components Negative = ( I128 % High < 0_I8B ) IF ( Negative ) THEN High = NOT ( I128 % High ) IF ( I128 % Low == 0_I8B ) High = High + 1_I8B Low = NOT ( I128 % Low ) + 1_I8B ELSE High = I128 % High Low = I128 % Low END IF IF ( High == 0_I8B ) THEN R128 = U64_To_R128 ( Low ) IF ( Negative ) R128 = - R128 RETURN END IF S = LEADZ ( High ) IF ( S >= 15 ) THEN R128 = U64_To_R128 ( Low ) + REAL ( High , KIND = QP ) * TwoPow64 IF ( Negative ) R128 = - R128 RETURN END IF ! Mask out the 113 MSBits Shift = 15 - S IBits ( 2 ) = SHIFTR ( High , Shift ) IBits ( 1 ) = IOR ( SHIFTR ( Low , Shift ), SHIFTL ( High , 64 - Shift )) ! get the binary exponent Exp = INT ( IAND ( 16510 - S , Mask ), KIND = I8B ) ! 16510 = 64 + 64 + 16383 - 1 ! The leading bit is implicit, cancel it out to get the significand ! and also add the exponent IBits ( 1 ) = IEOR ( IOR ( SHIFTR ( Low , Shift ), SHIFTL ( High , 64 - Shift )), TwoPow112 ( 1 )) IBits ( 2 ) = IOR ( IEOR ( SHIFTR ( High , Shift ), TwoPow112 ( 2 )), SHIFTL ( Exp , 48 )) ! 48 = 112 - 64 ! transfer output (RBits mapped to IBits using equivalence) ! For big-endian machine, this one is likely wrong so we must ! swap IBits(1) and IBits(2) before the assignment. !   Tmp = IBits(1); IBits(1) = IBits(2); IBits(2) = Tmp R128 = RBits ! check and add sign if needed IF ( Negative ) R128 = - R128 RETURN CONTAINS FUNCTION U64_To_R128 ( LongVal ) RESULT ( QuadVal ) !DIR$ ATTRIBUTES FORCEINLINE :: U64_To_R128 !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned 64-bit integer number to a 128-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LongVal ! integer number treated as unsigned one REAL ( KIND = QP ) :: QuadVal ! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LongVal >= 0_I8B ) THEN QuadVal = REAL ( LongVal , KIND = QP ) ELSE QuadVal = TwoPow64 + REAL ( LongVal , KIND = QP ) END IF RETURN END FUNCTION U64_To_R128 !****************************************************************************** END FUNCTION R128_From_I128 !****************************************************************************** FUNCTION U128_From_I128 ( I128 ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer to an unsigned 128-bit integer IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( UInt128 ) :: U128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128 = UInt128 ( I128 % High , I128 % Low ) RETURN END FUNCTION U128_From_I128 !****************************************************************************** FUNCTION DecString_From_I128 ( I128 ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 128-bit integer number to a decimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 CHARACTER ( LEN = :), ALLOCATABLE :: Str !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN = 1 ), PARAMETER :: NumStr ( 0 : 9 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: BufLen , Top , I , J CHARACTER ( LEN = 41 ) :: Buffer TYPE ( SInt128 ) :: Copy INTEGER ( KIND = I8B ) :: Tmp INTEGER ( KIND = I8B ) :: Indx LOGICAL :: Negative !** FLOW IF ( I128 == ZeroI128 ) THEN Str = '0' RETURN END IF BufLen = 41 FORALL ( I = 1 : BufLen ) Buffer ( I : I ) = '0' Top = BufLen Negative = IsNegative ( I128 ) IF ( Negative ) THEN IF ( I128 == MinI128 ) THEN Str = '-170141183460469231731687303715884105728' RETURN ELSE Copy = - I128 END IF ELSE Copy = I128 END IF DO J = Top Tmp = ToStringDivide ( Copy ) DO WHILE ( Tmp > 0_I8B ) Indx = MOD ( Tmp , 10_I8B ) Buffer ( Top : Top ) = NumStr ( Indx ) Top = Top - 1 Tmp = Tmp / 10_I8B END DO IF (( Copy % High == 0 ). AND .( Copy % Low == 0 )) THEN EXIT ELSE Top = J - 13 END IF END DO IF ( Negative ) THEN Buffer ( Top : Top ) = '-' Str = Buffer ( Top : BufLen ) ELSE Str = Buffer ( Top + 1 : BufLen ) END IF RETURN CONTAINS FUNCTION ToStringDivide ( I128 ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To divide the number by 10**13 and return the remainder IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: I128 INTEGER ( KIND = I8B ) :: Remainder !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Pow2 = SHIFTL ( 1 , 13 ) INTEGER ( KIND = I4B ), PARAMETER :: Pow5 = 1220703125 INTEGER ( KIND = I8B ), PARAMETER :: Pow10 = INT ( Pow2 , KIND = I8B ) * INT ( Pow5 , KIND = I8B ) LOGICAL , PARAMETER :: Positive = FalseVal LOGICAL , PARAMETER :: AsUnsigned = TrueVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Rem , Quot , Numer , Pow10_128 INTEGER ( KIND = I8B ) :: Q , R , Mod2 !** FLOW Q = I128 % High / Pow5 R = I128 % High - Q * Pow5 I128 % High = SHIFTR ( Q , 13 ) Numer % High = R Numer % Low = I128 % Low Mod2 = IAND ( I128 % Low , Pow2 - 1_I8B ) CALL DivMod ( Numer , SInt128 ( Pow5 ), Quot , Rem ) I128 % Low = IOR ( SHIFTL ( Q , 51 ), SHIFTR ( Quot % Low , 13 )) ! Applies the Chinese Rem Theorem. ! -67*5&#94;13 + 9983778*2&#94;13 = 1 Pow10_128 = SInt128 ( 0_I8B , Pow10 ) Rem = SMOD (( Rem - SMOD ( Pow5 * ( Mod2 - Rem ), Pow10_128 ) * 67 ), Pow10_128 ) IF ( Rem % High < 0_I8B ) Rem = Rem + Pow10 Remainder = Rem % Low RETURN END FUNCTION ToStringDivide !************************************************************************** FUNCTION SMOD ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division of two UInt128 objects (Dividend / Divisor) ! and return the remainder ! note: although the input and output objects are of UInt128 type, !       they are all treated as if they are signed 128-bit integers IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Quotient !** FLOW CALL DivMod ( Dividend , Divisor , Quotient , Remainder ) RETURN END FUNCTION SMOD !************************************************************************** END FUNCTION DecString_From_I128 !****************************************************************************** FUNCTION HexString_From_I128 ( I128 ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a signed 128-bit integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 CHARACTER ( LEN = :), ALLOCATABLE :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: U128 !** FLOW IF ( I128 == MinI128 ) THEN Str = '-80000000000000000000000000000000' ELSEIF ( IsNegative ( I128 )) THEN U128 = ToU128 ( - I128 ) Str = '-' // ToHexString ( U128 ) ELSE U128 = ToU128 ( I128 ) Str = ToHexString ( U128 ) END IF RETURN END FUNCTION HexString_From_I128 !------------------------------------------------------------------------------ ! !                           COMPARISION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I128_Equal ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether two SInt128 objects are equal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( LHS % High == RHS % High ). AND .( LHS % Low == RHS % Low ) RETURN END FUNCTION I128_Equal !****************************************************************************** FUNCTION I128_NotEqual ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether two SInt128 objects are NOT equal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( LHS % High /= RHS % High ). OR .( LHS % Low /= RHS % Low ) RETURN END FUNCTION I128_NotEqual !****************************************************************************** FUNCTION I128_LessThan ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS SInt128 object is less than the RHS SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) < IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( LHS % High < RHS % High ) END IF RETURN END FUNCTION I128_LessThan !****************************************************************************** FUNCTION I128_LessEqual ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS SInt128 object is less than or equal to the RHS SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) <= IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( LHS % High <= RHS % High ) END IF RETURN END FUNCTION I128_LessEqual !****************************************************************************** FUNCTION I128_GreaterThan ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS SInt128 object is greater than the RHS SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) > IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( LHS % High > RHS % High ) END IF RETURN END FUNCTION I128_GreaterThan !****************************************************************************** FUNCTION I128_GreaterEqual ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS SInt128 object is greater than or equal to the RHS SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) >= IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( LHS % High >= RHS % High ) END IF RETURN END FUNCTION I128_GreaterEqual !****************************************************************************** FUNCTION I128_Compare ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS objects. !   -> return -1 if LHS < RHS !   -> return  0 if LHS == RHS !   -> return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LHS TYPE ( SInt128 ), INTENT ( IN ) :: RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: ULHS , URHS !** FLOW IF ( LHS % High < RHS % High ) THEN Flag = - 1 ELSEIF ( LHS % High > RHS % High ) THEN Flag = + 1 ELSE ULHS = IEOR ( LHS % Low , MinI64 ) URHS = IEOR ( RHS % Low , MinI64 ) IF ( ULHS < URHS ) THEN Flag = - 1 ELSEIF ( ULHS > URHS ) THEN Flag = + 1 ELSE Flag = 0 END IF END IF RETURN END FUNCTION I128_Compare !------------------------------------------------------------------------------ ! !                           BITWISE ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I128_SHIFTL_Once ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IOR ( SHIFTL ( InVal % High , 1 ), SHIFTR ( InVal % Low , 63 )) OutVal % Low = SHIFTL ( InVal % Low , 1 ) RETURN END FUNCTION I128_SHIFTL_Once !****************************************************************************** FUNCTION I128_SHIFTR_Once ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTR ( InVal % High , 1 ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , 1 ), SHIFTL ( SHIFTL ( InVal % High , 1 ), 62 )) RETURN END FUNCTION I128_SHIFTR_Once !****************************************************************************** FUNCTION I128_SHIFTA_Once ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform arithmetic right shift by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTA ( InVal % High , 1 ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , 1 ), SHIFTL ( SHIFTL ( InVal % High , 1 ), 62 )) RETURN END FUNCTION I128_SHIFTA_Once !****************************************************************************** FUNCTION I128_SHIFTL_64 ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 64 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = InVal % Low OutVal % Low = 0_I8B RETURN END FUNCTION I128_SHIFTL_64 !****************************************************************************** FUNCTION I128_SHIFTR_64 ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 64 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = 0_I8B OutVal % Low = InVal % High RETURN END FUNCTION I128_SHIFTR_64 !****************************************************************************** FUNCTION I128_SHIFTA_64 ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform arithmetic right shift by 64 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTA ( InVal % High , 63 ) OutVal % Low = InVal % High RETURN END FUNCTION I128_SHIFTA_64 !****************************************************************************** FUNCTION I128_SHIFTL_63Down ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 63 or less IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IOR ( SHIFTL ( InVal % High , ShiftPos ), SHIFTR ( InVal % Low , 64 - ShiftPos )) OutVal % Low = SHIFTL ( InVal % Low , ShiftPos ) RETURN END FUNCTION I128_SHIFTL_63Down !****************************************************************************** FUNCTION I128_SHIFTR_63Down ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 63 or less IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTR ( InVal % High , ShiftPos ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , ShiftPos ), & SHIFTL ( SHIFTL ( InVal % High , 1 ), 63 - ShiftPos )) RETURN END FUNCTION I128_SHIFTR_63Down !****************************************************************************** FUNCTION I128_SHIFTA_63Down ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform arithmetic right shift by 63 or less IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTA ( InVal % High , ShiftPos ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , ShiftPos ), & SHIFTL ( SHIFTL ( InVal % High , 1 ), 63 - ShiftPos )) RETURN END FUNCTION I128_SHIFTA_63Down !****************************************************************************** FUNCTION I128_SHIFTL_64Up ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 64 or more IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTL ( InVal % Low , ShiftPos - 64 ) OutVal % Low = 0_I8B RETURN END FUNCTION I128_SHIFTL_64Up !****************************************************************************** FUNCTION I128_SHIFTR_64Up ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 64 or more IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = 0_I8B OutVal % Low = SHIFTR ( InVal % High , ShiftPos - 64 ) RETURN END FUNCTION I128_SHIFTR_64Up !****************************************************************************** FUNCTION I128_SHIFTA_64Up ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform arithmetic right shift by 64 or more IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTA ( InVal % High , 63 ) OutVal % Low = SHIFTA ( InVal % High , ShiftPos - 64 ) RETURN END FUNCTION I128_SHIFTA_64Up !****************************************************************************** FUNCTION I128_ShiftLogical ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical (left or rigth) shift of the SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! -128 <= ShiftPos <= 128; !! -> positive, the shift is to the left; !! -> negative, the shift is to the right TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN OutVal = SHIFTR ( InVal , - ShiftPos ) ELSE OutVal = SHIFTL ( InVal , ShiftPos ) END IF RETURN END FUNCTION I128_ShiftLogical !****************************************************************************** FUNCTION I128_ShiftLeft ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical/arithmetic left shift of the SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! must be nonnegative and <= 128 TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ShiftLeft' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'ShiftPos must be nonnegative number' ); ELSEIF ( ShiftPos == 0 ) THEN OutVal = InVal ELSEIF ( ShiftPos >= 128 ) THEN OutVal = ZeroI128 ELSEIF ( ShiftPos >= 64 ) THEN OutVal % High = SHIFTL ( InVal % Low , ShiftPos - 64 ) OutVal % Low = 0_I8B ELSE OutVal % High = IOR ( SHIFTL ( InVal % High , ShiftPos ), SHIFTR ( InVal % Low , 64 - ShiftPos )) OutVal % Low = SHIFTL ( InVal % Low , ShiftPos ) END IF RETURN END FUNCTION I128_ShiftLeft !****************************************************************************** FUNCTION I128_ShiftRightArithmetic ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform arithmetic right shift of the SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! must be nonnegative and <= 128 TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ShiftRightArithmetic' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'ShiftPos must be nonnegative number' ) ELSEIF ( ShiftPos == 0 ) THEN OutVal = InVal ELSEIF ( ShiftPos >= 128 ) THEN IF ( IsNegative ( InVal )) THEN OutVal = - 1 ELSE OutVal = ZeroI128 END IF ELSEIF ( ShiftPos >= 64 ) THEN OutVal % High = SHIFTA ( InVal % High , 63 ) OutVal % Low = SHIFTA ( InVal % High , ShiftPos - 64 ) ELSE OutVal % High = SHIFTA ( InVal % High , ShiftPos ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , ShiftPos ), & SHIFTL ( SHIFTL ( InVal % High , 1 ), 63 - ShiftPos )) END IF RETURN END FUNCTION I128_ShiftRightArithmetic !****************************************************************************** FUNCTION I128_ShiftRightLogical ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift of the SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! must be nonnegative and <= 128 TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ShiftRightLogical' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'ShiftPos must be nonnegative number' ) ELSEIF ( ShiftPos == 0 ) THEN OutVal = InVal ELSEIF ( ShiftPos >= 128 ) THEN OutVal = ZeroI128 ELSEIF ( ShiftPos >= 64 ) THEN OutVal % High = 0_I8B OutVal % Low = SHIFTR ( InVal % High , ShiftPos - 64 ) ELSE OutVal % High = SHIFTR ( InVal % High , ShiftPos ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , ShiftPos ), & SHIFTL ( SHIFTL ( InVal % High , 1 ), 63 - ShiftPos )) END IF RETURN END FUNCTION I128_ShiftRightLogical !****************************************************************************** FUNCTION I128_Rotate ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform a circular shift of the rightmost bits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! -128 <= ShiftPos <= 128; !! -> positive, the shift is to the left; !! -> negative, the shift is to the right TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LeftShift !** FLOW IF ( ShiftPos == 0 ) THEN OutVal = InVal RETURN ELSEIF ( ABS ( ShiftPos ) == 128 ) THEN OutVal = ZeroI128 RETURN ELSEIF ( ABS ( ShiftPos ) > 128 ) THEN LeftShift = MOD ( ShiftPos , 128 ) ELSE LeftShift = ShiftPos END IF IF ( LeftShift < 0 ) LeftShift = 128 + LeftShift OutVal = IOR ( SHIFTL ( InVal , LeftShift ), SHIFTR ( InVal , 128 - LeftShift )) RETURN END FUNCTION I128_Rotate !****************************************************************************** FUNCTION I128_Not ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To return the bitwise logical complement of the SInt128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = NOT ( InVal % High ) OutVal % Low = NOT ( InVal % Low ) RETURN END FUNCTION I128_Not !****************************************************************************** FUNCTION I128_Ior ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform an inclusive OR on corresponding bits of the SInt128 objects IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IOR ( LhsVal % High , RhsVal % High ) OutVal % Low = IOR ( LhsVal % Low , RhsVal % Low ) RETURN END FUNCTION I128_Ior !****************************************************************************** FUNCTION I128_Iand ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform a logical AND on corresponding bits of the SInt128 objects IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IAND ( LhsVal % High , RhsVal % High ) OutVal % Low = IAND ( LhsVal % Low , RhsVal % Low ) RETURN END FUNCTION I128_Iand !****************************************************************************** FUNCTION I128_Ieor ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform an exclusive OR on corresponding bits of the SInt128 objects IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IEOR ( LhsVal % High , RhsVal % High ) OutVal % Low = IEOR ( LhsVal % Low , RhsVal % Low ) RETURN END FUNCTION I128_Ieor !****************************************************************************** FUNCTION I128_LeadingZeros ( I128 ) RESULT ( NumLZ ) !** PURPOSE OF THIS SUBROUTINE: !! To count the number of leading zero bits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I4B ) :: NumLZ !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( I128 % High == 0_I8B ) THEN NumLZ = LEADZ ( I128 % Low ) + 64 ELSE NumLZ = LEADZ ( I128 % High ) END IF RETURN END FUNCTION I128_LeadingZeros !****************************************************************************** FUNCTION I128_TrailingZeros ( I128 ) RESULT ( NumTZ ) !** PURPOSE OF THIS SUBROUTINE: !! To count the number of trailing zero bits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I4B ) :: NumTZ !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( I128 % Low == 0_I8B ) THEN NumTZ = TRAILZ ( I128 % High ) + 64 ELSE NumTZ = TRAILZ ( I128 % Low ) END IF RETURN END FUNCTION I128_TrailingZeros !****************************************************************************** FUNCTION I128_Count1Bits ( I128 ) RESULT ( NumBits ) !** PURPOSE OF THIS SUBROUTINE: !! To count the number of 1 bits in the specified input IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I4B ) :: NumBits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW NumBits = POPCNT ( I128 % Low ) + POPCNT ( I128 % High ) RETURN END FUNCTION I128_Count1Bits !****************************************************************************** FUNCTION I128_Parity ( I128 ) RESULT ( ParNum ) !** PURPOSE OF THIS SUBROUTINE: !! To determine the parity of the specified input IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I4B ) :: ParNum !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! ParNum = IAND(POPCNT(I128), 1) ParNum = POPPAR ( I128 % Low ) + POPPAR ( I128 % High ) IF ( ParNum == 2 ) ParNum = 0 RETURN END FUNCTION I128_Parity !****************************************************************************** FUNCTION I128_SetBit ( InVal , Pos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the bit at the specified position to 1 ! For more detail, see explanation of elemental intrinsic function 'IBSET' IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_SetBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroI128 RETURN END IF IF ( Pos < 64 ) THEN OutVal % Low = IBSET ( InVal % Low , Pos ) OutVal % High = InVal % High ELSE OutVal % Low = InVal % Low OutVal % High = IBSET ( InVal % High , Pos - 64 ) END IF RETURN END FUNCTION I128_SetBit !****************************************************************************** FUNCTION I128_ClearBit ( InVal , Pos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the bit at the specified position to 0 ! For more detail, see explanation of elemental intrinsic function 'IBCLR' IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ClearBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroI128 RETURN END IF IF ( Pos < 64 ) THEN OutVal % Low = IBCLR ( InVal % Low , Pos ) OutVal % High = InVal % High ELSE OutVal % Low = InVal % Low OutVal % High = IBCLR ( InVal % High , Pos - 64 ) END IF RETURN END FUNCTION I128_ClearBit !****************************************************************************** FUNCTION I128_FlipBit ( InVal , Pos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To reverse the bit at the specified position IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: HiPos !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_FlipBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroI128 RETURN END IF IF ( Pos < 64 ) THEN IF ( BTEST ( InVal % Low , Pos )) THEN ! clear bit OutVal % Low = IBCLR ( InVal % Low , Pos ) ELSE ! set bit OutVal % Low = IBSET ( InVal % Low , Pos ) END IF OutVal % High = InVal % High ELSE HiPos = Pos - 64 IF ( BTEST ( InVal % High , HiPos )) THEN ! clear bit OutVal % High = IBCLR ( InVal % High , HiPos ) ELSE ! set bit OutVal % High = IBSET ( InVal % High , HiPos ) END IF OutVal % Low = InVal % Low END IF RETURN END FUNCTION I128_FlipBit !****************************************************************************** FUNCTION I128_TestBit ( I128 , Pos ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the bit at the specifed position is 0 (False) or 1 (True) ! For more detail, see explanation of elemental intrinsic function 'BTEST' IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_TestBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) Flag = . FALSE . RETURN END IF IF ( Pos < 64 ) THEN Flag = BTEST ( I128 % Low , Pos ) ELSE Flag = BTEST ( I128 % High , Pos - 64 ) END IF RETURN END FUNCTION I128_TestBit !****************************************************************************** FUNCTION I128_ExtractBits ( InVal , Pos , Len ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To extract a sequence of bits according to the specified input ! For more detail, see explanation of elemental intrinsic function 'IBITS' IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos INTEGER ( KIND = I4B ), INTENT ( IN ) :: Len TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Len1 , Len2 , Len3 !** FLOW ! first, check input validity IF ( Len < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ExtractBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Len must be nonnegative.' ) OutVal = ZeroI128 RETURN ELSEIF ( Len == 0 ) THEN OutVal = ZeroI128 RETURN ELSEIF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ExtractBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroI128 RETURN ELSEIF ( Pos + Len > 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_ExtractBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos + Len > 128.' ) OutVal = ZeroI128 RETURN END IF OutVal = ZeroI128 IF ( Pos < 64 ) THEN IF ( Pos + Len <= 64 ) THEN ! bit fields are in only lower elements of both input and output CALL MVBITS ( InVal % Low , Pos , Len , OutVal % Low , 0 ) ELSE IF ( Len <= 64 ) THEN ! bit fields are in both lower and upper elements of input ! but only in lower element of output Len1 = 64 - Pos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , Pos , Len1 , OutVal % Low , 0 ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , Len1 ) ELSE ! bit fields are in lower and upper elements of both input and output Len1 = 64 - Pos ! Input%Low  -> Output%Low Len2 = 64 - Len1 ! Input%High -> Output%Low Len3 = Len - ( Len1 + Len2 ) ! Input%High -> Output%High CALL MVBITS ( InVal % Low , Pos , Len1 , OutVal % Low , 0 ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , Len1 ) CALL MVBITS ( InVal % High , Len2 , Len3 , OutVal % High , 0 ) END IF END IF ELSE ! one of the simplest cases where bit fields are in upper element of input ! and in lower element of output CALL MVBITS ( InVal % High , Pos - 64 , Len , OutVal % Low , 0 ) END IF RETURN END FUNCTION I128_ExtractBits !****************************************************************************** SUBROUTINE I128_MoveBits ( InVal , InPos , Len , OutVal , OutPos ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy a sequence of bits (a bit field) from one location to another ! For more detail, see explanation of elemental intrinsic subroutine ! 'MVBITS' IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: InPos INTEGER ( KIND = I4B ), INTENT ( IN ) :: Len TYPE ( SInt128 ), INTENT ( INOUT ) :: OutVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: OutPos !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Len1 , Len2 , Len3 !** FLOW ! first, check input validity IF ( Len < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Len must be nonnegative.' ) RETURN ELSEIF ( Len == 0 ) THEN RETURN ELSEIF (( InPos < 0 ). OR .( InPos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'InPos must be between 0 and 127.' ) RETURN ELSEIF (( OutPos < 0 ). OR .( OutPos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'OutPos must be between 0 and 127.' ) RETURN ELSEIF ( InPos + Len > 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'InPos + Len > 128.' ) RETURN ELSEIF ( OutPos + Len > 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'I128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'OutPos + Len > 128.' ) RETURN END IF IF ( InPos < 64 ) THEN IF ( InPos + Len <= 64 ) THEN IF ( OutPos < 64 ) THEN IF ( OutPos + Len <= 64 ) THEN ! one of the simplest cases where bit fields are in lower elements CALL MVBITS ( InVal % Low , InPos , Len , OutVal % Low , OutPos ) ELSE ! bit fields are in lower element of input but in both lower and ! upper elements of output Len1 = 64 - OutPos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % Low , InPos + Len1 , Len2 , OutVal % High , 0 ) END IF ELSE ! one of the simplest cases where bit fields are in lower element of input ! and upper element of output, respectively CALL MVBITS ( InVal % Low , InPos , Len , OutVal % High , OutPos - 64 ) END IF ELSE IF ( OutPos < 64 ) THEN IF ( OutPos + Len <= 64 ) THEN ! bit fields are in both lower and upper element of input but ! only in lower element of output Len1 = 64 - InPos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , OutPos + Len1 ) ELSE ! the most complicated cases where bit fields are in lower ! and upper elements of both input and output IF ( InPos == OutPos ) THEN Len1 = 64 - InPos ! Input%Low  -> Output%Low Len2 = Len - Len1 ! Input%High -> Output%High CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % High , 0 ) ELSEIF ( InPos < OutPos ) THEN Len1 = 64 - OutPos ! Input%Low  -> Output%Low Len2 = 64 - ( InPos + Len1 ) ! Input%Low  -> Output%High Len3 = Len - ( Len1 + Len2 ) ! Input%High -> Output%High CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % Low , InPos + Len1 , Len2 , OutVal % High , 0 ) CALL MVBITS ( InVal % High , 0 , Len3 , OutVal % High , Len2 ) ELSE Len1 = 64 - InPos ! Input%Low  -> Output%Low Len2 = 64 - ( OutPos + Len1 ) ! Input%High -> Output%Low Len3 = Len - ( Len1 + Len2 ) ! Input%High -> Output%High CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , OutPos + Len1 ) CALL MVBITS ( InVal % High , Len2 , Len3 , OutVal % High , 0 ) END IF END IF ELSE ! bit fields are in both lower and upper element of input but ! only in upper element of output Len1 = 64 - InPos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % High , OutPos - 64 ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % High , OutPos - 64 + Len1 ) END IF END IF ELSE IF ( OutPos < 64 ) THEN IF ( OutPos + Len <= 64 ) THEN ! one of the simplest cases where bit fields are in upper element of input ! and lower element of output, respectively CALL MVBITS ( InVal % High , InPos - 64 , Len , OutVal % Low , OutPos ) ELSE ! bit fields are in upper element of input but in both lower and ! upper elements of output Len1 = 64 - OutPos Len2 = Len - Len1 CALL MVBITS ( InVal % High , InPos - 64 , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , InPos - 64 + Len1 , Len2 , OutVal % High , 0 ) END IF ELSE ! one of the simplest cases where bit fields are in upper elements CALL MVBITS ( InVal % High , InPos - 64 , Len , OutVal % High , OutPos - 64 ) END IF END IF RETURN END SUBROUTINE I128_MoveBits !------------------------------------------------------------------------------ ! !                           ARITHMETIC ROUTINES ! !------------------------------------------------------------------------------ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++                    ADDITION OPERATIONS                   ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION I128_UnaryPlus ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To return result of the unary plus sign of the Sint128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = InVal RETURN END FUNCTION I128_UnaryPlus !****************************************************************************** SUBROUTINE I128_Increment ( Val ) !** PURPOSE OF THIS SUBROUTINE: !! To increase value of the input by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Val % Low == - 1_I8B ) THEN Val % High = Val % High + 1_I8B Val % Low = 0_I8B ELSE Val % Low = Val % Low + 1_I8B END IF RETURN END SUBROUTINE I128_Increment !****************************************************************************** SUBROUTINE I128_Add_I32 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  This = This + Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , OutLo !** FLOW CALL AddU64 ( This % Low , INT ( Other , KIND = I8B ), 0_I8B , OutLo , Carry ) This % Low = OutLo IF ( Other < 0_I8B ) THEN This % High = This % High - 1_I8B + Carry ELSE This % High = This % High + Carry END IF RETURN END SUBROUTINE I128_Add_I32 !****************************************************************************** SUBROUTINE I128_Add_I64 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  This = This + Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , OutLo !** FLOW CALL AddU64 ( This % Low , Other , 0_I8B , OutLo , Carry ) This % Low = OutLo IF ( Other < 0_I8B ) THEN This % High = This % High - 1_I8B + Carry ELSE This % High = This % High + Carry END IF RETURN END SUBROUTINE I128_Add_I64 !****************************************************************************** SUBROUTINE I128_Add_I128 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  This = This + Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , OutLo , OutHi !** FLOW CALL AddU64 ( This % Low , Other % Low , 0_I8B , OutLo , Carry ) CALL AddU64 ( This % High , Other % High , Carry , OutHi ) This % Low = OutLo This % High = OutHi RETURN END SUBROUTINE I128_Add_I128 !****************************************************************************** FUNCTION I128_Plus_I32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal % Low , INT ( RhsVal , KIND = I8B ), 0_I8B , OutVal % Low , Carry ) IF ( RhsVal < 0 ) THEN OutVal % High = LhsVal % High - 1_I8B + Carry ELSE OutVal % High = LhsVal % High + Carry END IF RETURN END FUNCTION I128_Plus_I32 !****************************************************************************** FUNCTION I32_Plus_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( INT ( LhsVal , KIND = I8B ), RhsVal % Low , 0_I8B , OutVal % Low , Carry ) IF ( LhsVal < 0 ) THEN OutVal % High = RhsVal % High - 1_I8B + Carry ELSE OutVal % High = RhsVal % High + Carry END IF RETURN END FUNCTION I32_Plus_I128 !****************************************************************************** FUNCTION I128_Plus_I64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I8B ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal % Low , RhsVal , 0_I8B , OutVal % Low , Carry ) IF ( RhsVal < 0_I8B ) THEN OutVal % High = LhsVal % High - 1_I8B + Carry ELSE OutVal % High = LhsVal % High + Carry END IF RETURN END FUNCTION I128_Plus_I64 !****************************************************************************** FUNCTION I64_Plus_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal , RhsVal % Low , 0_I8B , OutVal % Low , Carry ) IF ( LhsVal < 0_I8B ) THEN OutVal % High = RhsVal % High - 1_I8B + Carry ELSE OutVal % High = RhsVal % High + Carry END IF RETURN END FUNCTION I64_Plus_I128 !****************************************************************************** FUNCTION I128_Plus_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition of two SInt128 objects (Lhs + Rhs) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal % Low , RhsVal % Low , 0_I8B , OutVal % Low , Carry ) CALL AddU64 ( LhsVal % High , RhsVal % High , Carry , OutVal % High ) RETURN END FUNCTION I128_Plus_I128 !****************************************************************************** PURE SUBROUTINE AddU64 ( X , Y , CarryIn , Sum , CarryOut ) !DIR$ ATTRIBUTES INLINE :: AddU64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the sum with carry of X, Y and CarryIn: Sum = X + Y + CarryIn. ! The carry input must be 0 or 1; otherwise the behavior is undefined. ! The carry output is guaranteed to be 0 or 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y , CarryIn INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Sum , CarryOut OPTIONAL :: CarryOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Sum = X + Y + CarryIn ! The sum will overflow if both top bits are set (x & y) or if one of them ! is (x | y), and a carry from the lower place happened. If such a carry ! happens, the top bit will be 1 + 0 + 1 = 0 (&&#94; sum). IF ( PRESENT ( CarryOut )) THEN CarryOut = SHIFTR ( IOR ( IAND ( X , Y ), IAND ( IOR ( X , Y ), NOT ( Sum ))), 63 ) END IF RETURN END SUBROUTINE AddU64 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++                  SUBTRACTION OPERATIONS                  ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION I128_Negate ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To negate the Uint128 object IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: InVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = NOT ( InVal % High ) IF ( InVal % Low == 0_I8B ) OutVal % High = OutVal % High + 1_I8B OutVal % Low = NOT ( InVal % Low ) + 1_I8B RETURN END FUNCTION I128_Negate !****************************************************************************** SUBROUTINE I128_Decrement ( Val ) !** PURPOSE OF THIS SUBROUTINE: !! To decrease value of the input by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Val % Low == 0_I8B ) THEN Val % High = Val % High - 1_I8B Val % Low = - 1_I8B ELSE Val % Low = Val % Low - 1_I8B END IF RETURN END SUBROUTINE I128_Decrement !****************************************************************************** SUBROUTINE I128_Subtract_I32 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  This = This - Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow , OutLo !** FLOW CALL SubU64 ( This % Low , INT ( Other , KIND = I8B ), 0_I8B , OutLo , Borrow ) This % Low = OutLo IF ( Other < 0 ) THEN This % High = This % High + 1_I8B - Borrow ELSE This % High = This % High - Borrow END IF RETURN END SUBROUTINE I128_Subtract_I32 !****************************************************************************** SUBROUTINE I128_Subtract_I64 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  This = This - Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow , OutLo !** FLOW CALL SubU64 ( This % Low , Other , 0_I8B , OutLo , Borrow ) This % Low = OutLo IF ( Other < 0_I8B ) THEN This % High = This % High + 1_I8B - Borrow ELSE This % High = This % High - Borrow END IF RETURN END SUBROUTINE I128_Subtract_I64 !****************************************************************************** SUBROUTINE I128_Subtract_I128 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  This = This - Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow , OutLo , OutHi !** FLOW CALL SubU64 ( This % Low , Other % Low , 0_I8B , OutLo , Borrow ) CALL SubU64 ( This % High , Other % High , Borrow , OutHi ) This % Low = OutLo This % High = OutHi RETURN END SUBROUTINE I128_Subtract_I128 !****************************************************************************** FUNCTION I128_Minus_I32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal % Low , INT ( RhsVal , KIND = I8B ), 0_I8B , OutVal % Low , Borrow ) IF ( RhsVal < 0 ) THEN OutVal % High = LhsVal % High + 1_I8B - Borrow ELSE OutVal % High = LhsVal % High - Borrow END IF RETURN END FUNCTION I128_Minus_I32 !****************************************************************************** FUNCTION I32_Minus_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( INT ( LhsVal , KIND = I8B ), RhsVal % Low , 0_I8B , OutVal % Low , Borrow ) IF ( LhsVal < 0 ) THEN OutVal % High = - ( RhsVal % High + 1_I8B + Borrow ) ELSE OutVal % High = - ( RhsVal % High + Borrow ) END IF RETURN END FUNCTION I32_Minus_I128 !****************************************************************************** FUNCTION I128_Minus_I64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I8B ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal % Low , RhsVal , 0_I8B , OutVal % Low , Borrow ) IF ( RhsVal < 0_I8B ) THEN OutVal % High = LhsVal % High + 1_I8B - Borrow ELSE OutVal % High = LhsVal % High - Borrow END IF RETURN END FUNCTION I128_Minus_I64 !****************************************************************************** FUNCTION I64_Minus_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal , RhsVal % Low , 0_I8B , OutVal % Low , Borrow ) IF ( LhsVal < 0_I8B ) THEN OutVal % High = - ( RhsVal % High + 1_I8B + Borrow ) ELSE OutVal % High = - ( RhsVal % High + Borrow ) END IF RETURN END FUNCTION I64_Minus_I128 !****************************************************************************** FUNCTION I128_Minus_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction of two SInt128 objects (Lhs - Rhs) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal % Low , RhsVal % Low , 0_I8B , OutVal % Low , Borrow ) CALL SubU64 ( LhsVal % High , RhsVal % High , Borrow , OutVal % High ) RETURN END FUNCTION I128_Minus_I128 !****************************************************************************** PURE SUBROUTINE SubU64 ( X , Y , BorrowIn , Diff , BorrowOut ) !DIR$ ATTRIBUTES INLINE :: SubU64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the difference of X, Y and BorrowIn: Diff = X - Y - BorrowIn. ! The borrow input must be 0 or 1; otherwise the behavior is undefined. ! The borrow output is guaranteed to be 0 or 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y , BorrowIn INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Diff , BorrowOut OPTIONAL :: BorrowOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Diff = X - Y - BorrowIn ! The difference will underflow if the top bit of x is not set and the top ! bit of y is set (&#94;x & y) or if they are the same (&#94;(x &#94; y)) and a Borrow ! from the lower place happens. If that Borrow happens, the result will be ! 1 - 1 - 1 = 0 - 0 - 1 = 1 (& diff). IF ( PRESENT ( BorrowOut )) THEN BorrowOut = SHIFTR ( IOR ( IAND ( NOT ( X ), Y ), IAND ( NOT ( IEOR ( X , Y )), Diff )), 63 ) END IF RETURN END SUBROUTINE SubU64 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++                 MULTIPLICATION OPERATIONS                ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE I128_Times_I32 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  This = This * Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi , ProductHi INTEGER ( KIND = I8B ) :: AbsOther !** FLOW AbsOther = ABS ( Other ) ! perform 'UMul128_Upper64' X_Lo = IAND ( AbsOther , Mask32 ) Y_Lo = IAND ( This % Low , Mask32 ) Y_Hi = SHIFTR ( This % Low , 32 ) ProductHi = SHIFTR ( SHIFTR ( X_Lo * Y_Lo , 32 ) + X_Lo * Y_Hi , 32 ) This % High = AbsOther * This % High + ProductHi This % Low = AbsOther * This % Low IF ( Other < 0 ) This = - This RETURN END SUBROUTINE I128_Times_I32 !****************************************************************************** SUBROUTINE I128_Times_I64 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  This = This * Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: AbsOther !** FLOW AbsOther = ABS ( Other ) This % High = This % High * AbsOther + UMul128_Upper64 ( This % Low , AbsOther ) This % Low = This % Low * AbsOther IF ( Other < 0_I8B ) This = - This RETURN END SUBROUTINE I128_Times_I64 !****************************************************************************** SUBROUTINE I128_Times_I128 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  This = This * Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW This % High = This % Low * Other % High + This % High * Other % Low + & UMul128_Upper64 ( This % Low , Other % Low ) This % Low = This % Low * Other % Low RETURN END SUBROUTINE I128_Times_I128 !****************************************************************************** FUNCTION I32_Multiply_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi , ProductHi INTEGER ( KIND = I8B ) :: AbsLhs !** FLOW AbsLhs = ABS ( LhsVal ) ! perform 'UMul128_Upper64' X_Lo = IAND ( AbsLhs , Mask32 ) Y_Lo = IAND ( RhsVal % Low , Mask32 ) Y_Hi = SHIFTR ( RhsVal % Low , 32 ) ProductHi = SHIFTR ( SHIFTR ( X_Lo * Y_Lo , 32 ) + X_Lo * Y_Hi , 32 ) OutVal % High = AbsLhs * RhsVal % High + ProductHi OutVal % Low = AbsLhs * RhsVal % Low IF ( LhsVal < 0 ) OutVal = - OutVal RETURN END FUNCTION I32_Multiply_I128 !****************************************************************************** FUNCTION I128_Multiply_I32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi , ProductHi INTEGER ( KIND = I8B ) :: AbsRhs !** FLOW AbsRhs = ABS ( RhsVal ) ! perform 'UMul128_Upper64' X_Lo = IAND ( AbsRhs , Mask32 ) Y_Lo = IAND ( LhsVal % Low , Mask32 ) Y_Hi = SHIFTR ( LhsVal % Low , 32 ) ProductHi = SHIFTR ( SHIFTR ( X_Lo * Y_Lo , 32 ) + X_Lo * Y_Hi , 32 ) OutVal % High = LhsVal % High * AbsRhs + ProductHi OutVal % Low = LhsVal % Low * AbsRhs IF ( RhsVal < 0 ) OutVal = - OutVal RETURN END FUNCTION I128_Multiply_I32 !****************************************************************************** FUNCTION I64_Multiply_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: AbsLhs !** FLOW AbsLhs = ABS ( LhsVal ) OutVal % High = AbsLhs * RhsVal % High + UMul128_Upper64 ( AbsLhs , RhsVal % Low ) OutVal % Low = AbsLhs * RhsVal % Low IF ( LhsVal < 0_I8B ) OutVal = - OutVal RETURN END FUNCTION I64_Multiply_I128 !****************************************************************************** FUNCTION I128_Multiply_I64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I8B ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: AbsRhs !** FLOW AbsRhs = ABS ( RhsVal ) OutVal % High = LhsVal % High * AbsRhs + UMul128_Upper64 ( LhsVal % Low , AbsRhs ) OutVal % Low = LhsVal % Low * AbsRhs IF ( RhsVal < 0_I8B ) OutVal = - OutVal RETURN END FUNCTION I128_Multiply_I64 !****************************************************************************** FUNCTION I128_Multiply_I128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication of two SInt128 objects (Lhs * Rhs) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: LhsVal TYPE ( SInt128 ), INTENT ( IN ) :: RhsVal TYPE ( SInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = LhsVal % Low * RhsVal % High + LhsVal % High * RhsVal % Low + & UMul128_Upper64 ( LhsVal % Low , RhsVal % Low ) OutVal % Low = LhsVal % Low * RhsVal % Low RETURN END FUNCTION I128_Multiply_I128 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++             DIVISION/MODULATION OPERATIONS               ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE I128_DivMod_I32 ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division:  Quotient = Dividend / Divisor and ! return both quotient and remainder IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ), INTENT ( OUT ) :: Quotient TYPE ( SInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DivMod ( Dividend , SInt128 ( Divisor ), Quotient , Remainder ) RETURN END SUBROUTINE I128_DivMod_I32 !****************************************************************************** SUBROUTINE I128_DivMod_I64 ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division:  Quotient = Dividend / Divisor and ! return both quotient and remainder IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ), INTENT ( OUT ) :: Quotient TYPE ( SInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DivMod ( Dividend , SInt128 ( Divisor ), Quotient , Remainder ) RETURN END SUBROUTINE I128_DivMod_I64 !****************************************************************************** SUBROUTINE I128_DivMod_I128 ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division of two SInt128 objects (Dividend / Divisor) and ! and return both the quotient and the remainder IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ), INTENT ( OUT ) :: Quotient TYPE ( SInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: UQuotient , URemainder !** FLOW IF (( Dividend == MinI128 ). AND .( Divisor == - OneI128 )) THEN ! not applicable for unsigned binary on two's complement CALL DisplaySevereError ( 'Message from Routine ' // 'I128_Divide_I128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Dividend = MinI128 and Divisor = -1' ) RETURN END IF CALL UDivMod ( UABS ( Dividend ), UABS ( Divisor ), UQuotient , URemainder ) IF (( Dividend % High < 0_I8B ) . NEQV . ( Divisor % High < 0_I8B )) UQuotient = - UQuotient IF ( Dividend % High < 0_I8B ) URemainder = - URemainder Quotient % High = BitCastToSigned ( UQuotient % High ) Quotient % Low = UQuotient % Low Remainder % High = BitCastToSigned ( URemainder % High ) Remainder % Low = URemainder % Low RETURN END SUBROUTINE I128_DivMod_I128 !****************************************************************************** SUBROUTINE I128_Over_I32 ( This , Other , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  This = This / Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Dividend , Rem !** FLOW Dividend = This CALL DivMod ( Dividend , SInt128 ( Other ), This , Rem ) IF ( PRESENT ( Remainder )) Remainder = Rem RETURN END SUBROUTINE I128_Over_I32 !****************************************************************************** SUBROUTINE I128_Over_I64 ( This , Other , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  This = This / Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other INTEGER ( KIND = I8B ), OPTIONAL , INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Dividend , Rem !** FLOW Dividend = This CALL DivMod ( Dividend , SInt128 ( Other ), This , Rem ) IF ( PRESENT ( Remainder )) Remainder = Rem RETURN END SUBROUTINE I128_Over_I64 !****************************************************************************** SUBROUTINE I128_Over_I128 ( This , Other , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  This = This / Other IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other TYPE ( SInt128 ), OPTIONAL , INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Dividend , Rem !** FLOW Dividend = This IF ( PRESENT ( Remainder )) THEN CALL DivMod ( Dividend , Other , This , Remainder ) ELSE CALL DivMod ( Dividend , Other , This , Rem ) END IF RETURN END SUBROUTINE I128_Over_I128 !****************************************************************************** FUNCTION I128_Divide_I32 ( Dividend , Divisor ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  Quotient = Dividend / Divisor IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Remainder !** FLOW CALL DivMod ( Dividend , SInt128 ( Divisor ), Quotient , Remainder ) RETURN END FUNCTION I128_Divide_I32 !****************************************************************************** FUNCTION I128_Divide_I64 ( Dividend , Divisor ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  Quotient = Dividend / Divisor IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Remainder !** FLOW CALL DivMod ( Dividend , SInt128 ( Divisor ), Quotient , Remainder ) RETURN END FUNCTION I128_Divide_I64 !****************************************************************************** FUNCTION I128_Divide_I128 ( Dividend , Divisor ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division of two SInt128 objects (Dividend / Divisor) and ! and return the quotient IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Remainder !** FLOW CALL DivMod ( Dividend , Divisor , Quotient , Remainder ) RETURN END FUNCTION I128_Divide_I128 !****************************************************************************** FUNCTION I128_Mod_I32 ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform modulation:  Remainder = Dividend MOD Divisor IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Quotient !** FLOW CALL DivMod ( Dividend , SInt128 ( Divisor ), Quotient , Remainder ) RETURN END FUNCTION I128_Mod_I32 !****************************************************************************** FUNCTION I128_Mod_I64 ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform modulation:  Remainder = Dividend MOD Divisor IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Quotient !** FLOW CALL DivMod ( Dividend , SInt128 ( Divisor ), Quotient , Remainder ) RETURN END FUNCTION I128_Mod_I64 !****************************************************************************** FUNCTION I128_Mod_I128 ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division of two SInt128 objects (Dividend / Divisor) ! and return the remainder IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( SInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SInt128 ) :: Quotient !** FLOW CALL DivMod ( Dividend , Divisor , Quotient , Remainder ) RETURN END FUNCTION I128_Mod_I128 !------------------------------------------------------------------------------ ! !                           INQUIRY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I128_Is_Zero ( I128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the number is zero or not IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = I128 == ZeroI128 RETURN END FUNCTION I128_Is_Zero !****************************************************************************** FUNCTION I128_Is_Negative ( I128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the number is negative or not IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = I128 % High < 0_I8B RETURN END FUNCTION I128_Is_Negative !****************************************************************************** FUNCTION I128_Is_Positive ( I128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the number is positive or not IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( I128 % High > 0_I8B ). OR .(( I128 % High == 0_I8B ). AND .( I128 % Low /= 0_I8B )) RETURN END FUNCTION I128_Is_Positive !------------------------------------------------------------------------------ ! !                           AUXILIARY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION U64_To_I64 ( U64 ) RESULT ( I64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert unsigned 64-bit integer to signed 64-bit integer IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: U64 !! number treated as unsigned INTEGER ( KIND = I8B ) :: I64 !! number treated as signed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! Casting an unsigned integer to a signed integer of the same ! width is implementation defined behavior if the source value would not fit ! in the destination type. We step around it with a roundtrip bitwise not ! operation to make sure this function remains constexpr. IF ( IAND ( U64 , SHIFTL ( 1_I8B , 63 )) /= 0_I8B ) THEN I64 = NOT ( NOT ( U64 )) ELSE I64 = U64 END IF RETURN END FUNCTION U64_To_I64 !****************************************************************************** FUNCTION I128_UnsignedAbsolute ( I128 ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To return the unsigned absolute value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( UInt128 ) :: U128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! Cast to UInt128 before possibly negating because -Int128Min is undefined. IF ( I128 % High < 0_I8B ) THEN U128 = - ToU128 ( I128 ) ELSE U128 = ToU128 ( I128 ) END IF RETURN END FUNCTION I128_UnsignedAbsolute !****************************************************************************** FUNCTION I128_Absolute ( I128 ) RESULT ( ABS ) !** PURPOSE OF THIS SUBROUTINE: !! To return the absolute value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( SInt128 ) :: ABS !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( IsNegative ( I128 )) THEN ABS = - I128 ELSE ABS = I128 END IF RETURN END FUNCTION I128_Absolute !****************************************************************************** SUBROUTINE I128_Write ( I128 , Unit , IOStat , IOMsg , ShowComponent , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !! To write 'SInt128' object to the screen (or the specified unit) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SInt128 ), INTENT ( IN ) :: I128 !! SInt128 object INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: Unit !! output logical unit INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( OUT ) :: IOStat !! io stat CHARACTER ( LEN =* ), OPTIONAL , INTENT ( OUT ) :: IOMsg !! io message LOGICAL , OPTIONAL , INTENT ( IN ) :: ShowComponent !&#94; flag indicating whether to show components or not ! if flag is present and true, write compoents of the object ! otherwise, write the object as a decimal string CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: Prefix !! prefix string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: AsString INTEGER ( KIND = I4B ) :: OutUnit INTEGER ( KIND = I4B ) :: IO_Stat CHARACTER ( LEN = 128 ) :: IO_Msg CHARACTER ( LEN = :), ALLOCATABLE :: DispStr !** FLOW ! set defaults OutUnit = OUTPUT_UNIT AsString = TrueVal ! check optional input IF ( PRESENT ( ShowComponent )) THEN IF ( ShowComponent ) AsString = FalseVal END IF IF ( PRESENT ( Unit )) OutUnit = Unit ! write the object IF ( AsString ) THEN IF ( PRESENT ( Prefix )) THEN DispStr = Prefix // ToDecString ( I128 ) ELSE DispStr = ' I128 = ' // ToDecString ( I128 ) END IF WRITE ( UNIT = OutUnit , FMT = '(A)' , IOSTAT = IO_Stat , IOMSG = IO_Msg ) DispStr ELSE DispStr = '-: ' IF ( PRESENT ( Prefix )) DispStr = Prefix WRITE ( UNIT = OutUnit , FMT = '(A, I0)' , IOSTAT = IO_Stat , IOMSG = IO_Msg ) & DispStr // 'High value = ' , I128 % High WRITE ( UNIT = OutUnit , FMT = '(A, I0)' , IOSTAT = IO_Stat , IOMSG = IO_Msg ) & DispStr // 'Low value = ' , I128 % Low END IF ! return output if requested IF ( PRESENT ( IOStat )) IOStat = IO_Stat IF ( PRESENT ( IOMsg )) IOMsg = IO_Msg RETURN END SUBROUTINE I128_Write !****************************************************************************** END MODULE ModBase_SInt128 !******************************************************************************","tags":"","loc":"sourcefile\\modbase - sint128.f90.html"},{"title":"ModBase - RealSP - CharConv.f90 – FortCharConv","text":"Source Code MODULE ModBase_RealSP_CharConv !&#94; **PURPOSE OF THIS MODULE**: ! This module contains routines that perform a conversion between a 32-bit !   floating point number and a string. ! !&#94; **REFERENCE TECHNICAL ARTICLES**: ! [1]  Junekey Jeon.  [Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm](https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf) ! [2]  Ulf Adams.  [Ryu: Fast Float-to-String Conversion](https://dl.acm.org/doi/10.1145/3192366.3192369) ! [3]  Raffaello Giulietti.  [The Schubfach way to render doubles](https://drive.google.com/open?id=1luHhyQF9zKlM8yJ1nebU0OgVYhfC6CBN) ! [4]  Clinger WD. [How to Read Floating Point Numbers Accurately](https://doi.org/10.1145/989393.989430), !   SIGPLAN Not 2004 Apr;39(4):360–371. ! [5]  Daniel Lemire.  [Number Parsing at a Gigabyte per Second](https://arxiv.org/abs/2101.11408), !   Software: Practice and Experience 51 (8), 2021. ! [6]  Noble Mushtak and Daniel Lemire.  [Fast Number Parsing Without Fallback](https://arxiv.org/abs/2212.06644), !   Software: Practice and Experience 53 (7), 2023. ! [7]  Bouvier & Zimmermann.  [Division-Free Binary-to-Decimal Conversion](https://hal.inria.fr/hal-00864293v1/document) ! [8]  Hacker's Delight, 2nd Edition. ! [9]  Nigel Tao.  [The Eisel-Lemire ParseNumberF64 Algorithm](https://nigeltao.github.io/blog/2020/eisel-lemire.html) ! [10] Nigel Tao.  [ParseNumberF64 by Simple Decimal Conversion](https://nigeltao.github.io/blog/2020/parse-number-f64-simple.html) ! !&#94; **REFERENCE CODE IMPLEMENTATION**: ! [11] [DragonBox: C++ reference implementation](https://github.com/jk-jeon/dragonbox) ! [12] [Ryu: C reference implementation](https://github.com/ulfjack/ryu) ! [13] [Schubfach: Java reference implementation](https://github.com/c4f7fcce9cb06515/Schubfach) ! [14] [Drachennest: Different algorithms for converting binary to decimal floating-point numbers](https://github.com/abolz/Drachennest) ! [15] [Number Conversion Benchmark in C](https://github.com/ibireme/c_numconv_benchmark) ! [16] [fast_float number parsing library: 4x faster than strtod](https://github.com/fastfloat/fast_float) ! [17] [fast_double_parser: 4x faster than strtod](https://github.com/lemire/fast_double_parser) ! [18] [The LLVM Project: LibC Support](https://github.com/llvm/llvm-project/tree/main/libc/src/__support) ! [19] [Double Conversion: Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles](https://github.com/google/double-conversion) ! [20] [fmt: A modern formatting library](https://github.com/fmtlib/fmt) ! !&#94; **TECHNICAL AND IMPLEMENTATION NOTES**: ! ***On the output to string***: ! 1) Three routines are available to convert a real (floating-point) number into a string. !    - \"RealToString_DragonBox\" is based on the Dragonbox binary-to-decimal conversion algorithm [1] !      and the reference implementation [11, 14, 20] !    - \"RealToString_Ryu\" is based on the Ryu binary-to-decimal conversion algorithm [2] !      and the reference implementation [12, 14] !    - \"RealToString_Schubfach\" is based on the Schubfach binary-to-decimal conversion algorithm [3] !      and the reference implementation [13, 14, 15] ! 2) All three binary-to-decimal conversion algorithms employed here produce the so-called shortest !    output representation that provide an error-free write-read cycle.  This means that any correct !    parsers (e.g. RealFromString routines) will read in the output string and return the original !    real (floating-poing) number. ! 3) Although the DragonBox reference implementation provides several modes of rounding, only the !    round-to-nearest mode is implemented here (the other two algorithms also use this mode). ! 4) Although the Ryu reference implementation provides several conversion output formats (Shortest, !    Scientific, Fixed), only the shortest representation (as mentioned above) is implemented. !    Therefore, all three routines will produces the output string in a format similar to \"G0\" format !    specification in Fortran. ! 5) Actually, the RealToString routines have an optional \"format\" argument that we can use to specify !    whether to output the string in \"General (G)\" or \"Scientific (ES)\" format.  However, because they !    always produce the shortest output, no input argument to the routines is provided to specify !    the desired number of significant digits as typically done in Fortran format specifications. ! ***On the input from string***: ! 1) Four routines are available to convert a string into a real (floating-point) number.  All four !    routines utilize the so-call Clinger's fast-path algorithm [4].  Three of them (except \"YY\") employ !    the so-call Eisel-Lemire decimal-to-binary conversion algorithm [5, 9] but are based on different !    reference implementation.  When the Eisel-Lemire (or YY's fast-path) algorithm is NOT valid, three !    of the routines (except \"LibC\") use multi-precision (unsigned) integer arithmetic (i.e. BigUInt) !    whereas \"LibC\" employs the so-call Simple Decimal Conversion algorithm [10]. !    - \"RealFromString_FastFloat\" is based on the reference implementation [16] !    - \"RealFromString_LibC\" is based on the reference implementation [18] !    - \"RealFromString_YY\" is based on the reference implementation [15, 19] !    - \"RealFromString_Lemire\" is based on the reference implementation [17, 19] ! 2) The RealFromString routines have an optional \"parsing\" argument that we can use to specify how !    the routines interpret the input string. ! 3) The \"Parse_Fortran_String\" routine is called when the optional \"parsing\" argument is not specified !    (i.e. the default option) or \"FortNum (or 1)\" value is supplied as the parsing argument.  The routine !    will interpret the input string as a valid Fortran real (floating point) number if it has one of !    the two following forms: !    <1> A number without exponent part -> [S]N[N...] !    <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] !       where !       [ ] indicates an optional field !       S is a sign indicator (required if negative '-', optional if positive '+'). !       N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere !           after the sign (but before the exponent). !       E is an exponent indicator (either 'e' or 'E') !    The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. !    - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. !    - The optional kind parameter (e.g. 10.0_DP) is not allowed here. !    Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered !    valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\" !    is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement !    where spaces inside the valid number are allowed. However, this can easily be done by adding an !    optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or 'ignored'. !    Then, the input will be pre-processed according to the flag.  Nonetheless, this routine neglects !    this optional input because it will make the routine much less efficient due to the fact that !    we will need to scan the whole string twice and we will also need to copy the input string into !    a buffer string and working with the buffer instead of directly handling the input string. ! 4) The \"Parse_FPlus_String\" routine is called when \"FPlusNum (or 2)\" value is supplied as the parsing !    argument.  The routine will parse a valid Fortran real (floating point) number with more relaxed !    rules than those used in \"Parse_Fortran_Number\" routine. The relaxed rules consider the following !    numbers as valid: !    - a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' !      in place of 'e' or 'E'. !    - a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to !      be expressed in a valid number expressed in the scientific format. !    - digits before any invalid character encountered are treated as a valid number !      and any characters after the first encounter (including the first invalid one) !      are neglected.  therefore, for example, a '12.56ax-300' is considered to be !      a valid number with a value of 12.56. ! 5) The \"Parse_JSON_String\" routine is called when \"JsonNum (or 3)\" value is supplied as the parsing !    argument.  The routine will parse a valid JSON floating point number where its differences from !    from Fortran number are as follows: !    - leading and trailing spaces are not allowed. !    - a plus sign as the first character is not allowed. !    - leading zero(s) is not allowed (if 0 is the first character, the second one !      must either be a period or an exponent indicator.) !    - a period must be followed by at least one digit. ! !&#94; **USAGE**: ! ***On the output to string***: ! => cStr = RealXP_ToString_DragonBox(Number, IsScientific) ! => cStr = RealXP_ToString_Ryu(Number, IsScientific) ! => cStr = RealXP_ToString_Schubfach(Number, IsScientific) !   where !   \"cStr\" is an \"allocatable\" character string representing the output string !   \"Number\" is a real number representing the floating point value !   \"IsScientific\" is a logical flag (optional argument) indicating whether !       the output string is in \"General\" or \"Scientific\" format. !       If present and true, the output string is in \"Scientific\" format. !       Otherwise, the output string is in \"General\" format. ! ***On the input from string***: ! => Number = RealXP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) !   where !   \"Number\" is a real number representing the floating point value if the input string is valid !   \"cStr\" is a character string representing the floating-point number string !   \"ParseOpt\" is an integer input flag (optional) indicating how to interpret the input string. !       The valid value is FortNum (1), FPlusNum (2) or JsonNum (3). !       If not specified and invalid, the routines will interpret the input string as a Fortran number. !   \"ErrFlag\" is a logical output flag (optional) indicating whether there is an error in parsing !       the input string.  True if the string represents a valid number.  False, otherwise. !   \"ErrMsg\" is an allocatable output character string (optional) that returns a message that describe !       the result of parsing the input string. ! **NOTE**: \"XP\" in the routine names shown above indicate the precision of the real number. !   The actual name will either be \"RealSP_...\", \"RealDP_...\" or \"RealQP_...\" for single-precision, !   double-precision and quadruple-precision number, respectively. !** USE STATEMENTS: USE ModBase_Common USE ModBase_SIntUtil USE ModBase_UIntUtil USE ModBase_UInt128 USE ModBase_Tables_CharConv USE , INTRINSIC :: IEEE_ARITHMETIC IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! Real-To-String PUBLIC :: RealSP_ToString_DragonBox PUBLIC :: RealSP_ToString_Ryu PUBLIC :: RealSP_ToString_Schubfach ! Real-From-String PUBLIC :: RealSP_FromString_FastFloat PUBLIC :: RealSP_FromString_LibC PUBLIC :: RealSP_FromString_YY PUBLIC :: RealSP_FromString_Lemire PRIVATE ! by default, hide all data and routines except those declared explicitly !** USE STATEMENTS: USE ModBase_Common USE ModBase_SIntUtil USE ModBase_UIntUtil USE ModBase_UInt128 USE ModBase_Tables_CharConv USE , INTRINSIC :: IEEE_ARITHMETIC IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! Real-To-String PUBLIC :: RealSP_ToString_DragonBox PUBLIC :: RealSP_ToString_Ryu PUBLIC :: RealSP_ToString_Schubfach ! Real-From-String PUBLIC :: RealSP_FromString_FastFloat PUBLIC :: RealSP_FromString_LibC PUBLIC :: RealSP_FromString_YY PUBLIC :: RealSP_FromString_Lemire PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! options for type of number to be parsed INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: FortNum = 1 ! strict fortran number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: FPlusNum = 2 ! relaxed fortran number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: JsonNum = 3 ! json number ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ parameters used to convert bit widths to whole decimal digits +++ INTEGER ( KIND = I8B ), PARAMETER :: LB2To10_M1 = 301029995664_I8B ! LogBaseTenOfTwoTimesTenToThe12th INTEGER ( KIND = I8B ), PARAMETER :: LB2To10_M2 = 1000000000000_I8B ! TenToThe12th ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ Characteristics of IEEE-754 & related binary floating-point numbers +++ ! kind INTEGER ( KIND = I4B ), PARAMETER :: RealKind = 4 ! binary-precision number of bit INTEGER ( KIND = I4B ), PARAMETER :: BinaryPrecision = 24 INTEGER ( KIND = I4B ), PARAMETER :: TotalBits = 32 INTEGER ( KIND = I4B ), PARAMETER :: SignBits = TotalBits - 1 ! 31 INTEGER ( KIND = I4B ), PARAMETER :: SignificandBits = BinaryPrecision - 1 ! 23 INTEGER ( KIND = I4B ), PARAMETER :: ExponentBits = TotalBits - BinaryPrecision ! 8 INTEGER ( KIND = I4B ), PARAMETER :: MaxExponent = SHIFTL ( 1 , ExponentBits ) - 1 ! 255 INTEGER ( KIND = I4B ), PARAMETER :: ExponentBias = SHIFTL ( 1 , ExponentBits - 1 ) - 1 ! 127 INTEGER ( KIND = I4B ), PARAMETER :: DecimalPrecision = INT (( SignificandBits * LB2To10_M1 ) / LB2To10_M2 , KIND = I4B ) ! 6 INTEGER ( KIND = I4B ), PARAMETER :: DecimalRange = INT ((( ExponentBias - 1 ) * LB2To10_M1 ) / LB2To10_M2 , KIND = I4B ) ! 37 INTEGER ( KIND = I4B ), PARAMETER :: MaxDecimalConversionDigits = 112 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ masking parameters +++ INTEGER ( KIND = I4B ), PARAMETER :: SigHidBitMask = SHIFTL ( 1 , SignificandBits ) INTEGER ( KIND = I4B ), PARAMETER :: SignificandMask = SigHidBitMask - 1 INTEGER ( KIND = I4B ), PARAMETER :: SignMask = SHIFTL ( 1 , SignBits ) INTEGER ( KIND = I4B ), PARAMETER :: ExponentMask = NOT ( IOR ( SignMask , SignificandMask )) INTEGER ( KIND = I4B ), PARAMETER :: ExpMantMask = SignificandMask + ExponentMask ! = NOT(SignMask) INTEGER ( KIND = I4B ), PARAMETER :: QuietNaNMask = SHIFTL ( 1 , SignificandBits - 1 ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Exceptional exponent value for NaN or Infinity INTEGER ( KIND = I4B ), PARAMETER :: ExceptionalExponent = INT ( Z '7FFFFFFF' , KIND = I4B ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ maximum and minimum (positive) parameters +++ ! note:  These parameters are stored in an integer data type that have the same number of bits to !        a real data type of the floating point number. !# minimum value of subnormal floating point number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: MinSubnormal = 1 !# maximum value of subnormal floating point number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: MaxSubnormal = SHIFTL ( 1 , SignificandBits ) - 1 !# minimum value of normal floating point number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: MinNormal = SHIFTL ( 1 , SignificandBits ) !# maximum value of normal floating point number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: MaxNormal = IOR ( SHIFTL (( MaxExponent - 1 ), SignificandBits ), MaxSubnormal ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------------------------------- ! -----   parameters for high-precision decmial conversion algorithm  ----- ! ------------------------------------------------------------------------- ! 150 is an arbitrary number of digits, but should be large enough for any practical number. ! Important note: a number of digits large enough to represent the smallest subnormal ! for single-precision number is about 166 (= 54 + 112). INTEGER ( KIND = I4B ), PARAMETER :: MAX_NUM_DIGITS = 150 ! The maximum amount we can shift is the number of bits used in the Accumulator, ! minus the number of bits needed to represent the base (in this case 4). INTEGER ( KIND = I4B ), PARAMETER :: MAX_SHIFT_AMOUNT = 4 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------------------- ! -----   parameters for BigUInt of FastFloat algorithm  ----- ! ----------------------------------------------------------- ! the number of bits of 'Digit' of BigUInt. INTEGER ( KIND = I4B ), PARAMETER :: DigitBits = 64 ! the total number of bits of a BigUInt that needs to be at least the number of bits ! required to store the largest BigUInt, which is Log2(10**(MaxDigits + MaxExp10)), or ! Log2(10**(112 + 54))`, or ~551 bits, so we round to 576. INTEGER ( KIND = I4B ), PARAMETER :: BigUIntBits = 576 ! the (fixed) capacity of a BigUInt INTEGER ( KIND = I4B ), PARAMETER :: BigCapacity = BigUIntBits / DigitBits ! = 9 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INTEGER ( KIND = I4B ), PARAMETER :: DivBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: MaxDivbyBase = 429496729 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ number parameters +++ INTEGER ( KIND = I4B ), PARAMETER :: TwoUInt = 2 INTEGER ( KIND = I4B ), PARAMETER :: ThreeUInt = 3 INTEGER ( KIND = I4B ), PARAMETER :: FourUInt = 4 INTEGER ( KIND = I4B ), PARAMETER :: FiveUInt = 5 INTEGER ( KIND = I4B ), PARAMETER :: TenUInt = 10 INTEGER ( KIND = I4B ), PARAMETER :: FortyUInt = 40 INTEGER ( KIND = I4B ), PARAMETER :: HundredUInt = 100 INTEGER ( KIND = I4B ), PARAMETER :: TenThousandUInt = 10000 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ---------------------------------------------------- ! -----   Simple-Decimal-Algorithm' parameters   ----- ! ---------------------------------------------------- ! The nth item in Powers_Of_Two represents the greatest power of two less than ! 10&#94;n. This tells us how much we can safely shift without overshooting. INTEGER ( KIND = I1B ), PARAMETER :: Powers_Of_Two ( 0 : 18 ) = [ & 0 , 3 , 6 , 9 , 13 , 16 , 19 , 23 , 26 , 29 , 33 , 36 , 39 , 43 , 46 , 49 , 53 , 56 , 59 ] INTEGER ( KIND = I4B ), PARAMETER :: Num_Powers_Of_Two = SIZE ( Powers_Of_Two ) ! = 19 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! -------------------------------------------------- ! -----   Eisel-Lemire-Algorithm' parameters   ----- ! -------------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: LowBits = TotalBits - SignificandBits - 3 ! = 6 ! The halfway constant is used to check if the bits that will be shifted away intially are all 1. INTEGER ( KIND = I4B ), PARAMETER :: HalfWay = SHIFTL ( 1 , LowBits ) - 1 ! = 63 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! -------------------------------------------------- ! -----   Clinger-Algorithm' parameters   ----- ! -------------------------------------------------- INTEGER ( KIND = I4B ) :: Idx REAL ( KIND = SP ), PARAMETER :: Powers_Of_Ten ( 0 : 10 ) = [( 1 0.0E0 ** Idx , Idx = 0 , 10 )] INTEGER ( KIND = I4B ), PARAMETER :: Num_Exact_Pow10 = 10 INTEGER ( KIND = I4B ), PARAMETER :: Num_Mantissa_Digits = 7 REAL ( KIND = SP ), PARAMETER :: Max_Exact_Integer = 1677721 5.0_SP ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INTEGER ( KIND = I4B ), PARAMETER :: Exponent_UppBound = 39 ! = 38 + 1 INTEGER ( KIND = I4B ), PARAMETER :: Exponent_LowBound = - 54 ! = (-45) - 9 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Dragonbox-Algorithm' parameters   ----- ! ----------------------------------------------- ! parameters for main routine INTEGER ( KIND = I4B ), PARAMETER :: Kappa = 1 INTEGER ( KIND = I4B ), PARAMETER :: Big_Divisor = 10 ** ( Kappa + 1 ) ! 100 INTEGER ( KIND = I4B ), PARAMETER :: Small_Divisor = Big_Divisor / 10 ! 10 INTEGER ( KIND = I4B ), PARAMETER :: Half_Small_Divisor = Small_Divisor / 2 ! 5 INTEGER ( KIND = I4B ), PARAMETER :: Divisibility_Check_By_5_Threshold = 39 INTEGER ( KIND = I4B ), PARAMETER :: Case_Fc_Pm_Half_Lower_Threshold = - 1 ! parameters for short interval case INTEGER ( KIND = I4B ), PARAMETER :: Case_Shorter_Interval_Left_Endpoint_Lower_Threshold = 2 INTEGER ( KIND = I4B ), PARAMETER :: Case_Shorter_Interval_Left_Endpoint_Upper_Threshold = 3 INTEGER ( KIND = I4B ), PARAMETER :: Shorter_Interval_Tie_Lower_Threshold = - 35 INTEGER ( KIND = I4B ), PARAMETER :: Shorter_Interval_Tie_Upper_Threshold = - 35 ! parameters for Is_Divisible_By_Pow10 routine INTEGER ( KIND = I4B ), PARAMETER :: Info_Shift_Amount = 16 INTEGER ( KIND = I4B ), PARAMETER :: OneShiftL = SHIFTL ( 1 , Info_Shift_Amount ) INTEGER ( KIND = I4B ), PARAMETER :: Comparison_Mask = OneShiftL - 1 INTEGER ( KIND = I4B ), PARAMETER :: Magic_Number = OneShiftL / Small_Divisor + 1 ! parameters for Divide_By_10_To_Kappa_Plus_1 INTEGER ( KIND = I8B ), PARAMETER :: DivM = 1374389535_I8B INTEGER ( KIND = I4B ), PARAMETER :: DivS = 37 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Ryu-Algorithm' parameters   ----- ! ----------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: BitsPerPow5 = 64 INTEGER ( KIND = I4B ), PARAMETER :: MaxExp_ModInv5 = 13 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Schubfach-Algorithm' parameters   ----- ! ----------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: Pow10_Min_Exact_Exp = 0 INTEGER ( KIND = I4B ), PARAMETER :: Pow10_Max_Exact_Exp = 27 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   FastFloat-Algorithm' parameters   ----- ! ----------------------------------------------- ! Bias so we can get the real exponent with an invalid adjusted_mantissa INTEGER ( KIND = I4B ), PARAMETER :: Invalid_AM_Bias = - INT ( Z '00008000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: Mantissa_Explicit_Bits = SignificandBits INTEGER ( KIND = I4B ), PARAMETER :: Minimum_Exponent = - ExponentBias INTEGER ( KIND = I4B ), PARAMETER :: Infinite_Power = MaxExponent INTEGER ( KIND = I4B ), PARAMETER :: Sign_Index = SignBits INTEGER ( KIND = I4B ), PARAMETER :: MantTotalBits = 64 ! see section 6 in 'Number Parsing at a Gigabyte per Second' paper for ! how the following two numbers can be obtained INTEGER ( KIND = I4B ), PARAMETER :: Max_Exponent_Round_To_Even = 10 INTEGER ( KIND = I4B ), PARAMETER :: Min_Exponent_Round_To_Even = - 17 INTEGER ( KIND = I4B ), PARAMETER :: Largest_Power_of_Ten = Exponent_UppBound - 1 INTEGER ( KIND = I4B ), PARAMETER :: Smallest_Power_of_Ten = Exponent_LowBound + 1 INTEGER ( KIND = I4B ), PARAMETER :: Max_Digits = MaxDecimalConversionDigits + 2 INTEGER ( KIND = I8B ), PARAMETER :: OneMant = 1_I8B INTEGER ( KIND = I8B ), PARAMETER :: Max_Mantissa_Fast_Path = SHIFTL ( 2_I8B , Mantissa_Explicit_Bits ) INTEGER ( KIND = I8B ), PARAMETER :: Exponent_Mask = ExponentMask INTEGER ( KIND = I8B ), PARAMETER :: Mantissa_Mask = SignificandMask INTEGER ( KIND = I8B ), PARAMETER :: Hidden_Bit_Mask = SigHidBitMask INTEGER ( KIND = I8B ), PARAMETER :: MaxMant = MAX_U64 INTEGER ( KIND = I8B ), PARAMETER :: NotOneMant = NOT ( 1_I8B ) INTEGER ( KIND = I8B ), PARAMETER :: NotSigHidBitMask = NOT ( SHIFTL ( 1_I8B , SignificandBits )) INTEGER ( KIND = I8B ), PARAMETER :: Powers_of_Ten_Uint64 ( 0 : 19 ) = & [ 0_I8B , & 10_I8B , & 100_I8B , & 1000_I8B , & 10000_I8B , & 100000_I8B , & 1000000_I8B , & 10000000_I8B , & 100000000_I8B , & 1000000000_I8B , & 10000000000_I8B , & 100000000000_I8B , & 1000000000000_I8B , & 10000000000000_I8B , & 100000000000000_I8B , & 1000000000000000_I8B , & 10000000000000000_I8B , & 100000000000000000_I8B , & 1000000000000000000_I8B , & - 8446744073709551616_I8B ] ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------ ! -----   YY/Lemire-Algorithm's parameters   ----- ! ------------------------------------------------ INTEGER ( KIND = I8B ), PARAMETER :: MaxU64 = MAX_U64 INTEGER ( KIND = I4B ), PARAMETER :: BitMask = SHIFTL ( 1 , LowBits ) - 1 ! = Halfway INTEGER ( KIND = I4B ), PARAMETER :: BitMaskMinus1 = BitMask - 1 INTEGER ( KIND = I4B ), PARAMETER :: AddRound = SHIFTL ( 1 , ExponentBits - 1 ) INTEGER ( KIND = I4B ), PARAMETER :: MaxUInt = INT ( Z 'FFFFFFFF' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FpRawInf = INT ( Z '7F800000' , KIND = I4B ) ! = ExponentMask INTEGER ( KIND = I4B ), PARAMETER :: MaxExpBin = 128 INTEGER ( KIND = I4B ), PARAMETER :: MinExpBin = - 125 INTEGER ( KIND = I4B ), PARAMETER :: UIntSafeDigits = 9 INTEGER ( KIND = I4B ), PARAMETER :: MaxDecDigits = MaxDecimalConversionDigits + 1 INTEGER ( KIND = I4B ), PARAMETER :: MaxMantissa = SHIFTL ( 1_I8B , BinaryPrecision ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INTEGER ( KIND = I8B ), PARAMETER :: MaskU32 = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !** DERIVED TYPE DEFINITIONS ! ---------------------------------------------------------------------------- ! auxiliary string information ! ---------------------------------------------------------------------------- TYPE StringAux INTEGER ( KIND = I4B ) :: Start ! starting position that exclude the leading spaces INTEGER ( KIND = I4B ) :: SigCut ! position after the string is truncated ! = zero if Truncated = False; non-zero if Truncated = True INTEGER ( KIND = I4B ) :: Indices ( 4 ) ! positions of characters representing the ! significand in the string LOGICAL :: Truncated ! flag indicating whether the computed decimal ! significand is based on a truncated string END TYPE StringAux ! ---------------------------------------------------------------------------- ! -----   derived types for high-precision decmial conversion algorithm  ----- ! ---------------------------------------------------------------------------- TYPE HPDecimal INTEGER ( KIND = I4B ) :: NumDigits = 0 INTEGER ( KIND = I4B ) :: DecimalPoint = 0 LOGICAL :: Truncated = FalseVal INTEGER ( KIND = I1B ) :: Digits ( 0 : MAX_NUM_DIGITS - 1 ) CONTAINS PROCEDURE :: ShouldRoundUp => HPDec_Should_Round_Up PROCEDURE :: GetNumNewDigits => HPDec_Get_Num_New_Digits PROCEDURE :: TrimTrailingZeroes => HPDec_Trim_Trailing_Zeroes PROCEDURE :: RightShift => HPDec_Right_Shift PROCEDURE :: LeftShift => HPDec_Left_Shift PROCEDURE :: Construct => HPDec_Construct PROCEDURE :: Shift => HPDec_Shift PROCEDURE :: RoundToUIntType => HPDec_Round_To_UInt END TYPE HPDecimal ! ---------------------------------------------------------------------------- ! -----   derived types for FastFloat algorithm                          ----- ! ---------------------------------------------------------------------------- ! a multiprecision (fixed capacity) unsigned integer where its representation are: ! - Base is 2**64. ! - Magnitude as array in little endian order. ! - The 'Length' first 'Digit' count as the number. ! ---------------------------------------------------------------------------- TYPE BigUInt INTEGER ( KIND = I8B ) :: Digit ( 0 : BigCapacity - 1 ) INTEGER ( KIND = I4B ) :: Length = 0 ! number of digit currently stored CONTAINS PROCEDURE :: IsEmpty => BigUInt_IsEmpty PROCEDURE :: IsNonZero => BigUInt_IsNonZero PROCEDURE :: Push => BigUInt_Push PROCEDURE :: Extend => BigUInt_Extend PROCEDURE :: Normalize => BigUInt_Normalize PROCEDURE :: FromU64 => BigUInt_From_U64 PROCEDURE :: Hi64 => BigUInt_Get_Hi64 PROCEDURE :: Compare => BigUInt_Compare PROCEDURE :: ShiftL => BigUInt_ShiftL PROCEDURE :: LeadZ => BigUInt_LeadZ PROCEDURE :: BitLen => BigUInt_BitLen PROCEDURE :: SmallMul => BigUInt_SmallMul PROCEDURE :: LongMul => BigUInt_LongMul PROCEDURE :: Add => BigUInt_Add PROCEDURE :: Pow2 => BigUInt_Pow2 PROCEDURE :: Pow5 => BigUInt_Pow5 PROCEDURE :: Pow10 => BigUInt_Pow10 END TYPE BigUInt ! parsed number information TYPE Parsed_Number_Info INTEGER ( KIND = I4B ) :: Exp ! base-10 exponent INTEGER ( KIND = I4B ) :: Sig ! base-10 significand INTEGER ( KIND = I4B ) :: IntegralStart ! starting index of integral part of the significand INTEGER ( KIND = I4B ) :: IntegralEnd ! ending index of integral part of the significand INTEGER ( KIND = I4B ) :: FractionStart ! starting index of fractional part of the significand INTEGER ( KIND = I4B ) :: FractionEnd ! ending index of fractional part of the significand END TYPE ! ---------------------------------------------------------------------------- ! binary floating-point representation in base 2 ! --> ((-1)**S) * M * (2**E) ! ---------------------------------------------------------------------------- TYPE BinRep INTEGER ( KIND = I4B ) :: Significand ! significand/mantissa (M) INTEGER ( KIND = I4B ) :: Exponent ! exponent (E); negative value is invalid LOGICAL :: Negative ! negative sign flag; true if the value is negative END TYPE BinRep ! ---------------------------------------------------------------------------- !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE/GENERIC DEFINITIONS: ! interfaces to routines used by FastFloat algorithm ABSTRACT INTERFACE SUBROUTINE CB_Round ( E , M , Min ) IMPORT INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M INTEGER ( KIND = I4B ), INTENT ( IN ) :: Min END SUBROUTINE FUNCTION CB_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) IMPORT LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag END FUNCTION END INTERFACE CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                       REAL32-TO-STRING MAIN ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RealSP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a single-precision floating-point value to a character (decimal) string ! using the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I4B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = SP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I4B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I4B )) THEN ! zero SigDec = 0_I4B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + WRITE_RealSP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealSP_ToString_DragonBox !****************************************************************************** FUNCTION RealSP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a single-precision floating-point value to a character (decimal) string ! using the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I4B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = SP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I4B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I4B )) THEN ! zero SigDec = 0_I4B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + WRITE_RealSP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealSP_ToString_Ryu !****************************************************************************** FUNCTION RealSP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a single-precision floating-point value to a character (decimal) string ! using the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Number !! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawBin ! raw IEEE binary floating point representation INTEGER ( KIND = I4B ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) REAL ( KIND = SP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( RawBin , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 48 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= 0_I4B SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = INT ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits ), KIND = I4B ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == 0_I4B )) THEN ! zero SigDec = 0_I4B ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + WRITE_RealSP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealSP_ToString_Schubfach !------------------------------------------------------------------------------ ! !                       REAL64-FROM-STRING MAIN ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RealSP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the FastFloat algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I8B ) :: SigBin64 ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using FastFloat algorithm if SlowPath is true ! IF (SlowPath) CALL Dec2Bin_FastFloat(SigDec, ExpDec, cStr, Aux%Truncated, Aux%Indices, SigBin, ExpBin) IF ( SlowPath ) THEN CALL Dec2Bin_FastFloat ( INT ( SigDec , KIND = I8B ), ExpDec , cStr , Aux % Truncated , Aux % Indices , SigBin64 , ExpBin ) SigBin = INT ( SigBin64 , KIND = I4B ) END IF ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_FastFloat !****************************************************************************** FUNCTION RealSP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the LibC algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using LibC algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_LibC ( SigDec , ExpDec , cStr , Aux % Start , Aux % Truncated , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_LibC !****************************************************************************** FUNCTION RealSP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the YY algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using YY's algorithm +++ RawVal = Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_YY !****************************************************************************** FUNCTION RealSP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a character (decimal) string to a single-precision floating-point value ! using the Lemire algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr !! input string INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt !! parsing option LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! error flag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message REAL ( KIND = SP ) :: Number !! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) INTEGER ( KIND = I4B ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux ! auxialiary string information LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I4B ) :: RawVal ! raw IEEE binary floating point representation REAL ( KIND = SP ) :: FloatVal ! working real (for conversion from binary representation) EQUIVALENCE ( RawVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = 0_I4B ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = 0_I4B ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using Lemire's algorithm +++ RawVal = Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealSP_FromString_Lemire !****************************************************************************** !------------------------------------------------------------------------------ ! !                           COMMON AND GENERIC ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Eight_Digits_Unrolled ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits_Unrolled !** PURPOSE OF THIS SUBROUTINE: ! To parse eight digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: K1 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K2 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K3 = INT ( Z '0000FFFF0000FFFF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M1 = 2561_I8B INTEGER ( KIND = I8B ), PARAMETER :: M2 = 6553601_I8B INTEGER ( KIND = I8B ), PARAMETER :: M3 = 42949672960001_I8B ! parameters for alternative implementation !    INTEGER(KIND=I8B), PARAMETER  :: Mask = INT(Z'000000FF000000FF', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: Mul1 = INT(Z'000F424000000064', KIND=I8B)   ! 100 + (1000000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Mul2 = INT(Z'0000271000000001', KIND=I8B)   ! 1 + (10000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Sub  = INT(Z'3030303030303030', KIND=I8B) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = SHIFTR ( IAND ( SHIFTR ( IAND ( SHIFTR ( IAND ( InVal , K1 ) * M1 , 8 ), K2 ) * M2 , 16 ), K3 ) * M3 , 32 ) ! alternative implementation !    OutVal = InVal - Sub !    OutVal = (OutVal*10) + SHIFTR(OutVal, 8)    ! OutVal = (OutVal * 2561) >> 8 !    OutVal = SHIFTR(((IAND(OutVal, Mask)*Mul1) + (IAND(SHIFTR(OutVal, 16), Mask)*Mul2)), 32) RETURN END FUNCTION Parse_Eight_Digits_Unrolled !****************************************************************************** FUNCTION Floor_Log10_ThreeQuartersPow2 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_ThreeQuartersPow2 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = FLOOR(LOG10((3/4)*(2**E))) where -2956395 <= E <= 2500325 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! base-2 exponent INTEGER ( KIND = I4B ) :: K ! base-10 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG10(2) * 2**Shift) ! Addend     = FLOOR(LOG10(3/4) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 41 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 661971961083_I8B INTEGER ( KIND = I8B ), PARAMETER :: Addend = - 274743187321_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW K = INT ( SHIFTA ( INT ( E , KIND = I8B ) * Multiplier + Addend , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_ThreeQuartersPow2 !****************************************************************************** FUNCTION Floor_Log10_Pow2 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_Pow2 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = FLOOR(LOG10(2**E)) where -5456721 <= E <= 5456721 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! base-2 exponent INTEGER ( KIND = I4B ) :: K ! base-10 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG10(2) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 41 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 661971961083_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW K = INT ( SHIFTA ( INT ( E , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_Pow2 !****************************************************************************** FUNCTION Floor_Log2_Pow10 ( K ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log2_Pow10 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = FLOOR(LOG2(10**K)) where -1838394 <= K <= 1838394 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! base-10 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG2(10) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 38 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 913124641741_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = INT ( SHIFTA ( INT ( K , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log2_Pow10 !****************************************************************************** FUNCTION Floor_Log2_Pow5 ( P ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log2_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = FLOOR(LOG2(5**P)) where -32768 <= Exp <= 32768 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! base-5 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG2(5) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 46 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 163391164108059_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = INT ( SHIFTA ( INT ( P , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log2_Pow5 !****************************************************************************** FUNCTION Floor_Log10_Pow5 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = Floor(Log10(5**E)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! ! 0 <= Exp <= 2**15 INTEGER ( KIND = I4B ) :: K !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Shift = 48 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 196742565691928_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The first value this approximation fails for is 5&#94;2621 which is just greater than 10&#94;1832. K = INT ( SHIFTR ( INT ( E , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_Pow5 !****************************************************************************** SUBROUTINE MultiplyBasic ( X , XLen , Y , YLen , Z ) !DIR$ ATTRIBUTES INLINE :: MultiplyBasic !** PURPOSE OF THIS SUBROUTINE: ! To multiply two magnitude arrays and return the result using grade-school algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: XLen ! The length of the first array INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ( 0 : XLen - 1 ) ! The first magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: YLen ! The length of the second array INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ( 0 : YLen - 1 ) ! The second magnitude array INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Z ( 0 : XLen + YLen - 1 ) ! The result array !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! min signed 64-bit !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry64 , ProductHi , ProductLo , Sum INTEGER ( KIND = I4B ) :: I , J !** FLOW Carry64 = 0_I8B DO J = 0 , YLen - 1 CALL UMul128 ( X ( 0 ), Y ( J ), ProductHi , ProductLo ) Z ( J ) = ProductLo + Carry64 IF ( IEOR ( Z ( J ), MinI64 ) < IEOR ( ProductLo , MinI64 )) THEN Carry64 = ProductHi + 1_I8B ELSE Carry64 = ProductHi END IF END DO Z ( YLen ) = Carry64 DO I = 1 , XLen - 1 Carry64 = 0_I8B DO J = 0 , YLen - 1 CALL UMul128 ( X ( I ), Y ( J ), ProductHi , ProductLo ) Sum = ProductLo + Z ( I + J ) IF ( IEOR ( Sum , MinI64 ) < IEOR ( ProductLo , MinI64 )) ProductHi = ProductHi + 1_I8B Z ( I + J ) = Sum + Carry64 IF ( IEOR ( Z ( I + J ), MinI64 ) < IEOR ( Sum , MinI64 )) THEN Carry64 = ProductHi + 1_I8B ELSE Carry64 = ProductHi END IF END DO Z ( I + YLen ) = Carry64 END DO RETURN END SUBROUTINE MultiplyBasic !****************************************************************************** SUBROUTINE ShiftRight ( X , ShiftPos ) !DIR$ ATTRIBUTES INLINE :: ShiftRight !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by the specified amount IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LargeShift , SmallShift !** FLOW IF ( ShiftPos == 0 ) RETURN LargeShift = SHIFTR ( ShiftPos , 6 ) IF ( LargeShift >= SIZE ( X )) THEN X = 0_I8B ELSE SmallShift = IAND ( ShiftPos , 63 ) IF ( LargeShift > 0 ) CALL ShiftLarge ( X , LargeShift ) IF ( SmallShift > 0 ) CALL ShiftSmall ( X , SmallShift ) END IF RETURN CONTAINS SUBROUTINE ShiftSmall ( X , Shift ) !DIR$ ATTRIBUTES FORCEINLINE :: ShiftSmall !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by the given amount (less than 64). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: I , XLen INTEGER ( KIND = I8B ) :: Nxt !** FLOW XLen = SIZE ( X ) Nxt = X ( 0 ) DO I = 0 , XLen - 2 X ( I ) = IOR ( SHIFTR ( Nxt , Shift ), SHIFTL ( X ( I + 1 ), 64 - Shift )) Nxt = X ( I + 1 ) END DO X ( XLen - 1 ) = SHIFTR ( X ( XLen - 1 ), Shift ) RETURN END SUBROUTINE ShiftSmall !****************************************************************************** SUBROUTINE ShiftLarge ( X , Shift ) !DIR$ ATTRIBUTES FORCEINLINE :: ShiftLarge !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by 64*shift, i.e. moves each ! element of the array shift positions to the right. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index , XLen !** FLOW XLen = SIZE ( X ) DO Index = 0 , XLen - Shift - 1 X ( Index ) = X ( Shift + Index ) END DO X ( XLen - Shift :) = 0_I8B RETURN END SUBROUTINE ShiftLarge !****************************************************************************** END SUBROUTINE ShiftRight !****************************************************************************** SUBROUTINE Multiply_N_ShiftRight ( X , XLen , Y , YLen , Shift , Z ) !DIR$ ATTRIBUTES INLINE :: Multiply_N_ShiftRight !** PURPOSE OF THIS SUBROUTINE: ! To perform multiplication and then rigth shift IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: XLen ! The length of the first array INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ( 0 : XLen - 1 ) ! The first magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: YLen ! The length of the second array INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ( 0 : YLen - 1 ) ! The second magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! shift position of bits in the result array INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Z ( 0 : XLen + YLen - 1 ) ! The result array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL MultiplyBasic ( X , XLen , Y , YLen , Z ) CALL ShiftRight ( Z , Shift ) RETURN END SUBROUTINE Multiply_N_ShiftRight !****************************************************************************** SUBROUTINE Increment_Value ( X ) !DIR$ ATTRIBUTES INLINE :: Increment_Value !** PURPOSE OF THIS SUBROUTINE: ! To increase value of the input by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: XLen , I INTEGER ( KIND = I8B ) :: Sum , Carry !** FLOW XLen = SIZE ( X ) Sum = X ( 0 ) + 1_I8B Carry = SHIFTR ( IOR ( IAND ( X ( 0 ), 1_I8B ), IAND ( IOR ( X ( 0 ), 1_I8B ), NOT ( Sum ))), 63 ) X ( 0 ) = Sum IF ( Carry /= 0_I8B ) THEN I = 1_I4B DO X ( I ) = X ( I ) + 1_I8B IF (. NOT .(( I < XLen ). AND .( X ( I ) == 0 ))) EXIT I = I + 1_I4B END DO END IF RETURN END SUBROUTINE Increment_Value !****************************************************************************** FUNCTION Get_Pow10_64Bits ( K ) RESULT ( Pow10 ) !DIR$ ATTRIBUTES FORCEINLINE :: Get_Pow10_64Bits !** PURPOSE OF THIS SUBROUTINE: ! To get the 64-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power INTEGER ( KIND = I8B ) :: Pow10 ! the power of ten !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10Cache ( 0 : 1 ) ! the power of ten in little-endian order !** FLOW IF (( K >= Pow10_256_Small_MinExp ). AND .( K <= Pow10_256_Small_MaxExp )) THEN ! get only the upper 64 bits Pow10 = Pow10_256_Small_Table ( 3 , K ) ELSE CALL Compute_Pow10_128Bits ( K , Pow10Cache ) ! get only the upper 64 bits Pow10 = Pow10Cache ( 1 ) END IF RETURN END FUNCTION Get_Pow10_64Bits !****************************************************************************** FUNCTION Get_Pow10_128Bits ( K ) RESULT ( Pow10 ) !DIR$ ATTRIBUTES FORCEINLINE :: Get_Pow10_128Bits !** PURPOSE OF THIS SUBROUTINE: ! To get the 128-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power TYPE ( UInt128 ) :: Pow10 ! the power of ten !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10Cache ( 0 : 1 ) ! the power of ten in little-endian order !** FLOW IF (( K >= Pow10_256_Small_MinExp ). AND .( K <= Pow10_256_Small_MaxExp )) THEN ! get only the upper 128 bits Pow10Cache ( 0 : 1 ) = Pow10_256_Small_Table ( 2 : 3 , K ) ELSE CALL Compute_Pow10_128Bits ( K , Pow10Cache ) END IF Pow10 = UInt128 ( Pow10Cache ( 1 ), Pow10Cache ( 0 )) RETURN END FUNCTION Get_Pow10_128Bits !****************************************************************************** SUBROUTINE Compute_Pow10_128Bits ( K , Pow10 ) !DIR$ ATTRIBUTES INLINE :: Compute_Pow10_128Bits !** PURPOSE OF THIS SUBROUTINE: ! To compute the 128-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Pow10 ( 0 : 1 ) ! the power of ten in little-endian order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pow10_Index , KBase , Offset , Alpha INTEGER ( KIND = I8B ) :: Pow10_Cache ( 0 : 1 ), Pow5 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Pow10_256 ( 0 : 3 ) !** FLOW ! compute essential indices Pow10_Index = ( K - Pow10_256_Compressed_MinExp ) / Pow5_128_Size KBase = Pow10_Index * Pow5_128_Size + Pow10_256_Compressed_MinExp Offset = K - KBase ! get base cache (only upper 128 bits) where table data is stored in little-endian ! order (i.e. the least significant byte is 0 and the most significant byte is 3) Pow10_Cache ( 0 : 1 ) = Pow10_256_Compressed_Table ( 2 : 3 , Pow10_Index ) IF ( Offset == 0 ) THEN Pow10 = Pow10_Cache RETURN END IF ! compute the required amount of bit-shift where Alpha should be in the range (0, 128) Alpha = Floor_Log2_Pow10 ( KBase + Offset ) - Floor_Log2_Pow10 ( KBase ) - Offset ! compute the approximation for the specified power K Pow5 = Pow5_128_Table (:, Offset ) CALL Multiply_N_ShiftRight ( Pow10_Cache , 2 , Pow5 , 2 , Alpha , Pow10_256 ) Pow10 ( 0 : 1 ) = Pow10_256 ( 0 : 1 ) CALL Increment_Value ( Pow10 ) RETURN END SUBROUTINE Compute_Pow10_128Bits !****************************************************************************** FUNCTION Handle_Invalid_String ( cStr , Start , Negative ) RESULT ( RealNum ) !** PURPOSE OF THIS SUBROUTINE: ! To handle invalid input string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start LOGICAL , INTENT ( IN ) :: Negative REAL ( KIND = SP ) :: RealNum !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Finish INTEGER ( KIND = I4B ) :: Ptr , Q !** FLOW ! Could not parse a decimal floating-point number.  Start has been ! advanced over any leading spaces. Ptr = Start Finish = LEN_TRIM ( cStr ) IF ( Start > Finish ) THEN ! empty string RealNum = IEEE_VALUE ( 0.0_SP , IEEE_QUIET_NAN ) ELSEIF ( Finish == Ptr + 2 ) THEN IF (( ToUpper ( cStr ( Ptr : Ptr )) == 'N' ). AND .( ToUpper ( cStr ( Ptr + 1 : Ptr + 1 )) == 'A' ). AND . & ( ToUpper ( cStr ( Ptr + 2 : Ptr + 2 )) == 'N' )) THEN ! Exact NAN RealNum = IEEE_VALUE ( 0.0_SP , IEEE_QUIET_NAN ) ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_SP , IEEE_SIGNALING_NAN ) END IF ELSE ! Try to parse Inf, maybe with a sign Q = Ptr IF ( Q <= Finish ) THEN IF ( Is_Character_Sign ( cStr ( Q : Q ))) Q = Q + 1 END IF IF ( Finish == Q + 2 ) THEN IF (( ToUpper ( cStr ( Q : Q )) == 'I' ). AND .( ToUpper ( cStr ( Q + 1 : Q + 1 )) == 'N' ). AND . & ( ToUpper ( cStr ( Q + 2 : Q + 2 )) == 'F' )) THEN IF ( Negative ) THEN RealNum = IEEE_VALUE ( 1.0_SP , IEEE_NEGATIVE_INF ) ELSE RealNum = IEEE_VALUE ( 1.0_SP , IEEE_POSITIVE_INF ) END IF ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_SP , IEEE_SIGNALING_NAN ) END IF ELSEIF ( Finish == Q + 7 ) THEN IF (( ToUpper ( cStr ( Q : Q )) == 'I' ). AND .( ToUpper ( cStr ( Q + 1 : Q + 1 )) == 'N' ). AND . & ( ToUpper ( cStr ( Q + 2 : Q + 2 )) == 'F' ). AND .( ToUpper ( cStr ( Q + 3 : Q + 3 )) == 'I' ). AND . & ( ToUpper ( cStr ( Q + 4 : Q + 4 )) == 'N' ). AND .( ToUpper ( cStr ( Q + 5 : Q + 5 )) == 'I' ). AND . & ( ToUpper ( cStr ( Q + 6 : Q + 6 )) == 'T' ). AND .( ToUpper ( cStr ( Q + 7 : Q + 7 )) == 'Y' )) THEN IF ( Negative ) THEN RealNum = IEEE_VALUE ( 1.0_SP , IEEE_NEGATIVE_INF ) ELSE RealNum = IEEE_VALUE ( 1.0_SP , IEEE_POSITIVE_INF ) END IF ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_SP , IEEE_SIGNALING_NAN ) END IF ELSE ! Invalid input RealNum = IEEE_VALUE ( 0.0_SP , IEEE_SIGNALING_NAN ) END IF END IF RETURN CONTAINS FUNCTION Is_Character_Sign ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is a 'sign' character IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN =* ), PARAMETER :: SET_SIGNS = '+-' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_SIGNS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Sign !************************************************************************** FUNCTION ToUpper ( ChrIn ) RESULT ( ChrOut ) !** PURPOSE OF THIS SUBROUTINE: ! To change case of the input character to upper case if applicable IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: ChrIn CHARACTER ( LEN = 1 ) :: ChrOut !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN =* ), PARAMETER :: SET_ALPHABETS_LOWER = 'abcdefghijklmnopqrstuvwxyz' CHARACTER ( LEN =* ), PARAMETER :: SET_ALPHABETS_UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ID !** FLOW: ID = INDEX ( SET_ALPHABETS_LOWER , ChrIn ) IF ( ID > 0 ) THEN ChrOut = SET_ALPHABETS_UPPER ( ID : ID ) ELSE ChrOut = ChrIn END IF RETURN END FUNCTION ToUpper !************************************************************************** END FUNCTION Handle_Invalid_String !****************************************************************************** !------------------------------------------------------------------------------ ! !           (RAW) FLOATING-POINT BINARY REPRESENTATION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RawFP_BiasedExponent ( RawVal ) RESULT ( BiasedExponent ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_BiasedExponent !** PURPOSE OF THIS SUBROUTINE: ! To determine the biased exponent of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I4B ) :: BiasedExponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BiasedExponent = INT ( SHIFTR ( IAND ( RawVal , ExponentMask ), SignificandBits ), KIND = I4B ) RETURN END FUNCTION RawFP_BiasedExponent !****************************************************************************** FUNCTION RawFP_Significand ( RawVal ) RESULT ( Significand ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Significand !** PURPOSE OF THIS SUBROUTINE: ! To determine the significand of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I4B ) :: Significand !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Significand = IAND ( RawVal , SignificandMask ) RETURN END FUNCTION RawFP_Significand !****************************************************************************** FUNCTION RawFP_Construct ( FpBin ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Construct !** PURPOSE OF THIS SUBROUTINE: ! To construct a raw binary floating point number based on ! its three parts IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BinRep ), INTENT ( IN ) :: FpBin INTEGER ( KIND = I4B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! set sign bit IF ( FpBin % Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( INT ( FpBin % Exponent , KIND = I4B ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( FpBin % Significand , SignificandMask )) RETURN END FUNCTION RawFP_Construct !****************************************************************************** FUNCTION RawFP_FromFloat ( RealVal ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_FromFloat !** PURPOSE OF THIS SUBROUTINE: ! To construct a raw binary floating point number based on ! the specified real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: RealVal INTEGER ( KIND = I4B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: IntVal REAL ( KIND = SP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW FloatVal = RealVal RawVal = IntVal RETURN END FUNCTION RawFP_FromFloat !****************************************************************************** FUNCTION RawFP_ToFloat ( RawVal ) RESULT ( RealVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_ToFloat !** PURPOSE OF THIS SUBROUTINE: ! To convert a raw binary floating point number into ! its equivalent real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: RawVal REAL ( KIND = SP ) :: RealVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: IntVal REAL ( KIND = SP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW IntVal = RawVal RealVal = FloatVal RETURN END FUNCTION RawFP_ToFloat !****************************************************************************** FUNCTION RawFP_SetZero ( Negative ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetZero !** PURPOSE OF THIS SUBROUTINE: ! To set value to zero IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I4B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = 0_I4B END IF RETURN END FUNCTION RawFP_SetZero !****************************************************************************** FUNCTION RawFP_SetInfinity ( Negative ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetInfinity !** PURPOSE OF THIS SUBROUTINE: ! To set value to infinity IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I4B ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exponent !** FLOW ! set sign of infinity RawVal = RawFP_SetZero ( Negative ) ! set infinity biased exponent Exponent = IAND ( SHIFTL ( INT ( MaxExponent , KIND = I4B ), SignificandBits ), ExponentMask ) RawVal = IAND ( RawVal , NOT ( ExponentMask )) RawVal = IOR ( RawVal , Exponent ) RETURN END FUNCTION RawFP_SetInfinity !****************************************************************************** !------------------------------------------------------------------------------ ! !               HIGH-PRECISION DECIMAL (HPDECIMAL) ROUTINES ! !------------------------------------------------------------------------------ FUNCTION HPDec_Should_Round_Up ( HP , RoundToDigit ) RESULT ( Flag ) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: RoundToDigit LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( RoundToDigit < 0 ). OR .( RoundToDigit >= HP % NumDigits )) THEN Flag = FalseVal RETURN END IF ! If we're right in the middle and there are no extra digits IF (( HP % Digits ( RoundToDigit ) == 5 ) . AND .( RoundToDigit + 1 == HP % NumDigits )) THEN ! Round up if we've truncated (since that means the result is slightly ! higher than what's represented.) IF ( HP % Truncated ) THEN Flag = TrueVal RETURN END IF ! If this exactly halfway, round to even. IF ( RoundToDigit == 0 ) THEN ! When the input is \".5\". Flag = FalseVal RETURN END IF Flag = MOD ( HP % Digits ( RoundToDigit - 1 ), 2 ) /= 0 RETURN END IF ! If there are digits after roundToDigit, they must be non-zero since we ! trim trailing zeroes after all operations that change digits. Flag = HP % Digits ( RoundToDigit ) >= 5 RETURN END FUNCTION HPDec_Should_Round_Up !****************************************************************************** FUNCTION HPDec_Get_Num_New_Digits ( HP , LShiftAmount ) RESULT ( NewDigits ) ! Takes an amount to left shift and returns the number of new digits needed ! to store the result based on LEFT_SHIFT_DIGIT_TABLE. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: LShiftAmount INTEGER ( KIND = I4B ) :: NewDigits !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = :), ALLOCATABLE :: PowerOfFive INTEGER ( KIND = I1B ) :: CurDigit , P5Digit INTEGER ( KIND = I4B ) :: Indx INTEGER ( KIND = I4B ) :: Length !** FLOW Length = LShift_Length ( LShiftAmount ) PowerOfFive = LShift_PowFive ( LShiftAmount )( 1 : Length ) NewDigits = LShift_Digits ( LShiftAmount ) Indx = 1 DO WHILE ( Indx <= Length ) IF ( Indx > HP % NumDigits ) THEN NewDigits = NewDigits - 1 RETURN END IF P5Digit = INT ( IACHAR ( PowerOfFive ( Indx : Indx )) - A0 , KIND = I1B ) CurDigit = HP % Digits ( Indx - 1 ) IF ( CurDigit /= P5Digit ) THEN IF ( CurDigit < P5Digit ) NewDigits = NewDigits - 1 RETURN END IF Indx = Indx + 1 END DO RETURN END FUNCTION HPDec_Get_Num_New_Digits !****************************************************************************** SUBROUTINE HPDec_Trim_Trailing_Zeroes ( HP ) ! Trim all trailing 0s !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW DO WHILE (( HP % NumDigits > 0 ). AND .( HP % Digits ( HP % NumDigits - 1 ) == 0 )) HP % NumDigits = HP % NumDigits - 1 END DO IF ( HP % NumDigits == 0 ) THEN HP % DecimalPoint = 0 END IF RETURN END SUBROUTINE HPDec_Trim_Trailing_Zeroes !****************************************************************************** SUBROUTINE HPDec_Right_Shift ( HP , ShiftAmount ) ! Perform a digitwise binary non-rounding right shift on this value by ShiftAmount. ! The ShiftAmount can't be more than MAX_SHIFT_AMOUNT to prevent overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftAmount !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ReadIndx INTEGER ( KIND = I4B ) :: WriteIndx INTEGER ( KIND = I8B ) :: Accumulator INTEGER ( KIND = I8B ) :: ShiftMask INTEGER ( KIND = I8B ) :: ReadDigit INTEGER ( KIND = I8B ) :: WriteDigit !** FLOW ! initialize ReadIndx = 0 WriteIndx = 0 Accumulator = 0_I8B ShiftMask = SHIFTL ( 1_I8B , ShiftAmount ) - 1_I8B ! Warm Up phase: we don't have enough digits to start writing, so just ! read them into the Accumulator. DO WHILE ( SHIFTR ( Accumulator , ShiftAmount ) == 0_I8B ) ReadDigit = 0_I8B ! If there are still digits to read, read the next one, else the digit is ! assumed to be 0. IF ( ReadIndx < HP % NumDigits ) ReadDigit = HP % Digits ( ReadIndx ) Accumulator = Accumulator * 10_I8B + ReadDigit ReadIndx = ReadIndx + 1 END DO ! Shift the decimal point by the number of digits it took to fill the ! Accumulator. HP % DecimalPoint = HP % DecimalPoint - ( ReadIndx - 1 ) ! Middle phase: we have enough digits to write, as well as more digits to ! read. Keep reading until we run out of digits. DO WHILE ( ReadIndx < HP % NumDigits ) ReadDigit = HP % Digits ( ReadIndx ) WriteDigit = SHIFTR ( Accumulator , ShiftAmount ) Accumulator = IAND ( Accumulator , ShiftMask ) HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) Accumulator = Accumulator * 10_I8B + ReadDigit ReadIndx = ReadIndx + 1 WriteIndx = WriteIndx + 1 END DO ! Cool Down phase: All of the readable digits have been read, so just write ! the remainder, DO WHILE treating any more digits as 0. ! DO WHILE (Accumulator > 0_I8B) DO WHILE ( Accumulator /= 0_I8B ) ! +++ unsigned comparison +++ WriteDigit = SHIFTR ( Accumulator , ShiftAmount ) Accumulator = IAND ( Accumulator , ShiftMask ) IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) WriteIndx = WriteIndx + 1 ELSEIF ( WriteDigit /= 0_I8B ) THEN ! +++ unsigned comparison +++ HP % Truncated = TrueVal END IF Accumulator = Accumulator * 10_I8B END DO HP % NumDigits = WriteIndx CALL HP % TrimTrailingZeroes () RETURN END SUBROUTINE HPDec_Right_Shift !****************************************************************************** SUBROUTINE HPDec_Left_Shift ( HP , ShiftAmount ) ! Perform a digitwise binary non-rounding left shift on this value by ShiftAmount. ! The ShiftAmount can't be more than MAX_SHIFT_AMOUNT to prevent overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftAmount !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NewDigits INTEGER ( KIND = I4B ) :: ReadIndx INTEGER ( KIND = I4B ) :: WriteIndx INTEGER ( KIND = I8B ) :: Accumulator INTEGER ( KIND = I8B ) :: NextAccumulator INTEGER ( KIND = I8B ) :: WriteDigit !** FLOW ! initialize NewDigits = HP % GetNumNewDigits ( ShiftAmount ) ReadIndx = HP % NumDigits - 1 WriteIndx = HP % NumDigits + NewDigits Accumulator = 0_I8B ! No Warm Up phase. Since we're putting digits in at the top and taking ! digits from the bottom we don't have to wait for the Accumulator to fill. ! Middle phase: while we have more digits to read, keep reading as well as ! writing. DO WHILE ( ReadIndx >= 0 ) Accumulator = Accumulator + SHIFTL ( INT ( HP % Digits ( ReadIndx ), KIND = I8B ), ShiftAmount ) ! +++ unsigned division and modulation +++ ! NextAccumulator = Accumulator / 10_I8B ! WriteDigit = Accumulator - (10_I8B * NextAccumulator) CALL UDivMod ( Accumulator , 10_I8B , NextAccumulator , WriteDigit ) WriteIndx = WriteIndx - 1 IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) ELSEIF ( WriteDigit /= 0_I8B ) THEN HP % Truncated = TrueVal END IF Accumulator = NextAccumulator ReadIndx = ReadIndx - 1 END DO ! Cool Down phase: there are no more digits to read, so just write the ! remaining digits in the Accumulator. ! DO WHILE (Accumulator > 0_I8B) DO WHILE ( Accumulator /= 0_I8B ) ! +++ unsigned comparison +++ ! +++ unsigned division and modulation +++ ! NextAccumulator = Accumulator / 10_I8B ! WriteDigit = Accumulator - (10_I8B * NextAccumulator) CALL UDivMod ( Accumulator , 10_I8B , NextAccumulator , WriteDigit ) WriteIndx = WriteIndx - 1 IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) ELSEIF ( WriteDigit /= 0_I8B ) THEN HP % Truncated = TrueVal END IF Accumulator = NextAccumulator END DO HP % NumDigits = HP % NumDigits + NewDigits IF ( HP % NumDigits > MAX_NUM_DIGITS ) THEN HP % NumDigits = MAX_NUM_DIGITS END IF HP % DecimalPoint = HP % DecimalPoint + NewDigits CALL HP % TrimTrailingZeroes () RETURN END SUBROUTINE HPDec_Left_Shift !****************************************************************************** SUBROUTINE HPDec_Construct ( HP , cStr , Start , Finish ) ! To construct 'HPDecimal' based on input string (cStr) where !   - Start is the index of the first valid numeric character, and !   - Finish is the index of the last valid character (== length of the input !     string excluding trailing space(s)) ! The routine assumes that cStr is a 'VALID' floating point string and ! Start is less than Finish. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start INTEGER ( KIND = I4B ), INTENT ( IN ) :: Finish !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) CHARACTER ( LEN =* ), PARAMETER :: SET_DIGITS = '0123456789' CHARACTER ( LEN =* ), PARAMETER :: SET_EXPONENTS = 'EeDdQq' CHARACTER ( LEN =* ), PARAMETER :: SET_SIGNS = '+-' CHARACTER ( LEN =* ), PARAMETER :: SET_INTEGERS = SET_DIGITS // SET_SIGNS !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Ptr INTEGER ( KIND = I4B ) :: Add2Exp LOGICAL :: SawDot INTEGER ( KIND = I4B ) :: TotalDigits ! This counts the digits in the number, even if ! there isn't space to store them all. !** FLOW ! initialize Ptr = Start SawDot = FalseVal TotalDigits = 0 DO WHILE (( Is_Character_Digit ( cStr ( Ptr : Ptr ))). OR .( cStr ( Ptr : Ptr ) == '.' )) IF ( cStr ( Ptr : Ptr ) == '.' ) THEN IF ( SawDot ) EXIT HP % DecimalPoint = TotalDigits SawDot = TrueVal ELSE IF (( cStr ( Ptr : Ptr ) == '0' ). AND .( HP % NumDigits == 0 )) THEN HP % DecimalPoint = HP % DecimalPoint - 1 Ptr = Ptr + 1 IF ( Ptr <= Finish ) THEN CYCLE ELSE EXIT END IF END IF TotalDigits = TotalDigits + 1 IF ( HP % NumDigits < MAX_NUM_DIGITS ) THEN HP % Digits ( HP % NumDigits ) = INT ( IACHAR ( cStr ( Ptr : Ptr )) - A0 , KIND = I1B ) HP % NumDigits = HP % NumDigits + 1 ELSEIF ( cStr ( Ptr : Ptr ) /= '0' ) THEN HP % Truncated = TrueVal END IF END IF Ptr = Ptr + 1 IF ( Ptr > Finish ) EXIT END DO IF (. NOT . SawDot ) HP % DecimalPoint = TotalDigits IF ( Ptr <= Finish ) THEN IF ( Is_Character_Exponent ( cStr ( Ptr : Ptr ))) THEN Ptr = Ptr + 1 IF ( Ptr <= Finish ) THEN IF ( Is_Character_Integer ( cStr ( Ptr : Ptr ))) THEN Add2Exp = I32_FromChar ( cStr ( Ptr :)) IF ( Add2Exp > 100000 ) THEN Add2Exp = 100000 ELSEIF ( Add2Exp < - 100000 ) THEN Add2Exp = - 100000 END IF HP % DecimalPoint = HP % DecimalPoint + Add2Exp END IF END IF ELSEIF ( Is_Character_Sign ( cStr ( Ptr : Ptr ))) THEN Add2Exp = I32_FromChar ( cStr ( Ptr :)) IF ( Add2Exp > 100000 ) THEN Add2Exp = 100000 ELSEIF ( Add2Exp < - 100000 ) THEN Add2Exp = - 100000 END IF HP % DecimalPoint = HP % DecimalPoint + Add2Exp END IF END IF CALL HP % TrimTrailingZeroes () RETURN CONTAINS FUNCTION Is_Character_Digit ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'DIGIT' set IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_DIGITS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Digit !************************************************************************** FUNCTION Is_Character_Exponent ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is an 'exponent' character IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_EXPONENTS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Exponent !************************************************************************** FUNCTION Is_Character_Integer ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'INTEGER' set IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_INTEGERS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Integer !************************************************************************** FUNCTION Is_Character_Sign ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'SIGN' set !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_SIGNS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Sign !************************************************************************** END SUBROUTINE HPDec_Construct !****************************************************************************** SUBROUTINE HPDec_Shift ( HP , Shift ) ! Binary shift left (ShiftAmount > 0) or right (ShiftAmount < 0) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftAmount !** FLOW ShiftAmount = Shift IF ( ShiftAmount > 0 ) THEN ! Left shift DO WHILE ( ShiftAmount > MAX_SHIFT_AMOUNT ) CALL HP % LeftShift ( MAX_SHIFT_AMOUNT ) ShiftAmount = ShiftAmount - MAX_SHIFT_AMOUNT END DO CALL HP % LeftShift ( ShiftAmount ) ELSEIF ( ShiftAmount < 0 ) THEN ! Right shift DO WHILE ( ShiftAmount < - MAX_SHIFT_AMOUNT ) CALL HP % RightShift ( MAX_SHIFT_AMOUNT ) ShiftAmount = ShiftAmount + MAX_SHIFT_AMOUNT END DO CALL HP % RightShift ( - ShiftAmount ) END IF RETURN END SUBROUTINE HPDec_Shift !****************************************************************************** SUBROUTINE HPDec_Round_To_UInt ( HP , ResVal ) ! Round the number represented to the closest value of UInt32. ! This is done ignoring overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: CurDigit !** FLOW ResVal = 0 CurDigit = 0 DO WHILE (( CurDigit < HP % DecimalPoint ). AND .( CurDigit < HP % NumDigits )) ResVal = ResVal * 10 + INT ( HP % Digits ( CurDigit ), KIND = I4B ) CurDigit = CurDigit + 1 END DO ! If there are implicit 0s at the end of the number, include those. DO WHILE ( CurDigit < HP % DecimalPoint ) ResVal = ResVal * 10 CurDigit = CurDigit + 1 END DO IF ( HP % ShouldRoundUp ( HP % DecimalPoint )) THEN ResVal = ResVal + 1 END IF RETURN END SUBROUTINE HPDec_Round_To_UInt !****************************************************************************** !------------------------------------------------------------------------------ ! !            MULTI-PRECISION UNSIGNED INTEGER (BIGUINT) ROUTINES ! !------------------------------------------------------------------------------ ! ----------------------------------------------------------------------------- ! -----   BigUInt Routines for FastFloat Algorithms                       ----- ! ----------------------------------------------------------------------------- FUNCTION Empty_Hi64 ( Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: Empty_Hi64 !** PURPOSE OF THIS SUBROUTINE: ! To return empty value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Truncated = FalseVal Val = 0_I8B RETURN END FUNCTION Empty_Hi64 !****************************************************************************** FUNCTION UInt64_Hi64_I ( R0 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Hi64_I !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW Truncated = FalseVal ShiftPos = LEADZ ( R0 ) Val = SHIFTL ( R0 , ShiftPos ) RETURN END FUNCTION UInt64_Hi64_I !****************************************************************************** FUNCTION UInt64_Hi64_II ( R0 , R1 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Hi64_II !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 values. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 , R1 LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW ShiftPos = LEADZ ( R0 ) IF ( ShiftPos == 0 ) THEN Truncated = R1 /= 0_I8B Val = R0 ELSE Truncated = SHIFTL ( R1 , ShiftPos ) /= 0_I8B Val = IOR ( SHIFTL ( R0 , ShiftPos ), SHIFTR ( R1 , 64 - ShiftPos )) END IF RETURN END FUNCTION UInt64_Hi64_II !****************************************************************************** FUNCTION BigUInt_IsEmpty ( Big ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether BigUInt is empty or not. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL :: Flag ! true if empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Big % Length == 0 RETURN END FUNCTION BigUInt_IsEmpty !****************************************************************************** FUNCTION BigUInt_IsNonZero ( Big , Index ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check if any limbs are non-zero after the given index. ! this needs to be done in reverse order, since the index ! is relative to the most significant limbs. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big ! BigUInt object INTEGER ( KIND = I4B ), INTENT ( IN ) :: Index ! the specified index LOGICAL :: Flag ! true if the stack is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: I , RIndex !** FLOW I = Index DO WHILE ( I < Big % Length ) RIndex = Big % Length - I - 1 IF ( Big % Digit ( RIndex ) /= 0_I8B ) THEN Flag = TrueVal RETURN END IF I = I + 1 END DO Flag = FalseVal RETURN END FUNCTION BigUInt_IsNonZero !****************************************************************************** SUBROUTINE BigUInt_Push ( Big , Value ) !** PURPOSE OF THIS SUBROUTINE: ! To append the item to the BigUInt IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value ! item to be appended !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Big % Digit ( Big % Length ) = Value Big % Length = Big % Length + 1 RETURN END SUBROUTINE BigUInt_Push !****************************************************************************** SUBROUTINE BigUInt_Extend ( Big , Span ) !** PURPOSE OF THIS SUBROUTINE: ! To append a span of items to the stack IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Span ( 0 :) ! span of items to be appended !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SpanLen ! FLOW SpanLen = SIZE ( Span ) Big % Digit ( Big % Length : Big % Length + SpanLen - 1 ) = Span ( 0 : SpanLen - 1 ) Big % Length = Big % Length + SpanLen RETURN END SUBROUTINE BigUInt_Extend !****************************************************************************** SUBROUTINE BigUInt_Normalize ( Big ) !** PURPOSE OF THIS SUBROUTINE: ! To normalize the BigUInt, so most-significant zero digits are removed. IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex ! FLOW RIndex = Big % Length - 1 IF ( RIndex >= 0 ) THEN DO WHILE ( Big % Digit ( RIndex ) == 0_I8B ) Big % Length = Big % Length - 1 RIndex = Big % Length - 1 IF ( RIndex < 0 ) EXIT END DO END IF RETURN END SUBROUTINE BigUInt_Normalize !****************************************************************************** FUNCTION ScalarAdd ( X , Y , Overflow ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To add two small integers, checking for overflow. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y LOGICAL , INTENT ( OUT ) :: Overflow INTEGER ( KIND = I8B ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! add value Z = X + Y ! check overflow Overflow = Z . ULT . X RETURN END FUNCTION ScalarAdd !****************************************************************************** FUNCTION ScalarMul ( X , Y , Carry ) RESULT ( Z_Low ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply two small integers, getting both the high and low bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Carry INTEGER ( KIND = I8B ) :: Z_Low !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Z_Hi LOGICAL :: Overflow !** FLOW CALL UMul128 ( X , Y , Z_Hi , Z_Low ) Z_Low = ScalarAdd ( Z_Low , Carry , Overflow ) IF ( Overflow ) Z_Hi = Z_Hi + 1_I8B ! cannot overflow Carry = Z_Hi RETURN END FUNCTION ScalarMul !****************************************************************************** SUBROUTINE BigUInt_SmallMul ( Big , Y ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply BigUInt by scalar value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ! value to be added !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index INTEGER ( KIND = I8B ) :: Carry !** FLOW Carry = 0_I8B DO Index = 0 , Big % Length - 1 Big % Digit ( Index ) = ScalarMul ( Big % Digit ( Index ), Y , Carry ) END DO IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_SmallMul !****************************************************************************** SUBROUTINE BigUInt_LongMul ( Big , Span ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply BigUInt and BigUInt using grade-school multiplication algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Span ( 0 :) ! span of values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SpanLen INTEGER ( KIND = I8B ) :: Z ( 0 : Big % Length + SIZE ( Span ) - 1 ) !** FLOW SpanLen = SIZE ( Span ) IF ( SpanLen /= 0 ) THEN ! perform multiplication CALL MultiplyBasic ( Big % Digit , Big % Length , Span , SpanLen , Z ) ! transfer output from the buffer back to the stack Big % Length = Big % Length + SpanLen Big % Digit ( 0 : Big % Length - 1 ) = Z ( 0 : Big % Length - 1 ) END IF CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_LongMul !****************************************************************************** SUBROUTINE BigUInt_From_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To create BigUInt from a unsigned 64-bit integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Push ( Val ) CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_From_U64 !****************************************************************************** FUNCTION BigUInt_Get_Hi64 ( Big , Truncated ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To get the high 64 bits from the vector, and if bits were truncated. ! this is to get the significant digits for the float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex !** FLOW IF ( Big % Length == 0 ) THEN Val = Empty_Hi64 ( Truncated ) ELSEIF ( Big % Length == 1 ) THEN RIndex = Big % Length - 1 Val = Uint64_Hi64_I ( Big % Digit ( RIndex ), Truncated ) ELSE RIndex = Big % Length - 1 Val = Uint64_Hi64_II ( Big % Digit ( RIndex ), Big % Digit ( RIndex - 1 ), Truncated ) Truncated = Truncated . OR . Big % IsNonZero ( 2 ) END IF RETURN END FUNCTION BigUInt_Get_Hi64 !****************************************************************************** FUNCTION BigUInt_Compare ( Big , Other ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare two big integers, returning the large value. ! assumes both are normalized. if the return value is ! negative, other is larger, if the return value is ! positive, this is larger, otherwise they are equal. ! the limbs are stored in little-endian order, so we ! must compare the limbs in ever order. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big , Other INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index !** FLOW IF ( Big % Length > Other % Length ) THEN Flag = 1 ELSEIF ( Big % Length < Other % Length ) THEN Flag = - 1 ELSE DO Index = Big % Length - 1 , 0 , - 1 ASSOCIATE ( XI => Big % Digit ( Index ), YI => Other % Digit ( Index )) IF ( XI . UGT . YI ) THEN Flag = 1 RETURN ELSEIF ( XI . ULT . YI ) THEN Flag = - 1 RETURN END IF END ASSOCIATE END DO Flag = 0 END IF RETURN END FUNCTION BigUInt_Compare !****************************************************************************** SUBROUTINE BigUInt_ShiftL ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To move the limbs left by `n` bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE PARAMETER DECLARATIONS: ! these parameters are for DigitBits = 64 INTEGER ( KIND = I4B ), PARAMETER :: LargePos = 6 INTEGER ( KIND = I4B ), PARAMETER :: SmallMask = 63 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LargeShift , SmallShift !** FLOW LargeShift = SHIFTR ( N , LargePos ) SmallShift = IAND ( N , SmallMask ) IF ( LargeShift > 0 ) CALL BigUInt_ShiftL_Limbs ( Big , LargeShift ) IF ( SmallShift > 0 ) CALL BigUInt_ShiftL_Bits ( Big , SmallShift ) RETURN CONTAINS SUBROUTINE BigUInt_ShiftL_Bits ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To shift left each limb n bits, carrying over to the new limb ! returns true if we were able to shift all the digits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index , Shl , Shr INTEGER ( KIND = I8B ) :: XI , Carry , Prev !** FLOW ! Internally, for each item, we shift left by n, and add the previous ! right shifted limb-bits. ! For example, we transform (for u8) shifted left 2, to: !      b10100100 b01000010 !      b10 b10010001 b00001000 ! ASSERT(n /= 0) ! ASSERT(n < sizeof(limb) * 8) Shl = N Shr = DigitBits - Shl Prev = 0_I8B DO Index = 0 , Big % Length - 1 XI = Big % Digit ( Index ) Big % Digit ( Index ) = IOR ( SHIFTL ( XI , Shl ), SHIFTR ( Prev , Shr )) Prev = XI END DO Carry = SHIFTR ( Prev , Shr ) IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_ShiftL_Bits !************************************************************************** SUBROUTINE BigUInt_ShiftL_Limbs ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To move the limbs left by `n` limbs. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Buffer ( 0 : Big % Length - 1 ) !** FLOW IF (. NOT . Big % IsEmpty ()) THEN ! move limbs by first copy source to buffer Buffer ( 0 : Big % Length - 1 ) = Big % Digit ( 0 : Big % Length - 1 ) ! then copy from the buffer to the destination Big % Digit ( N : Big % Length + N - 1 ) = Buffer ( 0 : Big % Length - 1 ) ! fill in empty limbs Big % Digit ( 0 : N - 1 ) = 0_I8B ! set length Big % Length = Big % Length + N END IF RETURN END SUBROUTINE BigUInt_ShiftL_Limbs !************************************************************************** END SUBROUTINE BigUInt_ShiftL !****************************************************************************** FUNCTION BigUInt_LeadZ ( Big ) RESULT ( N ) !** PURPOSE OF THIS SUBROUTINE: ! To get the number of leading zeros in the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big INTEGER ( KIND = I4B ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Big % IsEmpty ()) THEN N = 0 ELSE N = LEADZ ( Big % Digit ( Big % Length - 1 )) END IF RETURN END FUNCTION BigUInt_LeadZ !****************************************************************************** FUNCTION BigUInt_BitLen ( Big ) RESULT ( N ) !** PURPOSE OF THIS SUBROUTINE: ! To get the number of bits in the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big INTEGER ( KIND = I4B ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ !** FLOW LZ = Big % LeadZ () N = DigitBits * Big % Length - LZ RETURN END FUNCTION BigUInt_BitLen !****************************************************************************** SUBROUTINE BigUInt_Add ( Big , Y ) !** PURPOSE OF THIS SUBROUTINE: ! To add a long number to the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index INTEGER ( KIND = I8B ) :: Carry LOGICAL :: Overflow !** FLOW Index = 0 Carry = Y DO WHILE (( Carry /= 0_I8B ). AND .( Index < Big % Length )) Big % Digit ( Index ) = ScalarAdd ( Big % Digit ( Index ), Carry , Overflow ) IF ( Overflow ) THEN Carry = 1_I8B ELSE Carry = 0_I8B END IF Index = Index + 1 END DO IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_Add !****************************************************************************** SUBROUTINE BigUInt_Pow2 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 2 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % ShiftL ( Exp ) RETURN END SUBROUTINE BigUInt_Pow2 !****************************************************************************** SUBROUTINE BigUInt_Pow5 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 5 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE PARAMETER DECLARATIONS: ! multiply by a power of 5 INTEGER ( KIND = I4B ), PARAMETER :: Large_Step = 135 INTEGER ( KIND = I4B ), PARAMETER :: Small_Step = 27 INTEGER ( KIND = I4B ), PARAMETER :: Large_Length = 5 INTEGER ( KIND = I8B ), PARAMETER :: Small_Power_of_5 ( 0 : Small_Step ) = [ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '0000000000000005' , KIND = I8B ), & INT ( Z '0000000000000019' , KIND = I8B ), INT ( Z '000000000000007D' , KIND = I8B ), & INT ( Z '0000000000000271' , KIND = I8B ), INT ( Z '0000000000000C35' , KIND = I8B ), & INT ( Z '0000000000003D09' , KIND = I8B ), INT ( Z '000000000001312D' , KIND = I8B ), & INT ( Z '000000000005F5E1' , KIND = I8B ), INT ( Z '00000000001DCD65' , KIND = I8B ), & INT ( Z '00000000009502F9' , KIND = I8B ), INT ( Z '0000000002E90EDD' , KIND = I8B ), & INT ( Z '000000000E8D4A51' , KIND = I8B ), INT ( Z '0000000048C27395' , KIND = I8B ), & INT ( Z '000000016BCC41E9' , KIND = I8B ), INT ( Z '000000071AFD498D' , KIND = I8B ), & INT ( Z '0000002386F26FC1' , KIND = I8B ), INT ( Z '000000B1A2BC2EC5' , KIND = I8B ), & INT ( Z '000003782DACE9D9' , KIND = I8B ), INT ( Z '00001158E460913D' , KIND = I8B ), & INT ( Z '000056BC75E2D631' , KIND = I8B ), INT ( Z '0001B1AE4D6E2EF5' , KIND = I8B ), & INT ( Z '000878678326EAC9' , KIND = I8B ), INT ( Z '002A5A058FC295ED' , KIND = I8B ), & INT ( Z '00D3C21BCECCEDA1' , KIND = I8B ), INT ( Z '0422CA8B0A00A425' , KIND = I8B ), & INT ( Z '14ADF4B7320334B9' , KIND = I8B ), INT ( Z '6765C793FA10079D' , KIND = I8B )] INTEGER ( KIND = I8B ), PARAMETER :: Max_Native = Small_Power_of_5 ( Small_Step ) ! 7450580596923828125_I8B INTEGER ( KIND = I8B ), PARAMETER :: Large_Power_of_5 ( 0 : Large_Length - 1 ) = [ & INT ( Z '13A1D71CFF1B172D' , KIND = I8B ), INT ( Z '7F682D3DEFA07617' , KIND = I8B ), & INT ( Z '3F0131E7FF8C90C0' , KIND = I8B ), INT ( Z '917B01773FDCB9FE' , KIND = I8B ), & INT ( Z '2C06B9D16C407A7' , KIND = I8B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: IExp !** FLOW IExp = Exp ! multiply Big by 5**Large_Step DO WHILE ( IExp >= Large_Step ) CALL Big % LongMul ( Large_Power_of_5 ) IExp = IExp - Large_Step END DO ! multiply Big by 5**Small_Step DO WHILE ( IExp >= Small_Step ) CALL Big % SmallMul ( Max_Native ) IExp = IExp - Small_Step END DO ! multiply Big by 5**IExp IF ( IExp /= 0 ) CALL Big % SmallMul ( Small_Power_of_5 ( IExp )) RETURN END SUBROUTINE BigUInt_Pow5 !****************************************************************************** SUBROUTINE BigUInt_Pow10 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 10 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Pow5 ( Exp ) CALL Big % Pow2 ( Exp ) RETURN END SUBROUTINE BigUInt_Pow10 ! ----------------------------------------------------------------------------- ! -----   BigUInt Routines for YY Algorithms                              ----- ! ----------------------------------------------------------------------------- SUBROUTINE BigInt_Add_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big + Val'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx , Max INTEGER ( KIND = I8B ) :: Num , Add !** FLOW Num = Big % Digit ( 0 ) Add = Num + Val Big % Digit ( 0 ) = Add IF (( Add . UGE . Num ). OR .( Add . UGE . Val )) RETURN ! add digit Max = Big % Length DO Idx = 1 , Max - 1 IF ( Big % Digit ( Idx ) /= MaxU64 ) THEN Big % Digit ( Idx ) = Big % Digit ( Idx ) + 1_I8B RETURN END IF Big % Digit ( Idx ) = 0_I8B END DO Big % Digit ( Big % Length ) = 1_I8B Big % Length = Big % Length + 1 RETURN END SUBROUTINE BigInt_Add_U64 !****************************************************************************** SUBROUTINE BigInt_Mul_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * Val'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (cannot be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx , Max INTEGER ( KIND = I8B ) :: Hi , Lo , Carry !** FLOW ! initialize Idx = 0 Max = Big % Length Carry = 0_I8B DO WHILE ( Idx < Max ) IF ( Big % Digit ( Idx ) /= 0_I8B ) EXIT Idx = Idx + 1 END DO DO WHILE ( Idx < Max ) CALL UMul128_N_Add ( Big % Digit ( Idx ), Val , Carry , Hi , Lo ) Big % Digit ( Idx ) = Lo Carry = Hi Idx = Idx + 1 END DO IF ( Carry /= 0_I8B ) THEN Big % Digit ( Big % Length ) = Carry Big % Length = Big % Length + 1 END IF RETURN END SUBROUTINE BigInt_Mul_U64 !****************************************************************************** SUBROUTINE BigInt_Mul_Pow2 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * (2**Exp)'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! an exponent integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift , Move , Idx INTEGER ( KIND = I8B ) :: Num !** FLOW ! initialize Shift = IAND ( Exp , 63 ) ! small shift == MOD(Exp, 64) Move = SHIFTR ( Exp , 6 ) ! large shift == Exp / 64 Idx = Big % Length IF ( Shift == 0 ) THEN DO WHILE ( Idx > 0 ) Big % Digit ( Idx + Move - 1 ) = Big % Digit ( Idx - 1 ) Idx = Idx - 1 END DO Big % Length = Big % Length + Move DO WHILE ( Move /= 0 ) Move = Move - 1 Big % Digit ( Move ) = 0_I8B END DO ELSE Big % Digit ( Idx ) = 0_I8B DO WHILE ( Idx > 0 ) Num = SHIFTL ( Big % Digit ( Idx ), Shift ) Num = IOR ( Num , SHIFTR ( Big % Digit ( Idx - 1 ), ( 64 - Shift ))) Big % Digit ( Idx + Move ) = Num Idx = Idx - 1 END DO Big % Digit ( Move ) = SHIFTL ( Big % Digit ( 0 ), Shift ) IF ( Big % Digit ( Big % Length + Move ) /= 0_I8B ) THEN Big % Length = Big % Length + ( Move + 1 ) ELSE Big % Length = Big % Length + Move END IF DO WHILE ( Move /= 0 ) Move = Move - 1 Big % Digit ( Move ) = 0_I8B END DO END IF RETURN END SUBROUTINE BigInt_Mul_Pow2 !****************************************************************************** SUBROUTINE BigInt_Mul_Pow10 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * (10**Exp)'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! an exponent integer (cannot be 0) !** SUBROUTINE PARAMETER DECLARATIONS: ! Maximum exponent of exact pow10 INTEGER ( KIND = I4B ), PARAMETER :: U64_POW10_MAX_EXP = 19 ! Table: [ 10&#94;0, ..., 10&#94;19 ] INTEGER ( KIND = I8B ), PARAMETER :: U64_Pow10_Table ( 0 : U64_POW10_MAX_EXP ) = [ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B ), & INT ( Z '0000000000000064' , KIND = I8B ), INT ( Z '00000000000003E8' , KIND = I8B ), & INT ( Z '0000000000002710' , KIND = I8B ), INT ( Z '00000000000186A0' , KIND = I8B ), & INT ( Z '00000000000F4240' , KIND = I8B ), INT ( Z '0000000000989680' , KIND = I8B ), & INT ( Z '0000000005F5E100' , KIND = I8B ), INT ( Z '000000003B9ACA00' , KIND = I8B ), & INT ( Z '00000002540BE400' , KIND = I8B ), INT ( Z '000000174876E800' , KIND = I8B ), & INT ( Z '000000E8D4A51000' , KIND = I8B ), INT ( Z '000009184E72A000' , KIND = I8B ), & INT ( Z '00005AF3107A4000' , KIND = I8B ), INT ( Z '00038D7EA4C68000' , KIND = I8B ), & INT ( Z '002386F26FC10000' , KIND = I8B ), INT ( Z '016345785D8A0000' , KIND = I8B ), & INT ( Z '0DE0B6B3A7640000' , KIND = I8B ), INT ( Z '8AC7230489E80000' , KIND = I8B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Xpn !** FLOW ! initialize Xpn = Exp DO WHILE ( Xpn >= U64_POW10_MAX_EXP ) CALL BigInt_Mul_U64 ( Big , U64_Pow10_Table ( U64_POW10_MAX_EXP )) Xpn = Xpn - U64_POW10_MAX_EXP END DO IF ( Xpn /= 0 ) CALL BigInt_Mul_U64 ( Big , U64_Pow10_Table ( Xpn )) RETURN END SUBROUTINE BigInt_Mul_Pow10 !****************************************************************************** FUNCTION BigInt_Compare ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare two BigUInt. ! return -1 if 'a < b', +1 if 'a > b', 0 if 'a == b'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( IN ) :: A TYPE ( BigUInt ), INTENT ( IN ) :: B INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx !** FLOW ! first check Length components IF ( A % Length < B % Length ) THEN Flag = - 1 RETURN END IF IF ( A % Length > B % Length ) THEN Flag = + 1 RETURN END IF ! next check Digit components Idx = A % Length DO WHILE ( Idx > 0 ) Idx = Idx - 1 ASSOCIATE ( Av => A % Digit ( Idx ), Bv => B % Digit ( Idx )) IF ( Av . ULT . Bv ) THEN Flag = - 1 RETURN END IF IF ( Av . UGT . Bv ) THEN Flag = + 1 RETURN END IF END ASSOCIATE END DO Flag = 0 RETURN END FUNCTION BigInt_Compare !****************************************************************************** SUBROUTINE BigInt_Set_UIntType ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To set 'Big' with the specified unsigned integer value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Val ! an unsigned integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Big % Length = 1 Big % Digit ( 0 ) = ToUnsignedLong ( Val ) RETURN END SUBROUTINE BigInt_Set_UIntType !****************************************************************************** SUBROUTINE BigInt_Set_String ( Big , SigDec , ExpDec , cStr , Aux ) !** PURPOSE OF THIS SUBROUTINE: ! To set 'Big' with the specified floating point number string and its related information. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: ExpDec ! exponent in base 10 CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (. NOT . Aux % Truncated ) THEN ! no digit cut, set significant part only CALL BigInt_Set_UIntType ( Big , SigDec ) RETURN END IF ! some digits were cut, read them from 'SigCut' to 'SigEnd' BLOCK ! +++ local variables +++ INTEGER ( KIND = I4B ) :: Header , SigEnd , CurIdx , Length , DigitTotLen , DotPos INTEGER ( KIND = I8B ) :: CurVal LOGICAL :: DigitCut , HasDot ! +++ execution +++ ! initialize and process auxiliary string information needed Header = Aux % SigCut SigEnd = Aux % Indices ( 4 ) CurIdx = Header Length = 0 CurVal = 0_I8B DigitCut = FalseVal HasDot = TrueVal DotPos = Aux % Indices ( 3 ) - 1 IF ( SigEnd == 0 ) THEN SigEnd = Aux % Indices ( 2 ) HasDot = FalseVal DotPos = 0 END IF DigitTotLen = UIntSafeDigits + ( SigEnd - Header ) IF ( HasDot ) DigitTotLen = DigitTotLen + 1 IF ( DigitTotLen > MaxDecDigits ) THEN DigitCut = TrueVal SigEnd = SigEnd - ( DigitTotLen - ( MaxDecDigits + 1 )) IF ( Aux % Indices ( 3 ) == Aux % Indices ( 4 )) SigEnd = SigEnd - 1 DigitTotLen = ( MaxDecDigits + 1 ) END IF ExpDec = ExpDec - ( DigitTotLen - UIntSafeDigits ) ! set the truncated significand CALL BigInt_Set_UIntType ( Big , SigDec ) IF ( HasDot ) THEN ! SigCut occurred before encountering the period so we must check ! whether the current position is at the period DO WHILE ( CurIdx <= SigEnd ) IF ( CurIdx /= DotPos ) THEN CurVal = CurVal * IBase + ( IACHAR ( cStr ( CurIdx : CurIdx )) - A0 ) CurIdx = CurIdx + 1 Length = Length + 1 IF (( CurIdx > SigEnd ). AND .( DigitCut )) THEN ! The last digit must be non-zero, set it to '1' for correct rounding. CurVal = CurVal - UMOD ( CurVal , 10_I8B ) + 1_I8B END IF IF (( Length == UIntSafeDigits ). OR .( CurIdx > SigEnd )) THEN CALL Bigint_Mul_Pow10 ( Big , Length ) CALL Bigint_Add_U64 ( Big , CurVal ) CurVal = 0_I8B Length = 0 END IF ELSE CurIdx = CurIdx + 1 END IF END DO ELSE ! SigCut occurred after encountering the period so we do not need to check ! whether the current position is at the period DO WHILE ( CurIdx <= SigEnd ) CurVal = CurVal * IBase + ( IACHAR ( cStr ( CurIdx : CurIdx )) - A0 ) CurIdx = CurIdx + 1 Length = Length + 1 IF (( CurIdx > SigEnd ). AND .( DigitCut )) THEN ! The last digit must be non-zero, set it to '1' for correct rounding. CurVal = CurVal - UMOD ( CurVal , 10_I8B ) + 1_I8B END IF IF (( Length == UIntSafeDigits ). OR .( CurIdx > SigEnd )) THEN CALL Bigint_Mul_Pow10 ( Big , Length ) CALL Bigint_Add_U64 ( Big , CurVal ) CurVal = 0_I8B Length = 0 END IF END DO END IF END BLOCK RETURN END SUBROUTINE BigInt_Set_String !****************************************************************************** !------------------------------------------------------------------------------ ! !            PARSING FLOATING-POINT-NUMBER STRING ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Fortran_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid Fortran real (floating point) number that has one of the two following forms: ! 1. A number without exponent part -> [S]N[N...] ! 2. A number with exponent part    -> [S]N[N...]E[S]N[N...] !   Where !   [ ] indicates an optional field !   S is a sign indicator (required if negative '-', optional if positive '+'). !   N is a decimal digit (0 through 9). A decimal point may appear anywhere !       after the sign (but before the exponent). !   E is an exponent indicator (either 'e' or 'E') ! The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. ! 1. A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. ! 2. The optional kind parameter (_k) is not allowed here. ! ! Note: Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" !   and \"1.23   \" are considered valid.  However, no space is allowed inside !   the supposedly valid number.  For instance, \"1 .2 3\" is considered NOT valid. !   Therefore, this routine is not totally compatible with Fortran READ statement !   where spaces inside the valid number are allowed. !   However, this can easily be done by adding an optional 'Inside Space' flag that !   provide an interpretation of the spaces as 'zero' or 'ignored'.  Then, the input !   will be pre-processed according to the flag.  Nonetheless, this routine neglects !   this optional input because it will make the routine much less efficient due to !   the fact that we will need to scan the whole string twice and we will also need !   to copy the input string into a buffer string and working with the buffer instead !   of directly handling the input string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 9 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigLimit INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: AtLeastOneDigit , Truncated !** FLOW ! initialize SigDec = 0_I4B ExpDec = 0 Valid = FalseVal AtLeastOneDigit = FalseVal Truncated = FalseVal StrLen = LEN_TRIM ( cStr ) ! get valid string length by removing the trailing space(s) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF END IF ! check for sign of the significand NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or a dot CurChr => cStr ( Indx : Indx ) IF ((( CurChr < '0' ). OR .( CurChr > '9' )). AND .( CurChr /= '.' )) THEN ! current character is neither a digit nor a dot Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit or the dot.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN AtLeastOneDigit = TrueVal ! the current digit is zero so loop through the following ! characters until a non-zero character is found DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF ! compute for the significand in the integral part IntegralStart = 0 IntegralEnd = 0 SigCount = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal IntegralStart = Indx DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN IF ( AtLeastOneDigit ) THEN Valid = TrueVal ELSE ! this happens when not a number is encountered (i.e. the first non-blank character ! is not a sign, a digit or a period) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid input: the first non-blank character is not a sign, a digit or a period.' END IF RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (. NOT .(( CurChr == 'e' ). OR .( CurChr == 'E' ))) THEN ! the current character is NOT an exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: invalid character after a digit.' RETURN END IF Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr == '+' ). OR .( CurChr == '-' )) THEN IF ( CurChr == '-' ) ESign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ! check whether the following character is a digit CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ELSE IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent indicator.' RETURN END IF END IF ! here the current character is a digit so this is likely a valid number ExpDec = ( IACHAR ( CurChr ) - A0 ) DO Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! there is a non-integer character after the exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: not a digit after the exponent(+sign) indicator(s).' RETURN END IF ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT END DO END IF END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = 0_I4B SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_Fortran_String !****************************************************************************** FUNCTION Parse_JSON_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid JSON real (floating point) number where its differences ! from Fortran number are as follows: !   1. leading and trailing spaces are not allowed. !   2. a plus sign as the first character is not allowed. !   3. leading zero(s) is not allowed (if 0 is the first character, the second one !      must either be a period or an exponent indicator.) !   4. a period must be followed by at least one digit. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 9 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigLimit INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: Truncated !** FLOW ! initialize SigDec = 0_I4B ExpDec = 0 Valid = FalseVal Truncated = FalseVal StrLen = LEN ( cStr ) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check for sign of the significand NegSign = FalseVal Indx = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the current (leading) digit is zero Indx = Indx + 1 IF ( Indx > StrLen ) THEN ! only a zero digit encountered Valid = TrueVal RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN ! leading zero cannot be followed by an integer (i.e. no leading zeros) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is/are not allowed.' RETURN END IF IntegralStart = 0 IntegralEnd = 0 SigCount = 0 ELSE ! check whether the current character is a non-zero digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! must start with an integer IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a leading character is not a digit.' RETURN END IF ! compute for the significand in the integral part IntegralStart = Indx SigDec = IACHAR ( cStr ( Indx : Indx )) - A0 Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN ! this should not happen here since the algorithm implemented above should take care of this already? IF ( PRESENT ( ErrMsg )) ErrMsg = 'There must be something wrong with the implementation.' RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (. NOT .(( CurChr == 'e' ). OR .( CurChr == 'E' ))) THEN ! the current character is NOT an exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: invalid character after a digit.' RETURN END IF Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr == '+' ). OR .( CurChr == '-' )) THEN IF ( CurChr == '-' ) ESign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ! check whether the following character is a digit CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ELSE IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent indicator.' RETURN END IF END IF ! here the current character is a digit so this is likely a valid number ExpDec = ( IACHAR ( CurChr ) - A0 ) DO Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! there is a non-integer character after the exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: not a digit after the exponent(+sign) indicator(s).' RETURN END IF ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT END DO END IF END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = 0_I4B SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_JSON_String !****************************************************************************** FUNCTION Parse_FPlus_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid Fortran real (floating point) number with more relaxed rules than ! those used in \"Parse_Fortran_Number\" routine. ! The relaxed rules consider the following numbers as valid: !   1. a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' !      in place of 'e' or 'E'. !   2. a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to !      be expressed in a valid number expressed in the scientific format !   3. digits before any invalid character encountered are treated as a valid number !      and any characters after the first encounter (including the first invalid one) !      are neglected.  therefore, for example, a '12.56ax-300' is considered to be !      a valid number with value of 12.56. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 9 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigLimit INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: AtLeastOneDigit , Truncated !** FLOW ! initialize SigDec = 0_I4B ExpDec = 0 Valid = FalseVal AtLeastOneDigit = FalseVal Truncated = FalseVal StrLen = LEN_TRIM ( cStr ) ! get valid string length by removing the trailing space(s) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF END IF ! check for sign of the significand NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or a dot CurChr => cStr ( Indx : Indx ) IF ((( CurChr < '0' ). OR .( CurChr > '9' )). AND .( CurChr /= '.' )) THEN ! current character is neither a digit nor a dot Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit or the dot.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN AtLeastOneDigit = TrueVal ! the current digit is zero so loop through the following ! characters until a non-zero character is found DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF ! compute for the significand in the integral part IntegralStart = 0 IntegralEnd = 0 SigCount = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal IntegralStart = Indx DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT SigDec = SigDec * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN IF ( AtLeastOneDigit ) THEN Valid = TrueVal ELSE ! this happens when not a number is encountered (i.e. the first non-blank character ! is not a sign, a digit or a period) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid input: the first non-blank character is not a sign, a digit or a period.' END IF RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN DO SELECT CASE ( cStr ( Indx : Indx )) CASE ( 'e' , 'E' , 'd' , 'D' , 'q' , 'Q' ) Indx = Indx + 1 ! check for a sign of the exponent IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF ( CurChr == '-' ) THEN ESign = - 1 Indx = Indx + 1 ELSEIF ( CurChr == '+' ) THEN Indx = Indx + 1 END IF ELSE EXIT END IF CASE ( '-' ) ESign = - 1 Indx = Indx + 1 CASE ( '+' ) Indx = Indx + 1 CASE DEFAULT EXIT END SELECT IF ( Indx <= StrLen ) THEN DO CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT Indx = Indx + 1 IF ( Indx > StrLen ) EXIT END DO END IF EXIT END DO END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = 0_I4B SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_FPlus_String !****************************************************************************** !------------------------------------------------------------------------------ ! !                       BINARY-TO-DECIMAL CONVERSION ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 LOGICAL :: Include_Left_Endpoint , Include_Right_Endpoint INTEGER ( KIND = I4B ) :: Minus_K , Beta INTEGER ( KIND = I4B ) :: DeltaI , R , Dist INTEGER ( KIND = I4B ) :: Two_Fl , Two_Fc INTEGER ( KIND = I4B ) :: ZMul_Val LOGICAL :: ZMul_IsInteger LOGICAL :: XMul_IsInteger , XMul_Parity LOGICAL :: YMul_IsInteger , Approx_Y_Parity LOGICAL :: Divisible_By_Small_Divisor !** FLOW: ! Step 1: integer promotion & Schubfach multiplier calculation. ! Check if normal. IF (( ExpRaw /= 0 ). AND .( SigRaw == 0_I4B )) THEN CALL Shorter_Interval_Case ( ExpBin , SigDec , ExpDec ) RETURN END IF Include_Left_Endpoint = ( IAND ( SigBin , 1_I4B ) == 0_I4B ) Include_Right_Endpoint = Include_Left_Endpoint ! Compute K and Beta as well as get cached data Minus_K = Floor_Log10_Pow2 ( ExpBin ) - Kappa Beta = ExpBin + Floor_Log2_Pow10 ( - Minus_K ) Pow10 = Get_Pow10_64Bits ( - Minus_K ) IF ( Minus_K > 0 ) Pow10 = Pow10 + 1_I8B ! Compute Zi and Deltai. ! 10**Kappa <= Deltai < 10**(Kappa + 1) DeltaI = Compute_Delta ( Pow10 , Beta ) Two_Fc = SHIFTL ( SigBin , 1 ) ! For the case of binary32, the result of integer check is not correct for ! 29711844 * 2&#94;-82 ! = 6.1442653300000000008655037797566933477355632930994033813476... * 10&#94;-18 ! and 29711844 * 2&#94;-81 ! = 1.2288530660000000001731007559513386695471126586198806762695... * 10&#94;-17, ! and they are the unique counterexamples. However, since 29711844 is even, ! this does not cause any problem for the endpoints calculations; it can only ! cause a problem when we need to perform integer check for the center. ! Fortunately, with these inputs, that branch is never executed, so we are ! fine. CALL Compute_Mul ( SHIFTL ( IOR ( Two_Fc , 1_I4B ), Beta ), Pow10 , ZMul_Val , ZMul_IsInteger ) ! Step 2: Try larger divisor; remove trailing zeros if necessary. ! Using an upper bound on zi, we might be able to optimize the division ! better than the compiler; we are computing zi / big_divisor here. SigDec = Divide_By_10_To_Kappa_Plus_1 ( ZMul_Val ) R = ZMul_Val - Big_Divisor * SigDec ! implicit conversion if necessary IF ( R . ULT . DeltaI ) THEN ! Exclude the right endpoint if necessary. IF (( R == 0 ). AND . ZMul_IsInteger . AND .(. NOT . Include_Right_Endpoint )) THEN SigDec = SigDec - 1_I4B R = Big_Divisor ! must perform Step 3 ELSE ExpDec = Minus_K + Kappa + 1 RETURN END IF ELSEIF ( R == DeltaI ) THEN ! r == deltai; compare fractional parts. Two_Fl = Two_Fc - 1_I4B XMul_Parity = Compute_Mul_Parity ( Two_Fl , Pow10 , Beta , XMul_IsInteger ) IF ((. NOT . Include_Left_Endpoint ). OR .( ExpBin < Case_Fc_Pm_Half_Lower_Threshold ). OR . & ( ExpBin > Divisibility_Check_By_5_Threshold )) THEN ! If the left endpoint is not included, the condition for ! success is z&#94;(f) < delta&#94;(f) (odd parity). ! Otherwise, the inequalities on exponent ensure that ! x is not an integer, so if z&#94;(f) >= delta&#94;(f) (even parity), we in fact ! have strict inequality. IF ( XMul_Parity ) THEN ExpDec = Minus_K + Kappa + 1 RETURN END IF ! must perform Step 3 ELSE IF ( XMul_Parity . OR . XMul_IsInteger ) THEN ExpDec = Minus_K + Kappa + 1 RETURN END IF ! must perform Step 3 END IF ELSE ! must perform Step 3 END IF ! Step 3: Find the significand with the smaller divisor SigDec = SigDec * TenUInt ExpDec = Minus_K + Kappa Dist = R - SHIFTR ( DeltaI , 1 ) + Half_Small_Divisor Approx_Y_Parity = IAND ( IEOR ( Dist , Half_Small_Divisor ), 1 ) /= 0 Divisible_By_Small_Divisor = Is_Divisible_By_Pow10 ( Dist ) ! Add dist / 10&#94;kappa to the significand. SigDec = SigDec + Dist ! Is dist divisible by 10&#94;kappa? IF ( Divisible_By_Small_Divisor ) THEN ! Check z&#94;(f) >= epsilon&#94;(f). ! We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1, ! where yi == zi - epsiloni if and only if z&#94;(f) >= epsilon&#94;(f) ! Since there are only 2 possibilities, we only need to care about the ! parity. Also, zi and r should have the same parity since the divisor ! is an even number. IF ( Compute_Mul_Parity ( Two_Fc , Pow10 , Beta , YMul_IsInteger ) . NEQV . Approx_Y_Parity ) THEN SigDec = SigDec - 1_I4B ELSE ! If z&#94;(f) >= epsilon&#94;(f), we might have a tie ! when z&#94;(f) == epsilon&#94;(f), or equivalently, when y is an integer IF ( YMul_IsInteger ) THEN IF ( IAND ( SigDec , 1_I4B ) /= 0_I4B ) SigDec = SigDec - 1_I4B END IF END IF END IF RETURN CONTAINS SUBROUTINE Compute_Mul ( U , Pow10 , ResHi , IsInteger ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the multiplication of U and Pow10 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: U INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ResHi LOGICAL , INTENT ( OUT ) :: IsInteger !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Output !** FLOW Output = UMul96_Upper64 ( U , Pow10 ) ResHi = INT ( IAND ( SHIFTR ( Output , 32 ), MaskU32 ), KIND = I4B ) IsInteger = INT ( IAND ( Output , MaskU32 ), KIND = I4B ) == 0 RETURN END SUBROUTINE Compute_Mul !************************************************************************** FUNCTION Compute_Mul_Parity ( Two_F , Pow10 , Beta , IsInteger ) RESULT ( Parity ) !** PURPOSE OF THIS SUBROUTINE: ! To check multiplication parity IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Two_F INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta LOGICAL , INTENT ( OUT ) :: IsInteger LOGICAL :: Parity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Output !** FLOW Output = UMul96_Lower64 ( Two_F , Pow10 ) Parity = IAND ( SHIFTR ( Output , ( 64 - Beta )), 1_I8B ) /= 0_I8B IsInteger = INT ( IAND ( SHIFTR ( Output , ( 32 - Beta )), MaskU32 ), KIND = I4B ) == 0 RETURN END FUNCTION Compute_Mul_Parity !************************************************************************** FUNCTION Is_Divisible_By_Pow10 ( N ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To replace N by Floor(N / Pow(10, M)) returning true if and only if N is ! divisible by pow(10, M). ! Precondition: N <= Pow(10, M + 1). ! Note: M = Kappa IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: N LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The numbers below are chosen such that: !   1. floor(n/d) = floor(nm / 2&#94;k) where d=10 or d=100, !   2. nm mod 2&#94;k < m if and only if n is divisible by d, ! where m is magic_number, k is shift_amount ! and d is divisor. ! ! Item 1 is a common technique of replacing division by a constant with ! multiplication, see e.g. \"Division by Invariant Integers Using ! Multiplication\" by Granlund and Montgomery (1994). magic_number (m) is set ! to ceil(2&#94;k/d) for large enough k. ! The idea for item 2 originates from Schubfach. N = N * Magic_Number Flag = IAND ( N , Comparison_Mask ) . ULT . Magic_Number N = SHIFTR ( N , Info_Shift_Amount ) RETURN END FUNCTION Is_Divisible_By_Pow10 !************************************************************************** FUNCTION Divide_By_10_To_Kappa_Plus_1 ( N ) RESULT ( M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute M = Floor(N / 10**(Kappa + 1)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: N INTEGER ( KIND = I4B ) :: M !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW M = INT ( SHIFTR ( INT ( N , KIND = I8B ) * DivM , DivS ), KIND = I4B ) RETURN END FUNCTION Divide_By_10_To_Kappa_Plus_1 !************************************************************************** FUNCTION Compute_Delta ( Pow10 , Beta ) RESULT ( Delta ) !** PURPOSE OF THIS SUBROUTINE: ! To compute Delta IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I4B ) :: Delta !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Delta = INT ( IAND ( SHIFTR ( Pow10 , ( 64 - 1 - Beta )), MaskU32 ), KIND = I4B ) RETURN END FUNCTION Compute_Delta !************************************************************************** SUBROUTINE Shorter_Interval_Case ( Exponent , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the decimal representation ! for shorter interval case. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exponent ! The decoded value of exponent in binary INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Minus_K , Beta INTEGER ( KIND = I4B ) :: Xi , Zi INTEGER ( KIND = I8B ) :: Pow10 !** FLOW: ! Compute k and beta Minus_K = Floor_Log10_ThreeQuartersPow2 ( Exponent ) Beta = Exponent + Floor_Log2_Pow10 ( - Minus_K ) ! Compute Xi and Zi Pow10 = Get_Pow10_64Bits ( - Minus_K ) IF ( Minus_K > 0 ) Pow10 = Pow10 + 1_I8B Xi = Compute_Left_Endpoint ( Pow10 , Beta ) Zi = Compute_Right_Endpoint ( Pow10 , Beta ) ! If the left endpoint is not an integer, increase it IF (. NOT . Is_Left_Endpoint_Integer ( Exponent )) Xi = Xi + 1_I4B ! Try bigger divisor SigDec = Zi . UDIV . TenUInt ! If succeed, remove trailing zeros if necessary and return IF ( SigDec * TenUInt . UGE . Xi ) THEN ExpDec = Minus_K + 1 ExpDec = ExpDec RETURN END IF ! Otherwise, compute the round-up of y SigDec = Compute_Round_Up ( Pow10 , Beta ) ExpDec = Minus_K ! When tie occurs, choose one of them according to the rule IF ( Exponent >= Shorter_Interval_Tie_Lower_Threshold . AND . & Exponent <= Shorter_Interval_Tie_Upper_Threshold ) THEN IF ( IAND ( SigDec , 1_I4B ) /= 0_I4B ) SigDec = SigDec - 1_I4B ! Round to even. ELSEIF ( SigDec . ULT . Xi ) THEN SigDec = SigDec + 1_I4B END IF RETURN END SUBROUTINE Shorter_Interval_Case !************************************************************************** FUNCTION Compute_Left_Endpoint ( Pow10 , Beta ) RESULT ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the left end point (Xi) for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I4B ) :: X !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW X = INT ( IAND ( SHIFTR (( Pow10 - SHIFTR ( Pow10 , ( SignificandBits + 2 ))), & ( TotalBits * 2 - SignificandBits - 1 - Beta )), & MaskU32 ), KIND = I4B ) RETURN END FUNCTION Compute_Left_Endpoint !************************************************************************** FUNCTION Compute_Right_Endpoint ( Pow10 , Beta ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the right end point (Zi) for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I4B ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Z = INT ( IAND ( SHIFTR (( Pow10 + SHIFTR ( Pow10 , ( SignificandBits + 1 ))), & ( TotalBits * 2 - SignificandBits - 1 - Beta )), & MaskU32 ), KIND = I4B ) RETURN END FUNCTION Compute_Right_Endpoint !************************************************************************** FUNCTION Compute_Round_Up ( Pow10 , Beta ) RESULT ( Y ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the rounded-up value of Yi for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I4B ) :: Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Y = SHIFTR ( INT ( IAND ( SHIFTR ( Pow10 , ( TotalBits * 2 - SignificandBits - 2 - Beta )), & MaskU32 ), KIND = I4B ) + 1 , 1 ) RETURN END FUNCTION Compute_Round_Up !************************************************************************** FUNCTION Is_Left_Endpoint_Integer ( E ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To chaeck whether the left end point (Xi) is an integer for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = (( E >= Case_Shorter_Interval_Left_Endpoint_Lower_Threshold ) . AND . & ( E <= Case_Shorter_Interval_Left_Endpoint_Upper_Threshold )) RETURN END FUNCTION Is_Left_Endpoint_Integer !************************************************************************** END SUBROUTINE Bin2Dec_DragonBox !****************************************************************************** SUBROUTINE Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: REAL ( KIND = DP ), PARAMETER :: Log2Base5 = LOG ( 2.0_DP ) / LOG ( 5.0_DP ) INTEGER ( KIND = I4B ), PARAMETER :: QLimit = FLOOR ( Log2Base5 * BinaryPrecision ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: E2 INTEGER ( KIND = I4B ) :: M2 LOGICAL :: Even , AcceptBounds INTEGER ( KIND = I4B ) :: MV , MP , MM INTEGER ( KIND = I4B ) :: Vr , Vp , Vm INTEGER ( KIND = I4B ) :: VrDiv10 , VpDiv10 , VmDiv10 INTEGER ( KIND = I4B ) :: VrMod10 , VmMod10 INTEGER ( KIND = I4B ) :: E10 , Q LOGICAL :: VmIsTrailingZeros , VrIsTrailingZeros , DecrementVp INTEGER ( KIND = I4B ) :: Removed , LastRemovedDigit !** FLOW ! We subtract 2 in all cases so that the bounds computation has 2 additional bits. E2 = ExpBin - 2 M2 = SigBin Even = IAND ( M2 , 1_I4B ) == 0_I4B AcceptBounds = Even ! Step 2: Determine the interval of legal decimal representations. ! Implicit bool -> int conversion. True is 1, false is 0. MV = M2 * FourUInt MP = MV + TwoUInt ! check whether Cb is closer to the lower bound IF (( SigRaw == 0_I4B ). AND .( ExpRaw > 1 )) THEN ! closer to the lower bound; irregular spacing MM = MV - 1_I4B ELSE ! not closer to the lower bound; regular spacing MM = MV - TwoUInt END IF ! Step 3: Convert to a decimal power base using 128-bit arithmetic. VmIsTrailingZeros = FalseVal VrIsTrailingZeros = FalseVal DecrementVp = FalseVal IF ( E2 >= 0 ) THEN ! We need (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 ! and we need to remove at least Q' = LOG10(2**E2) digits from the ! scaled values Vm, Vr, Vp, i.e. we want to compute !  (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**Q' !               = (MM, MV, MP) * 2**E2 / 10**(E10) !               = (MM, MV, MP) * 5**(-E10) / 2**(E10 - E2) ! However, to correctly round the result we need to know the value of ! the last removed digit.  We therefore remove only Q = Q' - 1 digits in ! the first step and make sure that we execute the loop below at least ! once and determine the correct value of the last removed digit. Q = Floor_Log10_Pow2 ( E2 ) E10 = Q ! Determine whether all the removed digits are 0. ! ! Z(X, E2, Q) = MOD((X * 2**E2), 10**Q) == 0 !             = P10(X * 2**E2) >= Q !             = MIN(P2(X) + P2(E2), P5(X)) >= Q !             = P2(X) + E2 >= Q and P5(x) >= Q !             = P5(X) >= Q !             = MOD(X, 5**Q) == 0 ! QLimit = FLOOR(LOG5(2**BinaryPrecision)) IF ( Q <= QLimit ) THEN ! Only one of MP, MV, and MM can be a multiple of 5, if any. IF ( UMOD ( MV , FiveUInt ) == 0_I4B ) THEN VrIsTrailingZeros = Is_Multiple_Of_Pow5 ( MV , Q - 1 ) ELSEIF ( AcceptBounds ) THEN ! Same as min(E2 + (~MM & 1), Pow5Factor(MM)) >= Q ! <=> E2 + (~MM & 1) >= Q && Pow5Factor(MM) >= Q ! <=> true && Pow5Factor(MM) >= Q, since E2 >= Q. VmIsTrailingZeros = Is_Multiple_Of_Pow5 ( MM , Q ) ELSE ! Same as min(E2 + 1, Pow5Factor(MP)) >= Q. ! Vp -= Is_Multiple_Of_Pow5(MP, Q) DecrementVp = Is_Multiple_Of_Pow5 ( MP , Q ) END IF END IF ELSE ! We need (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**E2 ! and we need to remove at least Q' = LOG10(5**-E2) digits from the ! scaled values Vm, Vr, Vp, i.e. we want to compute !  (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**(E2 + Q') !               = (MM, MV, MP) * 2**E2 / 10**(E10), !               = (MM, MV, MP) * 5**(-E10) / 2**(E10 - E2) Q = Floor_Log10_Pow5 ( - E2 ) E10 = Q + E2 ! Determine whether all the removed digits are 0. ! ! Z(X, E2, Q) = MOD((X * 5**-E2), 10**Q) == 0 !             = MIN(P2(X), P5(X) - E2) >= Q !             = P2(X) >= Q and P5(X) - E2 >= Q !             = P2(X) >= Q !             = MOD(X, 2**Q) == 0 IF ( Q <= 1 ) THEN ! {Vr,Vp,Vm} is trailing zeros if {MV,MP,MM} has at least Q trailing 0 bits. ! MV = 4 M2, so it always has at least two trailing 0 bits. VrIsTrailingZeros = TrueVal IF ( AcceptBounds ) THEN ! MM = MV - 1 - MMShift, so it has 1 trailing 0 bit iff MMShift == 1. VmIsTrailingZeros = ( MM == ( MV - TwoUInt )) ELSE ! MP = MV + 2, so it always has at least one trailing 0 bit. DecrementVp = TrueVal END IF ELSEIF ( Q < ( TotalBits - 1 )) THEN ! TODO(ulfjack): Use a tighter bound here. ! We need to compute min(ntz(MV), Pow5Factor(MV) - E2) >= Q-1 ! <=> ntz(MV) >= Q-1  &&  Pow5Factor(MV) - E2 >= Q-1 ! <=> ntz(MV) >= Q-1    (E2 is negative and -E2 >= Q) ! <=> (MV & ((1 << (Q-1)) - 1)) == 0 ! We also need to make sure that the left shift does not overflow. VrIsTrailingZeros = Is_Multiple_Of_Pow2 ( MV , Q - 1 ) END IF END IF CALL MulPow5DivPow2 ( MM , MV , MP , - E10 , E10 - E2 , Vm , Vr , Vp ) IF ( DecrementVp ) Vp = Vp - 1_I4B ! Step 4: Find the shortest decimal representation in the interval of legal representations. Removed = 0 LastRemovedDigit = 0 VpDiv10 = Divide_By_Pow10Factor ( Vp , 10 ) CALL DivMod_By_Pow10Factor ( Vm , 10 , VmDiv10 , VmMod10 ) DO WHILE ( VpDiv10 . UGT . VmDiv10 ) VmIsTrailingZeros = VmIsTrailingZeros . AND . ( VmMod10 == 0_I4B ) VrIsTrailingZeros = VrIsTrailingZeros . AND . ( LastRemovedDigit == 0 ) CALL DivMod_By_Pow10Factor ( Vr , 10 , VrDiv10 , VrMod10 ) LastRemovedDigit = VrMod10 Vr = VrDiv10 Vp = VpDiv10 VpDiv10 = Divide_By_Pow10Factor ( Vp , 10 ) Vm = VmDiv10 CALL DivMod_By_Pow10Factor ( Vm , 10 , VmDiv10 , VmMod10 ) Removed = Removed + 1 END DO IF ( VmIsTrailingZeros ) THEN DO WHILE ( Mod_By_Pow10Factor ( Vm , 10 ) == 0_I4B ) VrIsTrailingZeros = VrIsTrailingZeros . AND . ( LastRemovedDigit == 0 ) CALL DivMod_By_Pow10Factor ( Vr , 10 , VrDiv10 , VrMod10 ) LastRemovedDigit = VrMod10 Vr = VrDiv10 Vp = Divide_By_Pow10Factor ( Vp , 10 ) Vm = Divide_By_Pow10Factor ( Vm , 10 ) Removed = Removed + 1 END DO END IF IF ( VrIsTrailingZeros . AND .( LastRemovedDigit == 5 ). AND .( Mod_By_Pow10Factor ( Vr , 2 ) == 0_I4B )) THEN ! Round even if the exact numbers is .....50..0. LastRemovedDigit = 4 END IF ! We need to take Vr+1 if Vr is outside bounds or we need to round up. SigDec = Vr IF ((( Vr == Vm ). AND .((. NOT . AcceptBounds ). OR .(. NOT . VmIsTrailingZeros ))) & . OR .( LastRemovedDigit >= 5 )) THEN SigDec = SigDec + 1_I4B END IF ExpDec = E10 + Removed RETURN CONTAINS SUBROUTINE MulPow5DivPow2 ( U , V , W , E5 , E2 , A , B , C ) !** PURPOSE OF THIS SUBROUTINE: ! To perform multipy by power of 5 and divide by power of 2 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: U , V , W INTEGER ( KIND = I4B ), INTENT ( IN ) :: E5 , E2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: A , B , C !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift INTEGER ( KIND = I8B ) :: Pow5 !** FLOW Shift = E2 - ( Floor_Log2_Pow5 ( E5 ) + 1 - BitsPerPow5 ) Pow5 = Get_Pow10_64Bits ( E5 ) IF (( E5 < Pow10_Min_Exact_Exp ). OR .( E5 > Pow10_Max_Exact_Exp )) Pow5 = Pow5 + 1_I8B A = MulShift32 ( U , Pow5 , Shift ) B = MulShift32 ( V , Pow5 , Shift ) C = MulShift32 ( W , Pow5 , Shift ) RETURN END SUBROUTINE MulPow5DivPow2 !************************************************************************** FUNCTION MulShift32 ( X , Y , J ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To perform multiplication of X and Y and then shift the product by J IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y INTEGER ( KIND = I4B ), INTENT ( IN ) :: J INTEGER ( KIND = I4B ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: A , B , Sum INTEGER ( KIND = I4B ) :: Shift !** FLOW A = ToUnsignedLong ( X ) * IAND ( Y , MaskU32 ) B = ToUnsignedLong ( X ) * SHIFTR ( Y , 32 ) Sum = B + SHIFTR ( A , 32 ) Shift = J - 32 Z = IAND ( SHIFTR ( Sum , Shift ), MaskU32 ) RETURN END FUNCTION MulShift32 !************************************************************************** FUNCTION Is_Multiple_Of_Pow5 ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Multiple_Of_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 5**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Exp <= MaxExp_ModInv5 ) THEN Flag = IsMultipleOfPow5_32Bits ( Value , Exp ) ELSE Flag = Pow5Factor_32Bits ( Value ) . UGE . Exp END IF RETURN END FUNCTION Is_Multiple_Of_Pow5 !************************************************************************** FUNCTION Is_Multiple_Of_Pow2 ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Multiple_Of_Pow2 !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 2**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IAND ( Value , SHIFTL ( 1_I4B , Exp ) - 1_I4B ) == 0_I4B RETURN END FUNCTION Is_Multiple_Of_Pow2 !************************************************************************** SUBROUTINE DivMod_By_Pow10Factor ( X , Y , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division by 5 or 10 (i.e. Y is 5 or 10). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 5 or 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: Quotient INTEGER ( KIND = I4B ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following algorithm actually can be used for all divisor (Y) Quotient = INT ( ToUnsignedLong ( X ) / ToUnsignedLong ( Y ), KIND = I4B ) Remainder = X - Quotient * Y RETURN END SUBROUTINE DivMod_By_Pow10Factor !************************************************************************** FUNCTION Divide_By_Pow10Factor ( X , Y ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division by 5 or 10. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 5 or 10 INTEGER ( KIND = I4B ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following algorithm actually can be used for all divisor (Y) Quotient = INT ( ToUnsignedLong ( X ) / ToUnsignedLong ( Y ), KIND = I4B ) RETURN END FUNCTION Divide_By_Pow10Factor !************************************************************************** FUNCTION Mod_By_Pow10Factor ( X , Y ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform modulus of 2, 5 or 10 (i.e. Y is 2 or 5 or 10. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 2, 5 or 10 INTEGER ( KIND = I4B ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following algorithm actually can be used for all divisor (Y) Remainder = INT ( MOD ( ToUnsignedLong ( X ), ToUnsignedLong ( Y )), KIND = I4B ) RETURN END FUNCTION Mod_By_Pow10Factor !************************************************************************** FUNCTION Pow5Factor_32Bits ( Value ) RESULT ( Count ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the factor of power of 5 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ) :: Count !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Dividend INTEGER ( KIND = I4B ) :: Quotient , Remainder !** FLOW Count = 0 Dividend = Value DO WHILE ( Dividend /= 0 ) CALL UDivMod ( Dividend , 5 , Quotient , Remainder ) IF ( Remainder /= 0 ) RETURN Dividend = Quotient Count = Count + 1 END DO Count = 0 RETURN END FUNCTION Pow5Factor_32Bits !************************************************************************** FUNCTION IsMultipleOfPow5_32Bits ( Value , Exp ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 5**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: ModInv5 ( 0 : 1 , 0 : MaxExp_ModInv5 ) = RESHAPE ([ & INT ( Z '00000001' , KIND = I4B ), INT ( Z 'FFFFFFFF' , KIND = I4B ), & INT ( Z 'CCCCCCCD' , KIND = I4B ), INT ( Z '33333333' , KIND = I4B ), & INT ( Z 'C28F5C29' , KIND = I4B ), INT ( Z '0A3D70A3' , KIND = I4B ), & INT ( Z '26E978D5' , KIND = I4B ), INT ( Z '020C49BA' , KIND = I4B ), & INT ( Z '3AFB7E91' , KIND = I4B ), INT ( Z '0068DB8B' , KIND = I4B ), & INT ( Z '0BCBE61D' , KIND = I4B ), INT ( Z '0014F8B5' , KIND = I4B ), & INT ( Z '68C26139' , KIND = I4B ), INT ( Z '000431BD' , KIND = I4B ), & INT ( Z 'AE8D46A5' , KIND = I4B ), INT ( Z '0000D6BF' , KIND = I4B ), & INT ( Z '22E90E21' , KIND = I4B ), INT ( Z '00002AF3' , KIND = I4B ), & INT ( Z '3A2E9C6D' , KIND = I4B ), INT ( Z '00000897' , KIND = I4B ), & INT ( Z '3ED61F49' , KIND = I4B ), INT ( Z '000001B7' , KIND = I4B ), & INT ( Z '0C913975' , KIND = I4B ), INT ( Z '00000057' , KIND = I4B ), & INT ( Z 'CF503EB1' , KIND = I4B ), INT ( Z '00000011' , KIND = I4B ), & INT ( Z 'F6433FBD' , KIND = I4B ), INT ( Z '00000003' , KIND = I4B )], [ 2 , 14 ]) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Cache ( 0 : 1 ) INTEGER ( KIND = I4B ) :: ModInverse , MaxQuotient !** FLOW Cache = ModInv5 (:, Exp ) ModInverse = Cache ( 0 ) MaxQuotient = Cache ( 1 ) Flag = Value * ModInverse . ULE . MaxQuotient RETURN END FUNCTION IsMultipleOfPow5_32Bits !************************************************************************** END SUBROUTINE Bin2Dec_Ryu !****************************************************************************** SUBROUTINE Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 INTEGER ( KIND = I4B ) :: Cb , Cbl , Cbr , Vb , Vbl , Vbr INTEGER ( KIND = I4B ) :: kExp , hExp , Exp10 LOGICAL :: uInside , wInside INTEGER ( KIND = I4B ) :: Sx , Sx4 , Sp INTEGER ( KIND = I4B ) :: Upper , Lower , Middle !** FLOW: Cb = SHIFTL ( SigBin , 2 ) Cbr = Cb + TwoUInt ! check whether Cb is closer to the lower bound IF (( SigRaw == 0_I4B ). AND .( ExpRaw > 1 )) THEN ! closer to the lower bound; irregular spacing Cbl = Cb - 1_I4B kExp = Floor_Log10_ThreeQuartersPow2 ( ExpBin ) ELSE ! not closer to the lower bound; regular spacing Cbl = Cb - TwoUInt kExp = Floor_Log10_Pow2 ( ExpBin ) END IF ! compute Exp10 and shift Exp10 = - kExp hExp = ExpBin + Floor_Log2_Pow10 ( Exp10 ) + 1 ! get the cached pow10 value from Pow10_Sig_Table or compute it Pow10 = Get_Pow10_64Bits ( Exp10 ) IF (( Exp10 < Pow10_Min_Exact_Exp ). OR .( Exp10 > Pow10_Max_Exact_Exp )) THEN Pow10 = Pow10 + 1_I8B END IF ! To perform integer multiplications and get upper bits of rounded values Vbl = Round2Odd ( Pow10 , SHIFTL ( Cbl , hExp )) Vb = Round2Odd ( Pow10 , SHIFTL ( Cb , hExp )) Vbr = Round2Odd ( Pow10 , SHIFTL ( Cbr , hExp )) IF ( IAND ( SigBin , 1_I4B ) == 0_I4B ) THEN Lower = Vbl Upper = Vbr ELSE Lower = Vbl + 1_I4B Upper = Vbr - 1_I4B END IF Sx = SHIFTR ( Vb , 2 ) ! Sx = Vb / 4 IF ( Sx . UGE . TenUInt ) THEN ! Vb >= 40 Sp = Sx . UDIV . TenUInt ! Vb / 40 Sx4 = FortyUInt * Sp uInside = ( Lower . ULE . Sx4 ) wInside = ( Upper . UGE . ( Sx4 + FortyUInt )) IF ( uInside . NEQV . wInside ) THEN IF ( wInside ) THEN SigDec = Sp + 1_I4B ELSE SigDec = Sp END IF ExpDec = kExp + 1 RETURN END IF END IF Sx4 = SHIFTL ( Sx , 2 ) uInside = ( Lower . ULE . Sx4 ) wInside = ( Upper . UGE . ( Sx4 + FourUInt )) ExpDec = kExp SigDec = Sx IF ( uInside . NEQV . wInside ) THEN IF ( wInside ) SigDec = SigDec + 1_I4B RETURN END IF Middle = Sx4 + TwoUInt IF (( Vb . UGT . Middle ). OR .(( Vb == Middle ). AND .( IAND ( Sx , 1_I4B ) /= 0_I4B ))) THEN SigDec = SigDec + 1_I4B END IF RETURN CONTAINS FUNCTION Round2Odd ( G , Cx ) RESULT ( Vx ) !** PURPOSE OF THIS SUBROUTINE: ! To perform the rounding of input IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: G INTEGER ( KIND = I4B ), INTENT ( IN ) :: Cx INTEGER ( KIND = I4B ) :: Vx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X , Y !** FLOW Y = ToUnsignedLong ( Cx ) X = Y * IAND ( G , MaskU32 ) Y = Y * SHIFTR ( G , 32 ) + SHIFTR ( X , 32 ) Vx = INT ( SHIFTR ( Y , 32 ), KIND = I4B ) IF ( INT ( IAND ( Y , MaskU32 ), KIND = I4B ) . UGT . 1 ) Vx = IOR ( Vx , 1 ) RETURN END FUNCTION Round2Odd !************************************************************************** END SUBROUTINE Bin2Dec_Schubfach !****************************************************************************** !------------------------------------------------------------------------------ ! !                       DECIMAL-TO-BINARY CONVERSION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Valid ) ! To convert decimal floating point representation into its exact ! binary floating point representation using the Clinger algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Valid ! true if conversion can be done !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RawFP INTEGER ( KIND = I4B ) :: Exp10 REAL ( KIND = SP ) :: FloatMantissa !** FLOW IF ( SHIFTR ( SigDec , SignificandBits ) /= 0_I4B ) THEN Valid = FalseVal RETURN END IF FloatMantissa = REAL ( SigDec , KIND = SP ) Exp10 = ExpDec IF ( Exp10 == 0 ) THEN RawFP = RawFP_FromFloat ( FloatMantissa ) END IF IF ( Exp10 > 0 ) THEN IF ( Exp10 > Num_Exact_Pow10 + Num_Mantissa_Digits ) THEN Valid = FalseVal RETURN END IF IF ( Exp10 > Num_Exact_Pow10 ) THEN FloatMantissa = FloatMantissa * Powers_Of_Ten ( Exp10 - Num_Exact_Pow10 ) Exp10 = Num_Exact_Pow10 END IF IF ( FloatMantissa > Max_Exact_Integer ) THEN Valid = FalseVal RETURN END  IF RawFP = RawFP_FromFloat ( FloatMantissa * Powers_Of_Ten ( Exp10 )) ELSEIF ( Exp10 < 0 ) THEN IF ( - Exp10 > Num_Exact_Pow10 ) THEN Valid = FalseVal RETURN END IF RawFP = RawFP_FromFloat ( FloatMantissa / Powers_Of_Ten ( - Exp10 )) END IF SigBin = RawFP_Significand ( RawFP ) ExpBin = RawFP_BiasedExponent ( RawFP ) Valid = TrueVal RETURN END FUNCTION Dec2Bin_Clinger !****************************************************************************** SUBROUTINE Dec2Bin_LibC ( SigDec , ExpDec , cStr , Start , Truncated , SigBin , ExpBin ) !** PURPOSE OF THIS SUBROUTINE: ! To use LibC algorithm to convert string to real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start LOGICAL , INTENT ( IN ) :: Truncated INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange - UIntSafeDigits + 1 INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange + 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    INTEGER(KIND=I4B)   :: FirstSigBin !    INTEGER(KIND=I4B)   :: FirstExpBin !** FLOW !NOTE : the Eisel-Lemire's algorithm based on LibC appears to be incorrect when the shortest-representation !       decimal string is halfway (i.e. between the correct value and its neighber, lower or upper). !       so the one based Fast_Double_Parser is used here ! check whether to use Lemire's fast path IF ((. NOT . Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN ! return if fast path is valid IF ( D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) RETURN END IF ! try the Eisel-Lemire's algorithm !    IF (Eisel_Lemire(SigDec, ExpDec, SigBin, ExpBin)) THEN !        ! the Eisel-Lemire's algorithm is possibly valid !        IF (.NOT.Truncated) RETURN !        ! If the mantissa is truncated, then the result may be off by the LSB, so !        ! check if rounding the mantissa up changes the result. If not, then it's !        ! safe, else use the fallback. !        FirstSigBin = SigBin !        FirstExpBin = ExpBin !        IF (Eisel_Lemire(SigDec + 1_I4B, ExpDec, SigBin, ExpBin)) THEN !            ! check if the Eisel-Lemire's algorithm is definitely valid !            IF ((SigBin == FirstSigBin).AND.(ExpBin == FirstExpBin)) RETURN !        END IF !    END IF ! use the slow Simple Decimal Conversion algorithm CALL Simple_Decimal_Conversion ( cStr , Start , LEN_TRIM ( cStr ), SigBin , ExpBin ) RETURN CONTAINS FUNCTION D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_Lemire_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's fast path algorithm to convert from decimal to binary representation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 INTEGER ( KIND = I8B ) :: MulProduct INTEGER ( KIND = I4B ) :: LZ INTEGER ( KIND = I4B ) :: Upperbit INTEGER ( KIND = I4B ) :: Significand INTEGER ( KIND = I4B ) :: Lower , Upper INTEGER ( KIND = I4B ) :: Exponent !** FLOW ! get 256/128/64-bit approximation of power of 10 (or power of 5) Pow10 = Get_Pow10_64Bits ( ExpDec ) ! compute the exponent Exponent = Floor_Log2_Pow10 ( ExpDec ) + MaxExpBin + SignBits ! +++ normalize the significand +++ ! We want the most significant bit of Significand to be 1. Shift if needed. LZ = LEADZ ( SigDec ) Significand = SHIFTL ( SigDec , LZ ) ! +++ perform multiplication +++ ! We want the most significant 128/64/32 bits of the product. We know this will be non-zero ! because the most significant bit of Significand is 1. MulProduct = ToUnsignedLong ( Significand ) * SHIFTR ( Pow10 , 32 ) Lower = INT ( IAND ( MulProduct , MaskU32 ), KIND = I4B ) Upper = INT ( SHIFTR ( MulProduct , 32 ), KIND = I4B ) ! We know that Upper has at most one leading zero because both Significand and  Pow10 have a leading one. ! As long as the first 13/9/6 bits of \"upper\" are not \"1\", then we know that we have an exact computed ! value for the leading 125/55/26 bits because any imprecision would play out as a +1, in the worst case. ! Having 125/55/26 bits is necessary because we need 123/53/24 bits for the mantissa but we have to have ! one rounding bit and we can waste a bit if the most significant bit of the product is zero. We expect ! this next branch to be rarely taken (say 1% of the time). When (Upper & BitMask) == BitMask, ! it can be common for Lower + Significand < Lower to be true (proba. much higher than 1%). ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ IF (( IAND ( Upper , BitMask ) == BitMask ). AND .(( Lower + Significand ) . ULT . Lower )) THEN BLOCK ! --- declaration --- INTEGER ( KIND = I4B ) :: Product_Low , Product_High INTEGER ( KIND = I4B ) :: Product_Middle , Product_Middle1 , Product_Middle2 ! --- execution --- ! perform multiplication MulProduct = ToUnsignedLong ( Significand ) * IAND ( Pow10 , MaskU32 ) Product_Low = INT ( IAND ( MulProduct , MaskU32 ), KIND = I4B ) Product_Middle2 = INT ( SHIFTR ( MulProduct , 32 ), KIND = I4B ) Product_Middle1 = Lower Product_High = Upper Product_Middle = Product_Middle1 + Product_Middle2 ! overflow carry IF ( Product_Middle . ULT . Product_Middle1 ) Product_High = Product_High + 1_I4B ! we want to check whether Pow10*Significand + Significand would affect our result ! This does happen, e.g. with 7.3177701707893310E+15 (for double-precision) IF ((( Product_Middle + 1_I4B == 0_I4B ). AND .( IAND ( Product_High , BitMask ) == BitMask ) & . AND .( Product_Low + Significand . ULT . Product_Low ))) THEN ! let us be prudent and bail out. Success = FalseVal RETURN END IF Lower = Product_Middle Upper = Product_High END BLOCK END IF ! The final mantissa should be 123/53/24 (BinaryPrecision) bits with a leading 1. ! We shift it so that it occupies 124/54/25 (BinaryPrecision+1) bits with a leading 1. Upperbit = INT ( SHIFTR ( Upper , SignBits ), KIND = I4B ) SigBin = SHIFTR ( Upper , ( Upperbit + LowBits )) LZ = LZ + IEOR ( 1 , Upperbit ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision+1). ! We have to round to even. The \"to even\" part ! is only a problem when we are right in between two floats ! which we guard against. ! If we have lots of trailing zeros, we may fall right between two ! floating-point values. IF (( Lower == 0_I4B ). AND .( IAND ( Upper , BitMask ) == 0_I4B ). AND . & ( IAND ( SigBin , ThreeUInt ) == 1_I4B )) THEN ! if IAND(SigBin, 1) == 1 we might need to round up. ! Scenarios: ! 1. We are not in the middle. Then we should round up. ! 2. We are right in the middle. Whether we round up depends on the last significant !    bit: if it is \"one\" then we round up (round to even) otherwise, we do not. ! So if the last significant bit is 1, we can safely round up.  Hence we only need ! to bail out if IAND(SigBin, 3) == 1.  Otherwise we may need more accuracy or analysis ! to determine whether we are exactly between two floating-point numbers. ! It can be triggered with 1E23. ! Note: because the factor_mantissa and factor_mantissa_low are almost always rounded !       down (except for small positive powers), almost always should round up. Success = FalseVal RETURN END IF SigBin = SHIFTR ( SigBin + IAND ( SigBin , 1_I4B ), 1 ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision), unless there was an overflow IF ( SigBin . UGE . MaxMantissa ) THEN ! This will happen when parsing values such as 7.2057594037927933E+16 SigBin = SigHidBitMask ! undo previous addition LZ = LZ - 1 END IF SigBin = IAND ( SigBin , NOT ( SigHidBitMask )) ExpBin = Exponent - LZ ! we have to check that ExpBin is in range, otherwise we bail out IF (( ExpBin < 1 ). OR .( ExpBin > ( MaxExponent - 1 ))) THEN Success = FalseVal ELSE Success = TrueVal END IF RETURN END FUNCTION D2B_Lemire_FastPath !************************************************************************** FUNCTION Eisel_Lemire ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Valid ) ! To convert decimal floating point representation into its closest ! binary floating point representation using the Eisel-Lemire algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Valid ! true if conversion can be done !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp2 INTEGER ( KIND = I4B ) :: CLZ INTEGER ( KIND = I4B ) :: Mantissa , HighU32 INTEGER ( KIND = I8B ) :: PowTen INTEGER ( KIND = I8B ) :: FirstApprox , FinalApprox , LowBits , SecondApprox INTEGER ( KIND = I4B ) :: FinalMantissa INTEGER ( KIND = I4B ) :: MSB !** FLOW ! normalization CLZ = LEADZ ( SigDec ) Mantissa = SHIFTL ( SigDec , CLZ ) Exp2 = Floor_Log2_Pow10 ( ExpDec ) + TotalBits + ExponentBias - CLZ ! multiplication PowTen = Get_Pow10_64Bits ( ExpDec ) FirstApprox = ToUnsignedLong ( Mantissa ) * SHIFTR ( PowTen , 32 ) ! Wider Approximation IF (( IAND ( INT ( SHIFTR ( FirstApprox , 32 ), KIND = I4B ), HalfWay ) == HalfWay ). AND . & ( INT ( IAND ( FirstApprox , MaskU32 ), KIND = I4B ) + Mantissa . ULT . Mantissa )) THEN BLOCK ! --- declaration --- INTEGER ( KIND = I4B ) :: Product_Low , Product_High INTEGER ( KIND = I4B ) :: Product_Middle , Product_Middle1 , Product_Middle2 ! --- execution --- ! perform multiplication LowBits = ToUnsignedLong ( Mantissa ) * IAND ( PowTen , MaskU32 ) Product_Low = INT ( IAND ( LowBits , MaskU32 ), KIND = I4B ) Product_Middle2 = INT ( SHIFTR ( LowBits , 32 ), KIND = I4B ) Product_Middle1 = INT ( IAND ( FirstApprox , MaskU32 ), KIND = I4B ) Product_High = INT ( SHIFTR ( FirstApprox , 32 ), KIND = I4B ) Product_Middle = Product_Middle1 + Product_Middle2 ! overflow carry IF ( Product_Middle . ULT . Product_Middle1 ) Product_High = Product_High + 1_I4B IF (( IAND ( Product_High , HalfWay ) == HalfWay ). AND .( Product_Middle + 1 == 0 ). AND . & ( Product_Low + Mantissa . ULT . Mantissa )) THEN Valid = FalseVal RETURN END IF SecondApprox = IOR ( SHIFTL ( ToUnsignedLong ( Product_High ), 32 ), ToUnsignedLong ( Product_Middle )) END BLOCK FinalApprox = SecondApprox ELSE FinalApprox = FirstApprox END IF ! Shifting to 25 bits for singles HighU32 = INT ( SHIFTR ( FinalApprox , 32 ), KIND = I4B ) MSB = INT ( SHIFTR ( HighU32 , TotalBits - 1 ), KIND = I4B ) FinalMantissa = SHIFTR ( HighU32 , ( MSB + TotalBits - ( SignificandBits + 3 ))) Exp2 = Exp2 - IEOR ( 1 , MSB ) ! same as NOT(MSB) ! Half-way ambiguity IF (( INT ( IAND ( FinalApprox , MaskU32 ), KIND = I4B ) == 0 ). AND . & ( IAND ( HighU32 , HalfWay ) == 0 ). AND .( IAND ( FinalMantissa , 3 ) == 1 )) THEN Valid = FalseVal RETURN END IF ! From 25 to 24 bits for singles FinalMantissa = FinalMantissa + IAND ( FinalMantissa , 1 ) FinalMantissa = SHIFTR ( FinalMantissa , 1 ) IF ( SHIFTR ( FinalMantissa , ( SignificandBits + 1 )) /= 0 ) THEN FinalMantissa = SHIFTR ( FinalMantissa , 1 ) Exp2 = Exp2 + 1 END IF ! check exponent validity IF (( Exp2 < 1 ). OR .( Exp2 > ( MaxExponent - 1 ))) THEN Valid = FalseVal RETURN END IF SigBin = FinalMantissa ! implicit conversion if type is mismatch ExpBin = Exp2 Valid = TrueVal RETURN END FUNCTION Eisel_Lemire !****************************************************************************** SUBROUTINE Simple_Decimal_Conversion ( cStr , Start , Finish , SigBin , ExpBin ) ! To convert decimal string into its closest floating point binary representation ! using the Simple Decimal Conversion algorithm. ! The routine assumes that cStr is a 'VALID' floating point string and ! Start is less than Finish where !   - Start is the index of the first valid numeric character, and !   - Finish is the index of the last valid character (== length of the input !     string excluding trailing space(s)) !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start INTEGER ( KIND = I4B ), INTENT ( IN ) :: Finish INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( HPDecimal ) :: HP INTEGER ( KIND = I4B ) :: FinalMantissa INTEGER ( KIND = I4B ) :: Exp2 INTEGER ( KIND = I4B ) :: ShiftAmount !** FLOW ! initialize Exp2 = 0 ! construct HPDecimal object CALL HP % Construct ( cStr , Start , Finish ) IF ( HP % NumDigits == 0 ) THEN SigBin = 0_I4B ExpBin = 0 RETURN END IF ! If the exponent is too large and can't be represented in this size of ! float, return inf. IF (( HP % DecimalPoint > 0 ). AND .( Floor_Log2_Pow10 ( HP % DecimalPoint - 1 ) > ExponentBias )) THEN SigBin = 0_I4B ExpBin = MaxExponent RETURN END IF ! If the exponent is too small even for a subnormal, return 0. IF (( HP % DecimalPoint < 0 ). AND . & ( Floor_Log2_Pow10 ( - HP % DecimalPoint ) > ( ExponentBias + SignificandBits ))) THEN SigBin = 0_I4B ExpBin = 0 RETURN END IF ! Right shift until the number is smaller than 1. DO WHILE ( HP % DecimalPoint > 0 ) ShiftAmount = 0 IF ( HP % DecimalPoint >= Num_Powers_Of_Two ) THEN ShiftAmount = 60 ELSE ShiftAmount = Powers_Of_Two ( HP % DecimalPoint ) END IF Exp2 = Exp2 + ShiftAmount CALL HP % Shift ( - ShiftAmount ) END DO ! Left shift until the number is between 1/2 and 1 DO WHILE (( HP % DecimalPoint < 0 ). OR .(( HP % DecimalPoint == 0 ). AND .( HP % Digits ( 0 ) < 5 ))) ShiftAmount = 0 IF ( - HP % DecimalPoint >= Num_Powers_Of_Two ) THEN ShiftAmount = 60 ELSEIF ( HP % DecimalPoint /= 0 ) THEN ShiftAmount = Powers_Of_Two ( - HP % DecimalPoint ) ELSE ! This handles the case of the number being between .1 and .5 ShiftAmount = 1 END IF Exp2 = Exp2 - ShiftAmount CALL HP % Shift ( ShiftAmount ) END DO ! Left shift once so that the number is between 1 and 2 Exp2 = Exp2 - 1 CALL HP % Shift ( 1 ) ! Get the biased exponent Exp2 = Exp2 + ExponentBias ! Handle the exponent being too large (and return inf). IF ( Exp2 >= MaxExponent ) THEN SigBin = 0 ExpBin = MaxExponent RETURN END IF ! Shift left to fill the mantissa CALL HP % Shift ( SignificandBits ) CALL HP % RoundToUIntType ( FinalMantissa ) ! Handle subnormals IF ( Exp2 <= 0 ) THEN ! Shift right until there is a valid exponent DO WHILE ( Exp2 < 0 ) CALL HP % Shift ( - 1 ) Exp2 = Exp2 + 1 END DO ! Shift right one more time to compensate for the left shift to get it ! between 1 and 2. CALL HP % Shift ( - 1 ) CALL HP % RoundToUIntType ( FinalMantissa ) ! Check if by shifting right we've caused this to round to a normal number. IF ( SHIFTR ( FinalMantissa , SignificandBits ) /= 0_I4B ) THEN Exp2 = Exp2 + 1 END IF END IF ! Check if rounding added a bit, and shift down if that's the case. IF ( FinalMantissa == SHIFTL ( INT ( 2 , KIND = I4B ), SignificandBits )) THEN FinalMantissa = SHIFTR ( FinalMantissa , 1 ) Exp2 = Exp2 + 1 ! Check if this rounding causes Exp2 to go out of range and make the result ! INF. If this is the case, then finalMantissa and Exp2 are already the ! correct values for an INF result. IF ( Exp2 >= MaxExponent ) THEN ! report error if applicable END IF END IF IF ( Exp2 == 0 ) THEN ! report error if applicable END IF SigBin = FinalMantissa ExpBin = Exp2 RETURN END SUBROUTINE Simple_Decimal_Conversion !****************************************************************************** END SUBROUTINE Dec2Bin_LibC !****************************************************************************** SUBROUTINE Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , SigCut , Indices , SigBin , ExpBin ) !** PURPOSE OF THIS SUBROUTINE: ! To use FastFloat algorithm to convert string to real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: SigDec INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr LOGICAL , INTENT ( IN ) :: SigCut INTEGER ( KIND = I4B ), INTENT ( IN ) :: Indices ( 4 ) INTEGER ( KIND = I8B ), INTENT ( OUT ) :: SigBin INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: EBase INTEGER ( KIND = I4B ) :: ECmp INTEGER ( KIND = I8B ) :: MBase INTEGER ( KIND = I8B ) :: MCmp !** FLOW ! compute float CALL Compute_Float ( ExpDec , SigDec , EBase , MBase ) IF ( SigCut . AND . EBase >= 0 ) THEN CALL Compute_Float ( ExpDec , SigDec + OneMant , ECmp , MCmp ) IF ( Is_AdjustedMantissa_NE ( EBase , MBase , ECmp , MCmp )) THEN CALL Compute_Error ( ExpDec , SigDec , EBase , MBase ) END IF END IF ! If we have an invalid power (EBase < 0), then we need to go ! the long way around again. This is very uncommon. IF ( EBase < 0 ) THEN BLOCK TYPE ( Parsed_Number_Info ) :: NumInfo ! set NumInfo NumInfo % Exp = ExpDec NumInfo % Sig = SigDec NumInfo % IntegralStart = Indices ( 1 ) NumInfo % IntegralEnd = Indices ( 2 ) NumInfo % FractionStart = Indices ( 3 ) NumInfo % FractionEnd = Indices ( 4 ) ECmp = EBase MCmp = MBase ! compare digits CALL Digit_Comparision ( cStr , NumInfo , ECmp , MCmp , EBase , MBase ) END BLOCK END IF SigBin = MBase ExpBin = EBase RETURN CONTAINS SUBROUTINE Compute_Product_Approximation ( Q , W , ProductHi , ProductLo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute or rather approximate W * 5**Q and return a pair of 64-bit words ! approximating the result, with the \"high\" part corresponding to the most ! significant bits and the low part corresponding to the least significant bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! mantissa INTEGER ( KIND = I8B ) :: ProductHi , ProductLo ! product approximation !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: BitPrecision INTEGER ( KIND = I8B ) :: PrecisionMask , SecondProductHi TYPE ( UInt128 ) :: Pow10 !** FLOW ! The required precision is Mantissa_Explicit_Bits + 3 because ! 1. We need the implicit bit ! 2. We need an extra bit for rounding purposes ! 3. We might lose a bit due to the \"UpperBit\" (result too small, requiring a shift) ! BitPrecision = 26 for 32-bit number and 55 for 64-bit number BitPrecision = Mantissa_Explicit_Bits + 3 ! compute precision mask PrecisionMask = SHIFTR ( MaxMant , BitPrecision ) ! get 128-bit approximation of power of ten (or power of five) Pow10 = Get_Pow10_128Bits ( Q ) ! For small values of Q, e.g., Q in [0,27], the product is always exact. CALL UMul128 ( W , Pow10 % High , ProductHi , ProductLo ) IF ( IAND ( ProductHi , PrecisionMask ) == PrecisionMask ) THEN ! could further guard with  (ProductLo + W < ProductLo) ! regarding the second product, we only need the upper bits of the product. SecondProductHi = UMul128_Upper64 ( W , Pow10 % Low ) ProductLo = ProductLo + SecondProductHi IF ( SecondProductHi . UGT . ProductLo ) ProductHi = ProductHi + 1_I8B END IF RETURN END SUBROUTINE Compute_Product_Approximation !************************************************************************** FUNCTION Power ( Q ) RESULT ( E ) !** PURPOSE OF THIS SUBROUTINE: ! To compute power in base 2 based on the power in base 10 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! power in base 10 INTEGER ( KIND = I4B ) :: E ! power in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = Floor_Log2_Pow10 ( Q ) + MantTotalBits - 1 RETURN END FUNCTION Power !************************************************************************** SUBROUTINE Compute_Error_Scaled ( Q , W , LZ , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To create an adjusted mantissa, biased by the invalid power2 ! for significant digits already multiplied by 10 ** Q. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LZ ! leading zeros in W INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! significand in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: HiLZ , Bias !** FLOW HiLZ = IEOR ( INT ( SHIFTR ( W , MantTotalBits - 1 ), KIND = I4B ), 1 ) Bias = Mantissa_Explicit_Bits - Minimum_Exponent M = SHIFTL ( W , HiLZ ) E = Power ( Q ) + Bias - HiLZ - LZ - ( MantTotalBits - 2 ) + Invalid_AM_Bias RETURN END SUBROUTINE Compute_Error_Scaled !************************************************************************** SUBROUTINE Compute_Error ( Q , W , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute W * 10 ** Q, without rounding the representation up. ! the power2 in the exponent will be adjusted by Invalid_AM_Bias. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! significand in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ INTEGER ( KIND = I8B ) :: LocalW INTEGER ( KIND = I8B ) :: ProductHi , ProductLo !** FLOW ! perform normalization LZ = LEADZ ( W ) LocalW = SHIFTL ( W , LZ ) ! compute the product approximation CALL Compute_Product_Approximation ( Q , LocalW , ProductHi , ProductLo ) ! compute the adjusted mantissa biased by the invalid power2 CALL Compute_Error_Scaled ( Q , ProductHi , LZ , E , M ) RETURN END SUBROUTINE Compute_Error !************************************************************************** SUBROUTINE Compute_Float ( Q , W , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute W * 10 ** Q ! The returned value should be a valid ieee64 number that simply need to be packed. ! However, in some very rare cases, the computation will fail. In such cases, we ! return an adjusted_mantissa with a negative power of 2: the caller should recompute ! in such cases. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: W ! significand in base 10 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ , UpperBit INTEGER ( KIND = I8B ) :: LocalW INTEGER ( KIND = I8B ) :: ProductHi , ProductLo !** FLOW ! check for special cases (may not be needed since it is taken care of in the caller?) IF (( W == 0_I4B ) . OR . ( Q < Smallest_Power_of_Ten )) THEN E = 0 M = 0_I4B ! result should be zero RETURN END IF IF ( Q > Largest_Power_of_Ten ) THEN ! we want to get infinity: E = Infinite_Power M = 0_I4B RETURN END IF ! At this point in time Q is in [Smallest_Power_of_Ten, Largest_Power_of_Ten]. ! We want the most significant bit of i to be 1. Shift if needed. ! (i.e. perform normalization) LZ = LEADZ ( W ) LocalW = SHIFTL ( W , LZ ) ! compute the product approximation CALL Compute_Product_Approximation ( Q , LocalW , ProductHi , ProductLo ) ! The computed product is always sufficient. ! See mathematical proof in the following reference: ! Noble Mushtak, Daniel Lemire, Fast Number Parsing Without Fallback, !       Software: Practice and Experience 53 (7), 2023. ! Shifting to Mantissa_Explicit_Bits + 2 bits UpperBit = INT ( SHIFTR ( ProductHi , MantTotalBits - 1 ), KIND = I4B ) M = SHIFTR ( ProductHi , ( UpperBit + MantTotalBits - Mantissa_Explicit_Bits - 3 )) E = Power ( Q ) + UpperBit - LZ - Minimum_Exponent IF ( E <= 0 ) THEN ! we have a subnormal? ! Here have that E <= 0 so -E >= 0 IF ( - E + 1 >= MantTotalBits ) THEN ! if we have more than 'MantTotalBits' bits below the minimum exponent, you have a zero for sure. E = 0 M = 0_I4B ! result should be zero RETURN END IF ! next line is safe because -E + 1 < MantTotalBits M = SHIFTR ( M , - E + 1 ) ! Thankfully, we can't have both \"round-to-even\" and subnormals because ! \"round-to-even\" only occurs for powers close to 0. M = M + IAND ( M , OneMant ) ! round up M = SHIFTR ( M , 1 ) ! There is a weird scenario where we don't have a subnormal but just. ! Suppose we start with 2.2250738585072013e-308, we end up ! with 0x3fffffffffffff x 2&#94;-1023-53 which is technically subnormal ! whereas 0x40000000000000 x 2&#94;-1023-53  is normal. Now, we need to round ! up 0x3fffffffffffff x 2&#94;-1023-53  and once we do, we are no longer ! subnormal, but we can only know this after rounding. ! So we only declare a subnormal if we are smaller than the threshold. ! IF (M .ULT. SHIFTL(OneMant, Mantissa_Explicit_Bits)) THEN IF ( M . ULT . Hidden_Bit_Mask ) THEN E = 0 ELSE E = 1 END IF RETURN END IF ! usually, we round *up*, but if we fall right in between and and we have an ! even basis, we need to round down ! We are only concerned with the cases where 5**Q fits in single 64-bit word. IF (( ProductLo . ULE . OneMant ) . AND . ( Q >= Min_Exponent_Round_To_Even ) . AND . & ( Q <= Max_Exponent_Round_To_Even ) . AND . & ( IAND ( M , 3_I8B ) == OneMant )) THEN ! we may fall between two floats! ! To be in-between two floats we need that in doing !   M = ProductHi >> (UpperBit + 64 - Mantissa_Explicit_Bits - 3) ! ... we dropped out only zeroes. But if this happened, then we can go back!!! IF ( SHIFTL ( M , ( UpperBit + MantTotalBits - Mantissa_Explicit_Bits - 3 )) == & ProductHi ) THEN M = IAND ( M , NotOneMant ) ! flip it so that we do not round up END IF END IF M = M + IAND ( M , OneMant ) ! round up M = SHIFTR ( M , 1 ) IF ( M . UGE . Max_Mantissa_Fast_Path ) THEN M = SHIFTL ( OneMant , Mantissa_Explicit_Bits ) E = E + 1 ! undo previous addition END IF M = IAND ( M , NotSigHidBitMask ) IF ( E >= Infinite_Power ) THEN ! infinity E = Infinite_Power M = 0_I4B END IF RETURN END SUBROUTINE Compute_Float !************************************************************************** FUNCTION Scientific_Exponent ( Number ) RESULT ( Exponent ) !** PURPOSE OF THIS SUBROUTINE: ! To calculate the exponent, in scientific notation, of the number. ! this algorithm is not even close to optimized, but it has no practical ! effect on performance: in order to have a faster algorithm, we'd need ! to slow down performance for faster algorithms, and this is still fast. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: Number INTEGER ( KIND = I4B ) :: Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Mantissa !** FLOW Mantissa = Number % Sig ! implicit narrow conversion for 32-bit Exponent = Number % Exp DO WHILE ( Mantissa . UGE . TenThousandUInt ) Mantissa = DivByPow10 ( Mantissa , 4 ) Exponent = Exponent + 4 END DO DO WHILE ( Mantissa . UGE . HundredUInt ) Mantissa = DivByPow10 ( Mantissa , 2 ) Exponent = Exponent + 2 END DO DO WHILE ( Mantissa . UGE . TenUInt ) Mantissa = DivByPow10 ( Mantissa , 1 ) Exponent = Exponent + 1 END DO RETURN END FUNCTION Scientific_Exponent !************************************************************************** SUBROUTINE Digit_Comparision ( cStr , NumInfo , EIn , MIn , EOut , MOut ) !** PURPOSE OF THIS SUBROUTINE: ! To parse the significant digits as a big integer to unambiguously round the ! the significant digits. here, we are trying to determine how to round ! an extended float representation close to `b+h`, halfway between `b` ! (the float rounded-down) and `b+u`, the next positive float. this ! algorithm is always correct, and uses one of two approaches. when ! the exponent is positive relative to the significant digits (such as ! 1234), we create a big-integer representation, get the high 64-bits, ! determine if any lower bits are truncated, and use that to direct ! rounding. in case of a negative exponent relative to the significant ! digits (such as 1.2345), we create a theoretical representation of ! `b` as a big-integer type, scaled to the same binary exponent as ! the actual digits. we then compare the big integer representations ! of both, and use that to direct rounding. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: NumInfo INTEGER ( KIND = I4B ), INTENT ( IN ) :: EIn INTEGER ( KIND = I4B ), INTENT ( OUT ) :: EOut INTEGER ( KIND = I8B ), INTENT ( IN ) :: MIn INTEGER ( KIND = I8B ), INTENT ( OUT ) :: MOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BigUInt ) :: Big INTEGER ( KIND = I4B ) :: Sci_Exp , Digits , Exponent INTEGER ( KIND = I4B ) :: EIn2 !** FLOW ! remove the invalid exponent bias EIn2 = EIn - Invalid_AM_Bias Sci_Exp = Scientific_Exponent ( NumInfo ) Digits = 0 CALL Parse_Mantissa ( cStr , Big , NumInfo , Max_Digits , Digits ) ! can't underflow, since digits is at most max_digits. Exponent = Sci_Exp + 1 - Digits IF ( Exponent >= 0 ) THEN CALL Positive_Digit_Comparision ( Big , Exponent , EOut , MOut ) ELSE CALL Negative_Digit_Comparision ( Big , EIn2 , MIn , Exponent , EOut , MOut ) END IF RETURN END SUBROUTINE Digit_Comparision !************************************************************************** FUNCTION Is_AdjustedMantissa_NE ( ELhs , MLhs , ERhs , MRhs ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare whether LHS /= RHS. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: ELhs INTEGER ( KIND = I4B ), INTENT ( IN ) :: ERhs INTEGER ( KIND = I8B ), INTENT ( IN ) :: MLhs INTEGER ( KIND = I8B ), INTENT ( IN ) :: MRhs LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( MLhs /= MRhs ). OR .( ELhs /= ERhs ) RETURN END FUNCTION Is_AdjustedMantissa_NE !************************************************************************** END SUBROUTINE Dec2Bin_FastFloat !****************************************************************************** SUBROUTINE Round ( E , M , CB ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float to the nearest machine float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 PROCEDURE ( CB_Round ) :: CB ! actual procedure that perform rounding !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Mantissa_Shift , Shift !** FLOW Mantissa_Shift = MantTotalBits - Mantissa_Explicit_Bits - 1 IF ( - E >= Mantissa_Shift ) THEN ! have a denormal float Shift = - E + 1 CALL CB ( E , M , MIN ( Shift , MantTotalBits )) ! check for round-up: if rounding-nearest carried us to the hidden bit. IF ( M . ULT . Hidden_Bit_Mask ) THEN E = 0 ELSE E = 1 END IF RETURN END IF ! have a normal float, use the default shift. CALL CB ( E , M , Mantissa_Shift ) ! check for carry IF ( M . UGE . Max_Mantissa_Fast_Path ) THEN M = Hidden_Bit_Mask E = E + 1 END IF ! check for infinite: we could have carried to an infinite power M = IAND ( M , NotSigHidBitMask ) IF ( E >= Infinite_Power ) THEN E = Infinite_Power M = 0_I8B END IF RETURN END SUBROUTINE Round !****************************************************************************** SUBROUTINE Round_Nearest_Tie_Even ( E , M , Shift , CB ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float to the nearest tie to even. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift PROCEDURE ( CB_Round_Nearest ) :: CB !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Mask , Halfway , Truncated_Bits LOGICAL :: Is_Above , Is_Halfway , Is_Odd !** FLOW IF ( Shift == MantTotalBits ) THEN Mask = MaxMant ELSE Mask = SHIFTL ( OneMant , Shift ) - OneMant END IF IF ( Shift == 0 ) THEN Halfway = 0_I4B ELSE Halfway = SHIFTL ( OneMant , ( Shift - 1 )) END IF Truncated_Bits = IAND ( M , Mask ) Is_Above = Truncated_Bits . UGT . Halfway Is_Halfway = Truncated_Bits == Halfway ! shift digits into position IF ( Shift == MantTotalBits ) THEN M = 0_I4B ELSE M = SHIFTR ( M , Shift ) END IF E = E + Shift Is_Odd = IAND ( M , OneMant ) == OneMant IF ( CB ( Is_Odd , Is_Halfway , Is_Above )) M = M + OneMant RETURN END SUBROUTINE Round_Nearest_Tie_Even !****************************************************************************** SUBROUTINE Parse_Mantissa ( cStr , Big , NumInfo , Max_Digits , Digits ) !** PURPOSE OF THIS SUBROUTINE: ! To parse the significant digits into a BigUInt IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr TYPE ( BigUInt ), INTENT ( INOUT ) :: Big TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: NumInfo INTEGER ( KIND = I4B ), INTENT ( IN ) :: Max_Digits INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Digits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IEnd INTEGER ( KIND = I4B ) :: Counter , Step INTEGER ( KIND = I8B ) :: Value LOGICAL :: Truncated !** FLOW ! try to minimize the number of big integer and scalar multiplication. ! therefore, try to parse 8 digits at a time, and multiply by the largest ! scalar value (19 digits) for each step. Counter = 0 Digits = 0 Value = 0_I8B Step = 19 ! process all integer digits. IF ( NumInfo % IntegralStart /= 0 ) THEN Indx = NumInfo % IntegralStart IEnd = NumInfo % IntegralEnd CALL Skip_Zeros ( cStr , Indx , IEnd ) ! process all digits, in increments of step per loop DO WHILE ( Indx <= IEnd ) DO WHILE (( Indx + 7 <= IEnd ). AND .( Step - Counter >= 8 ). AND .( Max_Digits - Digits >= 8 )) CALL Parse_Eight_Digits ( cStr , Indx , Value , Counter , Digits ) END DO DO WHILE (( Counter < Step ). AND .( Indx <= IEnd ). AND .( Digits < Max_Digits )) CALL Parse_One_Digit ( cStr , Indx , Value , Counter , Digits ) END DO IF ( Digits == Max_Digits ) THEN ! add the temporary value, then check if we've truncated any digits CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Truncated = Is_Truncated ( cStr , Indx , IEnd ) IF ( NumInfo % FractionStart /= 0 ) THEN Truncated = Truncated . OR . Is_Truncated ( cStr , NumInfo % FractionStart , NumInfo % FractionEnd ) END IF IF ( Truncated ) THEN CALL Round_Up_BigUInt ( Big , Digits ) END IF RETURN ELSE CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Counter = 0 Value = 0_I8B END IF END DO END IF ! add our fraction digits, if they're available. IF ( NumInfo % FractionStart /= 0 ) THEN Indx = NumInfo % FractionStart IEnd = NumInfo % FractionEnd IF ( Digits == 0 ) THEN CALL Skip_Zeros ( cStr , Indx , IEnd ) END IF ! process all digits, in increments of step per loop DO WHILE ( Indx <= IEnd ) DO WHILE (( Indx + 7 <= IEnd ). AND .( Step - Counter >= 8 ). AND .( Max_Digits - Digits >= 8 )) CALL Parse_Eight_Digits ( cStr , Indx , Value , Counter , Digits ) END DO DO WHILE (( Counter < Step ). AND .( Indx <= IEnd ). AND .( Digits < Max_Digits )) CALL Parse_One_Digit ( cStr , Indx , Value , Counter , Digits ) END DO IF ( Digits == Max_Digits ) THEN ! add the temporary value, then check if we've truncated any digits CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) IF ( Is_Truncated ( cStr , Indx , IEnd )) THEN CALL Round_Up_BigUInt ( Big , Digits ) END IF RETURN ELSE CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Counter = 0 Value = 0_I8B END IF END DO END IF IF ( Counter /= 0 ) THEN CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) END IF RETURN CONTAINS SUBROUTINE Skip_Zeros ( cStr , IStart , IEnd ) !DIR$ ATTRIBUTES FORCEINLINE :: Skip_Zeros !** PURPOSE OF THIS SUBROUTINE: ! To find IStart by skipping zeros. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: IStart INTEGER ( KIND = I4B ), INTENT ( IN ) :: IEnd !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MConst = INT ( Z '3030303030303030' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW DO WHILE ( IStart + 7 <= IEnd ) wStr = cStr ( IStart : IStart + 7 ) IF ( wVal /= MConst ) EXIT IStart = IStart + 8 END DO DO WHILE ( IStart <= IEnd ) IF ( cStr ( IStart : IStart ) /= '0' ) EXIT IStart = IStart + 1 END DO RETURN END SUBROUTINE Skip_Zeros !************************************************************************** FUNCTION Is_Truncated ( cStr , IStart , IEnd ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Truncated !** PURPOSE OF THIS SUBROUTINE: ! To determine if any non-zero digits were truncated. ! all characters must be valid digits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: IStart INTEGER ( KIND = I4B ), INTENT ( IN ) :: IEnd LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MConst = INT ( Z '3030303030303030' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW ! initialize Indx = IStart Flag = TrueVal ! do 8-bit optimizations, can just compare to 8 literal 0s. DO WHILE ( Indx + 7 <= IEnd ) wStr = cStr ( Indx : Indx + 7 ) IF ( wVal /= MConst ) RETURN Indx = Indx + 8 END DO DO WHILE ( Indx <= IEnd ) IF ( cStr ( Indx : Indx ) /= '0' ) RETURN Indx = Indx + 1 END DO Flag = FalseVal RETURN END FUNCTION Is_Truncated !************************************************************************** SUBROUTINE Parse_Eight_Digits ( cStr , Indx , Value , Counter , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits !** PURPOSE OF THIS SUBROUTINE: ! To parse 8 digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx , Counter , Count INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW wStr = cStr ( Indx : Indx + 7 ) Value = Value * 100000000_I8B + Parse_Eight_Digits_Unrolled ( wVal ) Indx = Indx + 8 Counter = Counter + 8 Count = Count + 8 RETURN END SUBROUTINE Parse_Eight_Digits !************************************************************************** SUBROUTINE Parse_One_Digit ( cStr , Indx , Value , Counter , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_One_Digit !** PURPOSE OF THIS SUBROUTINE: ! To parse 1 digit IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx , Counter , Count INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Value !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Value = Value * 10_I8B + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 Counter = Counter + 1 Count = Count + 1 RETURN END SUBROUTINE Parse_One_Digit !************************************************************************** SUBROUTINE Add_Native ( Big , Power , Value ) !DIR$ ATTRIBUTES FORCEINLINE :: Add_Native !** PURPOSE OF THIS SUBROUTINE: ! To add value to BigUInt IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Power , Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % SmallMul ( Power ) CALL Big % Add ( Value ) RETURN END SUBROUTINE Add_Native !************************************************************************** SUBROUTINE Round_Up_BigUInt ( Big , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Round_Up_BigUInt !** PURPOSE OF THIS SUBROUTINE: ! To round BigUInt up IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Count !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! need to round-up the digits, but need to avoid rounding ! ....9999 to ...10000, which could cause a false halfway point. CALL Add_Native ( Big , 10_I8B , 1_I8B ) Count = Count + 1 RETURN END SUBROUTINE Round_Up_BigUInt !************************************************************************** END SUBROUTINE Parse_Mantissa !****************************************************************************** SUBROUTINE Positive_Digit_Comparision ( Big , Exp , E2 , M2 ) !** PURPOSE OF THIS SUBROUTINE: ! To compare BigInt for positive exponent. !    USE Class_MpInt64 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E2 ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M2 ! adjusted significand in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Offset = Mantissa_Explicit_Bits - Minimum_Exponent - MantTotalBits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: Truncated !** FLOW CALL Big % Pow10 ( Exp ) M2 = Big % Hi64 ( Truncated ) E2 = Big % BitLen () + Offset CALL Round ( E2 , M2 , Callback_Round ) RETURN CONTAINS SUBROUTINE Callback_Round ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Nearest_Tie_Even ( E , M , Shift , Callback_Round_Nearest ) RETURN END SUBROUTINE !************************************************************************** FUNCTION Callback_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) ! arguments LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag ! execution Flag = IsAbove . OR .( IsHalfway . AND . Truncated ). OR .( IsOdd . AND . IsHalfway ) RETURN END FUNCTION !************************************************************************** END SUBROUTINE Positive_Digit_Comparision !****************************************************************************** SUBROUTINE Negative_Digit_Comparision ( Big , EIn , MIn , Exp , EOut , MOut ) !** PURPOSE OF THIS SUBROUTINE: ! To compare BigInt for negative exponent. ! ! The scaling here is quite simple: we have, for the real digits `m * 10&#94;e`, ! and for the theoretical digits `n * 2&#94;f`. Since `e` is always negative, ! to scale them identically, we do `n * 2&#94;f * 5&#94;-f`, so we now have `m * 2&#94;e`. ! we then need to scale by `2&#94;(f- e)`, and then the two significant digits ! are of the same magnitude. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), TARGET , INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: EIn INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp INTEGER ( KIND = I4B ), INTENT ( OUT ) :: EOut INTEGER ( KIND = I8B ), INTENT ( IN ) :: MIn INTEGER ( KIND = I8B ), INTENT ( OUT ) :: MOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BigUInt ), POINTER :: RealDigits => NULL () TYPE ( BigUInt ) :: TheoryDigits INTEGER ( KIND = I4B ) :: RealExp , TheoryExp INTEGER ( KIND = I4B ) :: Pow2_Exp , Pow5_Exp INTEGER ( KIND = I4B ) :: Ord REAL ( KIND = SP ) :: FloatBase INTEGER ( KIND = I4B ) :: EBase INTEGER ( KIND = I4B ) :: ETheory INTEGER ( KIND = I8B ) :: MBase INTEGER ( KIND = I8B ) :: MTheory !** FLOW ! set working variables RealDigits => Big RealExp = Exp ! get the value of `b`, rounded down, and get a bigint representation of b+h EBase = EIn MBase = MIn CALL Round ( EBase , MBase , CBRound ) CALL To_Float ( FalseVal , EBase , MBase , FloatBase ) CALL To_Extended_Halfway ( FloatBase , ETheory , MTheory ) CALL TheoryDigits % FromU64 ( MTheory ) TheoryExp = ETheory ! scale real digits and theor digits to be same power. Pow2_Exp = TheoryExp - RealExp Pow5_Exp = - RealExp IF ( Pow5_Exp /= 0 ) THEN CALL TheoryDigits % Pow5 ( Pow5_Exp ) END IF IF ( Pow2_Exp > 0 ) THEN CALL TheoryDigits % Pow2 ( Pow2_Exp ) ELSEIF ( Pow2_Exp < 0 ) THEN CALL RealDigits % Pow2 ( - Pow2_Exp ) END IF ! compare digits, and use it to director rounding Ord = RealDigits % Compare ( TheoryDigits ) EOut = EIn MOut = MIn CALL Round ( EOut , MOut , Callback_Round ) ! free pointer NULLIFY ( RealDigits ) RETURN CONTAINS SUBROUTINE CBRound ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Down ( E , M , Shift ) RETURN END SUBROUTINE !************************************************************************** SUBROUTINE Callback_Round ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Nearest_Tie_Even ( E , M , Shift , Callback_Round_Nearest ) RETURN END SUBROUTINE !************************************************************************** FUNCTION Callback_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) ! arguments LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag ! execution IF ( Ord > 0 ) THEN Flag = TrueVal ELSEIF ( Ord < 0 ) THEN Flag = FalseVal ELSE Flag = IsOdd END IF RETURN END FUNCTION !************************************************************************** SUBROUTINE To_Extended ( Value , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a native floating-point number to an extended-precision float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Bias = Mantissa_Explicit_Bits - Minimum_Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Bits !** FLOW Bits = INT ( RawFP_FromFloat ( Value ), KIND = I8B ) IF ( IAND ( Bits , Exponent_Mask ) == 0_I8B ) THEN ! denormal E = 1 - Bias M = IAND ( Bits , Mantissa_Mask ) ELSE ! normal E = INT ( SHIFTR ( IAND ( Bits , Exponent_Mask ), Mantissa_Explicit_Bits ), KIND = I4B ) - Bias M = IOR ( IAND ( Bits , Mantissa_Mask ), Hidden_Bit_Mask ) END IF RETURN END SUBROUTINE To_Extended !************************************************************************** SUBROUTINE To_Extended_Halfway ( Value , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To get the extended precision value of the halfway point between b and b+u. ! we are given a native float that represents b, so we need to adjust it ! halfway between b and b+u. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL To_Extended ( Value , E , M ) M = SHIFTL ( M , 1 ) + OneMant E = E - 1 RETURN END SUBROUTINE To_Extended_Halfway !************************************************************************** SUBROUTINE Round_Down ( E , M , Shift ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float down. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Shift == MantTotalBits ) THEN M = 0_I4B ELSE M = SHIFTR ( M , Shift ) END IF E = E + Shift RETURN END SUBROUTINE Round_Down !************************************************************************** SUBROUTINE To_Float ( Negative , E , M , Value ) !** PURPOSE OF THIS SUBROUTINE: ! To convert adjusted mantissa to double-precision value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! exponent in base 2 INTEGER ( KIND = I8B ), INTENT ( IN ) :: M ! adjusted significand in base 2 REAL ( KIND = SP ), INTENT ( OUT ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BinRep ) :: FpBin INTEGER ( KIND = I4B ) :: Word !** FLOW ! get input FpBin % Negative = Negative FpBin % Exponent = E FpBin % Significand = M ! implicit narrowing conversion for 32 bit ! compose the component parts into word Word = RawFP_Construct ( FpBin ) ! convert word to real number Value = RawFP_ToFloat ( Word ) RETURN END SUBROUTINE To_Float !************************************************************************** END SUBROUTINE Negative_Digit_Comparision !****************************************************************************** FUNCTION Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use YY's algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand, base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent, base 10 LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information INTEGER ( KIND = I4B ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange - UIntSafeDigits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigBin ! significand, base 2 INTEGER ( KIND = I4B ) :: ExpBin ! exponent, base 2 !** FLOW ! check whether to use YY's fast path IF ((. NOT . Aux % Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN IF ( D2B_YY_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! YY's fast path is success so set sign bit IF ( Negative ) THEN RawFP = SignMask ELSE RawFP = 0_I4B END IF ! then, add exponent bits RawFP = IOR ( RawFP , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! finally, add (both implicit and explicit) significand bits RawFP = IOR ( RawFP , IAND ( SigBin , SignificandMask )) RETURN END IF END IF ! perform decimal to binary conversion using YY's slow path RawFP = D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RETURN CONTAINS FUNCTION D2B_YY_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_YY_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use YY's fast path algorithm to convert from decimal representation ! to binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 INTEGER ( KIND = I8B ) :: Sig2 , Sig2_Ext INTEGER ( KIND = I8B ) :: FirstProduct , SecondProduct INTEGER ( KIND = I4B ) :: Hi , Lo , Hi2 INTEGER ( KIND = I4B ) :: Sig1 , Add , Bits INTEGER ( KIND = I4B ) :: Exp2 , Lz LOGICAL :: Exact !** FLOW ! To keep it simple, we only accept normal number here, ! let the slow path handle subnormal and infinity number. ! The result value is exactly equal to (SigDec * 10**ExpDec), ! the exponent part (10**ExpDec) can be converted to (Sig2 * 2**Exp2). ! The Sig2 can be an infinite length number, only the highest 256 bits ! is cached in the Pow10_Sig_Table. ! (Quad uses 256 bits, Double uses 128 bits, and Single uses 64 bits) ! Now we have these bits: ! Sig1 (normalized 128/64/32 bit)   : aaaaaaaaaaaaaaaa ! Sig2 (higher 128/64/32 bit)       : bbbbbbbbbbbbbbbb ! Sig2_Ext (lower 128/64/32 bit)    : cccccccccccccccc ! Sig2_Cut (extra unknown bits)     : dddddddddddddddddddddddd.... ! And the calculation process is: ! ------------------------------------------------------------- !         aaaaaaaaaaaaaaaa * !         bbbbbbbbbbbbbbbbccccccccccccccccdddddddddddd.... ! ------------------------------------------------------------- ! abababababababababababababababab + !         acacacacacacacacacacacacacacacac + !                 adadadadadadadadadadadadadadadadadadadad.... ! ------------------------------------------------------------- ! [Hi____][Lo____] + !         [Hi2___][Lo2___] + !                 [unknown___________....] ! ------------------------------------------------------------- ! The addition with carry may affect higher bits, but if there is a 0 ! in higher bits, the bits higher than 0 will not be affected. ! 'Lo2' + 'unknown' may get a carry bit and may affect 'Hi2', the max value ! of 'Hi2' is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE/0xFFFFFFFFFFFFFFFE/0xFFFFFFFE, ! so 'Hi2' will not overflow. ! 'Lo' + 'Hi2' may alse get a carry bit and may affect 'Hi', but only ! the highest significant 113/53/24 bits of 'Hi' is needed. If there is a 0 ! in the lower bits of 'Hi', then all the following bits can be dropped. ! To convert the result to IEEE-754 double number, we need to perform ! correct rounding: ! 1. if bit 114/54/25 is 0, round down, ! 2. if bit 114/54/25 is 1 and any bit beyond bit 114/54/25 is 1, round up, ! 3. if bit 114/54/25 is 1 and all bits beyond bit 114/54/25 are 0, round to even, !    as the extra bits is unknown, this case will not be handled here. ! initialize Exact = FalseVal Success = FalseVal ! convert (10*ExpDec) to (Sig2 * 2**Exp2) Pow10 = Get_Pow10_64Bits ( ExpDec ) Sig2 = SHIFTR ( Pow10 , 32 ) Sig2_Ext = IAND ( Pow10 , MaskU32 ) Exp2 = Floor_Log2_Pow10 ( ExpDec ) - SignBits ! normalize and multiply Lz = LEADZ ( SigDec ) Sig1 = SHIFTL ( SigDec , Lz ) Exp2 = Exp2 - Lz FirstProduct = ToUnsignedLong ( Sig1 ) * Sig2 Lo = INT ( IAND ( FirstProduct , MaskU32 ), KIND = I4B ) Hi = INT ( SHIFTR ( FirstProduct , 32 ), KIND = I4B ) ! To get normalized value, 'Hi' should be shifted to the left by 0 or 1. ! The highest significant 113/53/24 bits is used by IEEE-754 double number, ! and the bit 114/54/25 is used to detect rounding direction. ! The lowest 13 (= 128 - 114 - 1) / 9 (= 64 - 54 - 1) / 6 (= 32 - 25 - 1) bits (LowBits) ! is used to check whether it contains 0. ! Note: BitMask = SHIFTL(1, LowBits) - 1 Bits = IAND ( Hi , BitMask ) IF (( Bits /= 0_I4B ). AND .( Bits /= BitMask )) THEN ! The 'Bits' is not zero, so we don't need to check 'round to even' case. ! The 'Bits' contains bit '0', so we can drop the extra bits after '0'. Exact = TrueVal ELSE ! The 'Bits' is filled with all '0' or all '1', so we need to check ! more lower bits with another multiplication. SecondProduct = ToUnsignedLong ( Sig1 ) * Sig2_Ext Hi2 = INT ( SHIFTR ( SecondProduct , 32 ), KIND = I4B ) Add = Lo + Hi2 IF (( Add /= 0_I4B ). AND .( Add /= MaxUInt )) THEN ! The 'Add' is not zero, so we don't need to check 'round to even' case. ! The 'Add' contains bit '0', so we can drop the extra bits after '0'. ! The 'Hi' cannot be MaxUInt, so it will not overflow. IF (( Add . ULT . Lo ). OR .( Add . ULT . Hi2 )) Hi = Hi + 1_I4B Exact = TrueVal END IF END IF IF ( Exact ) THEN ! normalize IF ( Hi . ULT . SignMask ) THEN Hi = SHIFTL ( Hi , 1 ) Exp2 = Exp2 - 1 END IF Exp2 = Exp2 + TotalBits ! test the bit 114 and get rounding direction IF ( IAND ( Hi , AddRound ) /= 0_I4B ) Hi = Hi + AddRound ! test overflow IF ( Hi . ULT . AddRound ) THEN Hi = SignMask Exp2 = Exp2 + 1 END IF ! This is a normal number, convert it to binary representation. SigBin = SHIFTR ( Hi , ExponentBits ) ExpBin = Exp2 + ( ExponentBits + SignificandBits ) + ExponentBias Success = TrueVal END IF RETURN END FUNCTION D2B_YY_FastPath !************************************************************************** END FUNCTION Dec2Bin_YY !****************************************************************************** FUNCTION D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use YY's slow path algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information INTEGER ( KIND = I4B ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: ERR_ULP_LOG = 3 INTEGER ( KIND = I4B ), PARAMETER :: ERR_ULP = SHIFTL ( 1 , ERR_ULP_LOG ) INTEGER ( KIND = I4B ), PARAMETER :: ERR_CACHED_POW = ERR_ULP / 2 INTEGER ( KIND = I4B ), PARAMETER :: ERR_MUL_FIXED = ERR_ULP / 2 INTEGER ( KIND = I4B ), PARAMETER :: DIY_SIG_BITS = TotalBits INTEGER ( KIND = I4B ), PARAMETER :: EXP_BIAS = ExponentBias + SignificandBits INTEGER ( KIND = I4B ), PARAMETER :: EXP_SUBNORMAL = - EXP_BIAS + 1 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE DERIVED TYPE DEFINITIONS ! \"Do It Yourself Floating Point\" TYPE Diy_Fp INTEGER ( KIND = I4B ) :: Sig ! significand INTEGER ( KIND = I4B ) :: Exp ! exponent, base 2 END TYPE ! ---------------------------------------------------------------------------- !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: FpErr , PrecisionBits , HalfWay INTEGER ( KIND = I4B ) :: Bits INTEGER ( KIND = I4B ) :: Order_of_Magnitude , Effective_Significand_Size INTEGER ( KIND = I4B ) :: PrecisionDigitsCount , Cmp , Exp10 TYPE ( Diy_Fp ) :: Fp , FpUpper TYPE ( BigUInt ) :: BigFull , BigComp !** FLOW ! Slow path: read floating-point number exactly with diyfp. ! 1. Use cached diyfp to get an approximation value. ! 2. Use bigcomp to check the approximation value if needed. ! This algorithm refers to google's double-conversion project: ! https://github.com/google/double-conversion ! initialize IF ( Negative ) THEN Sign = 1_I4B ELSE Sign = 0_I4B END IF Fp % Sig = SigDec Fp % Exp = 0 IF ( Aux % Truncated ) THEN FpErr = INT ( ERR_ULP / 2 , KIND = I4B ) ! round up if the next digit after the cut is more than or equal to 5 IF (( IACHAR ( cStr ( Aux % SigCut : Aux % SigCut )) - A0 ) >= 5 ) Fp % Sig = Fp % Sig + 1_I4B ELSE FpErr = 0_I4B END IF ! normalize Bits = LEADZ ( Fp % Sig ) Fp % Sig = SHIFTL ( Fp % Sig , Bits ) Fp % Exp = Fp % Exp - Bits FpErr = SHIFTL ( FpErr , Bits ) ! multiply and add error Fp = Diy_Fp_Mul ( Fp , Diy_Fp_Get_Cached_Pow10 ( ExpDec )) IF ( FpErr == 0_I4B ) THEN FpErr = FpErr + INT ( ERR_CACHED_POW + ERR_MUL_FIXED , KIND = I4B ) ELSE FpErr = FpErr + INT ( ERR_CACHED_POW + ERR_MUL_FIXED + 1 , KIND = I4B ) END IF ! normalize Bits = LEADZ ( Fp % Sig ) Fp % Sig = SHIFTL ( Fp % Sig , Bits ) Fp % Exp = Fp % Exp - Bits FpErr = SHIFTL ( FpErr , Bits ) ! effective significand Order_of_Magnitude = DIY_SIG_BITS + Fp % Exp IF ( Order_of_Magnitude >= EXP_SUBNORMAL + BinaryPrecision ) THEN Effective_Significand_Size = BinaryPrecision ELSEIF ( Order_of_Magnitude <= EXP_SUBNORMAL ) THEN Effective_Significand_Size = 0 ELSE Effective_Significand_Size = Order_of_Magnitude - EXP_SUBNORMAL END IF ! precision digits count PrecisionDigitsCount = DIY_SIG_BITS - Effective_Significand_Size IF ( PrecisionDigitsCount + ERR_ULP_LOG >= DIY_SIG_BITS ) THEN BLOCK INTEGER ( KIND = I4B ) :: Shr Shr = ( PrecisionDigitsCount + ERR_ULP_LOG ) - DIY_SIG_BITS + 1 Fp % Sig = SHIFTR ( Fp % Sig , Shr ) Fp % Exp = Fp % Exp + Shr FpErr = SHIFTR ( FpErr , Shr ) + INT ( 1 + ERR_ULP , KIND = I4B ) PrecisionDigitsCount = PrecisionDigitsCount - Shr END BLOCK END IF ! half way PrecisionBits = IAND ( Fp % Sig , ( SHIFTL ( 1_I4B , PrecisionDigitsCount ) - 1_I4B )) PrecisionBits = PrecisionBits * ERR_ULP HalfWay = SHIFTL ( 1_I4B , ( PrecisionDigitsCount - 1 )) HalfWay = HalfWay * ERR_ULP ! rounding Fp % Sig = SHIFTR ( Fp % Sig , PrecisionDigitsCount ) IF ( PrecisionBits . UGE . HalfWay + FpErr ) Fp % Sig = Fp % Sig + 1_I4B Fp % Exp = Fp % Exp + PrecisionDigitsCount ! get IEEE raw value RawFP = Diy_Fp_To_IEEE_Raw ( Fp ) IF ( RawFP == FpRawInf ) THEN RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN END IF IF (( PrecisionBits . ULE . HalfWay - FpErr ). OR .( PrecisionBits . UGE . HalfWay + FpErr )) THEN ! number is accurate RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN END IF ! ------------------------------------------------------------------------- ! now the number is the correct value, or the next lower value ! ------------------------------------------------------------------------- ! upper boundary IF ( IAND ( RawFP , ExponentMask ) /= 0_I4B ) THEN FpUpper % Sig = IAND ( RawFP , SignificandMask ) + SHIFTL ( 1_I4B , SignificandBits ) FpUpper % Exp = INT ( SHIFTR ( IAND ( RawFP , ExponentMask ), SignificandBits ), KIND = I4B ) ELSE FpUpper % Sig = IAND ( RawFP , SignificandMask ) FpUpper % Exp = 1 END IF FpUpper % Exp = FpUpper % Exp - ( ExponentBias + SignificandBits ) FpUpper % Sig = SHIFTL ( FpUpper % Sig , 1 ) FpUpper % Exp = FpUpper % Exp - 1 FpUpper % Sig = FpUpper % Sig + 1 ! add half ulp ! compare with BigInt Exp10 = ExpDec CALL BigInt_Set_String ( BigFull , SigDec , Exp10 , cStr , Aux ) CALL BigInt_Set_UIntType ( BigComp , FpUpper % Sig ) IF ( Exp10 >= 0 ) THEN CALL BigInt_Mul_Pow10 ( BigFull , + Exp10 ) ELSE CALL BigInt_Mul_Pow10 ( BigComp , - Exp10 ) END IF IF ( FpUpper % Exp > 0 ) THEN CALL BigInt_Mul_Pow2 ( BigComp , + FpUpper % Exp ) ELSE CALL BigInt_Mul_Pow2 ( BigFull , - FpUpper % Exp ) END IF Cmp = BigInt_Compare ( BigFull , BigComp ) IF ( Cmp /= 0 ) THEN ! round down or round up IF ( Cmp > 0 ) RawFP = RawFP + 1_I4B ELSE ! falls midway, round to even IF ( IAND ( RawFP , 1_I4B ) /= 0_I4B ) RawFP = RawFP + 1_I4B END IF RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN CONTAINS FUNCTION Diy_Fp_Get_Cached_Pow10 ( Exp10 ) RESULT ( Fp ) !** PURPOSE OF THIS SUBROUTINE: ! To get cached rounded diy_fp with pow(10, e). The input value must in range ! [POW10_SIG_TABLE_MIN_EXP, POW10_SIG_TABLE_MAX_EXP]. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp10 ! an exponent TYPE ( Diy_Fp ) :: Fp ! Diy_Fp data !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 INTEGER ( KIND = I4B ) :: Sig_Ext !** FLOW Pow10 = Get_Pow10_64Bits ( Exp10 ) Fp % Sig = INT ( SHIFTR ( Pow10 , 32 ), KIND = I4B ) Sig_Ext = INT ( IAND ( Pow10 , MaskU32 ), KIND = I4B ) Fp % Exp = Floor_Log2_Pow10 ( Exp10 ) - SignBits Fp % Sig = Fp % Sig + SHIFTR ( Sig_Ext , SignBits ) RETURN END FUNCTION Diy_Fp_Get_Cached_Pow10 !************************************************************************** FUNCTION Diy_Fp_Mul ( Fp1 , Fp2 ) RESULT ( Fp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'fp1 * fp2'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Diy_Fp ), INTENT ( IN ) :: Fp1 , Fp2 TYPE ( Diy_Fp ) :: Fp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Hi , Lo INTEGER ( KIND = I8B ) :: Product !** FLOW Product = ToUnsignedLong ( Fp1 % Sig ) * ToUnsignedLong ( Fp2 % Sig ) Lo = INT ( IAND ( Product , MaskU32 ), KIND = I4B ) Hi = INT ( SHIFTR ( Product , 32 ), KIND = I4B ) Fp % Sig = Hi + SHIFTR ( Lo , SignBits ) Fp % Exp = Fp1 % Exp + Fp2 % Exp + TotalBits RETURN END FUNCTION Diy_Fp_Mul !************************************************************************** FUNCTION Diy_Fp_To_IEEE_Raw ( Fp ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To convert diy_fp to IEEE-754 raw value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Diy_Fp ), INTENT ( IN ) :: Fp INTEGER ( KIND = I4B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Sig INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I4B ) :: Lz_Bits !** FLOW ! initialize Sig = Fp % Sig Exp = Fp % Exp Val = 0_I4B IF ( Sig == 0_I4B ) RETURN ! compute significand and exponent Lz_Bits = LEADZ ( Sig ) Sig = SHIFTL ( Sig , Lz_Bits ) Sig = SHIFTR ( Sig , ExponentBits ) Exp = Exp - Lz_Bits + ExponentBits + SignificandBits ! check which range the result falls IF ( Exp >= MaxExpBin ) THEN ! overflow Val = RawFP_SetInfinity ( FalseVal ) ELSEIF ( Exp >= ( MinExpBin - 1 )) THEN ! normal Exp = Exp + ExponentBias Val = IOR ( SHIFTL ( INT ( Exp , KIND = I4B ), SignificandBits ), IAND ( Sig , SignificandMask )) ELSEIF ( Exp >= ( MinExpBin - BinaryPrecision )) THEN ! subnormal Val = SHIFTR ( Sig , ( MinExpBin - Exp - 1 )) ELSE ! underflow Val = 0_I4B END IF RETURN END FUNCTION Diy_Fp_To_IEEE_Raw !************************************************************************** END FUNCTION D2B_YY_SlowPath !****************************************************************************** FUNCTION Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand, base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent, base 10 LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information INTEGER ( KIND = I4B ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange - UIntSafeDigits + 1 INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange + 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SigBin ! significand, base 2 INTEGER ( KIND = I4B ) :: ExpBin ! exponent, base 2 !** FLOW ! check whether to use Lemire's fast path IF ((. NOT . Aux % Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN IF ( D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! Lemire's fast path is success so set sign bit IF ( Negative ) THEN RawFP = SignMask ELSE RawFP = 0_I4B END IF ! then, add exponent bits RawFP = IOR ( RawFP , SHIFTL ( INT ( ExpBin , KIND = I4B ), SignificandBits )) ! finally, add (both implicit and explicit) significand bits RawFP = IOR ( RawFP , IAND ( SigBin , SignificandMask )) RETURN END IF END IF ! perform decimal to binary conversion using YY's slow path RawFP = D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RETURN CONTAINS FUNCTION D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_Lemire_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's fast path algorithm to convert from decimal to binary representation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 INTEGER ( KIND = I8B ) :: MulProduct INTEGER ( KIND = I4B ) :: LZ INTEGER ( KIND = I4B ) :: Upperbit INTEGER ( KIND = I4B ) :: Significand INTEGER ( KIND = I4B ) :: Lower , Upper INTEGER ( KIND = I4B ) :: Exponent !** FLOW ! get 256/128/64-bit approximation of power of 10 (or power of 5) Pow10 = Get_Pow10_64Bits ( ExpDec ) ! compute the exponent Exponent = Floor_Log2_Pow10 ( ExpDec ) + MaxExpBin + SignBits ! +++ normalize the significand +++ ! We want the most significant bit of Significand to be 1. Shift if needed. LZ = LEADZ ( SigDec ) Significand = SHIFTL ( SigDec , LZ ) ! +++ perform multiplication +++ ! We want the most significant 128/64/32 bits of the product. We know this will be non-zero ! because the most significant bit of Significand is 1. MulProduct = ToUnsignedLong ( Significand ) * SHIFTR ( Pow10 , 32 ) Lower = INT ( IAND ( MulProduct , MaskU32 ), KIND = I4B ) Upper = INT ( SHIFTR ( MulProduct , 32 ), KIND = I4B ) ! We know that Upper has at most one leading zero because both Significand and  Pow10 have a leading one. ! As long as the first 13/9/6 bits of \"upper\" are not \"1\", then we know that we have an exact computed ! value for the leading 125/55/26 bits because any imprecision would play out as a +1, in the worst case. ! Having 125/55/26 bits is necessary because we need 123/53/24 bits for the mantissa but we have to have ! one rounding bit and we can waste a bit if the most significant bit of the product is zero. We expect ! this next branch to be rarely taken (say 1% of the time). When (Upper & BitMask) == BitMask, ! it can be common for Lower + Significand < Lower to be true (proba. much higher than 1%). ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ IF (( IAND ( Upper , BitMask ) == BitMask ). AND .(( Lower + Significand ) . ULT . Lower )) THEN BLOCK ! --- declaration --- INTEGER ( KIND = I4B ) :: Product_Low , Product_High INTEGER ( KIND = I4B ) :: Product_Middle , Product_Middle1 , Product_Middle2 ! --- execution --- ! perform multiplication MulProduct = ToUnsignedLong ( Significand ) * IAND ( Pow10 , MaskU32 ) Product_Low = INT ( IAND ( MulProduct , MaskU32 ), KIND = I4B ) Product_Middle2 = INT ( SHIFTR ( MulProduct , 32 ), KIND = I4B ) Product_Middle1 = Lower Product_High = Upper Product_Middle = Product_Middle1 + Product_Middle2 ! overflow carry IF ( Product_Middle . ULT . Product_Middle1 ) Product_High = Product_High + 1_I4B ! we want to check whether Pow10*Significand + Significand would affect our result ! This does happen, e.g. with 7.3177701707893310E+15 (for double-precision) IF ((( Product_Middle + 1_I4B == 0_I4B ). AND .( IAND ( Product_High , BitMask ) == BitMask ) & . AND .( Product_Low + Significand . ULT . Product_Low ))) THEN ! let us be prudent and bail out. Success = FalseVal RETURN END IF Lower = Product_Middle Upper = Product_High END BLOCK END IF ! The final mantissa should be 123/53/24 (BinaryPrecision) bits with a leading 1. ! We shift it so that it occupies 124/54/25 (BinaryPrecision+1) bits with a leading 1. Upperbit = INT ( SHIFTR ( Upper , SignBits ), KIND = I4B ) SigBin = SHIFTR ( Upper , ( Upperbit + LowBits )) LZ = LZ + IEOR ( 1 , Upperbit ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision+1). ! We have to round to even. The \"to even\" part ! is only a problem when we are right in between two floats ! which we guard against. ! If we have lots of trailing zeros, we may fall right between two ! floating-point values. IF (( Lower == 0_I4B ). AND .( IAND ( Upper , BitMask ) == 0_I4B ). AND . & ( IAND ( SigBin , ThreeUInt ) == 1_I4B )) THEN ! if IAND(SigBin, 1) == 1 we might need to round up. ! Scenarios: ! 1. We are not in the middle. Then we should round up. ! 2. We are right in the middle. Whether we round up depends on the last significant !    bit: if it is \"one\" then we round up (round to even) otherwise, we do not. ! So if the last significant bit is 1, we can safely round up.  Hence we only need ! to bail out if IAND(SigBin, 3) == 1.  Otherwise we may need more accuracy or analysis ! to determine whether we are exactly between two floating-point numbers. ! It can be triggered with 1E23. ! Note: because the factor_mantissa and factor_mantissa_low are almost always rounded !       down (except for small positive powers), almost always should round up. Success = FalseVal RETURN END IF SigBin = SHIFTR ( SigBin + IAND ( SigBin , 1_I4B ), 1 ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision), unless there was an overflow IF ( SigBin . UGE . MaxMantissa ) THEN ! This will happen when parsing values such as 7.2057594037927933E+16 SigBin = SigHidBitMask ! undo previous addition LZ = LZ - 1 END IF SigBin = IAND ( SigBin , NOT ( SigHidBitMask )) ExpBin = Exponent - LZ ! we have to check that ExpBin is in range, otherwise we bail out IF (( ExpBin < 1 ). OR .( ExpBin > ( MaxExponent - 1 ))) THEN Success = FalseVal ELSE Success = TrueVal END IF RETURN END FUNCTION D2B_Lemire_FastPath !************************************************************************** END FUNCTION Dec2Bin_Lemire !****************************************************************************** !------------------------------------------------------------------------------ ! !                           REAL32 AUXILIARY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION DivByPow10 ( X , P ) RESULT ( Y ) !** PURPOSE OF THIS SUBROUTINE: ! To compute Y = X .UDIV. (10**P) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X ! X <= 10**10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! 1 <= P <= 8 INTEGER ( KIND = I4B ) :: Y !** SUBROUTINE PARAMETER DECLARATIONS: ! Parameters for division by power of 10 applicable for N <= 10 digits ! (i.e. used for division of the 'Significand') INTEGER ( KIND = I8B ), PARAMETER :: MagicM ( 1 : 8 ) = [ & INT ( Z '0000000333333334' , KIND = I8B ), INT ( Z '000000028F5C28F6' , KIND = I8B ), & INT ( Z '00000004189374BD' , KIND = I8B ), INT ( Z '0000000346DC5D64' , KIND = I8B ), & INT ( Z '000000029F16B11D' , KIND = I8B ), INT ( Z '0000000431BDE82E' , KIND = I8B ), & INT ( Z '000000035AFE5358' , KIND = I8B ), INT ( Z '00000002AF31DC47' , KIND = I8B )] INTEGER ( KIND = I4B ), PARAMETER :: MagicS ( 1 : 8 ) = [ 37 , 40 , 44 , 47 , 50 , 54 , 57 , 60 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Multiplier INTEGER ( KIND = I4B ) :: Shift !** FLOW Multiplier = MagicM ( P ) Shift = MagicS ( P ) Y = INT ( SHIFTR ( ToUnsignedLong ( X ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION DivByPow10 !****************************************************************************** FUNCTION WRITE_RealSP ( Fp , Ep , cStr , IsScientific ) RESULT ( sLen ) !DIR$ ATTRIBUTES INLINE :: WRITE_RealSP !** PURPOSE OF THIS SUBROUTINE: ! To format the decimal F*10**E IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Fp ! significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: Ep ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE PARAMETER DECLARATIONS: ! maximum number of significant digits (i.e. the maximum decimal precision !   that guarantees an error-free write-read cycle.) INTEGER ( KIND = I4B ), PARAMETER :: H = 9 ! shift and multiplier parameters (i.e. magic number) for integer division INTEGER ( KIND = I4B ), PARAMETER :: S98 = 57 INTEGER ( KIND = I8B ), PARAMETER :: M98 = 1441151881_I8B INTEGER ( KIND = I4B ), PARAMETER :: S178 = 20 ! = 84-64 INTEGER ( KIND = I8B ), PARAMETER :: M178 = 193428131138340668_I8B INTEGER ( KIND = I8B ), PARAMETER :: DivE8 = 100000000_I8B ! The first powers of 10. The last entry must be 10&#94;H. INTEGER ( KIND = I4B ) :: I INTEGER ( KIND = I8B ), PARAMETER :: Pow10 ( 0 : H ) = [( 10 ** I , I = 0 , H )] ! Used for left-to-tight digit extraction. INTEGER ( KIND = I4B ), PARAMETER :: MASK_28 = SHIFTL ( 1 , 28 ) - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: F INTEGER ( KIND = I4B ) :: E , HF , LF LOGICAL :: IsGeneral ! true if to write the given number in general format !** FLOW ! check for special cases IF ( Ep == ExceptionalExponent ) THEN ! either NaN or Infinity IF ( Fp /= 0_I4B ) THEN cStr ( 1 : 3 ) = 'NaN' sLen = 3 ELSE cStr ( 1 : 8 ) = 'Infinity' sLen = 8 END IF RETURN END IF IF ( Fp == 0_I4B ) THEN ! zero cStr ( 1 : 3 ) = '0.0' sLen = 3 RETURN END IF ! For details not discussed here see section 10 of [3]. ! Determine len such that 10**(sLen-1) <= F < 10**sLen sLen = Floor_Log10_Pow2 ( 32 - LEADZ ( Fp )) IF ( Fp >= Pow10 ( sLen )) sLen = sLen + 1 ! Let Fp and Ep be the original F and E, respectively. ! Transform F and E to ensure !    10**(H-1) <= F < 10**H !    Fp*10**Ep = F*10**(E-H) = 0.F*10**E F = Fp * Pow10 ( H - sLen ) E = Ep + sLen ! ToChars perform left-to-right digits extraction using integers, ! provided that the arguments are limited to 8 digits. ! Therefore, split the H = 9 digits of F into: !     HF = the most significant digit of F !     LF = the last 8, least significant digits of F ! ! For N = 9, M = 8 the table in section 10 of [2] shows !     Floor(F/10**8) = Floor((1,441,151,881*F/2**57) ! HF = INT ( SHIFTR ( F * M98 , S98 ), KIND = I4B ) LF = INT ( F - DivE8 * HF , KIND = I4B ) ! set format flag IsGeneral = TrueVal IF ( PRESENT ( IsScientific )) IsGeneral = . NOT . IsScientific ! write output IF ( IsGeneral ) THEN IF (( 0 < E ). AND .( E <= 7 )) THEN ! plain format without leading zeroes sLen = ToChar_Plain_Without_LZ ( HF , LF , E , cStr ) ELSEIF (( - 3 < E ). AND .( E <= 0 )) THEN ! plain format with leading zeroes sLen = ToChar_Plain_With_LZ ( HF , LF , E , cStr ) ELSE ! scientific notation sLen = ToChar_Scientific ( HF , LF , E , cStr ) END IF ELSE ! scientific notation sLen = ToChar_Scientific ( HF , LF , E , cStr ) END IF RETURN CONTAINS FUNCTION ToChar_Plain_Without_LZ ( H , L , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Plain_Without_LZ !** PURPOSE OF THIS SUBROUTINE: ! For 0 < E <= 7, plain format without leading zeroes. ! Left-to-right digits extraction: ! algorithm 1 in [7], with b = 10, k = 8, n = 28. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: H ! high digit INTEGER ( KIND = I4B ), INTENT ( IN ) :: L ! low digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Y , T , I , Pos !** FLOW cStr ( 1 : 1 ) = Char1Digit ( H ) Pos = 2 ! Algorithm 1 in [7] needs computation of floor((a + 1) 2&#94;n / b&#94;k) - 1 ! with a < 10&#94;8, b = 10, k = 8, n = 28. ! Noting that (a + 1) 2&#94;n <= 10&#94;8 2&#94;28 < 10&#94;17 ! For n = 17, m = 8 the table in section 10 of [3] leads to: Y = INT ( SHIFTR ( UMul128_Upper64 ( SHIFTL ( INT ( L + 1 , KIND = I8B ), 28 ), M178 ), S178 ), KIND = I4B ) - 1 I = 1 DO WHILE ( I < E ) T = 10 * Y ! append digit cStr ( Pos : Pos ) = Char1Digit ( SHIFTR ( T , 28 )) Pos = Pos + 1 Y = IAND ( T , MASK_28 ) I = I + 1 END DO ! append period cStr ( Pos : Pos ) = '.' Pos = Pos + 1 DO WHILE ( I <= 8 ) T = 10 * Y ! append digit cStr ( Pos : Pos ) = Char1Digit ( SHIFTR ( T , 28 )) Pos = Pos + 1 Y = IAND ( T , MASK_28 ) I = I + 1 END DO Pos = Pos - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! set length sLen = Pos RETURN END FUNCTION ToChar_Plain_Without_LZ !****************************************************************************** FUNCTION ToChar_Plain_With_LZ ( H , L , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Plain_With_LZ !** PURPOSE OF THIS SUBROUTINE: ! For -3 < E <= 0: plain format with leading zeroes. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: H ! high digit INTEGER ( KIND = I4B ), INTENT ( IN ) :: L ! low digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pos !** FLOW ! fill the first 4 characters cStr ( 1 : 4 ) = '0.00' ! compute Pos Pos = 3 - E ! append H cStr ( Pos : Pos ) = Char1Digit ( H ) Pos = Pos + 1 ! append L Pos = Pos + Write_U32_8_Digits ( L , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! set length sLen = Pos RETURN END FUNCTION ToChar_Plain_With_LZ !****************************************************************************** FUNCTION ToChar_Scientific ( H , L , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Scientific !** PURPOSE OF THIS SUBROUTINE: ! For E <= -3 or E > 7: computerized scientific notation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: H ! high digit INTEGER ( KIND = I4B ), INTENT ( IN ) :: L ! low digits INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pos !** FLOW ! append H cStr ( 1 : 1 ) = Char1Digit ( H ) ! append period cStr ( 2 : 2 ) = '.' Pos = 3 ! append L Pos = Pos + Write_U32_8_Digits ( L , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! append exponent Pos = Pos + 1 cStr ( Pos : Pos ) = 'E' sLen = Pos + Write_I32_Exponent ( E - 1 , cStr ( Pos + 1 :)) RETURN END FUNCTION ToChar_Scientific !****************************************************************************** FUNCTION Write_U32_8_Digits ( Number , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_U32_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 digits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE PARAMETER DECLARATIONS: ! shift and multiplier parameters (i.e. magic number) for integer division INTEGER ( KIND = I4B ), PARAMETER :: Shf78 = 40 INTEGER ( KIND = I8B ), PARAMETER :: Mul78 = 109951163_I8B INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NxtNum , RemNum !** FLOW ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * Mul78 , Shf78 ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = Number - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) ! convert the rest (NxtNum) cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) sLen = 8 RETURN END FUNCTION Write_U32_8_Digits !************************************************************************** FUNCTION Write_I32_Exponent ( Exp , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_I32_Exponent !** PURPOSE OF THIS SUBROUTINE: ! To write a signed integer in the range -45 to 38 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! exponent number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosExp !** FLOW IF ( Exp < 0 ) THEN cStr ( 1 : 1 ) = '-' ELSE cStr ( 1 : 1 ) = '+' END IF PosExp = ABS ( Exp ) IF ( PosExp < 10 ) THEN ! 1 digit cStr ( 2 : 2 ) = Char1Digit ( PosExp ) sLen = 2 ELSE ! 2 digits cStr ( 2 : 3 ) = Char2Digits ( PosExp ) sLen = 3 END IF RETURN END FUNCTION Write_I32_Exponent !************************************************************************** END FUNCTION WRITE_RealSP !****************************************************************************** END MODULE ModBase_RealSP_CharConv !******************************************************************************","tags":"","loc":"sourcefile\\modbase - realsp - charconv.f90.html"},{"title":"ModBase - UIntUtil.f90 – FortCharConv","text":"Source Code MODULE ModBase_UIntUtil !&#94; **PURPOSE OF THIS MODULE**: ! This module contains routines that perform comparisons and arithmetic ! operations for unsigned integers.  The module also provide various ! utility routines including conversions from an unsigned integer to ! a string as well as unsigned multiplications (to higher precision). ! !&#94; **REFERENCES**: !\t[1] [Guava: Google Core Libraries for Java](https://github.com/google/guava) !\t[2] [Java's OpenJDK](https://github.com/openjdk/jdk) !\t[3] [FLIBS - A collection of Fortran modules](https://flibs.sourceforge.net/) ! !&#94; **TECHNICAL NOTES**: ! According to [3], Fortran does not natively support unsigned integers but !   intrinsic (signed) integer types in Fortran behave the same as unsigned !   one for positive values.  For negative values, however, they behave differently !   for the following operations: !    - *conversion*:   to and from string !    - *comparision*:  less than (<), less than or equal to(<=), !                      greater than (>), greater than or equal to (>=) !    - *arithmetic*:   division (/) and modulation (MOD) !   (note that in two's complement arithmetic, the three other basic !    arithmetic operations of add, subtract, and multiply are bit-wise !    identical if the two operands are regarded as both being signed !    or both being unsigned.) ! Therefore, the module only provides routines for those operations that differ. !   For those operations (the one that not yet mentioned including bitwise one) !   that have the same behaviors, normal Fortran expressions can be used. ! It is important to note that routines in this module cannot differentiate between !   signed and unsigned integers (i.e. they assume all integers (input and/or output) !   to be unsigned with the exception of output of 'CompareUnsigned' routines); thus, !   users of this module must be extremely careful not to mix up signed and unsigned !   integers in the same expressions. ! The application interface (API) used in this module follows closely that used in !   reference [3].  However, the implementations used here are mostly based on those !   in references [1] and [2] because it appears that algorithms used in [1] and [2] !   are more efficient than those used in [3]. !** USE STATEMENTS: USE ModBase_Common USE ModBase_SIntUtil IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! parameters PUBLIC :: MAX_U8 , MAX_U16 , MAX_U32 , MAX_U64 PUBLIC :: MIN_U8 , MIN_U16 , MIN_U32 , MIN_U64 ! comparison operators PUBLIC :: OPERATOR (. ULT .) PUBLIC :: OPERATOR (. ULE .) PUBLIC :: OPERATOR (. UGT .) PUBLIC :: OPERATOR (. UGE .) ! arithmetic operator and procedures PUBLIC :: OPERATOR (. UDIV .) PUBLIC :: UMOD , UDivMod ! comparison procedures PUBLIC :: CompareUnsigned ! conversion procedures PUBLIC :: ToUnsignedInteger PUBLIC :: ToUnsignedLong PUBLIC :: ToDecStrUnsigned PUBLIC :: ToHexStrUnsigned ! unsigned multiplications PUBLIC :: UMul96_Upper64 PUBLIC :: UMul96_Lower64 PUBLIC :: UMul128 ! U128_Multiply PUBLIC :: UMul128_Upper64 ! U128_Multiply_High PUBLIC :: UMul128_N_Add ! U128_Multiply_N_Add PUBLIC :: UMul128_N_Shift ! U128_Multiply_N_Shift PUBLIC :: UMul192_Upper128 PUBLIC :: UMul192_Lower128 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! bit and byte sizes INTEGER ( KIND = I4B ), PARAMETER :: Byte_BitSize = BIT_SIZE ( 1_I1B ) !  8 INTEGER ( KIND = I4B ), PARAMETER :: Byte_ByteSize = I1B !  1 INTEGER ( KIND = I4B ), PARAMETER :: Short_BitSize = BIT_SIZE ( 1_I2B ) ! 16 INTEGER ( KIND = I4B ), PARAMETER :: Short_ByteSize = I2B !  2 INTEGER ( KIND = I4B ), PARAMETER :: Integer_BitSize = BIT_SIZE ( 1_I4B ) ! 32 INTEGER ( KIND = I4B ), PARAMETER :: Integer_ByteSize = I4B !  4 INTEGER ( KIND = I4B ), PARAMETER :: Long_BitSize = BIT_SIZE ( 1_I8B ) ! 64 INTEGER ( KIND = I4B ), PARAMETER :: Long_ByteSize = I8B !  8 ! maximum values INTEGER ( KIND = I1B ), PARAMETER :: MAX_U8 = INT ( Z 'FF' , KIND = I1B ) !! 255 INTEGER ( KIND = I2B ), PARAMETER :: MAX_U16 = INT ( Z 'FFFF' , KIND = I2B ) !! 65535 INTEGER ( KIND = I4B ), PARAMETER :: MAX_U32 = INT ( Z 'FFFFFFFF' , KIND = I4B ) !! 4294967295 INTEGER ( KIND = I8B ), PARAMETER :: MAX_U64 = INT ( Z 'FFFFFFFFFFFFFFFF' , KIND = I8B ) !! 18446744073709551615 ! minimum values INTEGER ( KIND = I1B ), PARAMETER :: MIN_U8 = 0_I1B INTEGER ( KIND = I2B ), PARAMETER :: MIN_U16 = 0_I2B INTEGER ( KIND = I4B ), PARAMETER :: MIN_U32 = 0_I4B INTEGER ( KIND = I8B ), PARAMETER :: MIN_U64 = 0_I8B ! other parameters INTEGER ( KIND = I8B ), PARAMETER :: MaskU32 = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) !** DERIVED TYPE DEFINITIONS ! na !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE DEFINITIONS: INTERFACE OPERATOR (. ULT .) !&#94; **Operator Overload**: OPERATOR(.ULT.) !  **Purpose**:  To check if the LHS value is less than the RHS value !   return .TRUE. if LHS < RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .ULT. RHS !   --->    IF (LHS .ULT. RHS) DoSomething MODULE PROCEDURE UInt8_LT MODULE PROCEDURE UInt16_LT MODULE PROCEDURE UInt32_LT MODULE PROCEDURE UInt64_LT END INTERFACE INTERFACE OPERATOR (. ULE .) !&#94; **Operator Overload**: OPERATOR(.ULE.) !  **Purpose**:  To check if the LHS value is less than or equal to the RHS value !   return .TRUE. if LHS <= RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .ULE. RHS !   --->    IF (LHS .ULE. RHS) DoSomething MODULE PROCEDURE UInt8_LE MODULE PROCEDURE UInt16_LE MODULE PROCEDURE UInt32_LE MODULE PROCEDURE UInt64_LE END INTERFACE INTERFACE OPERATOR (. UGT .) !&#94; **Operator Overload**: OPERATOR(.UGT.) !  **Purpose**:  To check if the LHS value is greater than the RHS value !   return .TRUE. if LHS > RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .UGT. RHS !   --->    IF (LHS .UGT. RHS) DoSomething MODULE PROCEDURE UInt8_GT MODULE PROCEDURE UInt16_GT MODULE PROCEDURE UInt32_GT MODULE PROCEDURE UInt64_GT END INTERFACE INTERFACE OPERATOR (. UGE .) !&#94; **Operator Overload**: OPERATOR(.UGE.) !  **Purpose**:  To check if the LHS value is greater than or equal to the RHS value !   return .TRUE. if LHS >= RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .UGE. RHS !   --->    IF (LHS .UGE. RHS) DoSomething MODULE PROCEDURE UInt8_GE MODULE PROCEDURE UInt16_GE MODULE PROCEDURE UInt32_GE MODULE PROCEDURE UInt64_GE END INTERFACE INTERFACE OPERATOR (. UDIV .) !&#94; **Operator Overload**: OPERATOR(.UDIV.) !  **Purpose**:  To return the quotient of a division of two unsigned integers, !   where both input and an output have the same kind !  **Usage**: !   --->    QUOT = NUMER .UDIV. DENOM MODULE PROCEDURE UInt8_Divide MODULE PROCEDURE UInt16_Divide MODULE PROCEDURE UInt32_Divide MODULE PROCEDURE UInt64_Divide END INTERFACE INTERFACE UMOD !&#94; **Function Interface**: UMOD !  **Purpose**:  To return the remainder of a division of two unsigned integers, !   where both input and an output have the same kind !  **Usage**: !   --->    REM = UMOD(NUMER, DENOM) MODULE PROCEDURE UInt8_Remainder MODULE PROCEDURE UInt16_Remainder MODULE PROCEDURE UInt32_Remainder MODULE PROCEDURE UInt64_Remainder END INTERFACE INTERFACE UDivMod !&#94; **Subroutine Interface**: UDivMod !  **Purpose**:  To perform a division of two unsigned integers and then return both !   the quotient and the remainder where both input and output have the same kind !  **Usage**: !   --->    CALL UDivMod(NUMER, DENOM, QUOT, REM) MODULE PROCEDURE UInt32_DivMod MODULE PROCEDURE UInt64_DivMod END INTERFACE INTERFACE CompareUnsigned !&#94; **Function Interface**: CompareUnsigned !  **Purpose**:  To compare two unsigned integers (of the same kind) and return !   -1 if LHS < RHS !    0 if LHS == RHS !    1 if LHS > RHS !  **Usage**: !   --->    Flag = CompareUnsigned(LHS, RHS) !   --->    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE Compare_UInt8 MODULE PROCEDURE Compare_UInt16 MODULE PROCEDURE Compare_UInt32 MODULE PROCEDURE Compare_UInt64 END INTERFACE INTERFACE ToUnsignedInteger !&#94; **Function Interface**: ToUnsignedInteger !  **Purpose**:  To perform unsigned conversion from lower-precision unsigned integer !   to 32-bit unsigned integer !  **Usage**: !   --->    U32 = ToUnsignedInteger(U8) MODULE PROCEDURE ByteToUnsignedInteger MODULE PROCEDURE ShortToUnsignedInteger END INTERFACE INTERFACE ToUnsignedLong !&#94; **Function Interface**: ToUnsignedLong !  **Purpose**:  To perform unsigned conversion from lower-precision unsigned integer !   to 64-bit unsigned integer !  **Usage**: !   --->    U64 = ToUnsignedLong(U32) MODULE PROCEDURE ByteToUnsignedLong MODULE PROCEDURE ShortToUnsignedLong MODULE PROCEDURE IntegerToUnsignedLong END INTERFACE INTERFACE ToDecStrUnsigned !&#94; **Function Interface**: ToDecStrUnsigned !  **Purpose**:  To convert an unsigned integer to a decimal string !  **Usage**: !   --->    Str = ToDecStrUnsigned(U32) MODULE PROCEDURE U32_ToDecString MODULE PROCEDURE U64_ToDecString END INTERFACE INTERFACE ToHexStrUnsigned !&#94; **Function Interface**: ToHexStrUnsigned !  **Purpose**:  To convert an unsigned integer to a hexadecimal string !  **Usage**: !   --->    Str = ToHexStrUnsigned(U32) MODULE PROCEDURE U32_ToHexString MODULE PROCEDURE U64_ToHexString END INTERFACE CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   ROUTINES FOR BYTE INTEGER NUMBER !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION UInt8_LT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt8_LT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS < RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) < ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt8_LT !****************************************************************************** PURE FUNCTION UInt8_LE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt8_LE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS <= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) <= ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt8_LE !****************************************************************************** PURE FUNCTION UInt8_GT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt8_GT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS > RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) > ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt8_GT !****************************************************************************** PURE FUNCTION UInt8_GE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt8_GT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS >= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) >= ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt8_GE !****************************************************************************** PURE FUNCTION UInt8_Divide ( Dividend , Divisor ) RESULT ( ResVal ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt8_Divide !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned quotient of dividing the first argument by ! the second where each argument and the result is interpreted as ! an unsigned value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I1B ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ResVal = INT ( ToUnsignedInteger ( Dividend ) / ToUnsignedInteger ( Divisor ), KIND = I1B ) RETURN END FUNCTION UInt8_Divide !****************************************************************************** PURE FUNCTION UInt8_Remainder ( Dividend , Divisor ) RESULT ( Rem ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt8_Remainder !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned remainder from dividing the first argument ! by the second where each argument and the result is interpreted ! as an unsigned value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I1B ) :: Rem !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Rem = INT ( MOD ( ToUnsignedInteger ( Dividend ), ToUnsignedInteger ( Divisor )), KIND = I1B ) RETURN END FUNCTION UInt8_Remainder !****************************************************************************** PURE FUNCTION Compare_UInt8 ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Compare_UInt8 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS where both numbers are treated as unsigned. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Compare ( ToUnsignedInteger ( LHS ), ToUnsignedInteger ( RHS )) RETURN END FUNCTION Compare_UInt8 !****************************************************************************** PURE FUNCTION ByteToUnsignedInteger ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: ByteToUnsignedInteger !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert the argument to an integer by an unsigned ! conversion.  In an unsigned conversion to an integer, the ! high-order 24 bits of the integer are zero and the low-order ! 8 bits are equal to the bits of the byte argument. ! Consequently, zero and positive byte values are mapped ! to a numerically equal integer value and negative byte values ! are mapped to a integer value equal to the input plus 2**8. ! InVal  - the value to convert to an unsigned integer ! OutVal - the result converted to integer by an unsigned conversion IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( INT ( InVal , KIND = I4B ), Z '000000FF' ) RETURN END FUNCTION ByteToUnsignedInteger !****************************************************************************** PURE FUNCTION ByteToUnsignedLong ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: ByteToUnsignedLong !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert the argument to a long integer by an unsigned ! conversion.  In an unsigned conversion to a long, the ! high-order 56 bits of the long are zero and the low-order ! 8 bits are equal to the bits of the byte argument. ! Consequently, zero and positive byte values are mapped ! to a numerically equal long value and negative byte values ! are mapped to a long value equal to the input plus 2**8. ! InVal  - the value to convert to an unsigned long ! OutVal - the result converted to long by an unsigned conversion IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I1B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( INT ( InVal , KIND = I8B ), Z '00000000000000FF' ) RETURN END FUNCTION ByteToUnsignedLong !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   ROUTINES FOR SHORT INTEGER NUMBER !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION UInt16_LT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt16_LT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS < RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) < ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt16_LT !****************************************************************************** PURE FUNCTION UInt16_LE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt16_LE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS <= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) <= ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt16_LE !****************************************************************************** PURE FUNCTION UInt16_GT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt16_GT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS > RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) > ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt16_GT !****************************************************************************** PURE FUNCTION UInt16_GE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt16_GE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS >= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ToUnsignedInteger ( LHS ) >= ToUnsignedInteger ( RHS ) RETURN END FUNCTION UInt16_GE !****************************************************************************** PURE FUNCTION UInt16_Divide ( Dividend , Divisor ) RESULT ( ResVal ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt16_Divide !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned quotient of dividing the first argument by ! the second where each argument and the result is interpreted as ! an unsigned value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I2B ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ResVal = INT ( ToUnsignedInteger ( Dividend ) / ToUnsignedInteger ( Divisor ), KIND = I2B ) RETURN END FUNCTION UInt16_Divide !****************************************************************************** PURE FUNCTION UInt16_Remainder ( Dividend , Divisor ) RESULT ( Rem ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt16_Remainder !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned remainder from dividing the first argument ! by the second where each argument and the result is interpreted ! as an unsigned value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I2B ) :: Rem !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Rem = INT ( MOD ( ToUnsignedInteger ( Dividend ), ToUnsignedInteger ( Divisor )), KIND = I2B ) RETURN END FUNCTION UInt16_Remainder !****************************************************************************** PURE FUNCTION Compare_UInt16 ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Compare_UInt16 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS where both numbers are treated as unsigned. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Compare ( ToUnsignedInteger ( LHS ), ToUnsignedInteger ( RHS )) RETURN END FUNCTION Compare_UInt16 !****************************************************************************** PURE FUNCTION ShortToUnsignedInteger ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: ShortToUnsignedInteger !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert the argument to an integer by an unsigned ! conversion.  In an unsigned conversion to an integer, the ! high-order 16 bits of the integer are zero and the low-order ! 16 bits are equal to the bits of the short argument. ! Consequently, zero and positive short values are mapped ! to a numerically equal integer value and negative short values ! are mapped to a integer value equal to the input plus 2**16. ! InVal  - the value to convert to an unsigned integer ! OutVal - the result converted to integer by an unsigned conversion IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( INT ( InVal , KIND = I4B ), Z '0000FFFF' ) RETURN END FUNCTION ShortToUnsignedInteger !****************************************************************************** PURE FUNCTION ShortToUnsignedLong ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: ShortToUnsignedLong !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert the argument to a long integer by an unsigned ! conversion.  In an unsigned conversion to a long, the ! high-order 48 bits of the long are zero and the low-order ! 16 bits are equal to the bits of the short argument. ! Consequently, zero and positive short values are mapped ! to a numerically equal long value and negative short values ! are mapped to a long value equal to the input plus 2**16. ! InVal  - the value to convert to an unsigned long ! OutVal - the result converted to long by an unsigned conversion IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I2B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( INT ( InVal , KIND = I8B ), Z '000000000000FFFF' ) RETURN END FUNCTION ShortToUnsignedLong !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   ROUTINES FOR DEFAULT INTEGER NUMBER !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION UInt32_LT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_LT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS < RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I32 ) < IEOR ( RHS , MIN_I32 ) RETURN END FUNCTION UInt32_LT !****************************************************************************** PURE FUNCTION UInt32_LE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_LE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS <= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I32 ) <= IEOR ( RHS , MIN_I32 ) RETURN END FUNCTION UInt32_LE !****************************************************************************** PURE FUNCTION UInt32_GT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_GT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS > RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I32 ) > IEOR ( RHS , MIN_I32 ) RETURN END FUNCTION UInt32_GT !****************************************************************************** PURE FUNCTION UInt32_GE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_GE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS >= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I32 ) >= IEOR ( RHS , MIN_I32 ) RETURN END FUNCTION UInt32_GE !****************************************************************************** PURE FUNCTION UInt32_Divide ( Dividend , Divisor ) RESULT ( ResVal ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_Divide !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned quotient of dividing the first argument by ! the second where each argument and the result is interpreted as ! an unsigned value. ! Dividend - the value to be divided ! Divisor  - the value doing the dividing ! ResVal   - the unsigned quotient of the first argument divided by the second argument IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I4B ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! In lieu of tricky code, for now just use long arithmetic. ResVal = INT ( ToUnsignedLong ( Dividend ) / ToUnsignedLong ( Divisor ), KIND = I4B ) RETURN END FUNCTION UInt32_Divide !****************************************************************************** PURE FUNCTION UInt32_Remainder ( Dividend , Divisor ) RESULT ( Rem ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_Remainder !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned remainder from dividing the first argument ! by the second where each argument and the result is interpreted ! as an unsigned value. ! Dividend - the value to be divided ! Divisor  - the value doing the dividing ! Rem      - the unsigned remainder of the first argument divided by the second argument IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I4B ) :: Rem !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! In lieu of tricky code, for now just use long arithmetic. Rem = INT ( MOD ( ToUnsignedLong ( Dividend ), ToUnsignedLong ( Divisor )), KIND = I4B ) RETURN END FUNCTION UInt32_Remainder !****************************************************************************** PURE SUBROUTINE UInt32_DivMod ( Dividend , Divisor , Quotient , Remainder ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt32_DivMod !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned quotient of dividing the first argument by ! the second where each argument and the result is interpreted as ! an unsigned value. ! Dividend  - the value to be divided ! Divisor   - the value doing the dividing ! Quotient  - the unsigned quotient of the first argument divided by the second argument ! Remainder - the unsigned remainder of the first argument divided by the second argument IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I4B ), INTENT ( OUT ) :: Quotient , Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Q , R !** FLOW ! In lieu of tricky code, for now just use long arithmetic. CALL UDivMod ( ToUnsignedLong ( Dividend ), ToUnsignedLong ( Divisor ), Q , R ) Quotient = INT ( Q , KIND = I4B ) Remainder = INT ( R , KIND = I4B ) RETURN END SUBROUTINE UInt32_DivMod !****************************************************************************** PURE FUNCTION Compare_UInt32 ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Compare_UInt32 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS where both numbers are treated as unsigned. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Compare ( IEOR ( LHS , MIN_I32 ), IEOR ( RHS , MIN_I32 )) RETURN END FUNCTION Compare_UInt32 !****************************************************************************** PURE FUNCTION IntegerToUnsignedLong ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: IntegerToUnsignedLong !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert the argument to a long integer by an unsigned ! conversion.  In an unsigned conversion to a long, the ! high-order 32 bits of the long are zero and the low-order ! 32 bits are equal to the bits of the integer argument. ! Consequently, zero and positive integer values are mapped ! to a numerically equal long value and negative integer values ! are mapped to a long value equal to the input plus 2**32. ! InVal  - the value to convert to an unsigned long ! OutVal - the result converted to long by an unsigned conversion IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = IAND ( INT ( InVal , KIND = I8B ), Z '00000000FFFFFFFF' ) RETURN END FUNCTION IntegerToUnsignedLong !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   ROUTINES FOR LONG INTEGER NUMBER !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION UInt64_LT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_LT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS < RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I64 ) < IEOR ( RHS , MIN_I64 ) RETURN END FUNCTION UInt64_LT !****************************************************************************** PURE FUNCTION UInt64_LE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_LE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS <= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I64 ) <= IEOR ( RHS , MIN_I64 ) RETURN END FUNCTION UInt64_LE !****************************************************************************** PURE FUNCTION UInt64_GT ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_GT !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS > RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I64 ) > IEOR ( RHS , MIN_I64 ) RETURN END FUNCTION UInt64_GT !****************************************************************************** PURE FUNCTION UInt64_GE ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_GE !** PURPOSE OF THIS SUBROUTINE: !! To compare whether LHS >= RHS where both numbers are treated as unsigned. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LHS , RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IEOR ( LHS , MIN_I64 ) >= IEOR ( RHS , MIN_I64 ) RETURN END FUNCTION UInt64_GE !****************************************************************************** PURE FUNCTION UInt64_Divide ( Dividend , Divisor ) RESULT ( ResVal ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Divide !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned quotient of dividing the first argument by ! the second where each argument and the result is interpreted as ! an unsigned value. ! Dividend - the value to be divided ! Divisor  - the value doing the dividing ! ResVal   - the unsigned quotient of the first argument divided by the second argument IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I8B ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Quotient , Remainder !** FLOW ! See Hacker's Delight (2nd ed), section 9.3 IF ( Divisor >= 0_I8B ) THEN Quotient = SHIFTL ( SHIFTR ( Dividend , 1 ) / Divisor , 1 ) Remainder = Dividend - Quotient * Divisor ResVal = Quotient + SHIFTR ( IOR ( Remainder , NOT ( Remainder - Divisor )), ( Long_BitSize - 1 )) ELSE ResVal = SHIFTR ( IAND ( Dividend , NOT ( Dividend - Divisor )), ( Long_BitSize - 1 )) END IF RETURN END FUNCTION UInt64_Divide !****************************************************************************** PURE FUNCTION UInt64_Remainder ( Dividend , Divisor ) RESULT ( Rem ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Remainder !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned remainder from dividing the first argument ! by the second where each argument and the result is interpreted ! as an unsigned value. ! Dividend - the value to be divided ! Divisor  - the value doing the dividing ! Rem      - the unsigned remainder of the first argument divided by the second argument IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I8B ) :: Rem !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Q , R !** FLOW ! See Hacker's Delight (2nd ed), section 9.3 IF ( Divisor >= 0_I8B ) THEN Q = SHIFTL ( SHIFTR ( Dividend , 1 ) / Divisor , 1 ) R = Dividend - Q * Divisor ! Here, 0 <= r < 2 * divisor ! (1) When 0 <= r < divisor, the remainder is simply r. ! (2) Otherwise the remainder is r - divisor. ! ! In case (1), r - divisor < 0. Applying ~ produces a long with ! sign bit 0, so >> produces 0. The returned value is thus r. ! ! In case (2), a similar reasoning shows that >> produces -1, ! so the returned value is r - divisor. Rem = R - IAND ( SHIFTA ( NOT ( R - Divisor ), ( Long_BitSize - 1 )), Divisor ) ELSE ! (1) When dividend >= 0, the remainder is dividend. ! (2) Otherwise !      (2.1) When dividend < divisor, the remainder is dividend. !      (2.2) Otherwise the remainder is dividend - divisor ! ! A reasoning similar to the above shows that the returned value ! is as expected. Rem = Dividend - IAND ( SHIFTA ( IAND ( Dividend , NOT ( Dividend - Divisor )), & ( Long_BitSize - 1 )), Divisor ) END IF RETURN END FUNCTION UInt64_Remainder !****************************************************************************** PURE SUBROUTINE UInt64_DivMod ( Dividend , Divisor , Quotient , Remainder ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_DivMod !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the unsigned quotient of dividing the first argument by ! the second where each argument and the result is interpreted as ! an unsigned value. ! Dividend  - the value to be divided ! Divisor   - the value doing the dividing ! Quotient  - the unsigned quotient of the first argument divided by the second argument ! Remainder - the unsigned remainder of the first argument divided by the second argument IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Dividend , Divisor INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Quotient , Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Q , R !** FLOW ! See Hacker's Delight (2nd ed), section 9.3 IF ( Divisor >= 0_I8B ) THEN Q = SHIFTL ( SHIFTR ( Dividend , 1 ) / Divisor , 1 ) R = Dividend - Q * Divisor Quotient = Q + SHIFTR ( IOR ( R , NOT ( R - Divisor )), ( Long_BitSize - 1 )) ! Here, 0 <= r < 2 * divisor ! (1) When 0 <= r < divisor, the remainder is simply r. ! (2) Otherwise the remainder is r - divisor. ! ! In case (1), r - divisor < 0. Applying ~ produces a long with ! sign bit 0, so >> produces 0. The returned value is thus r. ! ! In case (2), a similar reasoning shows that >> produces -1, ! so the returned value is r - divisor. Remainder = R - IAND ( SHIFTA ( NOT ( R - Divisor ), ( Long_BitSize - 1 )), Divisor ) ELSE Quotient = SHIFTR ( IAND ( Dividend , NOT ( Dividend - Divisor )), ( Long_BitSize - 1 )) ! (1) When dividend >= 0, the remainder is dividend. ! (2) Otherwise !      (2.1) When dividend < divisor, the remainder is dividend. !      (2.2) Otherwise the remainder is dividend - divisor ! ! A reasoning similar to the above shows that the returned value ! is as expected. Remainder = Dividend - IAND ( SHIFTA ( IAND ( Dividend , NOT ( Dividend - Divisor )), & ( Long_BitSize - 1 )), Divisor ) END IF RETURN END SUBROUTINE UInt64_DivMod !****************************************************************************** PURE FUNCTION Compare_UInt64 ( LHS , RHS ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Compare_UInt64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS where both numbers are treated as unsigned. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LHS , RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Compare ( IEOR ( LHS , MIN_I64 ), IEOR ( RHS , MIN_I64 )) RETURN END FUNCTION Compare_UInt64 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   ROUTINES FOR CONVERSION TO STRING !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION U32_ToDecString ( Val ) RESULT ( RetStr ) ! PURPOSE OF THIS FUNCTION: !! To convert a 32-bit integer treated as an unsigned number into a string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine ! SUBROUTINE ARGUMENT DEFINITIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Val CHARACTER ( LEN = :), ALLOCATABLE :: RetStr ! SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na ! FLOW: IF ( Val >= 0 ) THEN RetStr = ToDecStrSigned ( Val ) ELSE BLOCK INTEGER ( KIND = I8B ) :: LongVal INTEGER ( KIND = I8B ) :: Quotient , Remainder CHARACTER ( LEN = :), ALLOCATABLE :: QuotStr , RemStr ! execution LongVal = IAND ( INT ( Val , KIND = I8B ), Z '00000000FFFFFFFF' ) Quotient = SHIFTR ( LongVal , 1 ) / 5 Remainder = LongVal - Quotient * 10 QuotStr = ToDecStrSigned ( Quotient ) RemStr = ToDecStrSigned ( Remainder ) RetStr = QuotStr // RemStr END BLOCK END IF RETURN END FUNCTION !****************************************************************************** FUNCTION U64_ToDecString ( Val ) RESULT ( RetStr ) ! PURPOSE OF THIS FUNCTION: !! To convert a 64-bit integer treated as an unsigned number into a string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine ! SUBROUTINE ARGUMENT DEFINITIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val CHARACTER ( LEN = :), ALLOCATABLE :: RetStr ! SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na ! FLOW: IF ( Val >= 0 ) THEN RetStr = ToDecStrSigned ( Val ) ELSE BLOCK INTEGER ( KIND = I8B ) :: Quotient , Remainder CHARACTER ( LEN = :), ALLOCATABLE :: QuotStr , RemStr ! execution Quotient = SHIFTR ( Val , 1 ) / 5 Remainder = Val - Quotient * 10 QuotStr = ToDecStrSigned ( Quotient ) RemStr = ToDecStrSigned ( Remainder ) RetStr = QuotStr // RemStr END BLOCK END IF RETURN END FUNCTION !****************************************************************************** FUNCTION U64_ToHexString ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an usigned 64-bit integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number treated as unsigned one CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! hexadecimal string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Shift = 4 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Quotient , Remainder CHARACTER ( LEN = :), ALLOCATABLE :: QuotStr , RemStr !** FLOW IF ( Number >= 0_I8B ) THEN cStr = ToHexStrSigned ( Number ) ELSE Quotient = SHIFTR ( Number , Shift ) Remainder = Number - SHIFTL ( Quotient , Shift ) QuotStr = ToHexStrSigned ( Quotient ) RemStr = ToHexStrSigned ( Remainder ) cStr = QuotStr // RemStr END IF RETURN END FUNCTION U64_ToHexString !****************************************************************************** FUNCTION U32_ToHexString ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an usigned 32-bit integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! hexadecimal string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Shift = 4 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Quotient , Remainder CHARACTER ( LEN = :), ALLOCATABLE :: QuotStr , RemStr !** FLOW IF ( Number >= 0 ) THEN cStr = ToHexStrSigned ( Number ) ELSE Quotient = SHIFTR ( Number , Shift ) Remainder = Number - SHIFTL ( Quotient , Shift ) QuotStr = ToHexStrSigned ( Quotient ) RemStr = ToHexStrSigned ( Remainder ) cStr = QuotStr // RemStr END IF RETURN END FUNCTION U32_ToHexString !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   ROUTINES FOR UNSIGNED MULTIPLICATION !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE SUBROUTINE UMul128 ( X , Y , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul128 !** PURPOSE OF THIS SUBROUTINE: !! To compute 128-bit result of multiplication of two 64-bit unsigned integers. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , X_Hi , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Hi_Lo , Cross !** FLOW X_Lo = IAND ( X , MaskU32 ) X_Hi = SHIFTR ( X , 32 ) Y_Lo = IAND ( Y , MaskU32 ) Y_Hi = SHIFTR ( Y , 32 ) Lo_Lo = X_Lo * Y_Lo Hi_Lo = X_Hi * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaskU32 ) + X_Lo * Y_Hi U128Hi = SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + X_Hi * Y_Hi U128Lo = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaskU32 )) RETURN END SUBROUTINE UMul128 !****************************************************************************** PURE FUNCTION UMul128_Upper64 ( X , Y ) RESULT ( U128Hi ) !DIR$ ATTRIBUTES INLINE :: UMul128_Upper64 !** PURPOSE OF THIS SUBROUTINE: !! To compute upper 64 bits of multiplication of two 64-bit unsigned integers IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ) :: U128Hi !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , X_Hi , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Hi_Lo , Cross !** FLOW X_Lo = IAND ( X , MaskU32 ) X_Hi = SHIFTR ( X , 32 ) Y_Lo = IAND ( Y , MaskU32 ) Y_Hi = SHIFTR ( Y , 32 ) Hi_Lo = X_Hi * Y_Lo Cross = SHIFTR ( X_Lo * Y_Lo , 32 ) + IAND ( Hi_Lo , MaskU32 ) + X_Lo * Y_Hi U128Hi = SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + X_Hi * Y_Hi RETURN END FUNCTION UMul128_Upper64 !****************************************************************************** PURE SUBROUTINE UMul192_Upper128 ( X , YHi , YLo , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul192_Upper128 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute upper 128 bits of multiplication of a 64-bit unsigned integer and ! a 128-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , YHi , YLo INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Add !** FLOW CALL UMul128 ( X , YHi , U128Hi , U128Lo ) Add = UMul128_Upper64 ( X , YLo ) U128Lo = U128Lo + Add IF ( U128Lo . ULT . Add ) U128Hi = U128Hi + 1_I8B RETURN END SUBROUTINE UMul192_Upper128 !****************************************************************************** PURE FUNCTION UMul96_Upper64 ( X , Y ) RESULT ( U128Hi ) !DIR$ ATTRIBUTES INLINE :: UMul96_Upper64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute upper 64 bits of multiplication of a 32-bit unsigned integer and ! a 64-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y INTEGER ( KIND = I8B ) :: U128Hi !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128Hi = UMul128_Upper64 ( SHIFTL ( ToUnsignedLong ( X ), 32 ), Y ) RETURN END FUNCTION UMul96_Upper64 !****************************************************************************** PURE SUBROUTINE UMul192_Lower128 ( X , YHi , YLo , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul192_Lower128 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute lower 128 bits of multiplication of a 64-bit unsigned integer and ! a 128-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , YHi , YLo INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL UMul128 ( X , YLo , U128Hi , U128Lo ) U128Hi = U128Hi + X * YHi RETURN END SUBROUTINE UMul192_Lower128 !****************************************************************************** PURE FUNCTION UMul96_Lower64 ( X , Y ) RESULT ( U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul96_Lower64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute lower 64 bits of multiplication of a 32-bit unsigned integer and ! a 64-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: X INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y INTEGER ( KIND = I8B ) :: U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128Lo = X * Y RETURN END FUNCTION UMul96_Lower64 !****************************************************************************** PURE SUBROUTINE UMul128_N_Add ( A , B , C , U128Hi , U128Lo ) !DIR$ ATTRIBUTES INLINE :: UMul128_N_Add !** PURPOSE OF THIS SUBROUTINE: !&#94; To multiply two 64-bit unsigned integers and add a value (A*B + C), and ! return the 128-bit result as U128Hi, U128Lo. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: A , B , C INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U128Hi , U128Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: H , L , T !** FLOW ! multiply A and B CALL UMul128 ( A , B , H , L ) ! add carry T = L + C ! check whether to add 1 to high bit IF ( T . ULT . L ) THEN H = H + 1_I8B ELSE IF ( T . ULT . C ) H = H + 1_I8B END IF U128Hi = H U128Lo = T RETURN END SUBROUTINE UMul128_N_Add !****************************************************************************** PURE FUNCTION UMul128_N_Shift ( A , B_Hi , B_Lo , ShrPos ) RESULT ( ResVal ) !DIR$ ATTRIBUTES INLINE :: UMul128_N_Shift !** PURPOSE OF THIS SUBROUTINE: !&#94; To multiply two 64-bit unsigned integers, and then shift ! the 128-bit result by ShrPos => SHIFTR(A*B, ShrPos). ! Note: ShrPos should be in the range [64, 128]. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: A , B_Hi , B_Lo INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShrPos INTEGER ( KIND = I8B ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: R0_Hi , R1_Lo , R1_Hi !** FLOW ! multiply A and B_Lo and return the high bit R0_Hi R0_Hi = UMul128_Upper64 ( A , B_Lo ) ! multiply A and B_Hi and add R0_Hi to the result CALL UMul128_N_Add ( A , B_Hi , R0_Hi , R1_Hi , R1_Lo ) ! shift the result by ShrPos position => SHIFTR(A*B, ShrPos) ResVal = IOR ( SHIFTL ( R1_Hi , ( 128 - ShrPos )), SHIFTR ( R1_Lo , ( ShrPos - 64 ))) RETURN END FUNCTION UMul128_N_Shift !****************************************************************************** END MODULE ModBase_UIntUtil !******************************************************************************","tags":"","loc":"sourcefile\\modbase - uintutil.f90.html"},{"title":"ModBase - UInt128.f90 – FortCharConv","text":"Source Code MODULE ModBase_UInt128 !&#94; **PURPOSE OF THIS MODULE**: !\tThis module contains a derived type and basic operations for a 128-bit unsigned integer. !  The application interface (API) follows Fortran intrinsic integer types as close as practical. !  However, since Fortran does not have an unsigned integer type, those operations that differ !  between unsigned and signed integers use API similar to those used in 'ModBase_UIntUtil' module. !  ***Important Note***: !   (1) For arithmetic operations, various types of unsigned integer types (32-, 64- and 128-bit) !   are allowed.  However, the use of signed and unsigned integers in the same operation is NOT !   allowed.  Signed integer types must be explicitly converted to unsigned types before using !   in the arithmetic operations. !   (2) For comparison and bitwise operations that require two input arguments, both arguments must !   only be the 128-bit unsigned integer type.  All other types must be explicitly converted to !   this type before using in the comparison and bitwise operations. ! !&#94; **REFERENCES**: !\t[1] [Absl's Numeric Library](https://github.com/abseil/abseil-cpp/tree/master/absl/numeric) !\t[2] [Fast 128-bit math library for Java](https://github.com/martint/int128/) !\t[3] [Extended precision integer C++ library](https://github.com/chfast/intx) !** USE STATEMENTS: USE ModBase_Common USE ModBase_Error_Handlers USE ModBase_SIntUtil USE ModBase_UIntUtil USE , INTRINSIC :: IEEE_ARITHMETIC USE , INTRINSIC :: ISO_FORTRAN_ENV , ONLY : OUTPUT_UNIT IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type + constructor PUBLIC :: UInt128 ! assignment (only applicable for unsigned integers) PUBLIC :: ASSIGNMENT ( = ) ! conversion PUBLIC :: ToI32 , ToI64 , ToR32 , ToR64 , ToR128 PUBLIC :: ToDecString , ToHexString ! comparison PUBLIC :: OPERATOR ( == ), OPERATOR ( /= ) PUBLIC :: OPERATOR (. ULT .), OPERATOR (. ULE .) PUBLIC :: OPERATOR (. UGT .), OPERATOR (. UGE .) PUBLIC :: CompareUnsigned ! arithmetic PUBLIC :: OPERATOR ( + ), OPERATOR ( - ) PUBLIC :: OPERATOR ( * ), OPERATOR (. UDIV .) PUBLIC :: Increment , Decrement , Add , Subtract PUBLIC :: Multiply , Divide , UMOD , UDivMod ! bitwise (general) PUBLIC :: SHIFTL , SHIFTR , ISHFT , ISHFTC PUBLIC :: IOR , IEOR , IAND , NOT , LEADZ , TRAILZ PUBLIC :: POPCNT , POPPAR , IBSET , IBCLR PUBLIC :: IBCHNG , BTEST , IBITS PUBLIC :: MoveBits ! == MVBITS ! bitwise (specialized) PUBLIC :: ShiftLOnce , ShiftROnce PUBLIC :: ShiftL64 , ShiftR64 PUBLIC :: ShiftL63Down , ShiftR63Down PUBLIC :: ShiftL64Up , ShiftR64Up ! auxiliary PUBLIC :: Display PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! module name CHARACTER ( LEN =* ), PARAMETER :: ModName = 'ModBase_UInt128' ! unsigned limit parameters INTEGER ( KIND = I8B ), PARAMETER :: MaxU64 = INT ( Z 'FFFFFFFFFFFFFFFF' , KIND = I8B ) ! max unsigned 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MinU64 = INT ( Z '0000000000000000' , KIND = I8B ) ! min unsigned 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MaxU32 = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) ! max unsigned 32-bit INTEGER ( KIND = I8B ), PARAMETER :: MinU32 = INT ( Z '0000000000000000' , KIND = I8B ) ! min unsigned 32-bit ! signed limit parameters INTEGER ( KIND = I8B ), PARAMETER :: MaxI64 = INT ( Z '7FFFFFFFFFFFFFFF' , KIND = I8B ) ! max signed 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! min signed 64-bit INTEGER ( KIND = I8B ), PARAMETER :: MaxI32 = INT ( Z '000000007FFFFFFF' , KIND = I8B ) ! max signed 32-bit INTEGER ( KIND = I8B ), PARAMETER :: MinI32 = INT ( Z '0000000080000000' , KIND = I8B ) ! min signed 32-bit ! miscellaneous INTEGER ( KIND = I8B ), PARAMETER :: Mask32 = MaxU32 INTEGER ( KIND = I8B ), PARAMETER :: TopBit = SHIFTL ( 1_I8B , 63 ) LOGICAL , PARAMETER :: AsUnsigned = TrueVal INTEGER ( KIND = I4B ), PARAMETER :: RecTable ( 0 : 255 ) = [ & 2045 , 2037 , 2029 , 2021 , 2013 , 2005 , 1998 , 1990 , & 1983 , 1975 , 1968 , 1960 , 1953 , 1946 , 1938 , 1931 , & 1924 , 1917 , 1910 , 1903 , 1896 , 1889 , 1883 , 1876 , & 1869 , 1863 , 1856 , 1849 , 1843 , 1836 , 1830 , 1824 , & 1817 , 1811 , 1805 , 1799 , 1792 , 1786 , 1780 , 1774 , & 1768 , 1762 , 1756 , 1750 , 1745 , 1739 , 1733 , 1727 , & 1722 , 1716 , 1710 , 1705 , 1699 , 1694 , 1688 , 1683 , & 1677 , 1672 , 1667 , 1661 , 1656 , 1651 , 1646 , 1641 , & 1636 , 1630 , 1625 , 1620 , 1615 , 1610 , 1605 , 1600 , & 1596 , 1591 , 1586 , 1581 , 1576 , 1572 , 1567 , 1562 , & 1558 , 1553 , 1548 , 1544 , 1539 , 1535 , 1530 , 1526 , & 1521 , 1517 , 1513 , 1508 , 1504 , 1500 , 1495 , 1491 , & 1487 , 1483 , 1478 , 1474 , 1470 , 1466 , 1462 , 1458 , & 1454 , 1450 , 1446 , 1442 , 1438 , 1434 , 1430 , 1426 , & 1422 , 1418 , 1414 , 1411 , 1407 , 1403 , 1399 , 1396 , & 1392 , 1388 , 1384 , 1381 , 1377 , 1374 , 1370 , 1366 , & 1363 , 1359 , 1356 , 1352 , 1349 , 1345 , 1342 , 1338 , & 1335 , 1332 , 1328 , 1325 , 1322 , 1318 , 1315 , 1312 , & 1308 , 1305 , 1302 , 1299 , 1295 , 1292 , 1289 , 1286 , & 1283 , 1280 , 1276 , 1273 , 1270 , 1267 , 1264 , 1261 , & 1258 , 1255 , 1252 , 1249 , 1246 , 1243 , 1240 , 1237 , & 1234 , 1231 , 1228 , 1226 , 1223 , 1220 , 1217 , 1214 , & 1211 , 1209 , 1206 , 1203 , 1200 , 1197 , 1195 , 1192 , & 1189 , 1187 , 1184 , 1181 , 1179 , 1176 , 1173 , 1171 , & 1168 , 1165 , 1163 , 1160 , 1158 , 1155 , 1153 , 1150 , & 1148 , 1145 , 1143 , 1140 , 1138 , 1135 , 1133 , 1130 , & 1128 , 1125 , 1123 , 1121 , 1118 , 1116 , 1113 , 1111 , & 1109 , 1106 , 1104 , 1102 , 1099 , 1097 , 1095 , 1092 , & 1090 , 1088 , 1086 , 1083 , 1081 , 1079 , 1077 , 1074 , & 1072 , 1070 , 1068 , 1066 , 1064 , 1061 , 1059 , 1057 , & 1055 , 1053 , 1051 , 1049 , 1047 , 1044 , 1042 , 1040 , & 1038 , 1036 , 1034 , 1032 , 1030 , 1028 , 1026 , 1024 ] !** DERIVED TYPE DEFINITIONS !# a 128-bit unsigned integer type where the base of its components is 2**64. TYPE UInt128 INTEGER ( KIND = I8B ) :: High !! upper 64 bits treated as unsigned integer INTEGER ( KIND = I8B ) :: Low !! lower 64 bits treated as unsigned integer END TYPE UInt128 !** MODULE PARAMETERS (PART 2): !# 128-bit unsigned parameter with maximum value TYPE ( UInt128 ), PARAMETER , PUBLIC :: MaxU128 = UInt128 ( MaxU64 , MaxU64 ) !# 128-bit unsigned parameter with minimum value TYPE ( UInt128 ), PARAMETER , PUBLIC :: MinU128 = UInt128 ( MinU64 , MinU64 ) !# 128-bit unsigned parameter with value of one TYPE ( UInt128 ), PARAMETER , PUBLIC :: OneU128 = UInt128 ( MinU64 , 1_I8B ) !# 128-bit unsigned parameter with value of zero TYPE ( UInt128 ), PARAMETER , PUBLIC :: ZeroU128 = MinU128 !# Used to cast a 64-bit integer to a 128bit integer without getting unwanted sign extension TYPE ( UInt128 ), PARAMETER , PUBLIC :: MASKI64 = UInt128 ( MinU64 , MaxU64 ) !** INTERFACE DEFINITIONS: !----------------------------------------------- !----- \t        conversion operations \t   ----- !----------------------------------------------- INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) !  **Purpose**:  To convert between a 128-bit unsigned integer and !   other unsigned integers (32- and 64-bit integers) !  **Usage**: !   --->    U128 = OtherType MODULE PROCEDURE U128_From_U32 MODULE PROCEDURE U128_From_U64 MODULE PROCEDURE U128_To_U32 MODULE PROCEDURE U128_To_U64 END INTERFACE INTERFACE UInt128 !&#94; **Constructor Interface**: UInt128 !  **Purpose**:  To construct a 128-bit unsigned integer from !   other Fortran intrinsic types !  **Usage**: !   --->    U128 = UInt128(OtherType) MODULE PROCEDURE I32_To_U128 MODULE PROCEDURE I64_To_U128 MODULE PROCEDURE R32_To_U128 MODULE PROCEDURE R64_To_U128 MODULE PROCEDURE R128_To_U128 MODULE PROCEDURE DecString_To_U128 END INTERFACE INTERFACE ToI32 !&#94; **Function Interface**: ToI32 !  **Purpose**:  To convert a 128-bit unsigned integer to a !   32-bit signed integer !  **Usage**: !   --->    I32 = ToI32(U128) MODULE PROCEDURE I32_From_U128 END INTERFACE INTERFACE ToI64 !&#94; **Function Interface**: ToI64 !  **Purpose**:  To convert a 128-bit unsigned integer to !   a 64-bit signed integer !  **Usage**: !   --->    I64 = ToI64(U128) MODULE PROCEDURE I64_From_U128 END INTERFACE INTERFACE ToR32 !&#94; **Function Interface**: ToR32 !  **Purpose**:  To convert a 128-bit unsigned integer to !   a 32-bit floating point (real) number !  **Usage**: !   --->    R32 = ToR32(U128) MODULE PROCEDURE R32_From_U128 END INTERFACE INTERFACE ToR64 !&#94; **Function Interface**: ToR64 !  **Purpose**:  To convert a 128-bit unsigned integer to !   a 64-bit floating point (real) number !  **Usage**: !   --->    R64 = ToR64(U128) MODULE PROCEDURE R64_From_U128 END INTERFACE INTERFACE ToR128 !&#94; **Function Interface**: ToR128 !  **Purpose**:  To convert a 128-bit unsigned integer to !   a 128-bit floating point (real) number !  **Usage**: !   --->    R128 = ToR128(U128) MODULE PROCEDURE R128_From_U128 END INTERFACE INTERFACE ToDecString !&#94; **Function Interface**: ToDecString !  **Purpose**:  To convert a 128-bit unsigned integer to !   a decimal string !  **Usage**: !   --->    Str = ToDecString(U128) MODULE PROCEDURE DecString_From_U128 END INTERFACE INTERFACE ToHexString !&#94; **Function Interface**: ToHexString !  **Purpose**:  To convert a 128-bit unsigned integer to !   a hexadecimal string !  **Usage**: !   --->    Str = ToHexString(U128) MODULE PROCEDURE HexString_From_U128 END INTERFACE !----------------------------------------------- !----- \t\t    comparison operations\t       ----- !----------------------------------------------- INTERFACE OPERATOR ( == ) !&#94; **Operator Overload**: OPERATOR(==) !  **Purpose**:  To check if values of two 128-bit unsigned integers are equal !   return .TRUE. if both values are equal; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS == RHS !   --->    IF (LHS .EQ. RHS) DoSomething MODULE PROCEDURE U128_Equal END INTERFACE INTERFACE OPERATOR ( /= ) !&#94; **Operator Overload**: OPERATOR(/=) !  **Purpose**:  To check if values of two 128-bit unsigned integers are not equal !   return .TRUE. if both values are NOT equal; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS /= RHS !   --->    IF (LHS .NE. RHS) DoSomething MODULE PROCEDURE U128_NotEqual END INTERFACE INTERFACE OPERATOR (. ULT .) !&#94; **Operator Overload**: OPERATOR(.ULT.) !  **Purpose**:  To check if the LHS value is less than the RHS value !   return .TRUE. if LHS < RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .ULT. RHS !   --->    IF (LHS .ULT. RHS) DoSomething MODULE PROCEDURE U128_LessThan END INTERFACE INTERFACE OPERATOR (. ULE .) !&#94; **Operator Overload**: OPERATOR(.ULE.) !  **Purpose**:  To check if the LHS value is less than or equal to the RHS value !   return .TRUE. if LHS <= RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .ULE. RHS !   --->    IF (LHS .ULE. RHS) DoSomething MODULE PROCEDURE U128_LessEqual END INTERFACE INTERFACE OPERATOR (. UGT .) !&#94; **Operator Overload**: OPERATOR(.UGT.) !  **Purpose**:  To check if the LHS value is greater than the RHS value !   return .TRUE. if LHS > RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .UGT. RHS !   --->    IF (LHS .UGT. RHS) DoSomething MODULE PROCEDURE U128_GreaterThan END INTERFACE INTERFACE OPERATOR (. UGE .) !&#94; **Operator Overload**: OPERATOR(.UGE.) !  **Purpose**:  To check if the LHS value is greater than or equal to the RHS value !   return .TRUE. if LHS >= RHS; otherwise return .FALSE. !  **Usage**: !   --->    Flag = LHS .UGE. RHS !   --->    IF (LHS .UGE. RHS) DoSomething MODULE PROCEDURE U128_GreaterEqual END INTERFACE INTERFACE CompareUnsigned !&#94; **Function Interface**: CompareUnsigned !  **Purpose**:  To compare two 128-bit unsigned integers and return !   -1 if LHS < RHS !    0 if LHS == RHS !    1 if LHS > RHS !  **Usage**: !   --->    Flag = CompareUnsigned(LHS, RHS) !   --->    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE U128_Compare END INTERFACE !----------------------------------------------- !----- \t\t arithmetic operations          ----- !----------------------------------------------- INTERFACE OPERATOR ( + ) !&#94; **Operator Overload**: OPERATOR(+) !  **Purpose**:  To perform a summation of two unsigned integers !   (at least one of which is a 128-bit unsigned integer) or !   to add a unary plus sign to a 128-bit unsigned integer !   (which has no effect on the unsigned integer) !  **Usage**: !   --->    OUTPUT = +INPUT !   --->    OUTPUT = FIRST_IN + SECOND_IN MODULE PROCEDURE U128_UnaryPlus MODULE PROCEDURE U128_Plus_U128 MODULE PROCEDURE U128_Plus_U32 MODULE PROCEDURE U32_Plus_U128 MODULE PROCEDURE U128_Plus_U64 MODULE PROCEDURE U64_Plus_U128 END INTERFACE INTERFACE OPERATOR ( - ) !&#94; **Operator Overload**: OPERATOR(-) !  **Purpose**:  To perform a subtraction of two unsigned integers !   (at least one of which is a 128-bit unsigned integer) or !   to perform a negation of a 128-bit unsigned integer !  **Usage**: !   --->    OUTPUT = -INPUT !   --->    OUTPUT = FIRST_IN - SECOND_IN !  ***Important Note***:  For subtraction of unsigned integers, value of FIRST_IN !   must always be greater than SECOND_IN.  Otherwise, value of OUTPUT !   is NOT valid. MODULE PROCEDURE U128_Negate MODULE PROCEDURE U128_Minus_U128 MODULE PROCEDURE U128_Minus_U32 MODULE PROCEDURE U32_Minus_U128 MODULE PROCEDURE U128_Minus_U64 MODULE PROCEDURE U64_Minus_U128 END INTERFACE INTERFACE OPERATOR ( * ) !&#94; **Operator Overload**: OPERATOR( * ) !  **Purpose**:  To perform a multiplication of two unsigned integers !   (at least one of which is a 128-bit unsigned integer) !  **Usage**: !   --->    OUTPUT = FIRST_IN * SECOND_IN MODULE PROCEDURE U128_Multiply_U128 MODULE PROCEDURE U128_Multiply_U32 MODULE PROCEDURE U32_Multiply_U128 MODULE PROCEDURE U128_Multiply_U64 MODULE PROCEDURE U64_Multiply_U128 END INTERFACE INTERFACE OPERATOR (. UDIV .) !&#94; **Operator Overload**: OPERATOR(.UDIV.) !  **Purpose**:  To return the quotient of a division of two unsigned integers, !   where the dividend (numerator) is a 128-bit unsigned integer and the !   divisor (denominator) can be 32-, 64- or 128-bit unsigned integer !  **Usage**: !   --->    QUOT = NUMER .UDIV. DENOM MODULE PROCEDURE U128_Divide_U32 MODULE PROCEDURE U128_Divide_U64 MODULE PROCEDURE U128_Divide_U128 END INTERFACE INTERFACE UMOD !&#94; **Function Interface**: UMOD !  **Purpose**:  To return the remainder of a division of two unsigned integers, !   where the dividend (numerator) is a 128-bit unsigned integer and the !   divisor (denominator) can be 32-, 64- or 128-bit unsigned integer !  **Usage**: !   --->    REM = UMOD(NUMER, DENOM) MODULE PROCEDURE U128_Mod_U32 MODULE PROCEDURE U128_Mod_U64 MODULE PROCEDURE U128_Mod_U128 END INTERFACE INTERFACE UDivMod !&#94; **Subroutine Interface**: UDivMod !  **Purpose**:  To perform a division of two unsigned integers (where the !   dividend (numerator) is a 128-bit unsigned integer and the divisor !   (denominator) can be 32-, 64- or 128-bit unsigned integer) and !   to return both the quotient and the remainder !  **Usage**: !   --->    CALL UDivMod(NUMER, DENOM, QUOT, REM) MODULE PROCEDURE U128_DivMod_U32 MODULE PROCEDURE U128_DivMod_U64 MODULE PROCEDURE U128_DivMod_U128 END INTERFACE INTERFACE Increment !&#94; **Subroutine Interface**: Increment !  **Purpose**:  To increase value of a 128-bit unsigned integer by one !  **Usage**: !   --->    CALL Increment(U128) MODULE PROCEDURE U128_Increment END INTERFACE INTERFACE Decrement !&#94; **Subroutine Interface**: Decrement !  **Purpose**:  To decrease value of a 128-bit unsigned integer by one !  **Usage**: !   --->    CALL Decrement(U128) MODULE PROCEDURE U128_Decrement END INTERFACE INTERFACE Add !&#94; **Subroutine Interface**: Add !  **Purpose**:  To add an unsigned integer to a 128-bit unsigned integer !  **Usage**: !   --->    CALL Add(This, Other) MODULE PROCEDURE U128_Add_U32 MODULE PROCEDURE U128_Add_U64 MODULE PROCEDURE U128_Add_U128 END INTERFACE INTERFACE Subtract !&#94; **Subroutine Interface**: Subtract !  **Purpose**:  To subtract an unsigned integer from a 128-bit unsigned integer !  **Usage**: !   --->    CALL Subtract(This, Other) !  ***Important Note***:  For subtraction of unsigned integers, value of This !   must always be greater than Other.  Otherwise, value of the returned !   This is NOT valid. MODULE PROCEDURE U128_Subtract_U32 MODULE PROCEDURE U128_Subtract_U64 MODULE PROCEDURE U128_Subtract_U128 END INTERFACE INTERFACE Multiply !&#94; **Subroutine Interface**: Multiply !  **Purpose**:  To multiply a 128-bit unsigned integer by an unsigned integer !  **Usage**: !   --->    CALL Multiply(This, Other) MODULE PROCEDURE U128_Times_U32 MODULE PROCEDURE U128_Times_U64 MODULE PROCEDURE U128_Times_U128 END INTERFACE INTERFACE Divide !&#94; **Subroutine Interface**: Divide !  **Purpose**:  To divide a 128-bit unsigned integer by an unsigned integer !  **Usage**: !   --->    CALL Divide(This, Other) MODULE PROCEDURE U128_Over_U32 MODULE PROCEDURE U128_Over_U64 MODULE PROCEDURE U128_Over_U128 END INTERFACE !----------------------------------------------- !----- \t\t    bitwise operations \t\t   ----- !----------------------------------------------- INTERFACE ShiftLOnce !&#94; **Function Interface**: ShiftLOnce !  **Purpose**:  To perform logical left shift by 1 !  **Usage**: !   --->    OUT = ShiftLOnce(IN) MODULE PROCEDURE U128_ShiftLeftOnce END INTERFACE INTERFACE ShiftROnce !&#94; **Function Interface**: ShiftROnce !  **Purpose**:  To perform logical right shift by 1 !  **Usage**: !   --->    OUT = ShiftROnce(IN) MODULE PROCEDURE U128_ShiftRightOnce END INTERFACE INTERFACE ShiftL64 !&#94; **Function Interface**: ShiftL64 !  **Purpose**:  To perform logical left shift by 64 !  **Usage**: !   --->    OUT = ShiftL64(IN) MODULE PROCEDURE U128_ShiftLeft64 END INTERFACE INTERFACE ShiftR64 !&#94; **Function Interface**: ShiftR64 !  **Purpose**:  To perform logical right shift by 64 !  **Usage**: !   --->    OUT = ShiftR64(IN) MODULE PROCEDURE U128_ShiftRight64 END INTERFACE INTERFACE ShiftL63Down !&#94; **Function Interface**: ShiftL63Down !  **Purpose**:  To perform logical left shift by 63 or less !  **Usage**: !   --->    OUT = ShiftL63Down(IN, 11) MODULE PROCEDURE U128_ShiftLeft63Down END INTERFACE INTERFACE ShiftR63Down !&#94; **Function Interface**: ShiftR63Down !  **Purpose**:  To perform logical right shift by 63 or less !  **Usage**: !   --->    OUT = ShiftR63Down(IN, 53) MODULE PROCEDURE U128_ShiftRight63Down END INTERFACE INTERFACE ShiftL64Up !&#94; **Function Interface**: ShiftL64Up !  **Purpose**:  To perform logical left shift by 64 or more (<= 128) !  **Usage**: !   --->    OUT = ShiftL64Up(IN, 111) MODULE PROCEDURE U128_ShiftLeft64Up END INTERFACE INTERFACE ShiftR64Up !&#94; **Function Interface**: ShiftR64Up !  **Purpose**:  To perform logical right shift by 64 or more (<= 128) !  **Usage**: !   --->    OUT = ShiftR64Up(IN, 84) MODULE PROCEDURE U128_ShiftRight64Up END INTERFACE INTERFACE SHIFTL !&#94; **Function Interface**: SHIFTL !  **Purpose**:  To perform logical left shift with 0 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = SHIFTL(IN, 127) MODULE PROCEDURE U128_ShiftLeft END INTERFACE INTERFACE SHIFTR !&#94; **Function Interface**: SHIFTR !  **Purpose**:  To perform logical right shift with 0 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = SHIFTR(IN, 33) MODULE PROCEDURE U128_ShiftRight END INTERFACE INTERFACE ISHFT !&#94; **Function Interface**: ISHFT !  **Purpose**:  To perform logical shift with -128 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 !   --->    OUT = ISHFT(IN, -24)   ! a logical right shift by 24 MODULE PROCEDURE U128_ShiftLogical END INTERFACE INTERFACE ISHFTC !&#94; **Function Interface**: ISHFTC !  **Purpose**:  To perform circular shift with -128 <= ShiftPos <= 128 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 !   --->    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24 MODULE PROCEDURE U128_Rotate END INTERFACE INTERFACE NOT !&#94; **Function Interface**: NOT !  **Purpose**:  To return the bitwise logical complement of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = NOT(IN) MODULE PROCEDURE U128_Not END INTERFACE INTERFACE IOR !&#94; **Function Interface**: IOR !  **Purpose**:  To perform an inclusive OR on corresponding bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IOR(LHSIN, RHSIN) MODULE PROCEDURE U128_Ior END INTERFACE INTERFACE IEOR !&#94; **Function Interface**: IEOR !  **Purpose**:  To perform an exclusive OR on corresponding bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IEOR(LHSIN, RHSIN) MODULE PROCEDURE U128_Ieor END INTERFACE INTERFACE IAND !&#94; **Function Interface**: IAND !  **Purpose**:  To perform a logical AND on corresponding bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IAND(LHSIN, RHSIN) MODULE PROCEDURE U128_Iand END INTERFACE INTERFACE LEADZ !&#94; **Function Interface**: LEADZ !  **Purpose**:  To count the number of leading zero bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumLZ = LEADZ(INPUT) MODULE PROCEDURE U128_LeadingZeros END INTERFACE INTERFACE TRAILZ !&#94; **Function Interface**: TRAILZ !  **Purpose**:  To count the number of trailing zero bits of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumTZ = TRAILZ(INPUT) MODULE PROCEDURE U128_TrailingZeros END INTERFACE INTERFACE POPCNT !&#94; **Function Interface**: POPCNT !  **Purpose**:  To count the number of 1 bits in the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumBits = POPCNT(INPUT) MODULE PROCEDURE U128_Count1Bits END INTERFACE INTERFACE POPPAR !&#94; **Function Interface**: POPPAR !  **Purpose**:  To determine the parity of the input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    NumPar = POPPAR(INPUT) MODULE PROCEDURE U128_Parity END INTERFACE INTERFACE IBSET !&#94; **Function Interface**: IBSET !  **Purpose**:  To set the bit at the specified position to 1 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBSET(IN, Pos) MODULE PROCEDURE U128_SetBit END INTERFACE INTERFACE IBCLR !&#94; **Function Interface**: IBCLR !  **Purpose**:  To set the bit at the specified position to 0 !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBCLR(IN, Pos) MODULE PROCEDURE U128_ClearBit END INTERFACE INTERFACE IBCHNG !&#94; **Function Interface**: IBCHNG !  **Purpose**:  To reverse the bit at the specified position !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBCHNG(IN, Pos) MODULE PROCEDURE U128_FlipBit END INTERFACE INTERFACE BTEST !&#94; **Function Interface**: BTEST !  **Purpose**:  To check whether the bit at the specified position is 0 (False) or 1 (True) !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    Flag = BTEST(IN, Pos) MODULE PROCEDURE U128_TestBit END INTERFACE INTERFACE IBITS !&#94; **Function Interface**: IBITS !  **Purpose**:  To extract a sequence of bits according to the specified input !   (For more information, see detailed explanation of the intrinsic function) !  **Usage**: !   --->    OUT = IBITS(IN, Pos, Len) MODULE PROCEDURE U128_ExtractBits END INTERFACE INTERFACE MoveBits !&#94; **Subroutine Interface**: MoveBits !  **Purpose**:  To copy a sequence of bits (a bit field) from one location to another !   (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS') !  **Usage**: !   --->    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos) MODULE PROCEDURE U128_MoveBits END INTERFACE !----------------------------------------------- !----- \t        Auxiliary Routine \t       ----- !----------------------------------------------- INTERFACE Display !&#94; **Subroutine Interface**: Display !  **Purpose**:  To write/display the 'UInt128' object to the screen (or the specified unit) !  **Usage**: !   To display (unsigned) value of U128 as a decimal string to the screen !   --->    CALL Display(U128) !   To display (unsigned) value of U128 as a decimal string to the output logical unit !   --->    CALL Display(U128, 11) !   To display (unsigned) value of U128 as a decimal string to the output logical unit !   with input/output status and message !   --->    CALL Display(U128, 11, IOStat, IOMsg) !   To display (signed) values of components of U128 as a decimal string to the screen !   --->    CALL Display(U128, ShowComponent=.TRUE.) !   To display (unsigned) value of U128 as a decimal string to the screen with a prefix string !   --->    CALL Display(U128, Prefix='Unsigned value of U128') MODULE PROCEDURE U128_Write END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                           ASSIGNMENT ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE U128_From_U32 ( U128 , U32 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 32-bit integer number to an unsigned 128-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( OUT ) :: U128 INTEGER ( KIND = I4B ), INTENT ( IN ) :: U32 !! number treated as unsigned !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128 = UInt128 ( MinU64 , ToUnsignedLong ( U32 )) RETURN END SUBROUTINE U128_From_U32 !****************************************************************************** SUBROUTINE U128_From_U64 ( U128 , U64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 64-bit integer number to an unsigned 128-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( OUT ) :: U128 INTEGER ( KIND = I8B ), INTENT ( IN ) :: U64 !! number treated as unsigned !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U128 = UInt128 ( MinU64 , U64 ) RETURN END SUBROUTINE U128_From_U64 !****************************************************************************** SUBROUTINE U128_To_U32 ( U32 , U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to an unsigned 32-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( OUT ) :: U32 !! number treated as unsigned TYPE ( UInt128 ), INTENT ( IN ) :: U128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U32 = INT ( U128 % Low , KIND = I4B ) RETURN END SUBROUTINE U128_To_U32 !****************************************************************************** SUBROUTINE U128_To_U64 ( U64 , U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to an unsigned 64-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( OUT ) :: U64 !! number treated as unsigned TYPE ( UInt128 ), INTENT ( IN ) :: U128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW U64 = U128 % Low RETURN END SUBROUTINE U128_To_U64 !------------------------------------------------------------------------------ ! !                           CONSTRUCTOR ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I32_To_U128 ( I32 , AsUnsigned ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a signed 32-bit integer number to an unsigned 128-bit integer number !  or to convert an unsigned 32-bit integer number to an unsigned 128-bit integer !  number if the specified flag is present and true. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: I32 !! number treated as signed (default) LOGICAL , OPTIONAL , INTENT ( IN ) :: AsUnsigned !! if present and true, number treated as unsigned TYPE ( UInt128 ) :: U128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( PRESENT ( AsUnsigned )) THEN IF ( AsUnsigned ) THEN ! number treated as unsigned U128 = UInt128 ( MinU64 , ToUnsignedLong ( I32 )) RETURN END IF END IF ! number treated as signed IF ( I32 < 0 ) THEN U128 = UInt128 ( MaxU64 , INT ( I32 , KIND = I8B )) ELSE U128 = UInt128 ( MinU64 , INT ( I32 , KIND = I8B )) END IF RETURN END FUNCTION I32_To_U128 !****************************************************************************** FUNCTION I64_To_U128 ( I64 , AsUnsigned ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a signed 64-bit integer number to an unsigned 128-bit integer number !! or to convert an unsigned 64-bit integer number to an unsigned 128-bit integer !! number if the specified flag is present and true. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: I64 !! number treated as signed (default) LOGICAL , OPTIONAL , INTENT ( IN ) :: AsUnsigned !! if present and true, number treated as unsigned TYPE ( UInt128 ) :: U128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( PRESENT ( AsUnsigned )) THEN IF ( AsUnsigned ) THEN ! number treated as unsigned U128 = UInt128 ( MinU64 , I64 ) RETURN END IF END IF ! number treated as signed IF ( I64 < 0_I8B ) THEN U128 = UInt128 ( MaxU64 , I64 ) ELSE U128 = UInt128 ( MinU64 , I64 ) END IF RETURN END FUNCTION I64_To_U128 !****************************************************************************** FUNCTION R32_To_U128 ( R32 ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 32-bit floating point number to an unsigned 128-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = SP ), INTENT ( IN ) :: R32 TYPE ( UInt128 ) :: U128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '000000FF' , KIND = I4B ) ! 255 INTEGER ( KIND = I4B ), PARAMETER :: C1 = SHIFTL ( 1 , 23 ) ! 2**23 INTEGER ( KIND = I4B ), PARAMETER :: C2 = C1 - 1 ! 2**23 - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I4B ) :: IBits REAL ( KIND = SP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! rounding behavior is towards zero. ! undefined behavior if R32 is NaN or cannot fit into U128. IF (. NOT . IEEE_IS_FINITE ( R32 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R32_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R32 is NOT finite.' ) U128 = MaxU128 RETURN ELSEIF ( R32 <= - 1.0_SP ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R32_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R32 < U128Min.' ) U128 = MinU128 RETURN ELSEIF ( R32 >= 2.0_SP ** 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R32_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R32 > U128Max.' ) U128 = MaxU128 RETURN ELSEIF ( R32 < 0.0_SP ) THEN U128 = ZeroU128 RETURN END IF ! transfer bits from real to integer RBits = R32 ! determine exponent bits Exp = IAND ( SHIFTR ( IBits , 23 ), Mask ) - 150 ! 150 = 127 + 23 ! determine significand bits IBits = IOR ( IAND ( IBits , C2 ), C1 ) ! convert and add exponent bits ! => U128 = UInt128(MinU64, IBits) ! => U128 = ISHFT(U128, Exp) IF ( Exp < 0 ) THEN Exp = - Exp IF ( Exp >= 64 ) THEN U128 = UInt128 ( MinU64 , MinU64 ) ELSE U128 = UInt128 ( MinU64 , SHIFTR ( INT ( IBits , KIND = I8B ), Exp )) END IF ELSE IF ( Exp >= 128 ) THEN U128 = UInt128 ( MinU64 , MinU64 ) ELSEIF ( Exp >= 64 ) THEN U128 = UInt128 ( SHIFTL ( INT ( IBits , KIND = I8B ), Exp - 64 ), MinU64 ) ELSE U128 = UInt128 ( SHIFTR ( INT ( IBits , KIND = I8B ), 64 - Exp ), SHIFTL ( INT ( IBits , KIND = I8B ), Exp )) END IF END IF RETURN END FUNCTION R32_To_U128 !****************************************************************************** FUNCTION R64_To_U128 ( R64 ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 64-bit floating point number to an unsigned 128-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = DP ), INTENT ( IN ) :: R64 TYPE ( UInt128 ) :: U128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: Mask = INT ( Z '00000000000007FF' , KIND = I8B ) ! 2047 INTEGER ( KIND = I8B ), PARAMETER :: C1 = SHIFTL ( 1_I8B , 52 ) ! 2**52 INTEGER ( KIND = I8B ), PARAMETER :: C2 = C1 - 1_I8B ! 2**52 - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I8B ) :: IBits REAL ( KIND = DP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! rounding behavior is towards zero. ! undefined behavior if R64 is NaN or cannot fit into U128. IF (. NOT . IEEE_IS_FINITE ( R64 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R64_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R64 is NOT finite.' ) U128 = MaxU128 RETURN ELSEIF ( R64 <= - 1.0_DP ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R64_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R64 < U128Min.' ) U128 = MinU128 RETURN ELSEIF ( R64 >= 2.0_DP ** 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R64_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R64 > U128Max.' ) U128 = MaxU128 RETURN ELSEIF ( R64 < 0.0_DP ) THEN U128 = ZeroU128 RETURN END IF ! transfer bits from real to integer RBits = R64 ! determine exponent bits Exp = INT ( IAND ( SHIFTR ( IBits , 52 ), Mask ), KIND = I4B ) - 1075 ! 1075 = 1023 + 52 ! determine significand bits IBits = IOR ( IAND ( IBits , C2 ), C1 ) ! convert and add exponent bits ! => U128 = UInt128(MinU64, IBits) ! => U128 = ISHFT(U128, Exp) IF ( Exp < 0 ) THEN Exp = - Exp IF ( Exp >= 64 ) THEN U128 = UInt128 ( MinU64 , MinU64 ) ELSE U128 = UInt128 ( MinU64 , SHIFTR ( IBits , Exp )) END IF ELSE IF ( Exp >= 128 ) THEN U128 = UInt128 ( MinU64 , MinU64 ) ELSEIF ( Exp >= 64 ) THEN U128 = UInt128 ( SHIFTL ( IBits , Exp - 64 ), MinU64 ) ELSE U128 = UInt128 ( SHIFTR ( IBits , 64 - Exp ), SHIFTL ( IBits , Exp )) END IF END IF RETURN END FUNCTION R64_To_U128 !****************************************************************************** FUNCTION R128_To_U128 ( R128 ) RESULT ( U128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a 128-bit floating point number to an unsigned 128-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: R128 TYPE ( UInt128 ) :: U128 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '00007FFF' , KIND = I4B ) ! 32767 INTEGER ( KIND = I8B ), PARAMETER :: C1 ( 2 ) = [ 0_I8B , 281474976710656_I8B ] ! 2**112 = SHIFTL(1, 112) INTEGER ( KIND = I8B ), PARAMETER :: C2 ( 2 ) = [ - 1_I8B , 281474976710655_I8B ] ! 2**112 -1 = SHIFTL(1, 112) - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I8B ) :: ExpL INTEGER ( KIND = I8B ) :: IBits ( 2 ) REAL ( KIND = QP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW ! rounding behavior is towards zero. ! undefined behavior if R128 is NaN or cannot fit into U128. IF (. NOT . IEEE_IS_FINITE ( R128 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R128_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R128 is NOT finite.' ) U128 = MaxU128 RETURN ELSEIF ( R128 <= - 1.0_QP ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R128_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R128 < U128Min.' ) U128 = MinU128 RETURN ELSEIF ( R128 >= 2.0_QP ** 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'R128_To_U128' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Undefined behavior: R128 > U128Max.' ) U128 = MaxU128 RETURN ELSEIF ( R128 < 0.0_QP ) THEN U128 = ZeroU128 RETURN END IF ! transfer bits from real to integer (assumming little-endian order) ! (if big-endian order, just switch IBits(1) and IBits(2)) RBits = R128 ! determine exponent bits ExpL = SHIFTR ( IBits ( 2 ), 48 ) ! 48 = 112-64 Exp = IAND ( INT ( ExpL , KIND = I4B ), Mask ) - 16495 ! 16495 = 16383 + 112 ! convert and add exponent bits U128 = UInt128 ( IOR ( IAND ( IBits ( 2 ), C2 ( 2 )), C1 ( 2 )), IOR ( IAND ( IBits ( 1 ), C2 ( 1 )), C1 ( 1 ))) IF ( Exp < 0 ) THEN Exp = - Exp ! perform right shift IF ( Exp >= 128 ) THEN U128 = UInt128 ( MinU64 , MinU64 ) ELSEIF ( Exp >= 64 ) THEN U128 % Low = SHIFTR ( U128 % High , Exp - 64 ) U128 % High = MinU64 ELSE U128 % Low = IOR ( SHIFTR ( U128 % Low , Exp ), SHIFTL ( U128 % High , 64 - Exp )) U128 % High = SHIFTR ( U128 % High , Exp ) END IF ELSE ! perform left shift IF ( Exp >= 128 ) THEN U128 = UInt128 ( MinU64 , MinU64 ) ELSEIF ( Exp >= 64 ) THEN U128 % High = SHIFTL ( U128 % Low , Exp - 64 ) U128 % Low = MinU64 ELSE U128 % High = IOR ( SHIFTL ( U128 % High , Exp ), SHIFTR ( U128 % Low , 64 - Exp )) U128 % Low = SHIFTL ( U128 % Low , Exp ) END IF END IF RETURN END FUNCTION R128_To_U128 !****************************************************************************** FUNCTION DecString_To_U128 ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to an unsigned 128-bit integer value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid TYPE ( UInt128 ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I4B ), PARAMETER :: A9 = IACHAR ( '9' ) INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI32 = 10 INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI64 = 19 INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitU128 = 39 CHARACTER ( LEN =* ), PARAMETER :: MaxStr = '340282366920938463463374607431768211455' INTEGER ( KIND = I8B ), PARAMETER :: Mask32 = MaxU32 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen , DigitLen INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart , IndxP7 CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: Overflow CHARACTER ( LEN = :), ALLOCATABLE , TARGET :: CurStr LOGICAL :: ErrorFlag ! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE :: ErrorMsg ! message if input is not invalid INTEGER ( KIND = I4B ) :: I32Val INTEGER ( KIND = I8B ) :: I64Val CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF END IF ! check for sign CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a minus sign is not allowed for an unsigned integer.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF END IF ! check for leading zero(s) Number = ZeroU128 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO ! if only zero digits encountered, return IF ( Indx > StrLen ) RETURN END IF ! compute the length of digits DigitLen = StrLen - Indx + 1 ! return quickly if possible IF ( DigitLen < MaxDigitI32 ) THEN I32Val = I32_FromChar ( cStr ( Indx : StrLen ), ErrorFlag , ErrorMsg ) IF ( ErrorFlag ) THEN Number = MinU128 ELSE Number = UInt128 ( I32Val ) END IF IF ( PRESENT ( ErrMsg )) ErrMsg = ErrorMsg IF ( PRESENT ( ErrFlag )) ErrFlag = ErrorFlag RETURN ELSEIF ( DigitLen < MaxDigitI64 ) THEN I64Val = I64_FromChar ( cStr ( Indx : StrLen ), ErrorFlag , ErrorMsg ) IF ( ErrorFlag ) THEN Number = MinU128 ELSE Number = UInt128 ( I64Val ) END IF IF ( PRESENT ( ErrMsg )) ErrMsg = ErrorMsg IF ( PRESENT ( ErrFlag )) ErrFlag = ErrorFlag RETURN END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx IndxP7 = Indx + 7 DO WHILE ( IndxP7 <= StrLen ) wStr = cStr ( Indx : IndxP7 ) IF ( Is8Digits ( WVal )) THEN ! process 8 digits at once ! => Number = Number*100000000_I8B + Parse8Digits(wVal) CALL MulAddU64 ( Number , 100000000_I8B , Parse8Digits ( wVal )) ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF Indx = Indx + 8 IndxP7 = Indx + 7 END DO IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid ! => Number = Number*10 + (IACHAR(CurChr)-A0) CALL MulAddU32 ( Number , 10 , ( IACHAR ( CurChr ) - A0 )) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF END DO END IF NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinU128 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitU128 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitU128 ) THEN ! value might be in the applicable range so check overflow CurStr = cStr ( IStart : StrLen ) Overflow = FalseVal DO Indx = 1 , MaxDigitU128 CurChr => CurStr ( Indx : Indx ) IF ( IACHAR ( CurChr ) < IACHAR ( MaxStr ( Indx : Indx ))) THEN EXIT ELSEIF ( IACHAR ( CurChr ) > IACHAR ( MaxStr ( Indx : Indx ))) THEN Overflow = TrueVal EXIT END IF END DO ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is too large.' Number = MaxU128 END IF RETURN CONTAINS FUNCTION Parse8Digits ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse8Digits !** PURPOSE OF THIS SUBROUTINE: ! To parse eight digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: K1 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K2 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K3 = INT ( Z '0000FFFF0000FFFF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M1 = 2561_I8B INTEGER ( KIND = I8B ), PARAMETER :: M2 = 6553601_I8B INTEGER ( KIND = I8B ), PARAMETER :: M3 = 42949672960001_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = SHIFTR ( IAND ( SHIFTR ( IAND ( SHIFTR ( IAND ( InVal , K1 ) * M1 , 8 ), K2 ) * M2 , 16 ), K3 ) * M3 , 32 ) RETURN END FUNCTION Parse8Digits !****************************************************************************** FUNCTION Is8Digits ( InVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is8Digits !** PURPOSE OF THIS SUBROUTINE: ! To check whether we can process eight digits immediately IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: C1 = INT ( Z 'F0F0F0F0F0F0F0F0' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C2 = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C3 = INT ( Z '0606060606060606' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IOR ( IAND ( InVal , C1 ), SHIFTR ( IAND (( InVal + C3 ), C1 ), 4 )) == C2 RETURN END FUNCTION Is8Digits !****************************************************************************** SUBROUTINE MulAddU64 ( U128 , Mul , Add ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply the given number by 'Mul' and then add 'Add' to it. ! (i.e. to set  U128 = U128*Mul + Add) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: U128 INTEGER ( KIND = I8B ), INTENT ( IN ) :: Mul INTEGER ( KIND = I8B ), INTENT ( IN ) :: Add !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Cross , MulLo !** FLOW ! perform multiplication X_Lo = IAND ( Mul , Mask32 ) Y_Lo = IAND ( U128 % Low , Mask32 ) Y_Hi = SHIFTR ( U128 % Low , 32 ) Lo_Lo = X_Lo * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + X_Lo * Y_Hi MulLo = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , Mask32 )) U128 % High = U128 % High * Mul + SHIFTR ( Cross , 32 ) ! perform addition U128 % Low = MulLo + Add IF ( IEOR ( U128 % Low , MinI64 ) < IEOR ( MulLo , MinI64 )) U128 % High = U128 % High + 1_I8B RETURN END SUBROUTINE MulAddU64 !****************************************************************************** SUBROUTINE MulAddU32 ( U128 , Mul , Add ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply the given number by 'Mul' and then add 'Add' to it. ! (i.e. to set  U128 = U128*Mul + Add) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: U128 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Mul INTEGER ( KIND = I4B ), INTENT ( IN ) :: Add !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Cross , MulLo !** FLOW ! perform multiplication X_Lo = IAND ( INT ( Mul , KIND = I8B ), Mask32 ) Y_Lo = IAND ( U128 % Low , Mask32 ) Y_Hi = SHIFTR ( U128 % Low , 32 ) Lo_Lo = X_Lo * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + X_Lo * Y_Hi MulLo = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , Mask32 )) U128 % High = U128 % High * Mul + SHIFTR ( Cross , 32 ) ! perform addition U128 % Low = MulLo + Add IF ( IEOR ( U128 % Low , MinI64 ) < IEOR ( MulLo , MinI64 )) U128 % High = U128 % High + 1_I8B RETURN END SUBROUTINE MulAddU32 !****************************************************************************** END FUNCTION DecString_To_U128 !------------------------------------------------------------------------------ ! !                           CONVERSION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I32_From_U128 ( U128 ) RESULT ( I32 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a signed 32-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I4B ) :: I32 !! number treated as signed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I32 = INT ( U128 % Low , KIND = I4B ) RETURN END FUNCTION I32_From_U128 !****************************************************************************** FUNCTION I64_From_U128 ( U128 ) RESULT ( I64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a signed 64-bit integer number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I8B ) :: I64 !! number treated as signed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW I64 = U128 % Low RETURN END FUNCTION I64_From_U128 !****************************************************************************** FUNCTION R32_From_U128 ( U128 ) RESULT ( R32 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a 32-bit floating point number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 REAL ( KIND = SP ) :: R32 !** SUBROUTINE PARAMETER DECLARATIONS: REAL ( KIND = SP ), PARAMETER :: TwoPow64 = 2.0_SP ** 64 INTEGER ( KIND = I4B ), PARAMETER :: TwoPow23 = SHIFTL ( 1 , 23 ) INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '000000FF' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: S , Exp INTEGER ( KIND = I4B ) :: IBits REAL ( KIND = SP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW IF ( U128 % High == 0_I8B ) THEN ! convert directly and return quickly R32 = U64_To_R32 ( U128 % Low ) RETURN END IF S = LEADZ ( U128 % High ) ! Mask out the 24 MSBits ! Also, the leading bit is implicit so cancel it out to get the significand IF ( S <= 40 ) THEN IBits = IEOR ( INT ( SHIFTR ( U128 % High , 40 - S ), KIND = I4B ), TwoPow23 ) ELSE ! S-40 == additional bits we need IBits = IEOR ( INT ( IOR ( SHIFTL ( U128 % High , S - 40 ), SHIFTR ( U128 % Low , 104 - S )), KIND = I4B ), TwoPow23 ) END IF ! get the binary exponent Exp = IAND ( 254 - S , Mask ) ! 254 = 64 + 64 + 127 - 1 ! Add the exponent IBits = IOR ( IBits , SHIFTL ( Exp , 23 )) ! transfer output (RBits mapped to IBits using equivalence) R32 = RBits RETURN CONTAINS FUNCTION U64_To_R32 ( LongVal ) RESULT ( SingleVal ) !DIR$ ATTRIBUTES FORCEINLINE :: U64_To_R32 !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned 64-bit integer number to a 32-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LongVal ! integer number treated as unsigned one REAL ( KIND = SP ) :: SingleVal ! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LongVal >= 0_I8B ) THEN SingleVal = REAL ( LongVal , KIND = SP ) ELSE SingleVal = TwoPow64 + REAL ( LongVal , KIND = SP ) END IF RETURN END FUNCTION U64_To_R32 !****************************************************************************** END FUNCTION R32_From_U128 !****************************************************************************** FUNCTION R64_From_U128 ( U128 ) RESULT ( R64 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a 64-bit floating point number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 REAL ( KIND = DP ) :: R64 !** SUBROUTINE PARAMETER DECLARATIONS: REAL ( KIND = DP ), PARAMETER :: TwoPow64 = 2.0_DP ** 64 INTEGER ( KIND = I8B ), PARAMETER :: TwoPow52 = SHIFTL ( 1_I8B , 52 ) INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '000007FF' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: S INTEGER ( KIND = I8B ) :: Exp INTEGER ( KIND = I8B ) :: IBits REAL ( KIND = DP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW IF ( U128 % High == 0_I8B ) THEN R64 = U64_To_R64 ( U128 % Low ) RETURN END IF S = LEADZ ( U128 % High ) ! Mask out the 53 MSBits ! Also, the leading bit is implicit so cancel it out to get the significand IF ( S <= 11 ) THEN IBits = IEOR ( SHIFTR ( U128 % High , 11 - S ), TwoPow52 ) ELSE ! S-11 == additional bits we need IBits = IEOR ( IOR ( SHIFTL ( U128 % High , S - 11 ), SHIFTR ( U128 % Low , 75 - S )), TwoPow52 ) END IF ! get the binary exponent Exp = INT ( IAND ( 1150 - S , Mask ), KIND = I8B ) ! 1150 = 64 + 64 + 1023 - 1 ! Add the exponent IBits = IOR ( IBits , SHIFTL ( Exp , 52 )) ! transfer output (RBits mapped to IBits using equivalence) R64 = RBits RETURN CONTAINS FUNCTION U64_To_R64 ( LongVal ) RESULT ( DoubleVal ) !DIR$ ATTRIBUTES FORCEINLINE :: U64_To_R64 !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned 64-bit integer number to a 64-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LongVal ! integer number treated as unsigned one REAL ( KIND = DP ) :: DoubleVal ! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LongVal >= 0_I8B ) THEN DoubleVal = REAL ( LongVal , KIND = DP ) ELSE DoubleVal = TwoPow64 + REAL ( LongVal , KIND = DP ) END IF RETURN END FUNCTION U64_To_R64 !****************************************************************************** END FUNCTION R64_From_U128 !****************************************************************************** FUNCTION R128_From_U128 ( U128 ) RESULT ( R128 ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a 128-bit floating point number. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 REAL ( KIND = QP ) :: R128 !** SUBROUTINE PARAMETER DECLARATIONS: REAL ( KIND = QP ), PARAMETER :: TwoPow64 = 2.0_QP ** 64 INTEGER ( KIND = I8B ), PARAMETER :: TwoPow112 ( 2 ) = [ 0_I8B , 281474976710656_I8B ] ! SHIFTL(1, 112) INTEGER ( KIND = I4B ), PARAMETER :: Mask = INT ( Z '00007FFF' , KIND = I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: S , Shift INTEGER ( KIND = I8B ) :: Exp INTEGER ( KIND = I8B ) :: IBits ( 2 ) REAL ( KIND = QP ) :: RBits EQUIVALENCE ( IBits , RBits ) !** FLOW IF ( U128 % High == 0_I8B ) THEN R128 = U64_To_R128 ( U128 % Low ) RETURN END IF S = LEADZ ( U128 % High ) IF ( S >= 15 ) THEN R128 = U64_To_R128 ( U128 % Low ) + U64_To_R128 ( U128 % High ) * TwoPow64 RETURN END IF ! Mask out the 113 MSBits (assumming little-endian order) ! (if big-endian order, just switch IBits(1) and IBits(2)) Shift = 15 - S IBits ( 2 ) = SHIFTR ( U128 % High , Shift ) IBits ( 1 ) = IOR ( SHIFTR ( U128 % Low , Shift ), SHIFTL ( U128 % High , 64 - Shift )) ! get the binary exponent Exp = INT ( IAND ( 16510 - S , Mask ), KIND = I8B ) ! 16510 = 64 + 64 + 16383 - 1 ! The leading bit is implicit, cancel it out to get the significand ! and also add the exponent IBits ( 1 ) = IEOR ( IOR ( SHIFTR ( U128 % Low , Shift ), SHIFTL ( U128 % High , 64 - Shift )), TwoPow112 ( 1 )) IBits ( 2 ) = IOR ( IEOR ( SHIFTR ( U128 % High , Shift ), TwoPow112 ( 2 )), SHIFTL ( Exp , 48 )) ! 48 = 112 - 64 ! transfer output (RBits mapped to IBits using equivalence) ! For big-endian machine, we must swap IBits(1) and IBits(2) before the assigment. ! => Tmp = IBits(1); IBits(1) = IBits(2); IBits(2) = Tmp R128 = RBits RETURN CONTAINS FUNCTION U64_To_R128 ( LongVal ) RESULT ( QuadVal ) !DIR$ ATTRIBUTES FORCEINLINE :: U64_To_R128 !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned 64-bit integer number to a 128-bit floating point number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LongVal ! integer number treated as unsigned one REAL ( KIND = QP ) :: QuadVal ! floating point number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LongVal >= 0_I8B ) THEN QuadVal = REAL ( LongVal , KIND = QP ) ELSE QuadVal = TwoPow64 + REAL ( LongVal , KIND = QP ) END IF RETURN END FUNCTION U64_To_R128 !****************************************************************************** END FUNCTION R128_From_U128 !****************************************************************************** FUNCTION DecString_From_U128 ( U128 ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a decimal string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 CHARACTER ( LEN = :), ALLOCATABLE :: Str !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN = 1 ), PARAMETER :: Char1Digit ( 0 : 9 ) = [ & '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] CHARACTER ( LEN = 2 ), PARAMETER :: Char2Digits ( 0 : 99 ) = [ & '00' , '01' , '02' , '03' , '04' , '05' , '06' , '07' , '08' , '09' , & '10' , '11' , '12' , '13' , '14' , '15' , '16' , '17' , '18' , '19' , & '20' , '21' , '22' , '23' , '24' , '25' , '26' , '27' , '28' , '29' , & '30' , '31' , '32' , '33' , '34' , '35' , '36' , '37' , '38' , '39' , & '40' , '41' , '42' , '43' , '44' , '45' , '46' , '47' , '48' , '49' , & '50' , '51' , '52' , '53' , '54' , '55' , '56' , '57' , '58' , '59' , & '60' , '61' , '62' , '63' , '64' , '65' , '66' , '67' , '68' , '69' , & '70' , '71' , '72' , '73' , '74' , '75' , '76' , '77' , '78' , '79' , & '80' , '81' , '82' , '83' , '84' , '85' , '86' , '87' , '88' , '89' , & '90' , '91' , '92' , '93' , '94' , '95' , '96' , '97' , '98' , '99' ] CHARACTER ( LEN = 4 ), PARAMETER :: Char4Digits ( 0 : 9999 ) = [ & '0000' , '0001' , '0002' , '0003' , '0004' , '0005' , '0006' , '0007' , '0008' , '0009' , & '0010' , '0011' , '0012' , '0013' , '0014' , '0015' , '0016' , '0017' , '0018' , '0019' , & '0020' , '0021' , '0022' , '0023' , '0024' , '0025' , '0026' , '0027' , '0028' , '0029' , & '0030' , '0031' , '0032' , '0033' , '0034' , '0035' , '0036' , '0037' , '0038' , '0039' , & '0040' , '0041' , '0042' , '0043' , '0044' , '0045' , '0046' , '0047' , '0048' , '0049' , & '0050' , '0051' , '0052' , '0053' , '0054' , '0055' , '0056' , '0057' , '0058' , '0059' , & '0060' , '0061' , '0062' , '0063' , '0064' , '0065' , '0066' , '0067' , '0068' , '0069' , & '0070' , '0071' , '0072' , '0073' , '0074' , '0075' , '0076' , '0077' , '0078' , '0079' , & '0080' , '0081' , '0082' , '0083' , '0084' , '0085' , '0086' , '0087' , '0088' , '0089' , & '0090' , '0091' , '0092' , '0093' , '0094' , '0095' , '0096' , '0097' , '0098' , '0099' , & '0100' , '0101' , '0102' , '0103' , '0104' , '0105' , '0106' , '0107' , '0108' , '0109' , & '0110' , '0111' , '0112' , '0113' , '0114' , '0115' , '0116' , '0117' , '0118' , '0119' , & '0120' , '0121' , '0122' , '0123' , '0124' , '0125' , '0126' , '0127' , '0128' , '0129' , & '0130' , '0131' , '0132' , '0133' , '0134' , '0135' , '0136' , '0137' , '0138' , '0139' , & '0140' , '0141' , '0142' , '0143' , '0144' , '0145' , '0146' , '0147' , '0148' , '0149' , & '0150' , '0151' , '0152' , '0153' , '0154' , '0155' , '0156' , '0157' , '0158' , '0159' , & '0160' , '0161' , '0162' , '0163' , '0164' , '0165' , '0166' , '0167' , '0168' , '0169' , & '0170' , '0171' , '0172' , '0173' , '0174' , '0175' , '0176' , '0177' , '0178' , '0179' , & '0180' , '0181' , '0182' , '0183' , '0184' , '0185' , '0186' , '0187' , '0188' , '0189' , & '0190' , '0191' , '0192' , '0193' , '0194' , '0195' , '0196' , '0197' , '0198' , '0199' , & '0200' , '0201' , '0202' , '0203' , '0204' , '0205' , '0206' , '0207' , '0208' , '0209' , & '0210' , '0211' , '0212' , '0213' , '0214' , '0215' , '0216' , '0217' , '0218' , '0219' , & '0220' , '0221' , '0222' , '0223' , '0224' , '0225' , '0226' , '0227' , '0228' , '0229' , & '0230' , '0231' , '0232' , '0233' , '0234' , '0235' , '0236' , '0237' , '0238' , '0239' , & '0240' , '0241' , '0242' , '0243' , '0244' , '0245' , '0246' , '0247' , '0248' , '0249' , & '0250' , '0251' , '0252' , '0253' , '0254' , '0255' , '0256' , '0257' , '0258' , '0259' , & '0260' , '0261' , '0262' , '0263' , '0264' , '0265' , '0266' , '0267' , '0268' , '0269' , & '0270' , '0271' , '0272' , '0273' , '0274' , '0275' , '0276' , '0277' , '0278' , '0279' , & '0280' , '0281' , '0282' , '0283' , '0284' , '0285' , '0286' , '0287' , '0288' , '0289' , & '0290' , '0291' , '0292' , '0293' , '0294' , '0295' , '0296' , '0297' , '0298' , '0299' , & '0300' , '0301' , '0302' , '0303' , '0304' , '0305' , '0306' , '0307' , '0308' , '0309' , & '0310' , '0311' , '0312' , '0313' , '0314' , '0315' , '0316' , '0317' , '0318' , '0319' , & '0320' , '0321' , '0322' , '0323' , '0324' , '0325' , '0326' , '0327' , '0328' , '0329' , & '0330' , '0331' , '0332' , '0333' , '0334' , '0335' , '0336' , '0337' , '0338' , '0339' , & '0340' , '0341' , '0342' , '0343' , '0344' , '0345' , '0346' , '0347' , '0348' , '0349' , & '0350' , '0351' , '0352' , '0353' , '0354' , '0355' , '0356' , '0357' , '0358' , '0359' , & '0360' , '0361' , '0362' , '0363' , '0364' , '0365' , '0366' , '0367' , '0368' , '0369' , & '0370' , '0371' , '0372' , '0373' , '0374' , '0375' , '0376' , '0377' , '0378' , '0379' , & '0380' , '0381' , '0382' , '0383' , '0384' , '0385' , '0386' , '0387' , '0388' , '0389' , & '0390' , '0391' , '0392' , '0393' , '0394' , '0395' , '0396' , '0397' , '0398' , '0399' , & '0400' , '0401' , '0402' , '0403' , '0404' , '0405' , '0406' , '0407' , '0408' , '0409' , & '0410' , '0411' , '0412' , '0413' , '0414' , '0415' , '0416' , '0417' , '0418' , '0419' , & '0420' , '0421' , '0422' , '0423' , '0424' , '0425' , '0426' , '0427' , '0428' , '0429' , & '0430' , '0431' , '0432' , '0433' , '0434' , '0435' , '0436' , '0437' , '0438' , '0439' , & '0440' , '0441' , '0442' , '0443' , '0444' , '0445' , '0446' , '0447' , '0448' , '0449' , & '0450' , '0451' , '0452' , '0453' , '0454' , '0455' , '0456' , '0457' , '0458' , '0459' , & '0460' , '0461' , '0462' , '0463' , '0464' , '0465' , '0466' , '0467' , '0468' , '0469' , & '0470' , '0471' , '0472' , '0473' , '0474' , '0475' , '0476' , '0477' , '0478' , '0479' , & '0480' , '0481' , '0482' , '0483' , '0484' , '0485' , '0486' , '0487' , '0488' , '0489' , & '0490' , '0491' , '0492' , '0493' , '0494' , '0495' , '0496' , '0497' , '0498' , '0499' , & '0500' , '0501' , '0502' , '0503' , '0504' , '0505' , '0506' , '0507' , '0508' , '0509' , & '0510' , '0511' , '0512' , '0513' , '0514' , '0515' , '0516' , '0517' , '0518' , '0519' , & '0520' , '0521' , '0522' , '0523' , '0524' , '0525' , '0526' , '0527' , '0528' , '0529' , & '0530' , '0531' , '0532' , '0533' , '0534' , '0535' , '0536' , '0537' , '0538' , '0539' , & '0540' , '0541' , '0542' , '0543' , '0544' , '0545' , '0546' , '0547' , '0548' , '0549' , & '0550' , '0551' , '0552' , '0553' , '0554' , '0555' , '0556' , '0557' , '0558' , '0559' , & '0560' , '0561' , '0562' , '0563' , '0564' , '0565' , '0566' , '0567' , '0568' , '0569' , & '0570' , '0571' , '0572' , '0573' , '0574' , '0575' , '0576' , '0577' , '0578' , '0579' , & '0580' , '0581' , '0582' , '0583' , '0584' , '0585' , '0586' , '0587' , '0588' , '0589' , & '0590' , '0591' , '0592' , '0593' , '0594' , '0595' , '0596' , '0597' , '0598' , '0599' , & '0600' , '0601' , '0602' , '0603' , '0604' , '0605' , '0606' , '0607' , '0608' , '0609' , & '0610' , '0611' , '0612' , '0613' , '0614' , '0615' , '0616' , '0617' , '0618' , '0619' , & '0620' , '0621' , '0622' , '0623' , '0624' , '0625' , '0626' , '0627' , '0628' , '0629' , & '0630' , '0631' , '0632' , '0633' , '0634' , '0635' , '0636' , '0637' , '0638' , '0639' , & '0640' , '0641' , '0642' , '0643' , '0644' , '0645' , '0646' , '0647' , '0648' , '0649' , & '0650' , '0651' , '0652' , '0653' , '0654' , '0655' , '0656' , '0657' , '0658' , '0659' , & '0660' , '0661' , '0662' , '0663' , '0664' , '0665' , '0666' , '0667' , '0668' , '0669' , & '0670' , '0671' , '0672' , '0673' , '0674' , '0675' , '0676' , '0677' , '0678' , '0679' , & '0680' , '0681' , '0682' , '0683' , '0684' , '0685' , '0686' , '0687' , '0688' , '0689' , & '0690' , '0691' , '0692' , '0693' , '0694' , '0695' , '0696' , '0697' , '0698' , '0699' , & '0700' , '0701' , '0702' , '0703' , '0704' , '0705' , '0706' , '0707' , '0708' , '0709' , & '0710' , '0711' , '0712' , '0713' , '0714' , '0715' , '0716' , '0717' , '0718' , '0719' , & '0720' , '0721' , '0722' , '0723' , '0724' , '0725' , '0726' , '0727' , '0728' , '0729' , & '0730' , '0731' , '0732' , '0733' , '0734' , '0735' , '0736' , '0737' , '0738' , '0739' , & '0740' , '0741' , '0742' , '0743' , '0744' , '0745' , '0746' , '0747' , '0748' , '0749' , & '0750' , '0751' , '0752' , '0753' , '0754' , '0755' , '0756' , '0757' , '0758' , '0759' , & '0760' , '0761' , '0762' , '0763' , '0764' , '0765' , '0766' , '0767' , '0768' , '0769' , & '0770' , '0771' , '0772' , '0773' , '0774' , '0775' , '0776' , '0777' , '0778' , '0779' , & '0780' , '0781' , '0782' , '0783' , '0784' , '0785' , '0786' , '0787' , '0788' , '0789' , & '0790' , '0791' , '0792' , '0793' , '0794' , '0795' , '0796' , '0797' , '0798' , '0799' , & '0800' , '0801' , '0802' , '0803' , '0804' , '0805' , '0806' , '0807' , '0808' , '0809' , & '0810' , '0811' , '0812' , '0813' , '0814' , '0815' , '0816' , '0817' , '0818' , '0819' , & '0820' , '0821' , '0822' , '0823' , '0824' , '0825' , '0826' , '0827' , '0828' , '0829' , & '0830' , '0831' , '0832' , '0833' , '0834' , '0835' , '0836' , '0837' , '0838' , '0839' , & '0840' , '0841' , '0842' , '0843' , '0844' , '0845' , '0846' , '0847' , '0848' , '0849' , & '0850' , '0851' , '0852' , '0853' , '0854' , '0855' , '0856' , '0857' , '0858' , '0859' , & '0860' , '0861' , '0862' , '0863' , '0864' , '0865' , '0866' , '0867' , '0868' , '0869' , & '0870' , '0871' , '0872' , '0873' , '0874' , '0875' , '0876' , '0877' , '0878' , '0879' , & '0880' , '0881' , '0882' , '0883' , '0884' , '0885' , '0886' , '0887' , '0888' , '0889' , & '0890' , '0891' , '0892' , '0893' , '0894' , '0895' , '0896' , '0897' , '0898' , '0899' , & '0900' , '0901' , '0902' , '0903' , '0904' , '0905' , '0906' , '0907' , '0908' , '0909' , & '0910' , '0911' , '0912' , '0913' , '0914' , '0915' , '0916' , '0917' , '0918' , '0919' , & '0920' , '0921' , '0922' , '0923' , '0924' , '0925' , '0926' , '0927' , '0928' , '0929' , & '0930' , '0931' , '0932' , '0933' , '0934' , '0935' , '0936' , '0937' , '0938' , '0939' , & '0940' , '0941' , '0942' , '0943' , '0944' , '0945' , '0946' , '0947' , '0948' , '0949' , & '0950' , '0951' , '0952' , '0953' , '0954' , '0955' , '0956' , '0957' , '0958' , '0959' , & '0960' , '0961' , '0962' , '0963' , '0964' , '0965' , '0966' , '0967' , '0968' , '0969' , & '0970' , '0971' , '0972' , '0973' , '0974' , '0975' , '0976' , '0977' , '0978' , '0979' , & '0980' , '0981' , '0982' , '0983' , '0984' , '0985' , '0986' , '0987' , '0988' , '0989' , & '0990' , '0991' , '0992' , '0993' , '0994' , '0995' , '0996' , '0997' , '0998' , '0999' , & '1000' , '1001' , '1002' , '1003' , '1004' , '1005' , '1006' , '1007' , '1008' , '1009' , & '1010' , '1011' , '1012' , '1013' , '1014' , '1015' , '1016' , '1017' , '1018' , '1019' , & '1020' , '1021' , '1022' , '1023' , '1024' , '1025' , '1026' , '1027' , '1028' , '1029' , & '1030' , '1031' , '1032' , '1033' , '1034' , '1035' , '1036' , '1037' , '1038' , '1039' , & '1040' , '1041' , '1042' , '1043' , '1044' , '1045' , '1046' , '1047' , '1048' , '1049' , & '1050' , '1051' , '1052' , '1053' , '1054' , '1055' , '1056' , '1057' , '1058' , '1059' , & '1060' , '1061' , '1062' , '1063' , '1064' , '1065' , '1066' , '1067' , '1068' , '1069' , & '1070' , '1071' , '1072' , '1073' , '1074' , '1075' , '1076' , '1077' , '1078' , '1079' , & '1080' , '1081' , '1082' , '1083' , '1084' , '1085' , '1086' , '1087' , '1088' , '1089' , & '1090' , '1091' , '1092' , '1093' , '1094' , '1095' , '1096' , '1097' , '1098' , '1099' , & '1100' , '1101' , '1102' , '1103' , '1104' , '1105' , '1106' , '1107' , '1108' , '1109' , & '1110' , '1111' , '1112' , '1113' , '1114' , '1115' , '1116' , '1117' , '1118' , '1119' , & '1120' , '1121' , '1122' , '1123' , '1124' , '1125' , '1126' , '1127' , '1128' , '1129' , & '1130' , '1131' , '1132' , '1133' , '1134' , '1135' , '1136' , '1137' , '1138' , '1139' , & '1140' , '1141' , '1142' , '1143' , '1144' , '1145' , '1146' , '1147' , '1148' , '1149' , & '1150' , '1151' , '1152' , '1153' , '1154' , '1155' , '1156' , '1157' , '1158' , '1159' , & '1160' , '1161' , '1162' , '1163' , '1164' , '1165' , '1166' , '1167' , '1168' , '1169' , & '1170' , '1171' , '1172' , '1173' , '1174' , '1175' , '1176' , '1177' , '1178' , '1179' , & '1180' , '1181' , '1182' , '1183' , '1184' , '1185' , '1186' , '1187' , '1188' , '1189' , & '1190' , '1191' , '1192' , '1193' , '1194' , '1195' , '1196' , '1197' , '1198' , '1199' , & '1200' , '1201' , '1202' , '1203' , '1204' , '1205' , '1206' , '1207' , '1208' , '1209' , & '1210' , '1211' , '1212' , '1213' , '1214' , '1215' , '1216' , '1217' , '1218' , '1219' , & '1220' , '1221' , '1222' , '1223' , '1224' , '1225' , '1226' , '1227' , '1228' , '1229' , & '1230' , '1231' , '1232' , '1233' , '1234' , '1235' , '1236' , '1237' , '1238' , '1239' , & '1240' , '1241' , '1242' , '1243' , '1244' , '1245' , '1246' , '1247' , '1248' , '1249' , & '1250' , '1251' , '1252' , '1253' , '1254' , '1255' , '1256' , '1257' , '1258' , '1259' , & '1260' , '1261' , '1262' , '1263' , '1264' , '1265' , '1266' , '1267' , '1268' , '1269' , & '1270' , '1271' , '1272' , '1273' , '1274' , '1275' , '1276' , '1277' , '1278' , '1279' , & '1280' , '1281' , '1282' , '1283' , '1284' , '1285' , '1286' , '1287' , '1288' , '1289' , & '1290' , '1291' , '1292' , '1293' , '1294' , '1295' , '1296' , '1297' , '1298' , '1299' , & '1300' , '1301' , '1302' , '1303' , '1304' , '1305' , '1306' , '1307' , '1308' , '1309' , & '1310' , '1311' , '1312' , '1313' , '1314' , '1315' , '1316' , '1317' , '1318' , '1319' , & '1320' , '1321' , '1322' , '1323' , '1324' , '1325' , '1326' , '1327' , '1328' , '1329' , & '1330' , '1331' , '1332' , '1333' , '1334' , '1335' , '1336' , '1337' , '1338' , '1339' , & '1340' , '1341' , '1342' , '1343' , '1344' , '1345' , '1346' , '1347' , '1348' , '1349' , & '1350' , '1351' , '1352' , '1353' , '1354' , '1355' , '1356' , '1357' , '1358' , '1359' , & '1360' , '1361' , '1362' , '1363' , '1364' , '1365' , '1366' , '1367' , '1368' , '1369' , & '1370' , '1371' , '1372' , '1373' , '1374' , '1375' , '1376' , '1377' , '1378' , '1379' , & '1380' , '1381' , '1382' , '1383' , '1384' , '1385' , '1386' , '1387' , '1388' , '1389' , & '1390' , '1391' , '1392' , '1393' , '1394' , '1395' , '1396' , '1397' , '1398' , '1399' , & '1400' , '1401' , '1402' , '1403' , '1404' , '1405' , '1406' , '1407' , '1408' , '1409' , & '1410' , '1411' , '1412' , '1413' , '1414' , '1415' , '1416' , '1417' , '1418' , '1419' , & '1420' , '1421' , '1422' , '1423' , '1424' , '1425' , '1426' , '1427' , '1428' , '1429' , & '1430' , '1431' , '1432' , '1433' , '1434' , '1435' , '1436' , '1437' , '1438' , '1439' , & '1440' , '1441' , '1442' , '1443' , '1444' , '1445' , '1446' , '1447' , '1448' , '1449' , & '1450' , '1451' , '1452' , '1453' , '1454' , '1455' , '1456' , '1457' , '1458' , '1459' , & '1460' , '1461' , '1462' , '1463' , '1464' , '1465' , '1466' , '1467' , '1468' , '1469' , & '1470' , '1471' , '1472' , '1473' , '1474' , '1475' , '1476' , '1477' , '1478' , '1479' , & '1480' , '1481' , '1482' , '1483' , '1484' , '1485' , '1486' , '1487' , '1488' , '1489' , & '1490' , '1491' , '1492' , '1493' , '1494' , '1495' , '1496' , '1497' , '1498' , '1499' , & '1500' , '1501' , '1502' , '1503' , '1504' , '1505' , '1506' , '1507' , '1508' , '1509' , & '1510' , '1511' , '1512' , '1513' , '1514' , '1515' , '1516' , '1517' , '1518' , '1519' , & '1520' , '1521' , '1522' , '1523' , '1524' , '1525' , '1526' , '1527' , '1528' , '1529' , & '1530' , '1531' , '1532' , '1533' , '1534' , '1535' , '1536' , '1537' , '1538' , '1539' , & '1540' , '1541' , '1542' , '1543' , '1544' , '1545' , '1546' , '1547' , '1548' , '1549' , & '1550' , '1551' , '1552' , '1553' , '1554' , '1555' , '1556' , '1557' , '1558' , '1559' , & '1560' , '1561' , '1562' , '1563' , '1564' , '1565' , '1566' , '1567' , '1568' , '1569' , & '1570' , '1571' , '1572' , '1573' , '1574' , '1575' , '1576' , '1577' , '1578' , '1579' , & '1580' , '1581' , '1582' , '1583' , '1584' , '1585' , '1586' , '1587' , '1588' , '1589' , & '1590' , '1591' , '1592' , '1593' , '1594' , '1595' , '1596' , '1597' , '1598' , '1599' , & '1600' , '1601' , '1602' , '1603' , '1604' , '1605' , '1606' , '1607' , '1608' , '1609' , & '1610' , '1611' , '1612' , '1613' , '1614' , '1615' , '1616' , '1617' , '1618' , '1619' , & '1620' , '1621' , '1622' , '1623' , '1624' , '1625' , '1626' , '1627' , '1628' , '1629' , & '1630' , '1631' , '1632' , '1633' , '1634' , '1635' , '1636' , '1637' , '1638' , '1639' , & '1640' , '1641' , '1642' , '1643' , '1644' , '1645' , '1646' , '1647' , '1648' , '1649' , & '1650' , '1651' , '1652' , '1653' , '1654' , '1655' , '1656' , '1657' , '1658' , '1659' , & '1660' , '1661' , '1662' , '1663' , '1664' , '1665' , '1666' , '1667' , '1668' , '1669' , & '1670' , '1671' , '1672' , '1673' , '1674' , '1675' , '1676' , '1677' , '1678' , '1679' , & '1680' , '1681' , '1682' , '1683' , '1684' , '1685' , '1686' , '1687' , '1688' , '1689' , & '1690' , '1691' , '1692' , '1693' , '1694' , '1695' , '1696' , '1697' , '1698' , '1699' , & '1700' , '1701' , '1702' , '1703' , '1704' , '1705' , '1706' , '1707' , '1708' , '1709' , & '1710' , '1711' , '1712' , '1713' , '1714' , '1715' , '1716' , '1717' , '1718' , '1719' , & '1720' , '1721' , '1722' , '1723' , '1724' , '1725' , '1726' , '1727' , '1728' , '1729' , & '1730' , '1731' , '1732' , '1733' , '1734' , '1735' , '1736' , '1737' , '1738' , '1739' , & '1740' , '1741' , '1742' , '1743' , '1744' , '1745' , '1746' , '1747' , '1748' , '1749' , & '1750' , '1751' , '1752' , '1753' , '1754' , '1755' , '1756' , '1757' , '1758' , '1759' , & '1760' , '1761' , '1762' , '1763' , '1764' , '1765' , '1766' , '1767' , '1768' , '1769' , & '1770' , '1771' , '1772' , '1773' , '1774' , '1775' , '1776' , '1777' , '1778' , '1779' , & '1780' , '1781' , '1782' , '1783' , '1784' , '1785' , '1786' , '1787' , '1788' , '1789' , & '1790' , '1791' , '1792' , '1793' , '1794' , '1795' , '1796' , '1797' , '1798' , '1799' , & '1800' , '1801' , '1802' , '1803' , '1804' , '1805' , '1806' , '1807' , '1808' , '1809' , & '1810' , '1811' , '1812' , '1813' , '1814' , '1815' , '1816' , '1817' , '1818' , '1819' , & '1820' , '1821' , '1822' , '1823' , '1824' , '1825' , '1826' , '1827' , '1828' , '1829' , & '1830' , '1831' , '1832' , '1833' , '1834' , '1835' , '1836' , '1837' , '1838' , '1839' , & '1840' , '1841' , '1842' , '1843' , '1844' , '1845' , '1846' , '1847' , '1848' , '1849' , & '1850' , '1851' , '1852' , '1853' , '1854' , '1855' , '1856' , '1857' , '1858' , '1859' , & '1860' , '1861' , '1862' , '1863' , '1864' , '1865' , '1866' , '1867' , '1868' , '1869' , & '1870' , '1871' , '1872' , '1873' , '1874' , '1875' , '1876' , '1877' , '1878' , '1879' , & '1880' , '1881' , '1882' , '1883' , '1884' , '1885' , '1886' , '1887' , '1888' , '1889' , & '1890' , '1891' , '1892' , '1893' , '1894' , '1895' , '1896' , '1897' , '1898' , '1899' , & '1900' , '1901' , '1902' , '1903' , '1904' , '1905' , '1906' , '1907' , '1908' , '1909' , & '1910' , '1911' , '1912' , '1913' , '1914' , '1915' , '1916' , '1917' , '1918' , '1919' , & '1920' , '1921' , '1922' , '1923' , '1924' , '1925' , '1926' , '1927' , '1928' , '1929' , & '1930' , '1931' , '1932' , '1933' , '1934' , '1935' , '1936' , '1937' , '1938' , '1939' , & '1940' , '1941' , '1942' , '1943' , '1944' , '1945' , '1946' , '1947' , '1948' , '1949' , & '1950' , '1951' , '1952' , '1953' , '1954' , '1955' , '1956' , '1957' , '1958' , '1959' , & '1960' , '1961' , '1962' , '1963' , '1964' , '1965' , '1966' , '1967' , '1968' , '1969' , & '1970' , '1971' , '1972' , '1973' , '1974' , '1975' , '1976' , '1977' , '1978' , '1979' , & '1980' , '1981' , '1982' , '1983' , '1984' , '1985' , '1986' , '1987' , '1988' , '1989' , & '1990' , '1991' , '1992' , '1993' , '1994' , '1995' , '1996' , '1997' , '1998' , '1999' , & '2000' , '2001' , '2002' , '2003' , '2004' , '2005' , '2006' , '2007' , '2008' , '2009' , & '2010' , '2011' , '2012' , '2013' , '2014' , '2015' , '2016' , '2017' , '2018' , '2019' , & '2020' , '2021' , '2022' , '2023' , '2024' , '2025' , '2026' , '2027' , '2028' , '2029' , & '2030' , '2031' , '2032' , '2033' , '2034' , '2035' , '2036' , '2037' , '2038' , '2039' , & '2040' , '2041' , '2042' , '2043' , '2044' , '2045' , '2046' , '2047' , '2048' , '2049' , & '2050' , '2051' , '2052' , '2053' , '2054' , '2055' , '2056' , '2057' , '2058' , '2059' , & '2060' , '2061' , '2062' , '2063' , '2064' , '2065' , '2066' , '2067' , '2068' , '2069' , & '2070' , '2071' , '2072' , '2073' , '2074' , '2075' , '2076' , '2077' , '2078' , '2079' , & '2080' , '2081' , '2082' , '2083' , '2084' , '2085' , '2086' , '2087' , '2088' , '2089' , & '2090' , '2091' , '2092' , '2093' , '2094' , '2095' , '2096' , '2097' , '2098' , '2099' , & '2100' , '2101' , '2102' , '2103' , '2104' , '2105' , '2106' , '2107' , '2108' , '2109' , & '2110' , '2111' , '2112' , '2113' , '2114' , '2115' , '2116' , '2117' , '2118' , '2119' , & '2120' , '2121' , '2122' , '2123' , '2124' , '2125' , '2126' , '2127' , '2128' , '2129' , & '2130' , '2131' , '2132' , '2133' , '2134' , '2135' , '2136' , '2137' , '2138' , '2139' , & '2140' , '2141' , '2142' , '2143' , '2144' , '2145' , '2146' , '2147' , '2148' , '2149' , & '2150' , '2151' , '2152' , '2153' , '2154' , '2155' , '2156' , '2157' , '2158' , '2159' , & '2160' , '2161' , '2162' , '2163' , '2164' , '2165' , '2166' , '2167' , '2168' , '2169' , & '2170' , '2171' , '2172' , '2173' , '2174' , '2175' , '2176' , '2177' , '2178' , '2179' , & '2180' , '2181' , '2182' , '2183' , '2184' , '2185' , '2186' , '2187' , '2188' , '2189' , & '2190' , '2191' , '2192' , '2193' , '2194' , '2195' , '2196' , '2197' , '2198' , '2199' , & '2200' , '2201' , '2202' , '2203' , '2204' , '2205' , '2206' , '2207' , '2208' , '2209' , & '2210' , '2211' , '2212' , '2213' , '2214' , '2215' , '2216' , '2217' , '2218' , '2219' , & '2220' , '2221' , '2222' , '2223' , '2224' , '2225' , '2226' , '2227' , '2228' , '2229' , & '2230' , '2231' , '2232' , '2233' , '2234' , '2235' , '2236' , '2237' , '2238' , '2239' , & '2240' , '2241' , '2242' , '2243' , '2244' , '2245' , '2246' , '2247' , '2248' , '2249' , & '2250' , '2251' , '2252' , '2253' , '2254' , '2255' , '2256' , '2257' , '2258' , '2259' , & '2260' , '2261' , '2262' , '2263' , '2264' , '2265' , '2266' , '2267' , '2268' , '2269' , & '2270' , '2271' , '2272' , '2273' , '2274' , '2275' , '2276' , '2277' , '2278' , '2279' , & '2280' , '2281' , '2282' , '2283' , '2284' , '2285' , '2286' , '2287' , '2288' , '2289' , & '2290' , '2291' , '2292' , '2293' , '2294' , '2295' , '2296' , '2297' , '2298' , '2299' , & '2300' , '2301' , '2302' , '2303' , '2304' , '2305' , '2306' , '2307' , '2308' , '2309' , & '2310' , '2311' , '2312' , '2313' , '2314' , '2315' , '2316' , '2317' , '2318' , '2319' , & '2320' , '2321' , '2322' , '2323' , '2324' , '2325' , '2326' , '2327' , '2328' , '2329' , & '2330' , '2331' , '2332' , '2333' , '2334' , '2335' , '2336' , '2337' , '2338' , '2339' , & '2340' , '2341' , '2342' , '2343' , '2344' , '2345' , '2346' , '2347' , '2348' , '2349' , & '2350' , '2351' , '2352' , '2353' , '2354' , '2355' , '2356' , '2357' , '2358' , '2359' , & '2360' , '2361' , '2362' , '2363' , '2364' , '2365' , '2366' , '2367' , '2368' , '2369' , & '2370' , '2371' , '2372' , '2373' , '2374' , '2375' , '2376' , '2377' , '2378' , '2379' , & '2380' , '2381' , '2382' , '2383' , '2384' , '2385' , '2386' , '2387' , '2388' , '2389' , & '2390' , '2391' , '2392' , '2393' , '2394' , '2395' , '2396' , '2397' , '2398' , '2399' , & '2400' , '2401' , '2402' , '2403' , '2404' , '2405' , '2406' , '2407' , '2408' , '2409' , & '2410' , '2411' , '2412' , '2413' , '2414' , '2415' , '2416' , '2417' , '2418' , '2419' , & '2420' , '2421' , '2422' , '2423' , '2424' , '2425' , '2426' , '2427' , '2428' , '2429' , & '2430' , '2431' , '2432' , '2433' , '2434' , '2435' , '2436' , '2437' , '2438' , '2439' , & '2440' , '2441' , '2442' , '2443' , '2444' , '2445' , '2446' , '2447' , '2448' , '2449' , & '2450' , '2451' , '2452' , '2453' , '2454' , '2455' , '2456' , '2457' , '2458' , '2459' , & '2460' , '2461' , '2462' , '2463' , '2464' , '2465' , '2466' , '2467' , '2468' , '2469' , & '2470' , '2471' , '2472' , '2473' , '2474' , '2475' , '2476' , '2477' , '2478' , '2479' , & '2480' , '2481' , '2482' , '2483' , '2484' , '2485' , '2486' , '2487' , '2488' , '2489' , & '2490' , '2491' , '2492' , '2493' , '2494' , '2495' , '2496' , '2497' , '2498' , '2499' , & '2500' , '2501' , '2502' , '2503' , '2504' , '2505' , '2506' , '2507' , '2508' , '2509' , & '2510' , '2511' , '2512' , '2513' , '2514' , '2515' , '2516' , '2517' , '2518' , '2519' , & '2520' , '2521' , '2522' , '2523' , '2524' , '2525' , '2526' , '2527' , '2528' , '2529' , & '2530' , '2531' , '2532' , '2533' , '2534' , '2535' , '2536' , '2537' , '2538' , '2539' , & '2540' , '2541' , '2542' , '2543' , '2544' , '2545' , '2546' , '2547' , '2548' , '2549' , & '2550' , '2551' , '2552' , '2553' , '2554' , '2555' , '2556' , '2557' , '2558' , '2559' , & '2560' , '2561' , '2562' , '2563' , '2564' , '2565' , '2566' , '2567' , '2568' , '2569' , & '2570' , '2571' , '2572' , '2573' , '2574' , '2575' , '2576' , '2577' , '2578' , '2579' , & '2580' , '2581' , '2582' , '2583' , '2584' , '2585' , '2586' , '2587' , '2588' , '2589' , & '2590' , '2591' , '2592' , '2593' , '2594' , '2595' , '2596' , '2597' , '2598' , '2599' , & '2600' , '2601' , '2602' , '2603' , '2604' , '2605' , '2606' , '2607' , '2608' , '2609' , & '2610' , '2611' , '2612' , '2613' , '2614' , '2615' , '2616' , '2617' , '2618' , '2619' , & '2620' , '2621' , '2622' , '2623' , '2624' , '2625' , '2626' , '2627' , '2628' , '2629' , & '2630' , '2631' , '2632' , '2633' , '2634' , '2635' , '2636' , '2637' , '2638' , '2639' , & '2640' , '2641' , '2642' , '2643' , '2644' , '2645' , '2646' , '2647' , '2648' , '2649' , & '2650' , '2651' , '2652' , '2653' , '2654' , '2655' , '2656' , '2657' , '2658' , '2659' , & '2660' , '2661' , '2662' , '2663' , '2664' , '2665' , '2666' , '2667' , '2668' , '2669' , & '2670' , '2671' , '2672' , '2673' , '2674' , '2675' , '2676' , '2677' , '2678' , '2679' , & '2680' , '2681' , '2682' , '2683' , '2684' , '2685' , '2686' , '2687' , '2688' , '2689' , & '2690' , '2691' , '2692' , '2693' , '2694' , '2695' , '2696' , '2697' , '2698' , '2699' , & '2700' , '2701' , '2702' , '2703' , '2704' , '2705' , '2706' , '2707' , '2708' , '2709' , & '2710' , '2711' , '2712' , '2713' , '2714' , '2715' , '2716' , '2717' , '2718' , '2719' , & '2720' , '2721' , '2722' , '2723' , '2724' , '2725' , '2726' , '2727' , '2728' , '2729' , & '2730' , '2731' , '2732' , '2733' , '2734' , '2735' , '2736' , '2737' , '2738' , '2739' , & '2740' , '2741' , '2742' , '2743' , '2744' , '2745' , '2746' , '2747' , '2748' , '2749' , & '2750' , '2751' , '2752' , '2753' , '2754' , '2755' , '2756' , '2757' , '2758' , '2759' , & '2760' , '2761' , '2762' , '2763' , '2764' , '2765' , '2766' , '2767' , '2768' , '2769' , & '2770' , '2771' , '2772' , '2773' , '2774' , '2775' , '2776' , '2777' , '2778' , '2779' , & '2780' , '2781' , '2782' , '2783' , '2784' , '2785' , '2786' , '2787' , '2788' , '2789' , & '2790' , '2791' , '2792' , '2793' , '2794' , '2795' , '2796' , '2797' , '2798' , '2799' , & '2800' , '2801' , '2802' , '2803' , '2804' , '2805' , '2806' , '2807' , '2808' , '2809' , & '2810' , '2811' , '2812' , '2813' , '2814' , '2815' , '2816' , '2817' , '2818' , '2819' , & '2820' , '2821' , '2822' , '2823' , '2824' , '2825' , '2826' , '2827' , '2828' , '2829' , & '2830' , '2831' , '2832' , '2833' , '2834' , '2835' , '2836' , '2837' , '2838' , '2839' , & '2840' , '2841' , '2842' , '2843' , '2844' , '2845' , '2846' , '2847' , '2848' , '2849' , & '2850' , '2851' , '2852' , '2853' , '2854' , '2855' , '2856' , '2857' , '2858' , '2859' , & '2860' , '2861' , '2862' , '2863' , '2864' , '2865' , '2866' , '2867' , '2868' , '2869' , & '2870' , '2871' , '2872' , '2873' , '2874' , '2875' , '2876' , '2877' , '2878' , '2879' , & '2880' , '2881' , '2882' , '2883' , '2884' , '2885' , '2886' , '2887' , '2888' , '2889' , & '2890' , '2891' , '2892' , '2893' , '2894' , '2895' , '2896' , '2897' , '2898' , '2899' , & '2900' , '2901' , '2902' , '2903' , '2904' , '2905' , '2906' , '2907' , '2908' , '2909' , & '2910' , '2911' , '2912' , '2913' , '2914' , '2915' , '2916' , '2917' , '2918' , '2919' , & '2920' , '2921' , '2922' , '2923' , '2924' , '2925' , '2926' , '2927' , '2928' , '2929' , & '2930' , '2931' , '2932' , '2933' , '2934' , '2935' , '2936' , '2937' , '2938' , '2939' , & '2940' , '2941' , '2942' , '2943' , '2944' , '2945' , '2946' , '2947' , '2948' , '2949' , & '2950' , '2951' , '2952' , '2953' , '2954' , '2955' , '2956' , '2957' , '2958' , '2959' , & '2960' , '2961' , '2962' , '2963' , '2964' , '2965' , '2966' , '2967' , '2968' , '2969' , & '2970' , '2971' , '2972' , '2973' , '2974' , '2975' , '2976' , '2977' , '2978' , '2979' , & '2980' , '2981' , '2982' , '2983' , '2984' , '2985' , '2986' , '2987' , '2988' , '2989' , & '2990' , '2991' , '2992' , '2993' , '2994' , '2995' , '2996' , '2997' , '2998' , '2999' , & '3000' , '3001' , '3002' , '3003' , '3004' , '3005' , '3006' , '3007' , '3008' , '3009' , & '3010' , '3011' , '3012' , '3013' , '3014' , '3015' , '3016' , '3017' , '3018' , '3019' , & '3020' , '3021' , '3022' , '3023' , '3024' , '3025' , '3026' , '3027' , '3028' , '3029' , & '3030' , '3031' , '3032' , '3033' , '3034' , '3035' , '3036' , '3037' , '3038' , '3039' , & '3040' , '3041' , '3042' , '3043' , '3044' , '3045' , '3046' , '3047' , '3048' , '3049' , & '3050' , '3051' , '3052' , '3053' , '3054' , '3055' , '3056' , '3057' , '3058' , '3059' , & '3060' , '3061' , '3062' , '3063' , '3064' , '3065' , '3066' , '3067' , '3068' , '3069' , & '3070' , '3071' , '3072' , '3073' , '3074' , '3075' , '3076' , '3077' , '3078' , '3079' , & '3080' , '3081' , '3082' , '3083' , '3084' , '3085' , '3086' , '3087' , '3088' , '3089' , & '3090' , '3091' , '3092' , '3093' , '3094' , '3095' , '3096' , '3097' , '3098' , '3099' , & '3100' , '3101' , '3102' , '3103' , '3104' , '3105' , '3106' , '3107' , '3108' , '3109' , & '3110' , '3111' , '3112' , '3113' , '3114' , '3115' , '3116' , '3117' , '3118' , '3119' , & '3120' , '3121' , '3122' , '3123' , '3124' , '3125' , '3126' , '3127' , '3128' , '3129' , & '3130' , '3131' , '3132' , '3133' , '3134' , '3135' , '3136' , '3137' , '3138' , '3139' , & '3140' , '3141' , '3142' , '3143' , '3144' , '3145' , '3146' , '3147' , '3148' , '3149' , & '3150' , '3151' , '3152' , '3153' , '3154' , '3155' , '3156' , '3157' , '3158' , '3159' , & '3160' , '3161' , '3162' , '3163' , '3164' , '3165' , '3166' , '3167' , '3168' , '3169' , & '3170' , '3171' , '3172' , '3173' , '3174' , '3175' , '3176' , '3177' , '3178' , '3179' , & '3180' , '3181' , '3182' , '3183' , '3184' , '3185' , '3186' , '3187' , '3188' , '3189' , & '3190' , '3191' , '3192' , '3193' , '3194' , '3195' , '3196' , '3197' , '3198' , '3199' , & '3200' , '3201' , '3202' , '3203' , '3204' , '3205' , '3206' , '3207' , '3208' , '3209' , & '3210' , '3211' , '3212' , '3213' , '3214' , '3215' , '3216' , '3217' , '3218' , '3219' , & '3220' , '3221' , '3222' , '3223' , '3224' , '3225' , '3226' , '3227' , '3228' , '3229' , & '3230' , '3231' , '3232' , '3233' , '3234' , '3235' , '3236' , '3237' , '3238' , '3239' , & '3240' , '3241' , '3242' , '3243' , '3244' , '3245' , '3246' , '3247' , '3248' , '3249' , & '3250' , '3251' , '3252' , '3253' , '3254' , '3255' , '3256' , '3257' , '3258' , '3259' , & '3260' , '3261' , '3262' , '3263' , '3264' , '3265' , '3266' , '3267' , '3268' , '3269' , & '3270' , '3271' , '3272' , '3273' , '3274' , '3275' , '3276' , '3277' , '3278' , '3279' , & '3280' , '3281' , '3282' , '3283' , '3284' , '3285' , '3286' , '3287' , '3288' , '3289' , & '3290' , '3291' , '3292' , '3293' , '3294' , '3295' , '3296' , '3297' , '3298' , '3299' , & '3300' , '3301' , '3302' , '3303' , '3304' , '3305' , '3306' , '3307' , '3308' , '3309' , & '3310' , '3311' , '3312' , '3313' , '3314' , '3315' , '3316' , '3317' , '3318' , '3319' , & '3320' , '3321' , '3322' , '3323' , '3324' , '3325' , '3326' , '3327' , '3328' , '3329' , & '3330' , '3331' , '3332' , '3333' , '3334' , '3335' , '3336' , '3337' , '3338' , '3339' , & '3340' , '3341' , '3342' , '3343' , '3344' , '3345' , '3346' , '3347' , '3348' , '3349' , & '3350' , '3351' , '3352' , '3353' , '3354' , '3355' , '3356' , '3357' , '3358' , '3359' , & '3360' , '3361' , '3362' , '3363' , '3364' , '3365' , '3366' , '3367' , '3368' , '3369' , & '3370' , '3371' , '3372' , '3373' , '3374' , '3375' , '3376' , '3377' , '3378' , '3379' , & '3380' , '3381' , '3382' , '3383' , '3384' , '3385' , '3386' , '3387' , '3388' , '3389' , & '3390' , '3391' , '3392' , '3393' , '3394' , '3395' , '3396' , '3397' , '3398' , '3399' , & '3400' , '3401' , '3402' , '3403' , '3404' , '3405' , '3406' , '3407' , '3408' , '3409' , & '3410' , '3411' , '3412' , '3413' , '3414' , '3415' , '3416' , '3417' , '3418' , '3419' , & '3420' , '3421' , '3422' , '3423' , '3424' , '3425' , '3426' , '3427' , '3428' , '3429' , & '3430' , '3431' , '3432' , '3433' , '3434' , '3435' , '3436' , '3437' , '3438' , '3439' , & '3440' , '3441' , '3442' , '3443' , '3444' , '3445' , '3446' , '3447' , '3448' , '3449' , & '3450' , '3451' , '3452' , '3453' , '3454' , '3455' , '3456' , '3457' , '3458' , '3459' , & '3460' , '3461' , '3462' , '3463' , '3464' , '3465' , '3466' , '3467' , '3468' , '3469' , & '3470' , '3471' , '3472' , '3473' , '3474' , '3475' , '3476' , '3477' , '3478' , '3479' , & '3480' , '3481' , '3482' , '3483' , '3484' , '3485' , '3486' , '3487' , '3488' , '3489' , & '3490' , '3491' , '3492' , '3493' , '3494' , '3495' , '3496' , '3497' , '3498' , '3499' , & '3500' , '3501' , '3502' , '3503' , '3504' , '3505' , '3506' , '3507' , '3508' , '3509' , & '3510' , '3511' , '3512' , '3513' , '3514' , '3515' , '3516' , '3517' , '3518' , '3519' , & '3520' , '3521' , '3522' , '3523' , '3524' , '3525' , '3526' , '3527' , '3528' , '3529' , & '3530' , '3531' , '3532' , '3533' , '3534' , '3535' , '3536' , '3537' , '3538' , '3539' , & '3540' , '3541' , '3542' , '3543' , '3544' , '3545' , '3546' , '3547' , '3548' , '3549' , & '3550' , '3551' , '3552' , '3553' , '3554' , '3555' , '3556' , '3557' , '3558' , '3559' , & '3560' , '3561' , '3562' , '3563' , '3564' , '3565' , '3566' , '3567' , '3568' , '3569' , & '3570' , '3571' , '3572' , '3573' , '3574' , '3575' , '3576' , '3577' , '3578' , '3579' , & '3580' , '3581' , '3582' , '3583' , '3584' , '3585' , '3586' , '3587' , '3588' , '3589' , & '3590' , '3591' , '3592' , '3593' , '3594' , '3595' , '3596' , '3597' , '3598' , '3599' , & '3600' , '3601' , '3602' , '3603' , '3604' , '3605' , '3606' , '3607' , '3608' , '3609' , & '3610' , '3611' , '3612' , '3613' , '3614' , '3615' , '3616' , '3617' , '3618' , '3619' , & '3620' , '3621' , '3622' , '3623' , '3624' , '3625' , '3626' , '3627' , '3628' , '3629' , & '3630' , '3631' , '3632' , '3633' , '3634' , '3635' , '3636' , '3637' , '3638' , '3639' , & '3640' , '3641' , '3642' , '3643' , '3644' , '3645' , '3646' , '3647' , '3648' , '3649' , & '3650' , '3651' , '3652' , '3653' , '3654' , '3655' , '3656' , '3657' , '3658' , '3659' , & '3660' , '3661' , '3662' , '3663' , '3664' , '3665' , '3666' , '3667' , '3668' , '3669' , & '3670' , '3671' , '3672' , '3673' , '3674' , '3675' , '3676' , '3677' , '3678' , '3679' , & '3680' , '3681' , '3682' , '3683' , '3684' , '3685' , '3686' , '3687' , '3688' , '3689' , & '3690' , '3691' , '3692' , '3693' , '3694' , '3695' , '3696' , '3697' , '3698' , '3699' , & '3700' , '3701' , '3702' , '3703' , '3704' , '3705' , '3706' , '3707' , '3708' , '3709' , & '3710' , '3711' , '3712' , '3713' , '3714' , '3715' , '3716' , '3717' , '3718' , '3719' , & '3720' , '3721' , '3722' , '3723' , '3724' , '3725' , '3726' , '3727' , '3728' , '3729' , & '3730' , '3731' , '3732' , '3733' , '3734' , '3735' , '3736' , '3737' , '3738' , '3739' , & '3740' , '3741' , '3742' , '3743' , '3744' , '3745' , '3746' , '3747' , '3748' , '3749' , & '3750' , '3751' , '3752' , '3753' , '3754' , '3755' , '3756' , '3757' , '3758' , '3759' , & '3760' , '3761' , '3762' , '3763' , '3764' , '3765' , '3766' , '3767' , '3768' , '3769' , & '3770' , '3771' , '3772' , '3773' , '3774' , '3775' , '3776' , '3777' , '3778' , '3779' , & '3780' , '3781' , '3782' , '3783' , '3784' , '3785' , '3786' , '3787' , '3788' , '3789' , & '3790' , '3791' , '3792' , '3793' , '3794' , '3795' , '3796' , '3797' , '3798' , '3799' , & '3800' , '3801' , '3802' , '3803' , '3804' , '3805' , '3806' , '3807' , '3808' , '3809' , & '3810' , '3811' , '3812' , '3813' , '3814' , '3815' , '3816' , '3817' , '3818' , '3819' , & '3820' , '3821' , '3822' , '3823' , '3824' , '3825' , '3826' , '3827' , '3828' , '3829' , & '3830' , '3831' , '3832' , '3833' , '3834' , '3835' , '3836' , '3837' , '3838' , '3839' , & '3840' , '3841' , '3842' , '3843' , '3844' , '3845' , '3846' , '3847' , '3848' , '3849' , & '3850' , '3851' , '3852' , '3853' , '3854' , '3855' , '3856' , '3857' , '3858' , '3859' , & '3860' , '3861' , '3862' , '3863' , '3864' , '3865' , '3866' , '3867' , '3868' , '3869' , & '3870' , '3871' , '3872' , '3873' , '3874' , '3875' , '3876' , '3877' , '3878' , '3879' , & '3880' , '3881' , '3882' , '3883' , '3884' , '3885' , '3886' , '3887' , '3888' , '3889' , & '3890' , '3891' , '3892' , '3893' , '3894' , '3895' , '3896' , '3897' , '3898' , '3899' , & '3900' , '3901' , '3902' , '3903' , '3904' , '3905' , '3906' , '3907' , '3908' , '3909' , & '3910' , '3911' , '3912' , '3913' , '3914' , '3915' , '3916' , '3917' , '3918' , '3919' , & '3920' , '3921' , '3922' , '3923' , '3924' , '3925' , '3926' , '3927' , '3928' , '3929' , & '3930' , '3931' , '3932' , '3933' , '3934' , '3935' , '3936' , '3937' , '3938' , '3939' , & '3940' , '3941' , '3942' , '3943' , '3944' , '3945' , '3946' , '3947' , '3948' , '3949' , & '3950' , '3951' , '3952' , '3953' , '3954' , '3955' , '3956' , '3957' , '3958' , '3959' , & '3960' , '3961' , '3962' , '3963' , '3964' , '3965' , '3966' , '3967' , '3968' , '3969' , & '3970' , '3971' , '3972' , '3973' , '3974' , '3975' , '3976' , '3977' , '3978' , '3979' , & '3980' , '3981' , '3982' , '3983' , '3984' , '3985' , '3986' , '3987' , '3988' , '3989' , & '3990' , '3991' , '3992' , '3993' , '3994' , '3995' , '3996' , '3997' , '3998' , '3999' , & '4000' , '4001' , '4002' , '4003' , '4004' , '4005' , '4006' , '4007' , '4008' , '4009' , & '4010' , '4011' , '4012' , '4013' , '4014' , '4015' , '4016' , '4017' , '4018' , '4019' , & '4020' , '4021' , '4022' , '4023' , '4024' , '4025' , '4026' , '4027' , '4028' , '4029' , & '4030' , '4031' , '4032' , '4033' , '4034' , '4035' , '4036' , '4037' , '4038' , '4039' , & '4040' , '4041' , '4042' , '4043' , '4044' , '4045' , '4046' , '4047' , '4048' , '4049' , & '4050' , '4051' , '4052' , '4053' , '4054' , '4055' , '4056' , '4057' , '4058' , '4059' , & '4060' , '4061' , '4062' , '4063' , '4064' , '4065' , '4066' , '4067' , '4068' , '4069' , & '4070' , '4071' , '4072' , '4073' , '4074' , '4075' , '4076' , '4077' , '4078' , '4079' , & '4080' , '4081' , '4082' , '4083' , '4084' , '4085' , '4086' , '4087' , '4088' , '4089' , & '4090' , '4091' , '4092' , '4093' , '4094' , '4095' , '4096' , '4097' , '4098' , '4099' , & '4100' , '4101' , '4102' , '4103' , '4104' , '4105' , '4106' , '4107' , '4108' , '4109' , & '4110' , '4111' , '4112' , '4113' , '4114' , '4115' , '4116' , '4117' , '4118' , '4119' , & '4120' , '4121' , '4122' , '4123' , '4124' , '4125' , '4126' , '4127' , '4128' , '4129' , & '4130' , '4131' , '4132' , '4133' , '4134' , '4135' , '4136' , '4137' , '4138' , '4139' , & '4140' , '4141' , '4142' , '4143' , '4144' , '4145' , '4146' , '4147' , '4148' , '4149' , & '4150' , '4151' , '4152' , '4153' , '4154' , '4155' , '4156' , '4157' , '4158' , '4159' , & '4160' , '4161' , '4162' , '4163' , '4164' , '4165' , '4166' , '4167' , '4168' , '4169' , & '4170' , '4171' , '4172' , '4173' , '4174' , '4175' , '4176' , '4177' , '4178' , '4179' , & '4180' , '4181' , '4182' , '4183' , '4184' , '4185' , '4186' , '4187' , '4188' , '4189' , & '4190' , '4191' , '4192' , '4193' , '4194' , '4195' , '4196' , '4197' , '4198' , '4199' , & '4200' , '4201' , '4202' , '4203' , '4204' , '4205' , '4206' , '4207' , '4208' , '4209' , & '4210' , '4211' , '4212' , '4213' , '4214' , '4215' , '4216' , '4217' , '4218' , '4219' , & '4220' , '4221' , '4222' , '4223' , '4224' , '4225' , '4226' , '4227' , '4228' , '4229' , & '4230' , '4231' , '4232' , '4233' , '4234' , '4235' , '4236' , '4237' , '4238' , '4239' , & '4240' , '4241' , '4242' , '4243' , '4244' , '4245' , '4246' , '4247' , '4248' , '4249' , & '4250' , '4251' , '4252' , '4253' , '4254' , '4255' , '4256' , '4257' , '4258' , '4259' , & '4260' , '4261' , '4262' , '4263' , '4264' , '4265' , '4266' , '4267' , '4268' , '4269' , & '4270' , '4271' , '4272' , '4273' , '4274' , '4275' , '4276' , '4277' , '4278' , '4279' , & '4280' , '4281' , '4282' , '4283' , '4284' , '4285' , '4286' , '4287' , '4288' , '4289' , & '4290' , '4291' , '4292' , '4293' , '4294' , '4295' , '4296' , '4297' , '4298' , '4299' , & '4300' , '4301' , '4302' , '4303' , '4304' , '4305' , '4306' , '4307' , '4308' , '4309' , & '4310' , '4311' , '4312' , '4313' , '4314' , '4315' , '4316' , '4317' , '4318' , '4319' , & '4320' , '4321' , '4322' , '4323' , '4324' , '4325' , '4326' , '4327' , '4328' , '4329' , & '4330' , '4331' , '4332' , '4333' , '4334' , '4335' , '4336' , '4337' , '4338' , '4339' , & '4340' , '4341' , '4342' , '4343' , '4344' , '4345' , '4346' , '4347' , '4348' , '4349' , & '4350' , '4351' , '4352' , '4353' , '4354' , '4355' , '4356' , '4357' , '4358' , '4359' , & '4360' , '4361' , '4362' , '4363' , '4364' , '4365' , '4366' , '4367' , '4368' , '4369' , & '4370' , '4371' , '4372' , '4373' , '4374' , '4375' , '4376' , '4377' , '4378' , '4379' , & '4380' , '4381' , '4382' , '4383' , '4384' , '4385' , '4386' , '4387' , '4388' , '4389' , & '4390' , '4391' , '4392' , '4393' , '4394' , '4395' , '4396' , '4397' , '4398' , '4399' , & '4400' , '4401' , '4402' , '4403' , '4404' , '4405' , '4406' , '4407' , '4408' , '4409' , & '4410' , '4411' , '4412' , '4413' , '4414' , '4415' , '4416' , '4417' , '4418' , '4419' , & '4420' , '4421' , '4422' , '4423' , '4424' , '4425' , '4426' , '4427' , '4428' , '4429' , & '4430' , '4431' , '4432' , '4433' , '4434' , '4435' , '4436' , '4437' , '4438' , '4439' , & '4440' , '4441' , '4442' , '4443' , '4444' , '4445' , '4446' , '4447' , '4448' , '4449' , & '4450' , '4451' , '4452' , '4453' , '4454' , '4455' , '4456' , '4457' , '4458' , '4459' , & '4460' , '4461' , '4462' , '4463' , '4464' , '4465' , '4466' , '4467' , '4468' , '4469' , & '4470' , '4471' , '4472' , '4473' , '4474' , '4475' , '4476' , '4477' , '4478' , '4479' , & '4480' , '4481' , '4482' , '4483' , '4484' , '4485' , '4486' , '4487' , '4488' , '4489' , & '4490' , '4491' , '4492' , '4493' , '4494' , '4495' , '4496' , '4497' , '4498' , '4499' , & '4500' , '4501' , '4502' , '4503' , '4504' , '4505' , '4506' , '4507' , '4508' , '4509' , & '4510' , '4511' , '4512' , '4513' , '4514' , '4515' , '4516' , '4517' , '4518' , '4519' , & '4520' , '4521' , '4522' , '4523' , '4524' , '4525' , '4526' , '4527' , '4528' , '4529' , & '4530' , '4531' , '4532' , '4533' , '4534' , '4535' , '4536' , '4537' , '4538' , '4539' , & '4540' , '4541' , '4542' , '4543' , '4544' , '4545' , '4546' , '4547' , '4548' , '4549' , & '4550' , '4551' , '4552' , '4553' , '4554' , '4555' , '4556' , '4557' , '4558' , '4559' , & '4560' , '4561' , '4562' , '4563' , '4564' , '4565' , '4566' , '4567' , '4568' , '4569' , & '4570' , '4571' , '4572' , '4573' , '4574' , '4575' , '4576' , '4577' , '4578' , '4579' , & '4580' , '4581' , '4582' , '4583' , '4584' , '4585' , '4586' , '4587' , '4588' , '4589' , & '4590' , '4591' , '4592' , '4593' , '4594' , '4595' , '4596' , '4597' , '4598' , '4599' , & '4600' , '4601' , '4602' , '4603' , '4604' , '4605' , '4606' , '4607' , '4608' , '4609' , & '4610' , '4611' , '4612' , '4613' , '4614' , '4615' , '4616' , '4617' , '4618' , '4619' , & '4620' , '4621' , '4622' , '4623' , '4624' , '4625' , '4626' , '4627' , '4628' , '4629' , & '4630' , '4631' , '4632' , '4633' , '4634' , '4635' , '4636' , '4637' , '4638' , '4639' , & '4640' , '4641' , '4642' , '4643' , '4644' , '4645' , '4646' , '4647' , '4648' , '4649' , & '4650' , '4651' , '4652' , '4653' , '4654' , '4655' , '4656' , '4657' , '4658' , '4659' , & '4660' , '4661' , '4662' , '4663' , '4664' , '4665' , '4666' , '4667' , '4668' , '4669' , & '4670' , '4671' , '4672' , '4673' , '4674' , '4675' , '4676' , '4677' , '4678' , '4679' , & '4680' , '4681' , '4682' , '4683' , '4684' , '4685' , '4686' , '4687' , '4688' , '4689' , & '4690' , '4691' , '4692' , '4693' , '4694' , '4695' , '4696' , '4697' , '4698' , '4699' , & '4700' , '4701' , '4702' , '4703' , '4704' , '4705' , '4706' , '4707' , '4708' , '4709' , & '4710' , '4711' , '4712' , '4713' , '4714' , '4715' , '4716' , '4717' , '4718' , '4719' , & '4720' , '4721' , '4722' , '4723' , '4724' , '4725' , '4726' , '4727' , '4728' , '4729' , & '4730' , '4731' , '4732' , '4733' , '4734' , '4735' , '4736' , '4737' , '4738' , '4739' , & '4740' , '4741' , '4742' , '4743' , '4744' , '4745' , '4746' , '4747' , '4748' , '4749' , & '4750' , '4751' , '4752' , '4753' , '4754' , '4755' , '4756' , '4757' , '4758' , '4759' , & '4760' , '4761' , '4762' , '4763' , '4764' , '4765' , '4766' , '4767' , '4768' , '4769' , & '4770' , '4771' , '4772' , '4773' , '4774' , '4775' , '4776' , '4777' , '4778' , '4779' , & '4780' , '4781' , '4782' , '4783' , '4784' , '4785' , '4786' , '4787' , '4788' , '4789' , & '4790' , '4791' , '4792' , '4793' , '4794' , '4795' , '4796' , '4797' , '4798' , '4799' , & '4800' , '4801' , '4802' , '4803' , '4804' , '4805' , '4806' , '4807' , '4808' , '4809' , & '4810' , '4811' , '4812' , '4813' , '4814' , '4815' , '4816' , '4817' , '4818' , '4819' , & '4820' , '4821' , '4822' , '4823' , '4824' , '4825' , '4826' , '4827' , '4828' , '4829' , & '4830' , '4831' , '4832' , '4833' , '4834' , '4835' , '4836' , '4837' , '4838' , '4839' , & '4840' , '4841' , '4842' , '4843' , '4844' , '4845' , '4846' , '4847' , '4848' , '4849' , & '4850' , '4851' , '4852' , '4853' , '4854' , '4855' , '4856' , '4857' , '4858' , '4859' , & '4860' , '4861' , '4862' , '4863' , '4864' , '4865' , '4866' , '4867' , '4868' , '4869' , & '4870' , '4871' , '4872' , '4873' , '4874' , '4875' , '4876' , '4877' , '4878' , '4879' , & '4880' , '4881' , '4882' , '4883' , '4884' , '4885' , '4886' , '4887' , '4888' , '4889' , & '4890' , '4891' , '4892' , '4893' , '4894' , '4895' , '4896' , '4897' , '4898' , '4899' , & '4900' , '4901' , '4902' , '4903' , '4904' , '4905' , '4906' , '4907' , '4908' , '4909' , & '4910' , '4911' , '4912' , '4913' , '4914' , '4915' , '4916' , '4917' , '4918' , '4919' , & '4920' , '4921' , '4922' , '4923' , '4924' , '4925' , '4926' , '4927' , '4928' , '4929' , & '4930' , '4931' , '4932' , '4933' , '4934' , '4935' , '4936' , '4937' , '4938' , '4939' , & '4940' , '4941' , '4942' , '4943' , '4944' , '4945' , '4946' , '4947' , '4948' , '4949' , & '4950' , '4951' , '4952' , '4953' , '4954' , '4955' , '4956' , '4957' , '4958' , '4959' , & '4960' , '4961' , '4962' , '4963' , '4964' , '4965' , '4966' , '4967' , '4968' , '4969' , & '4970' , '4971' , '4972' , '4973' , '4974' , '4975' , '4976' , '4977' , '4978' , '4979' , & '4980' , '4981' , '4982' , '4983' , '4984' , '4985' , '4986' , '4987' , '4988' , '4989' , & '4990' , '4991' , '4992' , '4993' , '4994' , '4995' , '4996' , '4997' , '4998' , '4999' , & '5000' , '5001' , '5002' , '5003' , '5004' , '5005' , '5006' , '5007' , '5008' , '5009' , & '5010' , '5011' , '5012' , '5013' , '5014' , '5015' , '5016' , '5017' , '5018' , '5019' , & '5020' , '5021' , '5022' , '5023' , '5024' , '5025' , '5026' , '5027' , '5028' , '5029' , & '5030' , '5031' , '5032' , '5033' , '5034' , '5035' , '5036' , '5037' , '5038' , '5039' , & '5040' , '5041' , '5042' , '5043' , '5044' , '5045' , '5046' , '5047' , '5048' , '5049' , & '5050' , '5051' , '5052' , '5053' , '5054' , '5055' , '5056' , '5057' , '5058' , '5059' , & '5060' , '5061' , '5062' , '5063' , '5064' , '5065' , '5066' , '5067' , '5068' , '5069' , & '5070' , '5071' , '5072' , '5073' , '5074' , '5075' , '5076' , '5077' , '5078' , '5079' , & '5080' , '5081' , '5082' , '5083' , '5084' , '5085' , '5086' , '5087' , '5088' , '5089' , & '5090' , '5091' , '5092' , '5093' , '5094' , '5095' , '5096' , '5097' , '5098' , '5099' , & '5100' , '5101' , '5102' , '5103' , '5104' , '5105' , '5106' , '5107' , '5108' , '5109' , & '5110' , '5111' , '5112' , '5113' , '5114' , '5115' , '5116' , '5117' , '5118' , '5119' , & '5120' , '5121' , '5122' , '5123' , '5124' , '5125' , '5126' , '5127' , '5128' , '5129' , & '5130' , '5131' , '5132' , '5133' , '5134' , '5135' , '5136' , '5137' , '5138' , '5139' , & '5140' , '5141' , '5142' , '5143' , '5144' , '5145' , '5146' , '5147' , '5148' , '5149' , & '5150' , '5151' , '5152' , '5153' , '5154' , '5155' , '5156' , '5157' , '5158' , '5159' , & '5160' , '5161' , '5162' , '5163' , '5164' , '5165' , '5166' , '5167' , '5168' , '5169' , & '5170' , '5171' , '5172' , '5173' , '5174' , '5175' , '5176' , '5177' , '5178' , '5179' , & '5180' , '5181' , '5182' , '5183' , '5184' , '5185' , '5186' , '5187' , '5188' , '5189' , & '5190' , '5191' , '5192' , '5193' , '5194' , '5195' , '5196' , '5197' , '5198' , '5199' , & '5200' , '5201' , '5202' , '5203' , '5204' , '5205' , '5206' , '5207' , '5208' , '5209' , & '5210' , '5211' , '5212' , '5213' , '5214' , '5215' , '5216' , '5217' , '5218' , '5219' , & '5220' , '5221' , '5222' , '5223' , '5224' , '5225' , '5226' , '5227' , '5228' , '5229' , & '5230' , '5231' , '5232' , '5233' , '5234' , '5235' , '5236' , '5237' , '5238' , '5239' , & '5240' , '5241' , '5242' , '5243' , '5244' , '5245' , '5246' , '5247' , '5248' , '5249' , & '5250' , '5251' , '5252' , '5253' , '5254' , '5255' , '5256' , '5257' , '5258' , '5259' , & '5260' , '5261' , '5262' , '5263' , '5264' , '5265' , '5266' , '5267' , '5268' , '5269' , & '5270' , '5271' , '5272' , '5273' , '5274' , '5275' , '5276' , '5277' , '5278' , '5279' , & '5280' , '5281' , '5282' , '5283' , '5284' , '5285' , '5286' , '5287' , '5288' , '5289' , & '5290' , '5291' , '5292' , '5293' , '5294' , '5295' , '5296' , '5297' , '5298' , '5299' , & '5300' , '5301' , '5302' , '5303' , '5304' , '5305' , '5306' , '5307' , '5308' , '5309' , & '5310' , '5311' , '5312' , '5313' , '5314' , '5315' , '5316' , '5317' , '5318' , '5319' , & '5320' , '5321' , '5322' , '5323' , '5324' , '5325' , '5326' , '5327' , '5328' , '5329' , & '5330' , '5331' , '5332' , '5333' , '5334' , '5335' , '5336' , '5337' , '5338' , '5339' , & '5340' , '5341' , '5342' , '5343' , '5344' , '5345' , '5346' , '5347' , '5348' , '5349' , & '5350' , '5351' , '5352' , '5353' , '5354' , '5355' , '5356' , '5357' , '5358' , '5359' , & '5360' , '5361' , '5362' , '5363' , '5364' , '5365' , '5366' , '5367' , '5368' , '5369' , & '5370' , '5371' , '5372' , '5373' , '5374' , '5375' , '5376' , '5377' , '5378' , '5379' , & '5380' , '5381' , '5382' , '5383' , '5384' , '5385' , '5386' , '5387' , '5388' , '5389' , & '5390' , '5391' , '5392' , '5393' , '5394' , '5395' , '5396' , '5397' , '5398' , '5399' , & '5400' , '5401' , '5402' , '5403' , '5404' , '5405' , '5406' , '5407' , '5408' , '5409' , & '5410' , '5411' , '5412' , '5413' , '5414' , '5415' , '5416' , '5417' , '5418' , '5419' , & '5420' , '5421' , '5422' , '5423' , '5424' , '5425' , '5426' , '5427' , '5428' , '5429' , & '5430' , '5431' , '5432' , '5433' , '5434' , '5435' , '5436' , '5437' , '5438' , '5439' , & '5440' , '5441' , '5442' , '5443' , '5444' , '5445' , '5446' , '5447' , '5448' , '5449' , & '5450' , '5451' , '5452' , '5453' , '5454' , '5455' , '5456' , '5457' , '5458' , '5459' , & '5460' , '5461' , '5462' , '5463' , '5464' , '5465' , '5466' , '5467' , '5468' , '5469' , & '5470' , '5471' , '5472' , '5473' , '5474' , '5475' , '5476' , '5477' , '5478' , '5479' , & '5480' , '5481' , '5482' , '5483' , '5484' , '5485' , '5486' , '5487' , '5488' , '5489' , & '5490' , '5491' , '5492' , '5493' , '5494' , '5495' , '5496' , '5497' , '5498' , '5499' , & '5500' , '5501' , '5502' , '5503' , '5504' , '5505' , '5506' , '5507' , '5508' , '5509' , & '5510' , '5511' , '5512' , '5513' , '5514' , '5515' , '5516' , '5517' , '5518' , '5519' , & '5520' , '5521' , '5522' , '5523' , '5524' , '5525' , '5526' , '5527' , '5528' , '5529' , & '5530' , '5531' , '5532' , '5533' , '5534' , '5535' , '5536' , '5537' , '5538' , '5539' , & '5540' , '5541' , '5542' , '5543' , '5544' , '5545' , '5546' , '5547' , '5548' , '5549' , & '5550' , '5551' , '5552' , '5553' , '5554' , '5555' , '5556' , '5557' , '5558' , '5559' , & '5560' , '5561' , '5562' , '5563' , '5564' , '5565' , '5566' , '5567' , '5568' , '5569' , & '5570' , '5571' , '5572' , '5573' , '5574' , '5575' , '5576' , '5577' , '5578' , '5579' , & '5580' , '5581' , '5582' , '5583' , '5584' , '5585' , '5586' , '5587' , '5588' , '5589' , & '5590' , '5591' , '5592' , '5593' , '5594' , '5595' , '5596' , '5597' , '5598' , '5599' , & '5600' , '5601' , '5602' , '5603' , '5604' , '5605' , '5606' , '5607' , '5608' , '5609' , & '5610' , '5611' , '5612' , '5613' , '5614' , '5615' , '5616' , '5617' , '5618' , '5619' , & '5620' , '5621' , '5622' , '5623' , '5624' , '5625' , '5626' , '5627' , '5628' , '5629' , & '5630' , '5631' , '5632' , '5633' , '5634' , '5635' , '5636' , '5637' , '5638' , '5639' , & '5640' , '5641' , '5642' , '5643' , '5644' , '5645' , '5646' , '5647' , '5648' , '5649' , & '5650' , '5651' , '5652' , '5653' , '5654' , '5655' , '5656' , '5657' , '5658' , '5659' , & '5660' , '5661' , '5662' , '5663' , '5664' , '5665' , '5666' , '5667' , '5668' , '5669' , & '5670' , '5671' , '5672' , '5673' , '5674' , '5675' , '5676' , '5677' , '5678' , '5679' , & '5680' , '5681' , '5682' , '5683' , '5684' , '5685' , '5686' , '5687' , '5688' , '5689' , & '5690' , '5691' , '5692' , '5693' , '5694' , '5695' , '5696' , '5697' , '5698' , '5699' , & '5700' , '5701' , '5702' , '5703' , '5704' , '5705' , '5706' , '5707' , '5708' , '5709' , & '5710' , '5711' , '5712' , '5713' , '5714' , '5715' , '5716' , '5717' , '5718' , '5719' , & '5720' , '5721' , '5722' , '5723' , '5724' , '5725' , '5726' , '5727' , '5728' , '5729' , & '5730' , '5731' , '5732' , '5733' , '5734' , '5735' , '5736' , '5737' , '5738' , '5739' , & '5740' , '5741' , '5742' , '5743' , '5744' , '5745' , '5746' , '5747' , '5748' , '5749' , & '5750' , '5751' , '5752' , '5753' , '5754' , '5755' , '5756' , '5757' , '5758' , '5759' , & '5760' , '5761' , '5762' , '5763' , '5764' , '5765' , '5766' , '5767' , '5768' , '5769' , & '5770' , '5771' , '5772' , '5773' , '5774' , '5775' , '5776' , '5777' , '5778' , '5779' , & '5780' , '5781' , '5782' , '5783' , '5784' , '5785' , '5786' , '5787' , '5788' , '5789' , & '5790' , '5791' , '5792' , '5793' , '5794' , '5795' , '5796' , '5797' , '5798' , '5799' , & '5800' , '5801' , '5802' , '5803' , '5804' , '5805' , '5806' , '5807' , '5808' , '5809' , & '5810' , '5811' , '5812' , '5813' , '5814' , '5815' , '5816' , '5817' , '5818' , '5819' , & '5820' , '5821' , '5822' , '5823' , '5824' , '5825' , '5826' , '5827' , '5828' , '5829' , & '5830' , '5831' , '5832' , '5833' , '5834' , '5835' , '5836' , '5837' , '5838' , '5839' , & '5840' , '5841' , '5842' , '5843' , '5844' , '5845' , '5846' , '5847' , '5848' , '5849' , & '5850' , '5851' , '5852' , '5853' , '5854' , '5855' , '5856' , '5857' , '5858' , '5859' , & '5860' , '5861' , '5862' , '5863' , '5864' , '5865' , '5866' , '5867' , '5868' , '5869' , & '5870' , '5871' , '5872' , '5873' , '5874' , '5875' , '5876' , '5877' , '5878' , '5879' , & '5880' , '5881' , '5882' , '5883' , '5884' , '5885' , '5886' , '5887' , '5888' , '5889' , & '5890' , '5891' , '5892' , '5893' , '5894' , '5895' , '5896' , '5897' , '5898' , '5899' , & '5900' , '5901' , '5902' , '5903' , '5904' , '5905' , '5906' , '5907' , '5908' , '5909' , & '5910' , '5911' , '5912' , '5913' , '5914' , '5915' , '5916' , '5917' , '5918' , '5919' , & '5920' , '5921' , '5922' , '5923' , '5924' , '5925' , '5926' , '5927' , '5928' , '5929' , & '5930' , '5931' , '5932' , '5933' , '5934' , '5935' , '5936' , '5937' , '5938' , '5939' , & '5940' , '5941' , '5942' , '5943' , '5944' , '5945' , '5946' , '5947' , '5948' , '5949' , & '5950' , '5951' , '5952' , '5953' , '5954' , '5955' , '5956' , '5957' , '5958' , '5959' , & '5960' , '5961' , '5962' , '5963' , '5964' , '5965' , '5966' , '5967' , '5968' , '5969' , & '5970' , '5971' , '5972' , '5973' , '5974' , '5975' , '5976' , '5977' , '5978' , '5979' , & '5980' , '5981' , '5982' , '5983' , '5984' , '5985' , '5986' , '5987' , '5988' , '5989' , & '5990' , '5991' , '5992' , '5993' , '5994' , '5995' , '5996' , '5997' , '5998' , '5999' , & '6000' , '6001' , '6002' , '6003' , '6004' , '6005' , '6006' , '6007' , '6008' , '6009' , & '6010' , '6011' , '6012' , '6013' , '6014' , '6015' , '6016' , '6017' , '6018' , '6019' , & '6020' , '6021' , '6022' , '6023' , '6024' , '6025' , '6026' , '6027' , '6028' , '6029' , & '6030' , '6031' , '6032' , '6033' , '6034' , '6035' , '6036' , '6037' , '6038' , '6039' , & '6040' , '6041' , '6042' , '6043' , '6044' , '6045' , '6046' , '6047' , '6048' , '6049' , & '6050' , '6051' , '6052' , '6053' , '6054' , '6055' , '6056' , '6057' , '6058' , '6059' , & '6060' , '6061' , '6062' , '6063' , '6064' , '6065' , '6066' , '6067' , '6068' , '6069' , & '6070' , '6071' , '6072' , '6073' , '6074' , '6075' , '6076' , '6077' , '6078' , '6079' , & '6080' , '6081' , '6082' , '6083' , '6084' , '6085' , '6086' , '6087' , '6088' , '6089' , & '6090' , '6091' , '6092' , '6093' , '6094' , '6095' , '6096' , '6097' , '6098' , '6099' , & '6100' , '6101' , '6102' , '6103' , '6104' , '6105' , '6106' , '6107' , '6108' , '6109' , & '6110' , '6111' , '6112' , '6113' , '6114' , '6115' , '6116' , '6117' , '6118' , '6119' , & '6120' , '6121' , '6122' , '6123' , '6124' , '6125' , '6126' , '6127' , '6128' , '6129' , & '6130' , '6131' , '6132' , '6133' , '6134' , '6135' , '6136' , '6137' , '6138' , '6139' , & '6140' , '6141' , '6142' , '6143' , '6144' , '6145' , '6146' , '6147' , '6148' , '6149' , & '6150' , '6151' , '6152' , '6153' , '6154' , '6155' , '6156' , '6157' , '6158' , '6159' , & '6160' , '6161' , '6162' , '6163' , '6164' , '6165' , '6166' , '6167' , '6168' , '6169' , & '6170' , '6171' , '6172' , '6173' , '6174' , '6175' , '6176' , '6177' , '6178' , '6179' , & '6180' , '6181' , '6182' , '6183' , '6184' , '6185' , '6186' , '6187' , '6188' , '6189' , & '6190' , '6191' , '6192' , '6193' , '6194' , '6195' , '6196' , '6197' , '6198' , '6199' , & '6200' , '6201' , '6202' , '6203' , '6204' , '6205' , '6206' , '6207' , '6208' , '6209' , & '6210' , '6211' , '6212' , '6213' , '6214' , '6215' , '6216' , '6217' , '6218' , '6219' , & '6220' , '6221' , '6222' , '6223' , '6224' , '6225' , '6226' , '6227' , '6228' , '6229' , & '6230' , '6231' , '6232' , '6233' , '6234' , '6235' , '6236' , '6237' , '6238' , '6239' , & '6240' , '6241' , '6242' , '6243' , '6244' , '6245' , '6246' , '6247' , '6248' , '6249' , & '6250' , '6251' , '6252' , '6253' , '6254' , '6255' , '6256' , '6257' , '6258' , '6259' , & '6260' , '6261' , '6262' , '6263' , '6264' , '6265' , '6266' , '6267' , '6268' , '6269' , & '6270' , '6271' , '6272' , '6273' , '6274' , '6275' , '6276' , '6277' , '6278' , '6279' , & '6280' , '6281' , '6282' , '6283' , '6284' , '6285' , '6286' , '6287' , '6288' , '6289' , & '6290' , '6291' , '6292' , '6293' , '6294' , '6295' , '6296' , '6297' , '6298' , '6299' , & '6300' , '6301' , '6302' , '6303' , '6304' , '6305' , '6306' , '6307' , '6308' , '6309' , & '6310' , '6311' , '6312' , '6313' , '6314' , '6315' , '6316' , '6317' , '6318' , '6319' , & '6320' , '6321' , '6322' , '6323' , '6324' , '6325' , '6326' , '6327' , '6328' , '6329' , & '6330' , '6331' , '6332' , '6333' , '6334' , '6335' , '6336' , '6337' , '6338' , '6339' , & '6340' , '6341' , '6342' , '6343' , '6344' , '6345' , '6346' , '6347' , '6348' , '6349' , & '6350' , '6351' , '6352' , '6353' , '6354' , '6355' , '6356' , '6357' , '6358' , '6359' , & '6360' , '6361' , '6362' , '6363' , '6364' , '6365' , '6366' , '6367' , '6368' , '6369' , & '6370' , '6371' , '6372' , '6373' , '6374' , '6375' , '6376' , '6377' , '6378' , '6379' , & '6380' , '6381' , '6382' , '6383' , '6384' , '6385' , '6386' , '6387' , '6388' , '6389' , & '6390' , '6391' , '6392' , '6393' , '6394' , '6395' , '6396' , '6397' , '6398' , '6399' , & '6400' , '6401' , '6402' , '6403' , '6404' , '6405' , '6406' , '6407' , '6408' , '6409' , & '6410' , '6411' , '6412' , '6413' , '6414' , '6415' , '6416' , '6417' , '6418' , '6419' , & '6420' , '6421' , '6422' , '6423' , '6424' , '6425' , '6426' , '6427' , '6428' , '6429' , & '6430' , '6431' , '6432' , '6433' , '6434' , '6435' , '6436' , '6437' , '6438' , '6439' , & '6440' , '6441' , '6442' , '6443' , '6444' , '6445' , '6446' , '6447' , '6448' , '6449' , & '6450' , '6451' , '6452' , '6453' , '6454' , '6455' , '6456' , '6457' , '6458' , '6459' , & '6460' , '6461' , '6462' , '6463' , '6464' , '6465' , '6466' , '6467' , '6468' , '6469' , & '6470' , '6471' , '6472' , '6473' , '6474' , '6475' , '6476' , '6477' , '6478' , '6479' , & '6480' , '6481' , '6482' , '6483' , '6484' , '6485' , '6486' , '6487' , '6488' , '6489' , & '6490' , '6491' , '6492' , '6493' , '6494' , '6495' , '6496' , '6497' , '6498' , '6499' , & '6500' , '6501' , '6502' , '6503' , '6504' , '6505' , '6506' , '6507' , '6508' , '6509' , & '6510' , '6511' , '6512' , '6513' , '6514' , '6515' , '6516' , '6517' , '6518' , '6519' , & '6520' , '6521' , '6522' , '6523' , '6524' , '6525' , '6526' , '6527' , '6528' , '6529' , & '6530' , '6531' , '6532' , '6533' , '6534' , '6535' , '6536' , '6537' , '6538' , '6539' , & '6540' , '6541' , '6542' , '6543' , '6544' , '6545' , '6546' , '6547' , '6548' , '6549' , & '6550' , '6551' , '6552' , '6553' , '6554' , '6555' , '6556' , '6557' , '6558' , '6559' , & '6560' , '6561' , '6562' , '6563' , '6564' , '6565' , '6566' , '6567' , '6568' , '6569' , & '6570' , '6571' , '6572' , '6573' , '6574' , '6575' , '6576' , '6577' , '6578' , '6579' , & '6580' , '6581' , '6582' , '6583' , '6584' , '6585' , '6586' , '6587' , '6588' , '6589' , & '6590' , '6591' , '6592' , '6593' , '6594' , '6595' , '6596' , '6597' , '6598' , '6599' , & '6600' , '6601' , '6602' , '6603' , '6604' , '6605' , '6606' , '6607' , '6608' , '6609' , & '6610' , '6611' , '6612' , '6613' , '6614' , '6615' , '6616' , '6617' , '6618' , '6619' , & '6620' , '6621' , '6622' , '6623' , '6624' , '6625' , '6626' , '6627' , '6628' , '6629' , & '6630' , '6631' , '6632' , '6633' , '6634' , '6635' , '6636' , '6637' , '6638' , '6639' , & '6640' , '6641' , '6642' , '6643' , '6644' , '6645' , '6646' , '6647' , '6648' , '6649' , & '6650' , '6651' , '6652' , '6653' , '6654' , '6655' , '6656' , '6657' , '6658' , '6659' , & '6660' , '6661' , '6662' , '6663' , '6664' , '6665' , '6666' , '6667' , '6668' , '6669' , & '6670' , '6671' , '6672' , '6673' , '6674' , '6675' , '6676' , '6677' , '6678' , '6679' , & '6680' , '6681' , '6682' , '6683' , '6684' , '6685' , '6686' , '6687' , '6688' , '6689' , & '6690' , '6691' , '6692' , '6693' , '6694' , '6695' , '6696' , '6697' , '6698' , '6699' , & '6700' , '6701' , '6702' , '6703' , '6704' , '6705' , '6706' , '6707' , '6708' , '6709' , & '6710' , '6711' , '6712' , '6713' , '6714' , '6715' , '6716' , '6717' , '6718' , '6719' , & '6720' , '6721' , '6722' , '6723' , '6724' , '6725' , '6726' , '6727' , '6728' , '6729' , & '6730' , '6731' , '6732' , '6733' , '6734' , '6735' , '6736' , '6737' , '6738' , '6739' , & '6740' , '6741' , '6742' , '6743' , '6744' , '6745' , '6746' , '6747' , '6748' , '6749' , & '6750' , '6751' , '6752' , '6753' , '6754' , '6755' , '6756' , '6757' , '6758' , '6759' , & '6760' , '6761' , '6762' , '6763' , '6764' , '6765' , '6766' , '6767' , '6768' , '6769' , & '6770' , '6771' , '6772' , '6773' , '6774' , '6775' , '6776' , '6777' , '6778' , '6779' , & '6780' , '6781' , '6782' , '6783' , '6784' , '6785' , '6786' , '6787' , '6788' , '6789' , & '6790' , '6791' , '6792' , '6793' , '6794' , '6795' , '6796' , '6797' , '6798' , '6799' , & '6800' , '6801' , '6802' , '6803' , '6804' , '6805' , '6806' , '6807' , '6808' , '6809' , & '6810' , '6811' , '6812' , '6813' , '6814' , '6815' , '6816' , '6817' , '6818' , '6819' , & '6820' , '6821' , '6822' , '6823' , '6824' , '6825' , '6826' , '6827' , '6828' , '6829' , & '6830' , '6831' , '6832' , '6833' , '6834' , '6835' , '6836' , '6837' , '6838' , '6839' , & '6840' , '6841' , '6842' , '6843' , '6844' , '6845' , '6846' , '6847' , '6848' , '6849' , & '6850' , '6851' , '6852' , '6853' , '6854' , '6855' , '6856' , '6857' , '6858' , '6859' , & '6860' , '6861' , '6862' , '6863' , '6864' , '6865' , '6866' , '6867' , '6868' , '6869' , & '6870' , '6871' , '6872' , '6873' , '6874' , '6875' , '6876' , '6877' , '6878' , '6879' , & '6880' , '6881' , '6882' , '6883' , '6884' , '6885' , '6886' , '6887' , '6888' , '6889' , & '6890' , '6891' , '6892' , '6893' , '6894' , '6895' , '6896' , '6897' , '6898' , '6899' , & '6900' , '6901' , '6902' , '6903' , '6904' , '6905' , '6906' , '6907' , '6908' , '6909' , & '6910' , '6911' , '6912' , '6913' , '6914' , '6915' , '6916' , '6917' , '6918' , '6919' , & '6920' , '6921' , '6922' , '6923' , '6924' , '6925' , '6926' , '6927' , '6928' , '6929' , & '6930' , '6931' , '6932' , '6933' , '6934' , '6935' , '6936' , '6937' , '6938' , '6939' , & '6940' , '6941' , '6942' , '6943' , '6944' , '6945' , '6946' , '6947' , '6948' , '6949' , & '6950' , '6951' , '6952' , '6953' , '6954' , '6955' , '6956' , '6957' , '6958' , '6959' , & '6960' , '6961' , '6962' , '6963' , '6964' , '6965' , '6966' , '6967' , '6968' , '6969' , & '6970' , '6971' , '6972' , '6973' , '6974' , '6975' , '6976' , '6977' , '6978' , '6979' , & '6980' , '6981' , '6982' , '6983' , '6984' , '6985' , '6986' , '6987' , '6988' , '6989' , & '6990' , '6991' , '6992' , '6993' , '6994' , '6995' , '6996' , '6997' , '6998' , '6999' , & '7000' , '7001' , '7002' , '7003' , '7004' , '7005' , '7006' , '7007' , '7008' , '7009' , & '7010' , '7011' , '7012' , '7013' , '7014' , '7015' , '7016' , '7017' , '7018' , '7019' , & '7020' , '7021' , '7022' , '7023' , '7024' , '7025' , '7026' , '7027' , '7028' , '7029' , & '7030' , '7031' , '7032' , '7033' , '7034' , '7035' , '7036' , '7037' , '7038' , '7039' , & '7040' , '7041' , '7042' , '7043' , '7044' , '7045' , '7046' , '7047' , '7048' , '7049' , & '7050' , '7051' , '7052' , '7053' , '7054' , '7055' , '7056' , '7057' , '7058' , '7059' , & '7060' , '7061' , '7062' , '7063' , '7064' , '7065' , '7066' , '7067' , '7068' , '7069' , & '7070' , '7071' , '7072' , '7073' , '7074' , '7075' , '7076' , '7077' , '7078' , '7079' , & '7080' , '7081' , '7082' , '7083' , '7084' , '7085' , '7086' , '7087' , '7088' , '7089' , & '7090' , '7091' , '7092' , '7093' , '7094' , '7095' , '7096' , '7097' , '7098' , '7099' , & '7100' , '7101' , '7102' , '7103' , '7104' , '7105' , '7106' , '7107' , '7108' , '7109' , & '7110' , '7111' , '7112' , '7113' , '7114' , '7115' , '7116' , '7117' , '7118' , '7119' , & '7120' , '7121' , '7122' , '7123' , '7124' , '7125' , '7126' , '7127' , '7128' , '7129' , & '7130' , '7131' , '7132' , '7133' , '7134' , '7135' , '7136' , '7137' , '7138' , '7139' , & '7140' , '7141' , '7142' , '7143' , '7144' , '7145' , '7146' , '7147' , '7148' , '7149' , & '7150' , '7151' , '7152' , '7153' , '7154' , '7155' , '7156' , '7157' , '7158' , '7159' , & '7160' , '7161' , '7162' , '7163' , '7164' , '7165' , '7166' , '7167' , '7168' , '7169' , & '7170' , '7171' , '7172' , '7173' , '7174' , '7175' , '7176' , '7177' , '7178' , '7179' , & '7180' , '7181' , '7182' , '7183' , '7184' , '7185' , '7186' , '7187' , '7188' , '7189' , & '7190' , '7191' , '7192' , '7193' , '7194' , '7195' , '7196' , '7197' , '7198' , '7199' , & '7200' , '7201' , '7202' , '7203' , '7204' , '7205' , '7206' , '7207' , '7208' , '7209' , & '7210' , '7211' , '7212' , '7213' , '7214' , '7215' , '7216' , '7217' , '7218' , '7219' , & '7220' , '7221' , '7222' , '7223' , '7224' , '7225' , '7226' , '7227' , '7228' , '7229' , & '7230' , '7231' , '7232' , '7233' , '7234' , '7235' , '7236' , '7237' , '7238' , '7239' , & '7240' , '7241' , '7242' , '7243' , '7244' , '7245' , '7246' , '7247' , '7248' , '7249' , & '7250' , '7251' , '7252' , '7253' , '7254' , '7255' , '7256' , '7257' , '7258' , '7259' , & '7260' , '7261' , '7262' , '7263' , '7264' , '7265' , '7266' , '7267' , '7268' , '7269' , & '7270' , '7271' , '7272' , '7273' , '7274' , '7275' , '7276' , '7277' , '7278' , '7279' , & '7280' , '7281' , '7282' , '7283' , '7284' , '7285' , '7286' , '7287' , '7288' , '7289' , & '7290' , '7291' , '7292' , '7293' , '7294' , '7295' , '7296' , '7297' , '7298' , '7299' , & '7300' , '7301' , '7302' , '7303' , '7304' , '7305' , '7306' , '7307' , '7308' , '7309' , & '7310' , '7311' , '7312' , '7313' , '7314' , '7315' , '7316' , '7317' , '7318' , '7319' , & '7320' , '7321' , '7322' , '7323' , '7324' , '7325' , '7326' , '7327' , '7328' , '7329' , & '7330' , '7331' , '7332' , '7333' , '7334' , '7335' , '7336' , '7337' , '7338' , '7339' , & '7340' , '7341' , '7342' , '7343' , '7344' , '7345' , '7346' , '7347' , '7348' , '7349' , & '7350' , '7351' , '7352' , '7353' , '7354' , '7355' , '7356' , '7357' , '7358' , '7359' , & '7360' , '7361' , '7362' , '7363' , '7364' , '7365' , '7366' , '7367' , '7368' , '7369' , & '7370' , '7371' , '7372' , '7373' , '7374' , '7375' , '7376' , '7377' , '7378' , '7379' , & '7380' , '7381' , '7382' , '7383' , '7384' , '7385' , '7386' , '7387' , '7388' , '7389' , & '7390' , '7391' , '7392' , '7393' , '7394' , '7395' , '7396' , '7397' , '7398' , '7399' , & '7400' , '7401' , '7402' , '7403' , '7404' , '7405' , '7406' , '7407' , '7408' , '7409' , & '7410' , '7411' , '7412' , '7413' , '7414' , '7415' , '7416' , '7417' , '7418' , '7419' , & '7420' , '7421' , '7422' , '7423' , '7424' , '7425' , '7426' , '7427' , '7428' , '7429' , & '7430' , '7431' , '7432' , '7433' , '7434' , '7435' , '7436' , '7437' , '7438' , '7439' , & '7440' , '7441' , '7442' , '7443' , '7444' , '7445' , '7446' , '7447' , '7448' , '7449' , & '7450' , '7451' , '7452' , '7453' , '7454' , '7455' , '7456' , '7457' , '7458' , '7459' , & '7460' , '7461' , '7462' , '7463' , '7464' , '7465' , '7466' , '7467' , '7468' , '7469' , & '7470' , '7471' , '7472' , '7473' , '7474' , '7475' , '7476' , '7477' , '7478' , '7479' , & '7480' , '7481' , '7482' , '7483' , '7484' , '7485' , '7486' , '7487' , '7488' , '7489' , & '7490' , '7491' , '7492' , '7493' , '7494' , '7495' , '7496' , '7497' , '7498' , '7499' , & '7500' , '7501' , '7502' , '7503' , '7504' , '7505' , '7506' , '7507' , '7508' , '7509' , & '7510' , '7511' , '7512' , '7513' , '7514' , '7515' , '7516' , '7517' , '7518' , '7519' , & '7520' , '7521' , '7522' , '7523' , '7524' , '7525' , '7526' , '7527' , '7528' , '7529' , & '7530' , '7531' , '7532' , '7533' , '7534' , '7535' , '7536' , '7537' , '7538' , '7539' , & '7540' , '7541' , '7542' , '7543' , '7544' , '7545' , '7546' , '7547' , '7548' , '7549' , & '7550' , '7551' , '7552' , '7553' , '7554' , '7555' , '7556' , '7557' , '7558' , '7559' , & '7560' , '7561' , '7562' , '7563' , '7564' , '7565' , '7566' , '7567' , '7568' , '7569' , & '7570' , '7571' , '7572' , '7573' , '7574' , '7575' , '7576' , '7577' , '7578' , '7579' , & '7580' , '7581' , '7582' , '7583' , '7584' , '7585' , '7586' , '7587' , '7588' , '7589' , & '7590' , '7591' , '7592' , '7593' , '7594' , '7595' , '7596' , '7597' , '7598' , '7599' , & '7600' , '7601' , '7602' , '7603' , '7604' , '7605' , '7606' , '7607' , '7608' , '7609' , & '7610' , '7611' , '7612' , '7613' , '7614' , '7615' , '7616' , '7617' , '7618' , '7619' , & '7620' , '7621' , '7622' , '7623' , '7624' , '7625' , '7626' , '7627' , '7628' , '7629' , & '7630' , '7631' , '7632' , '7633' , '7634' , '7635' , '7636' , '7637' , '7638' , '7639' , & '7640' , '7641' , '7642' , '7643' , '7644' , '7645' , '7646' , '7647' , '7648' , '7649' , & '7650' , '7651' , '7652' , '7653' , '7654' , '7655' , '7656' , '7657' , '7658' , '7659' , & '7660' , '7661' , '7662' , '7663' , '7664' , '7665' , '7666' , '7667' , '7668' , '7669' , & '7670' , '7671' , '7672' , '7673' , '7674' , '7675' , '7676' , '7677' , '7678' , '7679' , & '7680' , '7681' , '7682' , '7683' , '7684' , '7685' , '7686' , '7687' , '7688' , '7689' , & '7690' , '7691' , '7692' , '7693' , '7694' , '7695' , '7696' , '7697' , '7698' , '7699' , & '7700' , '7701' , '7702' , '7703' , '7704' , '7705' , '7706' , '7707' , '7708' , '7709' , & '7710' , '7711' , '7712' , '7713' , '7714' , '7715' , '7716' , '7717' , '7718' , '7719' , & '7720' , '7721' , '7722' , '7723' , '7724' , '7725' , '7726' , '7727' , '7728' , '7729' , & '7730' , '7731' , '7732' , '7733' , '7734' , '7735' , '7736' , '7737' , '7738' , '7739' , & '7740' , '7741' , '7742' , '7743' , '7744' , '7745' , '7746' , '7747' , '7748' , '7749' , & '7750' , '7751' , '7752' , '7753' , '7754' , '7755' , '7756' , '7757' , '7758' , '7759' , & '7760' , '7761' , '7762' , '7763' , '7764' , '7765' , '7766' , '7767' , '7768' , '7769' , & '7770' , '7771' , '7772' , '7773' , '7774' , '7775' , '7776' , '7777' , '7778' , '7779' , & '7780' , '7781' , '7782' , '7783' , '7784' , '7785' , '7786' , '7787' , '7788' , '7789' , & '7790' , '7791' , '7792' , '7793' , '7794' , '7795' , '7796' , '7797' , '7798' , '7799' , & '7800' , '7801' , '7802' , '7803' , '7804' , '7805' , '7806' , '7807' , '7808' , '7809' , & '7810' , '7811' , '7812' , '7813' , '7814' , '7815' , '7816' , '7817' , '7818' , '7819' , & '7820' , '7821' , '7822' , '7823' , '7824' , '7825' , '7826' , '7827' , '7828' , '7829' , & '7830' , '7831' , '7832' , '7833' , '7834' , '7835' , '7836' , '7837' , '7838' , '7839' , & '7840' , '7841' , '7842' , '7843' , '7844' , '7845' , '7846' , '7847' , '7848' , '7849' , & '7850' , '7851' , '7852' , '7853' , '7854' , '7855' , '7856' , '7857' , '7858' , '7859' , & '7860' , '7861' , '7862' , '7863' , '7864' , '7865' , '7866' , '7867' , '7868' , '7869' , & '7870' , '7871' , '7872' , '7873' , '7874' , '7875' , '7876' , '7877' , '7878' , '7879' , & '7880' , '7881' , '7882' , '7883' , '7884' , '7885' , '7886' , '7887' , '7888' , '7889' , & '7890' , '7891' , '7892' , '7893' , '7894' , '7895' , '7896' , '7897' , '7898' , '7899' , & '7900' , '7901' , '7902' , '7903' , '7904' , '7905' , '7906' , '7907' , '7908' , '7909' , & '7910' , '7911' , '7912' , '7913' , '7914' , '7915' , '7916' , '7917' , '7918' , '7919' , & '7920' , '7921' , '7922' , '7923' , '7924' , '7925' , '7926' , '7927' , '7928' , '7929' , & '7930' , '7931' , '7932' , '7933' , '7934' , '7935' , '7936' , '7937' , '7938' , '7939' , & '7940' , '7941' , '7942' , '7943' , '7944' , '7945' , '7946' , '7947' , '7948' , '7949' , & '7950' , '7951' , '7952' , '7953' , '7954' , '7955' , '7956' , '7957' , '7958' , '7959' , & '7960' , '7961' , '7962' , '7963' , '7964' , '7965' , '7966' , '7967' , '7968' , '7969' , & '7970' , '7971' , '7972' , '7973' , '7974' , '7975' , '7976' , '7977' , '7978' , '7979' , & '7980' , '7981' , '7982' , '7983' , '7984' , '7985' , '7986' , '7987' , '7988' , '7989' , & '7990' , '7991' , '7992' , '7993' , '7994' , '7995' , '7996' , '7997' , '7998' , '7999' , & '8000' , '8001' , '8002' , '8003' , '8004' , '8005' , '8006' , '8007' , '8008' , '8009' , & '8010' , '8011' , '8012' , '8013' , '8014' , '8015' , '8016' , '8017' , '8018' , '8019' , & '8020' , '8021' , '8022' , '8023' , '8024' , '8025' , '8026' , '8027' , '8028' , '8029' , & '8030' , '8031' , '8032' , '8033' , '8034' , '8035' , '8036' , '8037' , '8038' , '8039' , & '8040' , '8041' , '8042' , '8043' , '8044' , '8045' , '8046' , '8047' , '8048' , '8049' , & '8050' , '8051' , '8052' , '8053' , '8054' , '8055' , '8056' , '8057' , '8058' , '8059' , & '8060' , '8061' , '8062' , '8063' , '8064' , '8065' , '8066' , '8067' , '8068' , '8069' , & '8070' , '8071' , '8072' , '8073' , '8074' , '8075' , '8076' , '8077' , '8078' , '8079' , & '8080' , '8081' , '8082' , '8083' , '8084' , '8085' , '8086' , '8087' , '8088' , '8089' , & '8090' , '8091' , '8092' , '8093' , '8094' , '8095' , '8096' , '8097' , '8098' , '8099' , & '8100' , '8101' , '8102' , '8103' , '8104' , '8105' , '8106' , '8107' , '8108' , '8109' , & '8110' , '8111' , '8112' , '8113' , '8114' , '8115' , '8116' , '8117' , '8118' , '8119' , & '8120' , '8121' , '8122' , '8123' , '8124' , '8125' , '8126' , '8127' , '8128' , '8129' , & '8130' , '8131' , '8132' , '8133' , '8134' , '8135' , '8136' , '8137' , '8138' , '8139' , & '8140' , '8141' , '8142' , '8143' , '8144' , '8145' , '8146' , '8147' , '8148' , '8149' , & '8150' , '8151' , '8152' , '8153' , '8154' , '8155' , '8156' , '8157' , '8158' , '8159' , & '8160' , '8161' , '8162' , '8163' , '8164' , '8165' , '8166' , '8167' , '8168' , '8169' , & '8170' , '8171' , '8172' , '8173' , '8174' , '8175' , '8176' , '8177' , '8178' , '8179' , & '8180' , '8181' , '8182' , '8183' , '8184' , '8185' , '8186' , '8187' , '8188' , '8189' , & '8190' , '8191' , '8192' , '8193' , '8194' , '8195' , '8196' , '8197' , '8198' , '8199' , & '8200' , '8201' , '8202' , '8203' , '8204' , '8205' , '8206' , '8207' , '8208' , '8209' , & '8210' , '8211' , '8212' , '8213' , '8214' , '8215' , '8216' , '8217' , '8218' , '8219' , & '8220' , '8221' , '8222' , '8223' , '8224' , '8225' , '8226' , '8227' , '8228' , '8229' , & '8230' , '8231' , '8232' , '8233' , '8234' , '8235' , '8236' , '8237' , '8238' , '8239' , & '8240' , '8241' , '8242' , '8243' , '8244' , '8245' , '8246' , '8247' , '8248' , '8249' , & '8250' , '8251' , '8252' , '8253' , '8254' , '8255' , '8256' , '8257' , '8258' , '8259' , & '8260' , '8261' , '8262' , '8263' , '8264' , '8265' , '8266' , '8267' , '8268' , '8269' , & '8270' , '8271' , '8272' , '8273' , '8274' , '8275' , '8276' , '8277' , '8278' , '8279' , & '8280' , '8281' , '8282' , '8283' , '8284' , '8285' , '8286' , '8287' , '8288' , '8289' , & '8290' , '8291' , '8292' , '8293' , '8294' , '8295' , '8296' , '8297' , '8298' , '8299' , & '8300' , '8301' , '8302' , '8303' , '8304' , '8305' , '8306' , '8307' , '8308' , '8309' , & '8310' , '8311' , '8312' , '8313' , '8314' , '8315' , '8316' , '8317' , '8318' , '8319' , & '8320' , '8321' , '8322' , '8323' , '8324' , '8325' , '8326' , '8327' , '8328' , '8329' , & '8330' , '8331' , '8332' , '8333' , '8334' , '8335' , '8336' , '8337' , '8338' , '8339' , & '8340' , '8341' , '8342' , '8343' , '8344' , '8345' , '8346' , '8347' , '8348' , '8349' , & '8350' , '8351' , '8352' , '8353' , '8354' , '8355' , '8356' , '8357' , '8358' , '8359' , & '8360' , '8361' , '8362' , '8363' , '8364' , '8365' , '8366' , '8367' , '8368' , '8369' , & '8370' , '8371' , '8372' , '8373' , '8374' , '8375' , '8376' , '8377' , '8378' , '8379' , & '8380' , '8381' , '8382' , '8383' , '8384' , '8385' , '8386' , '8387' , '8388' , '8389' , & '8390' , '8391' , '8392' , '8393' , '8394' , '8395' , '8396' , '8397' , '8398' , '8399' , & '8400' , '8401' , '8402' , '8403' , '8404' , '8405' , '8406' , '8407' , '8408' , '8409' , & '8410' , '8411' , '8412' , '8413' , '8414' , '8415' , '8416' , '8417' , '8418' , '8419' , & '8420' , '8421' , '8422' , '8423' , '8424' , '8425' , '8426' , '8427' , '8428' , '8429' , & '8430' , '8431' , '8432' , '8433' , '8434' , '8435' , '8436' , '8437' , '8438' , '8439' , & '8440' , '8441' , '8442' , '8443' , '8444' , '8445' , '8446' , '8447' , '8448' , '8449' , & '8450' , '8451' , '8452' , '8453' , '8454' , '8455' , '8456' , '8457' , '8458' , '8459' , & '8460' , '8461' , '8462' , '8463' , '8464' , '8465' , '8466' , '8467' , '8468' , '8469' , & '8470' , '8471' , '8472' , '8473' , '8474' , '8475' , '8476' , '8477' , '8478' , '8479' , & '8480' , '8481' , '8482' , '8483' , '8484' , '8485' , '8486' , '8487' , '8488' , '8489' , & '8490' , '8491' , '8492' , '8493' , '8494' , '8495' , '8496' , '8497' , '8498' , '8499' , & '8500' , '8501' , '8502' , '8503' , '8504' , '8505' , '8506' , '8507' , '8508' , '8509' , & '8510' , '8511' , '8512' , '8513' , '8514' , '8515' , '8516' , '8517' , '8518' , '8519' , & '8520' , '8521' , '8522' , '8523' , '8524' , '8525' , '8526' , '8527' , '8528' , '8529' , & '8530' , '8531' , '8532' , '8533' , '8534' , '8535' , '8536' , '8537' , '8538' , '8539' , & '8540' , '8541' , '8542' , '8543' , '8544' , '8545' , '8546' , '8547' , '8548' , '8549' , & '8550' , '8551' , '8552' , '8553' , '8554' , '8555' , '8556' , '8557' , '8558' , '8559' , & '8560' , '8561' , '8562' , '8563' , '8564' , '8565' , '8566' , '8567' , '8568' , '8569' , & '8570' , '8571' , '8572' , '8573' , '8574' , '8575' , '8576' , '8577' , '8578' , '8579' , & '8580' , '8581' , '8582' , '8583' , '8584' , '8585' , '8586' , '8587' , '8588' , '8589' , & '8590' , '8591' , '8592' , '8593' , '8594' , '8595' , '8596' , '8597' , '8598' , '8599' , & '8600' , '8601' , '8602' , '8603' , '8604' , '8605' , '8606' , '8607' , '8608' , '8609' , & '8610' , '8611' , '8612' , '8613' , '8614' , '8615' , '8616' , '8617' , '8618' , '8619' , & '8620' , '8621' , '8622' , '8623' , '8624' , '8625' , '8626' , '8627' , '8628' , '8629' , & '8630' , '8631' , '8632' , '8633' , '8634' , '8635' , '8636' , '8637' , '8638' , '8639' , & '8640' , '8641' , '8642' , '8643' , '8644' , '8645' , '8646' , '8647' , '8648' , '8649' , & '8650' , '8651' , '8652' , '8653' , '8654' , '8655' , '8656' , '8657' , '8658' , '8659' , & '8660' , '8661' , '8662' , '8663' , '8664' , '8665' , '8666' , '8667' , '8668' , '8669' , & '8670' , '8671' , '8672' , '8673' , '8674' , '8675' , '8676' , '8677' , '8678' , '8679' , & '8680' , '8681' , '8682' , '8683' , '8684' , '8685' , '8686' , '8687' , '8688' , '8689' , & '8690' , '8691' , '8692' , '8693' , '8694' , '8695' , '8696' , '8697' , '8698' , '8699' , & '8700' , '8701' , '8702' , '8703' , '8704' , '8705' , '8706' , '8707' , '8708' , '8709' , & '8710' , '8711' , '8712' , '8713' , '8714' , '8715' , '8716' , '8717' , '8718' , '8719' , & '8720' , '8721' , '8722' , '8723' , '8724' , '8725' , '8726' , '8727' , '8728' , '8729' , & '8730' , '8731' , '8732' , '8733' , '8734' , '8735' , '8736' , '8737' , '8738' , '8739' , & '8740' , '8741' , '8742' , '8743' , '8744' , '8745' , '8746' , '8747' , '8748' , '8749' , & '8750' , '8751' , '8752' , '8753' , '8754' , '8755' , '8756' , '8757' , '8758' , '8759' , & '8760' , '8761' , '8762' , '8763' , '8764' , '8765' , '8766' , '8767' , '8768' , '8769' , & '8770' , '8771' , '8772' , '8773' , '8774' , '8775' , '8776' , '8777' , '8778' , '8779' , & '8780' , '8781' , '8782' , '8783' , '8784' , '8785' , '8786' , '8787' , '8788' , '8789' , & '8790' , '8791' , '8792' , '8793' , '8794' , '8795' , '8796' , '8797' , '8798' , '8799' , & '8800' , '8801' , '8802' , '8803' , '8804' , '8805' , '8806' , '8807' , '8808' , '8809' , & '8810' , '8811' , '8812' , '8813' , '8814' , '8815' , '8816' , '8817' , '8818' , '8819' , & '8820' , '8821' , '8822' , '8823' , '8824' , '8825' , '8826' , '8827' , '8828' , '8829' , & '8830' , '8831' , '8832' , '8833' , '8834' , '8835' , '8836' , '8837' , '8838' , '8839' , & '8840' , '8841' , '8842' , '8843' , '8844' , '8845' , '8846' , '8847' , '8848' , '8849' , & '8850' , '8851' , '8852' , '8853' , '8854' , '8855' , '8856' , '8857' , '8858' , '8859' , & '8860' , '8861' , '8862' , '8863' , '8864' , '8865' , '8866' , '8867' , '8868' , '8869' , & '8870' , '8871' , '8872' , '8873' , '8874' , '8875' , '8876' , '8877' , '8878' , '8879' , & '8880' , '8881' , '8882' , '8883' , '8884' , '8885' , '8886' , '8887' , '8888' , '8889' , & '8890' , '8891' , '8892' , '8893' , '8894' , '8895' , '8896' , '8897' , '8898' , '8899' , & '8900' , '8901' , '8902' , '8903' , '8904' , '8905' , '8906' , '8907' , '8908' , '8909' , & '8910' , '8911' , '8912' , '8913' , '8914' , '8915' , '8916' , '8917' , '8918' , '8919' , & '8920' , '8921' , '8922' , '8923' , '8924' , '8925' , '8926' , '8927' , '8928' , '8929' , & '8930' , '8931' , '8932' , '8933' , '8934' , '8935' , '8936' , '8937' , '8938' , '8939' , & '8940' , '8941' , '8942' , '8943' , '8944' , '8945' , '8946' , '8947' , '8948' , '8949' , & '8950' , '8951' , '8952' , '8953' , '8954' , '8955' , '8956' , '8957' , '8958' , '8959' , & '8960' , '8961' , '8962' , '8963' , '8964' , '8965' , '8966' , '8967' , '8968' , '8969' , & '8970' , '8971' , '8972' , '8973' , '8974' , '8975' , '8976' , '8977' , '8978' , '8979' , & '8980' , '8981' , '8982' , '8983' , '8984' , '8985' , '8986' , '8987' , '8988' , '8989' , & '8990' , '8991' , '8992' , '8993' , '8994' , '8995' , '8996' , '8997' , '8998' , '8999' , & '9000' , '9001' , '9002' , '9003' , '9004' , '9005' , '9006' , '9007' , '9008' , '9009' , & '9010' , '9011' , '9012' , '9013' , '9014' , '9015' , '9016' , '9017' , '9018' , '9019' , & '9020' , '9021' , '9022' , '9023' , '9024' , '9025' , '9026' , '9027' , '9028' , '9029' , & '9030' , '9031' , '9032' , '9033' , '9034' , '9035' , '9036' , '9037' , '9038' , '9039' , & '9040' , '9041' , '9042' , '9043' , '9044' , '9045' , '9046' , '9047' , '9048' , '9049' , & '9050' , '9051' , '9052' , '9053' , '9054' , '9055' , '9056' , '9057' , '9058' , '9059' , & '9060' , '9061' , '9062' , '9063' , '9064' , '9065' , '9066' , '9067' , '9068' , '9069' , & '9070' , '9071' , '9072' , '9073' , '9074' , '9075' , '9076' , '9077' , '9078' , '9079' , & '9080' , '9081' , '9082' , '9083' , '9084' , '9085' , '9086' , '9087' , '9088' , '9089' , & '9090' , '9091' , '9092' , '9093' , '9094' , '9095' , '9096' , '9097' , '9098' , '9099' , & '9100' , '9101' , '9102' , '9103' , '9104' , '9105' , '9106' , '9107' , '9108' , '9109' , & '9110' , '9111' , '9112' , '9113' , '9114' , '9115' , '9116' , '9117' , '9118' , '9119' , & '9120' , '9121' , '9122' , '9123' , '9124' , '9125' , '9126' , '9127' , '9128' , '9129' , & '9130' , '9131' , '9132' , '9133' , '9134' , '9135' , '9136' , '9137' , '9138' , '9139' , & '9140' , '9141' , '9142' , '9143' , '9144' , '9145' , '9146' , '9147' , '9148' , '9149' , & '9150' , '9151' , '9152' , '9153' , '9154' , '9155' , '9156' , '9157' , '9158' , '9159' , & '9160' , '9161' , '9162' , '9163' , '9164' , '9165' , '9166' , '9167' , '9168' , '9169' , & '9170' , '9171' , '9172' , '9173' , '9174' , '9175' , '9176' , '9177' , '9178' , '9179' , & '9180' , '9181' , '9182' , '9183' , '9184' , '9185' , '9186' , '9187' , '9188' , '9189' , & '9190' , '9191' , '9192' , '9193' , '9194' , '9195' , '9196' , '9197' , '9198' , '9199' , & '9200' , '9201' , '9202' , '9203' , '9204' , '9205' , '9206' , '9207' , '9208' , '9209' , & '9210' , '9211' , '9212' , '9213' , '9214' , '9215' , '9216' , '9217' , '9218' , '9219' , & '9220' , '9221' , '9222' , '9223' , '9224' , '9225' , '9226' , '9227' , '9228' , '9229' , & '9230' , '9231' , '9232' , '9233' , '9234' , '9235' , '9236' , '9237' , '9238' , '9239' , & '9240' , '9241' , '9242' , '9243' , '9244' , '9245' , '9246' , '9247' , '9248' , '9249' , & '9250' , '9251' , '9252' , '9253' , '9254' , '9255' , '9256' , '9257' , '9258' , '9259' , & '9260' , '9261' , '9262' , '9263' , '9264' , '9265' , '9266' , '9267' , '9268' , '9269' , & '9270' , '9271' , '9272' , '9273' , '9274' , '9275' , '9276' , '9277' , '9278' , '9279' , & '9280' , '9281' , '9282' , '9283' , '9284' , '9285' , '9286' , '9287' , '9288' , '9289' , & '9290' , '9291' , '9292' , '9293' , '9294' , '9295' , '9296' , '9297' , '9298' , '9299' , & '9300' , '9301' , '9302' , '9303' , '9304' , '9305' , '9306' , '9307' , '9308' , '9309' , & '9310' , '9311' , '9312' , '9313' , '9314' , '9315' , '9316' , '9317' , '9318' , '9319' , & '9320' , '9321' , '9322' , '9323' , '9324' , '9325' , '9326' , '9327' , '9328' , '9329' , & '9330' , '9331' , '9332' , '9333' , '9334' , '9335' , '9336' , '9337' , '9338' , '9339' , & '9340' , '9341' , '9342' , '9343' , '9344' , '9345' , '9346' , '9347' , '9348' , '9349' , & '9350' , '9351' , '9352' , '9353' , '9354' , '9355' , '9356' , '9357' , '9358' , '9359' , & '9360' , '9361' , '9362' , '9363' , '9364' , '9365' , '9366' , '9367' , '9368' , '9369' , & '9370' , '9371' , '9372' , '9373' , '9374' , '9375' , '9376' , '9377' , '9378' , '9379' , & '9380' , '9381' , '9382' , '9383' , '9384' , '9385' , '9386' , '9387' , '9388' , '9389' , & '9390' , '9391' , '9392' , '9393' , '9394' , '9395' , '9396' , '9397' , '9398' , '9399' , & '9400' , '9401' , '9402' , '9403' , '9404' , '9405' , '9406' , '9407' , '9408' , '9409' , & '9410' , '9411' , '9412' , '9413' , '9414' , '9415' , '9416' , '9417' , '9418' , '9419' , & '9420' , '9421' , '9422' , '9423' , '9424' , '9425' , '9426' , '9427' , '9428' , '9429' , & '9430' , '9431' , '9432' , '9433' , '9434' , '9435' , '9436' , '9437' , '9438' , '9439' , & '9440' , '9441' , '9442' , '9443' , '9444' , '9445' , '9446' , '9447' , '9448' , '9449' , & '9450' , '9451' , '9452' , '9453' , '9454' , '9455' , '9456' , '9457' , '9458' , '9459' , & '9460' , '9461' , '9462' , '9463' , '9464' , '9465' , '9466' , '9467' , '9468' , '9469' , & '9470' , '9471' , '9472' , '9473' , '9474' , '9475' , '9476' , '9477' , '9478' , '9479' , & '9480' , '9481' , '9482' , '9483' , '9484' , '9485' , '9486' , '9487' , '9488' , '9489' , & '9490' , '9491' , '9492' , '9493' , '9494' , '9495' , '9496' , '9497' , '9498' , '9499' , & '9500' , '9501' , '9502' , '9503' , '9504' , '9505' , '9506' , '9507' , '9508' , '9509' , & '9510' , '9511' , '9512' , '9513' , '9514' , '9515' , '9516' , '9517' , '9518' , '9519' , & '9520' , '9521' , '9522' , '9523' , '9524' , '9525' , '9526' , '9527' , '9528' , '9529' , & '9530' , '9531' , '9532' , '9533' , '9534' , '9535' , '9536' , '9537' , '9538' , '9539' , & '9540' , '9541' , '9542' , '9543' , '9544' , '9545' , '9546' , '9547' , '9548' , '9549' , & '9550' , '9551' , '9552' , '9553' , '9554' , '9555' , '9556' , '9557' , '9558' , '9559' , & '9560' , '9561' , '9562' , '9563' , '9564' , '9565' , '9566' , '9567' , '9568' , '9569' , & '9570' , '9571' , '9572' , '9573' , '9574' , '9575' , '9576' , '9577' , '9578' , '9579' , & '9580' , '9581' , '9582' , '9583' , '9584' , '9585' , '9586' , '9587' , '9588' , '9589' , & '9590' , '9591' , '9592' , '9593' , '9594' , '9595' , '9596' , '9597' , '9598' , '9599' , & '9600' , '9601' , '9602' , '9603' , '9604' , '9605' , '9606' , '9607' , '9608' , '9609' , & '9610' , '9611' , '9612' , '9613' , '9614' , '9615' , '9616' , '9617' , '9618' , '9619' , & '9620' , '9621' , '9622' , '9623' , '9624' , '9625' , '9626' , '9627' , '9628' , '9629' , & '9630' , '9631' , '9632' , '9633' , '9634' , '9635' , '9636' , '9637' , '9638' , '9639' , & '9640' , '9641' , '9642' , '9643' , '9644' , '9645' , '9646' , '9647' , '9648' , '9649' , & '9650' , '9651' , '9652' , '9653' , '9654' , '9655' , '9656' , '9657' , '9658' , '9659' , & '9660' , '9661' , '9662' , '9663' , '9664' , '9665' , '9666' , '9667' , '9668' , '9669' , & '9670' , '9671' , '9672' , '9673' , '9674' , '9675' , '9676' , '9677' , '9678' , '9679' , & '9680' , '9681' , '9682' , '9683' , '9684' , '9685' , '9686' , '9687' , '9688' , '9689' , & '9690' , '9691' , '9692' , '9693' , '9694' , '9695' , '9696' , '9697' , '9698' , '9699' , & '9700' , '9701' , '9702' , '9703' , '9704' , '9705' , '9706' , '9707' , '9708' , '9709' , & '9710' , '9711' , '9712' , '9713' , '9714' , '9715' , '9716' , '9717' , '9718' , '9719' , & '9720' , '9721' , '9722' , '9723' , '9724' , '9725' , '9726' , '9727' , '9728' , '9729' , & '9730' , '9731' , '9732' , '9733' , '9734' , '9735' , '9736' , '9737' , '9738' , '9739' , & '9740' , '9741' , '9742' , '9743' , '9744' , '9745' , '9746' , '9747' , '9748' , '9749' , & '9750' , '9751' , '9752' , '9753' , '9754' , '9755' , '9756' , '9757' , '9758' , '9759' , & '9760' , '9761' , '9762' , '9763' , '9764' , '9765' , '9766' , '9767' , '9768' , '9769' , & '9770' , '9771' , '9772' , '9773' , '9774' , '9775' , '9776' , '9777' , '9778' , '9779' , & '9780' , '9781' , '9782' , '9783' , '9784' , '9785' , '9786' , '9787' , '9788' , '9789' , & '9790' , '9791' , '9792' , '9793' , '9794' , '9795' , '9796' , '9797' , '9798' , '9799' , & '9800' , '9801' , '9802' , '9803' , '9804' , '9805' , '9806' , '9807' , '9808' , '9809' , & '9810' , '9811' , '9812' , '9813' , '9814' , '9815' , '9816' , '9817' , '9818' , '9819' , & '9820' , '9821' , '9822' , '9823' , '9824' , '9825' , '9826' , '9827' , '9828' , '9829' , & '9830' , '9831' , '9832' , '9833' , '9834' , '9835' , '9836' , '9837' , '9838' , '9839' , & '9840' , '9841' , '9842' , '9843' , '9844' , '9845' , '9846' , '9847' , '9848' , '9849' , & '9850' , '9851' , '9852' , '9853' , '9854' , '9855' , '9856' , '9857' , '9858' , '9859' , & '9860' , '9861' , '9862' , '9863' , '9864' , '9865' , '9866' , '9867' , '9868' , '9869' , & '9870' , '9871' , '9872' , '9873' , '9874' , '9875' , '9876' , '9877' , '9878' , '9879' , & '9880' , '9881' , '9882' , '9883' , '9884' , '9885' , '9886' , '9887' , '9888' , '9889' , & '9890' , '9891' , '9892' , '9893' , '9894' , '9895' , '9896' , '9897' , '9898' , '9899' , & '9900' , '9901' , '9902' , '9903' , '9904' , '9905' , '9906' , '9907' , '9908' , '9909' , & '9910' , '9911' , '9912' , '9913' , '9914' , '9915' , '9916' , '9917' , '9918' , '9919' , & '9920' , '9921' , '9922' , '9923' , '9924' , '9925' , '9926' , '9927' , '9928' , '9929' , & '9930' , '9931' , '9932' , '9933' , '9934' , '9935' , '9936' , '9937' , '9938' , '9939' , & '9940' , '9941' , '9942' , '9943' , '9944' , '9945' , '9946' , '9947' , '9948' , '9949' , & '9950' , '9951' , '9952' , '9953' , '9954' , '9955' , '9956' , '9957' , '9958' , '9959' , & '9960' , '9961' , '9962' , '9963' , '9964' , '9965' , '9966' , '9967' , '9968' , '9969' , & '9970' , '9971' , '9972' , '9973' , '9974' , '9975' , '9976' , '9977' , '9978' , '9979' , & '9980' , '9981' , '9982' , '9983' , '9984' , '9985' , '9986' , '9987' , '9988' , '9989' , & '9990' , '9991' , '9992' , '9993' , '9994' , '9995' , '9996' , '9997' , '9998' , '9999' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: BufLen , Top , I , J CHARACTER ( LEN = 41 ) :: Buffer TYPE ( UInt128 ) :: Copy INTEGER ( KIND = I8B ) :: Tmp !** FLOW IF ( U128 == ZeroU128 ) THEN Str = '0' RETURN END IF BufLen = 41 FORALL ( I = 1 : BufLen ) Buffer ( I : I ) = '0' Top = BufLen Copy = U128 DO J = Top Tmp = DivModBy10Pow18 ( Copy ) CALL Write_1_To_18_Digits ( Tmp , Buffer , Top ) IF (( Copy % High == 0 ). AND .( Copy % Low == 0 )) THEN EXIT ELSE Top = J - 18 END IF END DO Str = Buffer ( Top + 1 : BufLen ) RETURN CONTAINS SUBROUTINE Write_1_To_18_Digits ( Number , cStr , Indx ) !** PURPOSE OF THIS SUBROUTINE: ! To convert an integer number to character string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx ! current index to the character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 19 INTEGER ( KIND = I8B ), PARAMETER :: Div1E8 = 100000000_I8B ! multiplier and shift for 19 digits and divisor of 1.0E8 INTEGER ( KIND = I8B ), PARAMETER :: M90 = INT ( Z 'ABCC77118461CEFD' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: S90 = 90 - 64 ! multiplier for 11 digits and divisor of 1.0E8 INTEGER ( KIND = I8B ), PARAMETER :: M64 = INT ( Z '0000002AF31DC462' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr INTEGER ( KIND = I8B ) :: PosNum INTEGER ( KIND = I8B ) :: NxtNum , RemNum INTEGER ( KIND = I4B ) :: Start !** FLOW ! start the conversion IF ( Number >= 1000000000_I8B ) THEN ! compute NxtNum = Number/100000000 NxtNum = SHIFTR ( UMul128_Upper64 ( Number , M90 ), S90 ) ! compute RemNum = MOD(Number, 100000000) RemNum = Number - NxtNum * Div1E8 ! convert the remainder to a working string CALL Write_8_Digits ( INT ( RemNum , KIND = I4B ), wStr ( 12 : 19 )) PosNum = NxtNum IF ( PosNum > Div1E8 ) THEN ! compute NxtNum = PosNum/100000000 NxtNum = UMul128_Upper64 ( PosNum , M64 ) ! compute RemNum = MOD(PosNum, 100000000) RemNum = PosNum - NxtNum * Div1E8 ! convert the remainder to a working string CALL Write_8_Digits ( INT ( RemNum , KIND = I4B ), wStr ( 4 : 11 )) ! convert the rest IF ( NxtNum < 10 ) THEN wStr ( 3 : 3 ) = Char2Digits ( NxtNum )( 2 : 2 ) Start = 3 ELSEIF ( NxtNum < 100 ) THEN wStr ( 2 : 3 ) = Char2Digits ( NxtNum ) Start = 2 ELSE wStr ( 1 : 3 ) = Char4Digits ( NxtNum )( 2 : 4 ) Start = 1 END IF ELSE ! convert the rest Start = 3 + Write_1_to_8_Digits ( INT ( PosNum , KIND = I4B ), wStr ( 4 : 11 )) END IF ! transfer to output string DO I = MaxLen , Start , - 1 cStr ( Indx : Indx ) = wStr ( I : I ) Indx = Indx - 1 END DO ELSE CALL Write_1_To_9_Digits ( INT ( Number , KIND = I4B ), cStr , Indx ) END IF RETURN END SUBROUTINE Write_1_To_18_Digits !****************************************************************************** SUBROUTINE Write_1_To_9_Digits ( Number , cStr , Indx ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_To_9_Digits !** PURPOSE OF THIS SUBROUTINE: ! To convert an integer number to character string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx ! current index to the character string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 10 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I4B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I4B ) :: NxtNum ! next round of positive number INTEGER ( KIND = I4B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Start , Finish !** FLOW ! start the conversion IF ( Number >= 10000 ) THEN ! compute the next round of working number NxtNum = INT ( SHIFTR ( Number * Multiplier , ShiftPos ), KIND = I4B ) ! NxtNum = Number/10000 ! compute the remainder RemNum = Number - NxtNum * Divisor ! RemNum = MOD(Number, 10000) ! convert the remainder to a working string wStr ( 7 : 10 ) = Char4Digits ( RemNum ) Finish = 10 PosNum = NxtNum IF ( PosNum < 10000 ) THEN IF ( PosNum < 100 ) THEN wStr ( 5 : 6 ) = Char2Digits ( PosNum ) Start = 5 IF ( wStr ( Start : Start ) == '0' ) Start = 6 ELSE wStr ( 3 : 6 ) = Char4Digits ( PosNum ) Start = 3 IF ( wStr ( Start : Start ) == '0' ) Start = 4 END IF ELSE ! compute the next round of working number NxtNum = INT ( SHIFTR ( PosNum * Multiplier , ShiftPos ), KIND = I4B ) ! NxtNum = PosNum/10000 ! compute the remainder RemNum = PosNum - NxtNum * Divisor ! RemNum = MOD(PosNum, 10000) ! convert the remainder to a working string wStr ( 3 : 6 ) = Char4Digits ( RemNum ) IF ( NxtNum > 0 ) THEN IF ( NxtNum < 10 ) THEN wStr ( 2 : 2 ) = Char2Digits ( NxtNum )( 2 : 2 ) Start = 2 ELSE wStr ( 1 : 2 ) = Char2Digits ( NxtNum ) Start = 1 END IF ELSE Start = 3 END IF END IF ELSE Start = 1 IF ( Number < 100 ) THEN wStr ( 1 : 2 ) = Char2Digits ( Number ) Finish = 2 IF ( wStr ( Start : Start ) == '0' ) Start = 2 ELSE wStr ( 1 : 4 ) = Char4Digits ( Number ) Finish = 4 IF ( wStr ( Start : Start ) == '0' ) Start = 2 END IF END IF ! transfer to output string DO I = Finish , Start , - 1 cStr ( Indx : Indx ) = wStr ( I : I ) Indx = Indx - 1 END DO RETURN END SUBROUTINE Write_1_To_9_Digits !****************************************************************************** SUBROUTINE Write_8_Digits ( Number , cStr ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string !** SUBROUTINE PARAMETER DECLARATIONS: ! multiplier and shift for 4-byte integer and divisor of 10000 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NxtNum , RemNum !** FLOW ! compute NxtNum = PosNum/10000 NxtNum = INT ( SHIFTR ( Number * Multiplier , ShiftPos ), KIND = I4B ) ! compute RemNum = MOD(PosNum, 10000) RemNum = Number - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) ! convert the rest cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) RETURN END SUBROUTINE Write_8_Digits !************************************************************************** FUNCTION Write_1_to_8_Digits ( Number , cStr ) RESULT ( Start ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_1_to_8_Digits !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 1 to 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: Start !** SUBROUTINE PARAMETER DECLARATIONS: ! multiplier and shift for 4-byte integer and divisor of 10000 INTEGER ( KIND = I4B ), PARAMETER :: ShiftPos = 45 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = INT ( Z '00000000D1B71759' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: Divisor = 10000 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NxtNum , RemNum !** FLOW IF ( Number < 10000 ) THEN IF ( Number < 100 ) THEN cStr ( 7 : 8 ) = Char2Digits ( Number ) Start = 7 IF ( cStr ( Start : Start ) == '0' ) Start = 8 ELSE cStr ( 5 : 8 ) = Char4Digits ( Number ) Start = 5 IF ( cStr ( Start : Start ) == '0' ) Start = 6 END IF ELSE ! compute NxtNum = Number/10000 NxtNum = INT ( SHIFTR ( Number * Multiplier , ShiftPos ), KIND = I4B ) ! compute RemNum = MOD(Number, 10000) RemNum = Number - NxtNum * Divisor ! convert the remainder to a working string cStr ( 5 : 8 ) = Char4Digits ( RemNum ) IF ( NxtNum < 100 ) THEN cStr ( 3 : 4 ) = Char2Digits ( NxtNum ) Start = 3 IF ( cStr ( Start : Start ) == '0' ) Start = 4 ELSE cStr ( 1 : 4 ) = Char4Digits ( NxtNum ) Start = 1 IF ( cStr ( Start : Start ) == '0' ) Start = 2 END IF END IF RETURN END FUNCTION Write_1_to_8_Digits !************************************************************************** FUNCTION DivModBy10Pow18 ( DivQuot ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division DivQuot / Divisor where the Divisor is equal to 10**18 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: DivQuot ! on entry, the dividend ! on exit, the quotient INTEGER ( KIND = I8B ) :: Remainder ! the remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: LSh = 4 ! = LEADZ(Divisor) INTEGER ( KIND = I8B ), PARAMETER :: Denom = INT ( Z 'DE0B6B3A76400000' , KIND = I8B ) ! = SHIFTL(Divisor, LSh) INTEGER ( KIND = I8B ), PARAMETER :: V = INT ( Z '2725DD1D243ABA0E' , KIND = I8B ) ! = Reciprocal_2By1(Denom) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RSh INTEGER ( KIND = I8B ) :: NumerHi , NumerLo !        INTEGER(KIND=I8B)         :: DenomHi, DenomLo INTEGER ( KIND = I8B ) :: NumerEx , RshMask INTEGER ( KIND = I8B ) :: R1 , R2 !        INTEGER(KIND=I8B)         :: LHS, RHS !** FLOW IF ( DivQuot % High == 0_I8B ) THEN IF (( DivQuot % Low > 0_I8B ). AND .( DivQuot % Low < 1000000000000000000_I8B )) THEN Remainder = DivQuot % Low DivQuot % Low = 0_I8B RETURN END IF END IF RSh = 64 - LSh RShMask = - 1_I8B NumerLo = SHIFTL ( DivQuot % Low , LSh ) NumerHi = IOR ( SHIFTL ( DivQuot % High , LSh ), IAND ( SHIFTR ( DivQuot % Low , RSh ), RShMask )) NumerEx = IAND ( SHIFTR ( DivQuot % High , RSh ), RShMask ) CALL UDivRem_2By1 ( NumerEx , NumerHi , Denom , V , DivQuot % High , R1 ) CALL UDivRem_2By1 ( R1 , NumerLo , Denom , V , DivQuot % Low , R2 ) Remainder = SHIFTR ( R2 , LSh ) RETURN END FUNCTION DivModBy10Pow18 !************************************************************************** SUBROUTINE UDivRem_2By1 ( UHi , ULo , D , V , Q , R ) !** PURPOSE OF THIS SUBROUTINE: ! To performm 128-bit integer division by 64-bit integer IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: UHi , ULo , D , V INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Q , R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MinInt64 = INT ( Z '8000000000000000' , KIND = I8B ) ! -9223372036854775808 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: QHi , QLo , NewLo !** FLOW ! Q128 = V*UHi CALL UMul128 ( V , UHi , QHi , QLo ) ! Q128 = Q128 + U128 NewLo = QLo + ULo IF ( IEOR ( NewLo , MinInt64 ) < IEOR ( QLo , MinInt64 )) THEN QHi = QHi + UHi + 1_I8B ELSE QHi = QHi + UHi END IF QLo = NewLo QHi = QHi + 1_I8B R = ULo - QHi * D IF ( IEOR ( R , MinInt64 ) > IEOR ( QLo , MinInt64 )) THEN QHi = QHi - 1_I8B R = R + D END IF IF ( IEOR ( R , MinInt64 ) >= IEOR ( D , MinInt64 )) THEN QHi = QHi + 1_I8B R = R - D END IF Q = QHi RETURN END SUBROUTINE UDivRem_2By1 !************************************************************************** END FUNCTION DecString_From_U128 !****************************************************************************** FUNCTION HexString_From_U128 ( U128 ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !! To convert an unsigned 128-bit integer number to a hexadecimal string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 CHARACTER ( LEN = :), ALLOCATABLE :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !  na !** FLOW ! for hexadecimal, division and mod of UInt128 is not needed so it is simpler and faster IF ( U128 % High /= 0_I8B ) THEN BLOCK CHARACTER ( LEN = :), ALLOCATABLE :: LowHex CHARACTER ( LEN = 16 ) :: LowStr LowStr = '0000000000000000' LowHex = U64_ToHexStr ( U128 % Low ) IF ( LEN ( LowHex ) > 0 ) LowStr ( 17 - LEN ( LowHex ): 16 ) = LowHex Str = U64_ToHexStr ( U128 % High ) // LowStr END BLOCK ELSE Str = U64_ToHexStr ( U128 % Low ) END IF RETURN CONTAINS FUNCTION I64_ToHexStr ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert an integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! hexadecimal string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxLen = 16 INTEGER ( KIND = I8B ), PARAMETER :: Base = 16_I8B INTEGER ( KIND = I4B ), PARAMETER :: Shift = 4 CHARACTER ( LEN = 1 ), PARAMETER :: NumStr ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , & '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = MaxLen ) :: wStr ! working string INTEGER ( KIND = I8B ) :: PosNum ! positive number (working number) INTEGER ( KIND = I8B ) :: CurNum ! current (saved) working number INTEGER ( KIND = I8B ) :: RemNum ! remainder number INTEGER ( KIND = I4B ) :: Indx !** FLOW ! check whether the number is zero IF ( Number == 0_I8B ) THEN cStr = '0' RETURN END IF IF ( Number < 0_I8B ) THEN IF ( Number == MinI64 ) THEN cStr = '-8000000000000000' RETURN END IF PosNum = ABS ( Number ) ELSE PosNum = Number END IF Indx = MaxLen ! start the conversion DO ! save current number CurNum = PosNum ! compute the next round of working number PosNum = SHIFTR ( PosNum , Shift ) ! compute the remainder RemNum = CurNum - SHIFTL ( PosNum , Shift ) ! convert the remainder to a working string wStr ( Indx : Indx ) = NumStr ( RemNum ) Indx = Indx - 1 IF ( PosNum == 0_I8B ) EXIT END DO ! allocate the resulting string and transfer ! characters from the working string Indx = Indx + 1 IF ( Number < 0_I8B ) THEN cStr = '-' // wStr ( Indx : MaxLen ) ELSE cStr = wStr ( Indx : MaxLen ) END IF RETURN END FUNCTION I64_ToHexStr !****************************************************************************** FUNCTION U64_ToHexStr ( Number ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert an unsigned integer number to a hexadecimal string IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Number ! number treated as unsigned one CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! hexadecimal string !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Shift = 4 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Quotient , Remainder CHARACTER ( LEN = :), ALLOCATABLE :: QuotStr , RemStr !** FLOW IF ( Number >= 0_I8B ) THEN cStr = I64_ToHexStr ( Number ) ELSE Quotient = SHIFTR ( Number , Shift ) Remainder = Number - SHIFTL ( Quotient , Shift ) QuotStr = I64_ToHexStr ( Quotient ) RemStr = I64_ToHexStr ( Remainder ) cStr = QuotStr // RemStr END IF RETURN END FUNCTION U64_ToHexStr !****************************************************************************** END FUNCTION HexString_From_U128 !------------------------------------------------------------------------------ ! !                           comparison ROUTINES ! !------------------------------------------------------------------------------ FUNCTION U128_Equal ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether two Uint128 objects are equal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( LHS % High == RHS % High ). AND .( LHS % Low == RHS % Low ) RETURN END FUNCTION U128_Equal !****************************************************************************** FUNCTION U128_NotEqual ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether two Uint128 objects are NOT equal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( LHS % High /= RHS % High ). OR .( LHS % Low /= RHS % Low ) RETURN END FUNCTION U128_NotEqual !****************************************************************************** FUNCTION U128_LessThan ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS Uint128 object is less than the RHS Uint128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) < IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( IEOR ( LHS % High , MinI64 ) < IEOR ( RHS % High , MinI64 )) END IF RETURN END FUNCTION U128_LessThan !****************************************************************************** FUNCTION U128_LessEqual ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS Uint128 object is less than or equal to the RHS Uint128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) <= IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( IEOR ( LHS % High , MinI64 ) <= IEOR ( RHS % High , MinI64 )) END IF RETURN END FUNCTION U128_LessEqual !****************************************************************************** FUNCTION U128_GreaterThan ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS Uint128 object is greater than the RHS Uint128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) > IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( IEOR ( LHS % High , MinI64 ) > IEOR ( RHS % High , MinI64 )) END IF RETURN END FUNCTION U128_GreaterThan !****************************************************************************** FUNCTION U128_GreaterEqual ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the LHS Uint128 object is greater than or equal to the RHS Uint128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( LHS % High == RHS % High ) THEN Flag = ( IEOR ( LHS % Low , MinI64 ) >= IEOR ( RHS % Low , MinI64 )) ELSE Flag = ( IEOR ( LHS % High , MinI64 ) >= IEOR ( RHS % High , MinI64 )) END IF RETURN END FUNCTION U128_GreaterEqual !****************************************************************************** FUNCTION U128_Compare ( LHS , RHS ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare LHS and RHS objects. !   -> return -1 if LHS < RHS !   -> return  0 if LHS == RHS !   -> return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LHS TYPE ( UInt128 ), INTENT ( IN ) :: RHS INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: ULHS , URHS !** FLOW ULHS = IEOR ( LHS % High , MinI64 ) URHS = IEOR ( RHS % High , MinI64 ) IF ( ULHS < URHS ) THEN Flag = - 1 ELSEIF ( ULHS > URHS ) THEN Flag = + 1 ELSE ULHS = IEOR ( LHS % Low , MinI64 ) URHS = IEOR ( RHS % Low , MinI64 ) IF ( ULHS < URHS ) THEN Flag = - 1 ELSEIF ( ULHS > URHS ) THEN Flag = + 1 ELSE Flag = 0 END IF END IF RETURN END FUNCTION U128_Compare !------------------------------------------------------------------------------ ! !                           BITWISE ROUTINES ! !------------------------------------------------------------------------------ FUNCTION U128_ShiftLeftOnce ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IOR ( SHIFTL ( InVal % High , 1 ), SHIFTR ( InVal % Low , 63 )) OutVal % Low = SHIFTL ( InVal % Low , 1 ) RETURN END FUNCTION U128_ShiftLeftOnce !****************************************************************************** FUNCTION U128_ShiftRightOnce ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTR ( InVal % High , 1 ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , 1 ), SHIFTL ( InVal % High , 63 )) RETURN END FUNCTION U128_ShiftRightOnce !****************************************************************************** FUNCTION U128_ShiftLeft64 ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 64. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = InVal % Low OutVal % Low = 0_I8B RETURN END FUNCTION U128_ShiftLeft64 !****************************************************************************** FUNCTION U128_ShiftRight64 ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 64 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = 0_I8B OutVal % Low = InVal % High RETURN END FUNCTION U128_ShiftRight64 !****************************************************************************** FUNCTION U128_ShiftLeft63Down ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 63 or less. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! 0 <= ShiftPos < 64 TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IOR ( SHIFTL ( InVal % High , ShiftPos ), SHIFTR ( InVal % Low , 64 - ShiftPos )) OutVal % Low = SHIFTL ( InVal % Low , ShiftPos ) RETURN END FUNCTION U128_ShiftLeft63Down !****************************************************************************** FUNCTION U128_ShiftRight63Down ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 63 or less. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! 0 <= ShiftPos < 64 TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTR ( InVal % High , ShiftPos ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , ShiftPos ), SHIFTL ( InVal % High , 64 - ShiftPos )) RETURN END FUNCTION U128_ShiftRight63Down !****************************************************************************** FUNCTION U128_ShiftLeft64Up ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift by 64 or more. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! 64 < ShiftPos <= 128 TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = SHIFTL ( InVal % Low , ShiftPos - 64 ) OutVal % Low = 0_I8B RETURN END FUNCTION U128_ShiftLeft64Up !****************************************************************************** FUNCTION U128_ShiftRight64Up ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift by 64 or more. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! 64 < ShiftPos <= 128 TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = 0_I8B OutVal % Low = SHIFTR ( InVal % High , ShiftPos - 64 ) RETURN END FUNCTION U128_ShiftRight64Up !****************************************************************************** FUNCTION U128_ShiftLogical ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical (left or right) shift of the UInt128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! -128 <= ShiftPos <= 128; !! -> positive, the shift is to the left; !! -> negative, the shift is to the right TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN OutVal = SHIFTR ( InVal , - ShiftPos ) ELSE OutVal = SHIFTL ( InVal , ShiftPos ) END IF RETURN END FUNCTION U128_ShiftLogical !****************************************************************************** FUNCTION U128_ShiftLeft ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical left shift of the UInt128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! 0 <= ShiftPos <= 128 TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_ShiftLeft' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'ShiftPos must be nonnegative number' ) ELSEIF ( ShiftPos == 0 ) THEN OutVal = InVal ELSEIF ( ShiftPos >= 128 ) THEN OutVal = ZeroU128 ELSEIF ( ShiftPos >= 64 ) THEN OutVal % High = SHIFTL ( InVal % Low , ShiftPos - 64 ) OutVal % Low = 0_I8B ELSE OutVal % High = IOR ( SHIFTL ( InVal % High , ShiftPos ), SHIFTR ( InVal % Low , 64 - ShiftPos )) OutVal % Low = SHIFTL ( InVal % Low , ShiftPos ) END IF RETURN END FUNCTION U128_ShiftLeft !****************************************************************************** FUNCTION U128_ShiftRight ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform logical right shift of the UInt128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! 0 <= ShiftPos <= 128 TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ShiftPos < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_ShiftRight' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'ShiftPos must be nonnegative number' ) ELSEIF ( ShiftPos == 0 ) THEN OutVal = InVal ELSEIF ( ShiftPos >= 128 ) THEN OutVal = ZeroU128 ELSEIF ( ShiftPos >= 64 ) THEN OutVal % High = 0_I8B OutVal % Low = SHIFTR ( InVal % High , ShiftPos - 64 ) ELSE OutVal % High = SHIFTR ( InVal % High , ShiftPos ) OutVal % Low = IOR ( SHIFTR ( InVal % Low , ShiftPos ), SHIFTL ( InVal % High , 64 - ShiftPos )) END IF RETURN END FUNCTION U128_ShiftRight !****************************************************************************** FUNCTION U128_Rotate ( InVal , ShiftPos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform a circular shift of the rightmost bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !! -128 <= ShiftPos <= 128; !! -> positive, the shift is to the left; !! -> negative, the shift is to the right TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LeftShift !** FLOW IF ( ShiftPos == 0 ) THEN OutVal = InVal RETURN ELSEIF ( ABS ( ShiftPos ) == 128 ) THEN OutVal = ZeroU128 RETURN ELSEIF ( ABS ( ShiftPos ) > 128 ) THEN LeftShift = MOD ( ShiftPos , 128 ) ELSE LeftShift = ShiftPos END IF IF ( LeftShift < 0 ) LeftShift = 128 + LeftShift OutVal = IOR ( SHIFTL ( InVal , LeftShift ), SHIFTR ( InVal , 128 - LeftShift )) RETURN END FUNCTION U128_Rotate !****************************************************************************** FUNCTION U128_Not ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To return the bitwise logical complement of the UInt128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = NOT ( InVal % High ) OutVal % Low = NOT ( InVal % Low ) RETURN END FUNCTION U128_Not !****************************************************************************** FUNCTION U128_Ior ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform an inclusive OR on corresponding bits of the UInt128 objects. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IOR ( LhsVal % High , RhsVal % High ) OutVal % Low = IOR ( LhsVal % Low , RhsVal % Low ) RETURN END FUNCTION U128_Ior !****************************************************************************** FUNCTION U128_Iand ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform a logical AND on corresponding bits of the UInt128 objects. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IAND ( LhsVal % High , RhsVal % High ) OutVal % Low = IAND ( LhsVal % Low , RhsVal % Low ) RETURN END FUNCTION U128_Iand !****************************************************************************** FUNCTION U128_Ieor ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform an exclusive OR on corresponding bits of the UInt128 objects. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = IEOR ( LhsVal % High , RhsVal % High ) OutVal % Low = IEOR ( LhsVal % Low , RhsVal % Low ) RETURN END FUNCTION U128_Ieor !****************************************************************************** FUNCTION U128_LeadingZeros ( U128 ) RESULT ( NumLZ ) !** PURPOSE OF THIS SUBROUTINE: !! To count the number of leading zero bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I4B ) :: NumLZ !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( U128 % High == 0_I8B ) THEN NumLZ = LEADZ ( U128 % Low ) + 64 ELSE NumLZ = LEADZ ( U128 % High ) END IF RETURN END FUNCTION U128_LeadingZeros !****************************************************************************** FUNCTION U128_TrailingZeros ( U128 ) RESULT ( NumTZ ) !** PURPOSE OF THIS SUBROUTINE: !! To count the number of trailing zero bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I4B ) :: NumTZ !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( U128 % Low == 0_I8B ) THEN NumTZ = TRAILZ ( U128 % High ) + 64 ELSE NumTZ = TRAILZ ( U128 % Low ) END IF RETURN END FUNCTION U128_TrailingZeros !****************************************************************************** FUNCTION U128_Count1Bits ( U128 ) RESULT ( NumBits ) !** PURPOSE OF THIS SUBROUTINE: !! To count the number of 1 bits in the specified input. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I4B ) :: NumBits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW NumBits = POPCNT ( U128 % Low ) + POPCNT ( U128 % High ) RETURN END FUNCTION U128_Count1Bits !****************************************************************************** FUNCTION U128_Parity ( U128 ) RESULT ( ParNum ) !** PURPOSE OF THIS SUBROUTINE: !! To determine the parity of the specified input. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I4B ) :: ParNum !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! ParNum = IAND(POPCNT(U128), 1) ParNum = POPPAR ( U128 % Low ) + POPPAR ( U128 % High ) IF ( ParNum == 2 ) ParNum = 0 RETURN END FUNCTION U128_Parity !****************************************************************************** FUNCTION U128_SetBit ( InVal , Pos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the bit at the specified position to 1. !   For more detail, see explanation of elemental intrinsic function 'IBSET'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_SetBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroU128 RETURN END IF IF ( Pos < 64 ) THEN OutVal % Low = IBSET ( InVal % Low , Pos ) OutVal % High = InVal % High ELSE OutVal % Low = InVal % Low OutVal % High = IBSET ( InVal % High , Pos - 64 ) END IF RETURN END FUNCTION U128_SetBit !****************************************************************************** FUNCTION U128_ClearBit ( InVal , Pos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the bit at the specified position to 0. !   For more detail, see explanation of elemental intrinsic function 'IBCLR'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_ClearBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroU128 RETURN END IF IF ( Pos < 64 ) THEN OutVal % Low = IBCLR ( InVal % Low , Pos ) OutVal % High = InVal % High ELSE OutVal % Low = InVal % Low OutVal % High = IBCLR ( InVal % High , Pos - 64 ) END IF RETURN END FUNCTION U128_ClearBit !****************************************************************************** FUNCTION U128_FlipBit ( InVal , Pos ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To reverse the bit at the specified position. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: HiPos !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_FlipBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroU128 RETURN END IF IF ( Pos < 64 ) THEN IF ( BTEST ( InVal % Low , Pos )) THEN ! clear bit OutVal % Low = IBCLR ( InVal % Low , Pos ) ELSE ! set bit OutVal % Low = IBSET ( InVal % Low , Pos ) END IF OutVal % High = InVal % High ELSE HiPos = Pos - 64 IF ( BTEST ( InVal % High , HiPos )) THEN ! clear bit OutVal % High = IBCLR ( InVal % High , HiPos ) ELSE ! set bit OutVal % High = IBSET ( InVal % High , HiPos ) END IF OutVal % Low = InVal % Low END IF RETURN END FUNCTION U128_FlipBit !****************************************************************************** FUNCTION U128_TestBit ( U128 , Pos ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the bit at the specified position is 0 (False) or 1 (True). !   For more detail, see explanation of elemental intrinsic function 'BTEST'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_TestBit' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) Flag = . FALSE . RETURN END IF IF ( Pos < 64 ) THEN Flag = BTEST ( U128 % Low , Pos ) ELSE Flag = BTEST ( U128 % High , Pos - 64 ) END IF RETURN END FUNCTION U128_TestBit !****************************************************************************** FUNCTION U128_ExtractBits ( InVal , Pos , Len ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To extract a sequence of bits according to the specified input. !   For more detail, see explanation of elemental intrinsic function 'IBITS'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: Pos INTEGER ( KIND = I4B ), INTENT ( IN ) :: Len TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Len1 , Len2 , Len3 !** FLOW ! first, check input validity IF ( Len < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_ExtractBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Len must be nonnegative.' ) OutVal = ZeroU128 RETURN ELSEIF ( Len == 0 ) THEN OutVal = ZeroU128 RETURN ELSEIF (( Pos < 0 ). OR .( Pos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_ExtractBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos must be between 0 and 127.' ) OutVal = ZeroU128 RETURN ELSEIF ( Pos + Len > 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_ExtractBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Pos + Len > 128.' ) OutVal = ZeroU128 RETURN END IF OutVal = ZeroU128 IF ( Pos < 64 ) THEN IF ( Pos + Len <= 64 ) THEN ! bit fields are in only lower elements of both input and output CALL MVBITS ( InVal % Low , Pos , Len , OutVal % Low , 0 ) ELSE IF ( Len <= 64 ) THEN ! bit fields are in both lower and upper elements of input ! but only in lower element of output Len1 = 64 - Pos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , Pos , Len1 , OutVal % Low , 0 ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , Len1 ) ELSE ! bit fields are in lower and upper elements of both input and output Len1 = 64 - Pos ! Input%Low  -> Output%Low Len2 = 64 - Len1 ! Input%High -> Output%Low Len3 = Len - ( Len1 + Len2 ) ! Input%High -> Output%High CALL MVBITS ( InVal % Low , Pos , Len1 , OutVal % Low , 0 ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , Len1 ) CALL MVBITS ( InVal % High , Len2 , Len3 , OutVal % High , 0 ) END IF END IF ELSE ! one of the simplest cases where bit fields are in upper element of input ! and in lower element of output CALL MVBITS ( InVal % High , Pos - 64 , Len , OutVal % Low , 0 ) END IF RETURN END FUNCTION U128_ExtractBits !****************************************************************************** SUBROUTINE U128_MoveBits ( InVal , InPos , Len , OutVal , OutPos ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy a sequence of bits (a bit field) from one location to another. !   For more detail, see explanation of elemental intrinsic subroutine 'MVBITS'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: InPos INTEGER ( KIND = I4B ), INTENT ( IN ) :: Len TYPE ( UInt128 ), INTENT ( INOUT ) :: OutVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: OutPos !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Len1 , Len2 , Len3 !** FLOW ! first, check input validity IF ( Len < 0 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Len must be nonnegative.' ) RETURN ELSEIF ( Len == 0 ) THEN RETURN ELSEIF (( InPos < 0 ). OR .( InPos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'InPos must be between 0 and 127.' ) RETURN ELSEIF (( OutPos < 0 ). OR .( OutPos > 127 )) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'OutPos must be between 0 and 127.' ) RETURN ELSEIF ( InPos + Len > 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'InPos + Len > 128.' ) RETURN ELSEIF ( OutPos + Len > 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_MoveBits' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'OutPos + Len > 128.' ) RETURN END IF IF ( InPos < 64 ) THEN IF ( InPos + Len <= 64 ) THEN IF ( OutPos < 64 ) THEN IF ( OutPos + Len <= 64 ) THEN ! one of the simplest cases where bit fields are in lower elements CALL MVBITS ( InVal % Low , InPos , Len , OutVal % Low , OutPos ) ELSE ! bit fields are in lower element of input but in both lower and ! upper elements of output Len1 = 64 - OutPos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % Low , InPos + Len1 , Len2 , OutVal % High , 0 ) END IF ELSE ! one of the simplest cases where bit fields are in lower element of input ! and upper element of output, respectively CALL MVBITS ( InVal % Low , InPos , Len , OutVal % High , OutPos - 64 ) END IF ELSE IF ( OutPos < 64 ) THEN IF ( OutPos + Len <= 64 ) THEN ! bit fields are in both lower and upper element of input but ! only in lower element of output Len1 = 64 - InPos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , OutPos + Len1 ) ELSE ! the most complicated cases where bit fields are in lower ! and upper elements of both input and output IF ( InPos == OutPos ) THEN Len1 = 64 - InPos ! Input%Low  -> Output%Low Len2 = Len - Len1 ! Input%High -> Output%High CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % High , 0 ) ELSEIF ( InPos < OutPos ) THEN Len1 = 64 - OutPos ! Input%Low  -> Output%Low Len2 = 64 - ( InPos + Len1 ) ! Input%Low  -> Output%High Len3 = Len - ( Len1 + Len2 ) ! Input%High -> Output%High CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % Low , InPos + Len1 , Len2 , OutVal % High , 0 ) CALL MVBITS ( InVal % High , 0 , Len3 , OutVal % High , Len2 ) ELSE Len1 = 64 - InPos ! Input%Low  -> Output%Low Len2 = 64 - ( OutPos + Len1 ) ! Input%High -> Output%Low Len3 = Len - ( Len1 + Len2 ) ! Input%High -> Output%High CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % Low , OutPos + Len1 ) CALL MVBITS ( InVal % High , Len2 , Len3 , OutVal % High , 0 ) END IF END IF ELSE ! bit fields are in both lower and upper element of input but ! only in upper element of output Len1 = 64 - InPos Len2 = Len - Len1 CALL MVBITS ( InVal % Low , InPos , Len1 , OutVal % High , OutPos - 64 ) CALL MVBITS ( InVal % High , 0 , Len2 , OutVal % High , OutPos - 64 + Len1 ) END IF END IF ELSE IF ( OutPos < 64 ) THEN IF ( OutPos + Len <= 64 ) THEN ! one of the simplest cases where bit fields are in upper element of input ! and lower element of output, respectively CALL MVBITS ( InVal % High , InPos - 64 , Len , OutVal % Low , OutPos ) ELSE ! bit fields are in upper element of input but in both lower and ! upper elements of output Len1 = 64 - OutPos Len2 = Len - Len1 CALL MVBITS ( InVal % High , InPos - 64 , Len1 , OutVal % Low , OutPos ) CALL MVBITS ( InVal % High , InPos - 64 + Len1 , Len2 , OutVal % High , 0 ) END IF ELSE ! one of the simplest cases where bit fields are in upper elements CALL MVBITS ( InVal % High , InPos - 64 , Len , OutVal % High , OutPos - 64 ) END IF END IF RETURN END SUBROUTINE U128_MoveBits !------------------------------------------------------------------------------ ! !                           ARITHMETIC ROUTINES ! !------------------------------------------------------------------------------ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++                    ADDITION OPERATIONS                   ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION U128_UnaryPlus ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To return result of the unary plus sign of the Uint128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! !** FLOW OutVal = InVal RETURN END FUNCTION U128_UnaryPlus !****************************************************************************** SUBROUTINE U128_Increment ( Val ) !** PURPOSE OF THIS SUBROUTINE: !! To increase value of the input by 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! !** FLOW IF ( Val % Low == - 1_I8B ) THEN Val % High = Val % High + 1_I8B Val % Low = 0_I8B ELSE Val % Low = Val % Low + 1_I8B END IF RETURN END SUBROUTINE U128_Increment !****************************************************************************** SUBROUTINE U128_Add_U32 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  This = This + Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other !! value treated as unsigned integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , OutLo !** FLOW CALL AddU64 ( This % Low , ToUnsignedLong ( Other ), 0_I8B , OutLo , Carry ) This % Low = OutLo This % High = This % High + Carry RETURN END SUBROUTINE U128_Add_U32 !****************************************************************************** SUBROUTINE U128_Add_U64 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  This = This + Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other !! value treated as unsigned integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , OutLo !** FLOW CALL AddU64 ( This % Low , Other , 0_I8B , OutLo , Carry ) This % Low = OutLo This % High = This % High + Carry RETURN END SUBROUTINE U128_Add_U64 !****************************************************************************** SUBROUTINE U128_Add_U128 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  This = This + Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This TYPE ( UInt128 ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , OutLo , OutHi !** FLOW CALL AddU64 ( This % Low , Other % Low , 0_I8B , OutLo , Carry ) CALL AddU64 ( This % High , Other % High , Carry , OutHi ) This % Low = OutLo This % High = OutHi RETURN END SUBROUTINE U128_Add_U128 !****************************************************************************** FUNCTION U128_Plus_U32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: RhsVal !! value treated as unsigned integer TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal % Low , ToUnsignedLong ( RhsVal ), 0_I8B , OutVal % Low , Carry ) OutVal % High = LhsVal % High + Carry RETURN END FUNCTION U128_Plus_U32 !****************************************************************************** FUNCTION U32_Plus_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LhsVal !! value treated as unsigned integer TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( ToUnsignedLong ( LhsVal ), RhsVal % Low , 0_I8B , OutVal % Low , Carry ) OutVal % High = RhsVal % High + Carry RETURN END FUNCTION U32_Plus_U128 !****************************************************************************** FUNCTION U128_Plus_U64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I8B ), INTENT ( IN ) :: RhsVal !! value treated as unsigned integer TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal % Low , RhsVal , 0_I8B , OutVal % Low , Carry ) OutVal % High = LhsVal % High + Carry RETURN END FUNCTION U128_Plus_U64 !****************************************************************************** FUNCTION U64_Plus_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsVal !! value treated as unsigned integer TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal , RhsVal % Low , 0_I8B , OutVal % Low , Carry ) OutVal % High = RhsVal % High + Carry RETURN END FUNCTION U64_Plus_U128 !****************************************************************************** FUNCTION U128_Plus_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform addition:  OutVal = LhsVal + RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL AddU64 ( LhsVal % Low , RhsVal % Low , 0_I8B , OutVal % Low , Carry ) CALL AddU64 ( LhsVal % High , RhsVal % High , Carry , OutVal % High ) RETURN END FUNCTION U128_Plus_U128 !****************************************************************************** PURE SUBROUTINE AddU64 ( X , Y , CarryIn , Sum , CarryOut ) !DIR$ ATTRIBUTES INLINE :: AddU64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the sum with carry of X, Y and CarryIn: Sum = X + Y + CarryIn. !   The carry input must be 0 or 1; otherwise the behavior is undefined. !   The carry output is guaranteed to be 0 or 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y , CarryIn !! values treated as unsigned integers INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Sum , CarryOut !! values treated as unsigned integers OPTIONAL :: CarryOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Sum = X + Y + CarryIn ! The sum will overflow if both top bits are set (x & y) or if one of them ! is (x | y), and a carry from the lower place happened. If such a carry ! happens, the top bit will be 1 + 0 + 1 = 0 (&&#94; sum). IF ( PRESENT ( CarryOut )) THEN CarryOut = SHIFTR ( IOR ( IAND ( X , Y ), IAND ( IOR ( X , Y ), NOT ( Sum ))), 63 ) END IF RETURN END SUBROUTINE AddU64 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++                  SUBTRACTION OPERATIONS                  ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION U128_Negate ( InVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To negate the Uint128 object. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: InVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal % High = NOT ( InVal % High ) IF ( InVal % Low == 0_I8B ) OutVal % High = OutVal % High + 1_I8B OutVal % Low = NOT ( InVal % Low ) + 1_I8B RETURN END FUNCTION U128_Negate !****************************************************************************** SUBROUTINE U128_Decrement ( Val ) !** PURPOSE OF THIS SUBROUTINE: !! To decrease value of the input by 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! !** FLOW IF ( Val % Low == 0_I8B ) THEN Val % High = Val % High - 1_I8B Val % Low = - 1_I8B ELSE Val % Low = Val % Low - 1_I8B END IF RETURN END SUBROUTINE U128_Decrement !****************************************************************************** SUBROUTINE U128_Subtract_U32 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  This = This - Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other !! value treated as unsigned integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow , OutLo !** FLOW CALL SubU64 ( This % Low , ToUnsignedLong ( Other ), 0_I8B , OutLo , Borrow ) This % Low = OutLo This % High = This % High - Borrow RETURN END SUBROUTINE U128_Subtract_U32 !****************************************************************************** SUBROUTINE U128_Subtract_U64 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  This = This - Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other !! value treated as unsigned integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow , OutLo !** FLOW CALL SubU64 ( This % Low , Other , 0_I8B , OutLo , Borrow ) This % Low = OutLo This % High = This % High - Borrow RETURN END SUBROUTINE U128_Subtract_U64 !****************************************************************************** SUBROUTINE U128_Subtract_U128 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  This = This - Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This TYPE ( UInt128 ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow , OutLo , OutHi !** FLOW CALL SubU64 ( This % Low , Other % Low , 0_I8B , OutLo , Borrow ) CALL SubU64 ( This % High , Other % High , Borrow , OutHi ) This % Low = OutLo This % High = OutHi RETURN END SUBROUTINE U128_Subtract_U128 !****************************************************************************** FUNCTION U128_Minus_U32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: RhsVal !! value treated as unsigned integer TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal % Low , ToUnsignedLong ( RhsVal ), 0_I8B , OutVal % Low , Borrow ) OutVal % High = LhsVal % High - Borrow RETURN END FUNCTION U128_Minus_U32 !****************************************************************************** FUNCTION U32_Minus_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LhsVal !! value treated as unsigned integer TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( ToUnsignedLong ( LhsVal ), RhsVal % Low , 0_I8B , OutVal % Low , Borrow ) OutVal % High = - ( RhsVal % High + Borrow ) RETURN END FUNCTION U32_Minus_U128 !****************************************************************************** FUNCTION U128_Minus_U64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I8B ), INTENT ( IN ) :: RhsVal !! value treated as unsigned integer TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal % Low , RhsVal , 0_I8B , OutVal % Low , Borrow ) OutVal % High = LhsVal % High - Borrow RETURN END FUNCTION U128_Minus_U64 !****************************************************************************** FUNCTION U64_Minus_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsVal !! value treated as unsigned integer TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal , RhsVal % Low , 0_I8B , OutVal % Low , Borrow ) OutVal % High = - ( RhsVal % High + Borrow ) RETURN END FUNCTION U64_Minus_U128 !****************************************************************************** FUNCTION U128_Minus_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform subtraction:  OutVal = LhsVal - RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Borrow !** FLOW CALL SubU64 ( LhsVal % Low , RhsVal % Low , 0_I8B , OutVal % Low , Borrow ) CALL SubU64 ( LhsVal % High , RhsVal % High , Borrow , OutVal % High ) RETURN END FUNCTION U128_Minus_U128 !****************************************************************************** PURE SUBROUTINE SubU64 ( X , Y , BorrowIn , Diff , BorrowOut ) !DIR$ ATTRIBUTES INLINE :: SubU64 !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the difference of X, Y and BorrowIn: Diff = X - Y - BorrowIn. !   The borrow input must be 0 or 1; otherwise the behavior is undefined. !   The borrow output is guaranteed to be 0 or 1. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y , BorrowIn !! values treated as unsigned integers INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Diff , BorrowOut !! values treated as unsigned integers OPTIONAL :: BorrowOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Diff = X - Y - BorrowIn ! The difference will underflow if the top bit of x is not set and the top ! bit of y is set (&#94;x & y) or if they are the same (&#94;(x &#94; y)) and a Borrow ! from the lower place happens. If that Borrow happens, the result will be ! 1 - 1 - 1 = 0 - 0 - 1 = 1 (& diff). IF ( PRESENT ( BorrowOut )) THEN BorrowOut = SHIFTR ( IOR ( IAND ( NOT ( X ), Y ), IAND ( NOT ( IEOR ( X , Y )), Diff )), 63 ) END IF RETURN END SUBROUTINE SubU64 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++                 MULTIPLICATION OPERATIONS                ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE U128_Times_U32 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  This = This * Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Cross !** FLOW X_Lo = IAND ( INT ( Other , KIND = I8B ), Mask32 ) Y_Lo = IAND ( This % Low , Mask32 ) Y_Hi = SHIFTR ( This % Low , 32 ) Lo_Lo = X_Lo * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + X_Lo * Y_Hi This % High = This % High * Other + SHIFTR ( Cross , 32 ) This % Low = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , Mask32 )) RETURN END SUBROUTINE U128_Times_U32 !****************************************************************************** SUBROUTINE U128_Times_U64 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  This = This * Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , ProductLow !** FLOW CALL UMul128 ( This % Low , Other , Carry , ProductLow ) This % High = This % High * Other + Carry This % Low = ProductLow RETURN END SUBROUTINE U128_Times_U64 !****************************************************************************** SUBROUTINE U128_Times_U128 ( This , Other ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  This = This * Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This TYPE ( UInt128 ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry , ProductLow !** FLOW CALL UMul128 ( This % Low , Other % Low , Carry , ProductLow ) This % High = This % Low * Other % High + This % High * Other % Low + Carry This % Low = ProductLow RETURN END SUBROUTINE U128_Times_U128 !****************************************************************************** FUNCTION U32_Multiply_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Cross !** FLOW X_Lo = IAND ( INT ( LhsVal , KIND = I8B ), Mask32 ) Y_Lo = IAND ( RhsVal % Low , Mask32 ) Y_Hi = SHIFTR ( RhsVal % Low , 32 ) Lo_Lo = X_Lo * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + X_Lo * Y_Hi OutVal % High = LhsVal * RhsVal % High + SHIFTR ( Cross , 32 ) OutVal % Low = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , Mask32 )) RETURN END FUNCTION U32_Multiply_U128 !****************************************************************************** FUNCTION U128_Multiply_U32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I4B ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X_Lo , Y_Lo , Y_Hi INTEGER ( KIND = I8B ) :: Lo_Lo , Cross !** FLOW X_Lo = IAND ( INT ( RhsVal , KIND = I8B ), Mask32 ) Y_Lo = IAND ( LhsVal % Low , Mask32 ) Y_Hi = SHIFTR ( LhsVal % Low , 32 ) Lo_Lo = X_Lo * Y_Lo Cross = SHIFTR ( Lo_Lo , 32 ) + X_Lo * Y_Hi OutVal % High = RhsVal * LhsVal % High + SHIFTR ( Cross , 32 ) OutVal % Low = IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , Mask32 )) RETURN END FUNCTION U128_Multiply_U32 !****************************************************************************** FUNCTION U64_Multiply_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL UMul128 ( LhsVal , RhsVal % Low , Carry , OutVal % Low ) OutVal % High = LhsVal * RhsVal % High + Carry RETURN END FUNCTION U64_Multiply_U128 !****************************************************************************** FUNCTION U128_Multiply_U64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal INTEGER ( KIND = I8B ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL UMul128 ( LhsVal % Low , RhsVal , Carry , OutVal % Low ) OutVal % High = LhsVal % High * RhsVal + Carry RETURN END FUNCTION U128_Multiply_U64 !****************************************************************************** FUNCTION U128_Multiply_U128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !! To perform multiplication:  OutVal = LhsVal * RhsVal. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: LhsVal TYPE ( UInt128 ), INTENT ( IN ) :: RhsVal TYPE ( UInt128 ) :: OutVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry !** FLOW CALL UMul128 ( LhsVal % Low , RhsVal % Low , Carry , OutVal % Low ) OutVal % High = LhsVal % Low * RhsVal % High + LhsVal % High * RhsVal % Low + Carry RETURN END FUNCTION U128_Multiply_U128 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !++++++++++             DIVISION/MODULATION OPERATIONS               ++++++++++ !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE U128_DivMod_U32 ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division:  Quotient = Dividend / Divisor. !   And, to return both quotient and remainder. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL U128_DivMod_U128 ( Dividend , UInt128 ( Divisor , AsUnsigned ), Quotient , Remainder ) RETURN END SUBROUTINE U128_DivMod_U32 !****************************************************************************** SUBROUTINE U128_DivMod_U64 ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division:  Quotient = Dividend / Divisor. !   And, to return both quotient and remainder. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL U128_DivMod_U128 ( Dividend , UInt128 ( Divisor , AsUnsigned ), Quotient , Remainder ) RETURN END SUBROUTINE U128_DivMod_U64 !****************************************************************************** SUBROUTINE U128_DivMod_U128 ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division:  Quotient = Dividend / Divisor. !   And, to return both quotient and remainder. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend TYPE ( UInt128 ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Dividend % High < 0_I8B ) THEN CALL U128_DivMod_Intx ( Dividend , Divisor , Quotient , Remainder ) ELSE CALL U128_DivMod_Java ( Dividend , Divisor , Quotient , Remainder ) END IF RETURN END SUBROUTINE U128_DivMod_U128 !****************************************************************************** SUBROUTINE U128_Over_U32 ( This , Other , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  This = This / Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I4B ), INTENT ( IN ) :: Other INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Dividend , Rem !** FLOW Dividend = This CALL U128_DivMod_U128 ( Dividend , UInt128 ( Other , AsUnsigned ), This , Rem ) IF ( PRESENT ( Remainder )) Remainder = Rem RETURN END SUBROUTINE U128_Over_U32 !****************************************************************************** SUBROUTINE U128_Over_U64 ( This , Other , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  This = This / Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This INTEGER ( KIND = I8B ), INTENT ( IN ) :: Other INTEGER ( KIND = I8B ), OPTIONAL , INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Dividend , Rem !** FLOW Dividend = This CALL U128_DivMod_U128 ( Dividend , UInt128 ( Other , AsUnsigned ), This , Rem ) IF ( PRESENT ( Remainder )) Remainder = Rem RETURN END SUBROUTINE U128_Over_U64 !****************************************************************************** SUBROUTINE U128_Over_U128 ( This , Other , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  This = This / Other. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( INOUT ) :: This TYPE ( UInt128 ), INTENT ( IN ) :: Other TYPE ( UInt128 ), OPTIONAL , INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Dividend , Rem !** FLOW Dividend = This IF ( PRESENT ( Remainder )) THEN CALL U128_DivMod_U128 ( Dividend , Other , This , Remainder ) ELSE CALL U128_DivMod_U128 ( Dividend , Other , This , Rem ) END IF RETURN END SUBROUTINE U128_Over_U128 !****************************************************************************** FUNCTION U128_Divide_U32 ( Dividend , Divisor ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  Quotient = Dividend / Divisor. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Remainder !** FLOW CALL U128_DivMod_U128 ( Dividend , UInt128 ( Divisor , AsUnsigned ), Quotient , Remainder ) RETURN END FUNCTION U128_Divide_U32 !****************************************************************************** FUNCTION U128_Divide_U64 ( Dividend , Divisor ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  Quotient = Dividend / Divisor. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Remainder !** FLOW CALL U128_DivMod_U128 ( Dividend , UInt128 ( Divisor , AsUnsigned ), Quotient , Remainder ) RETURN END FUNCTION U128_Divide_U64 !****************************************************************************** FUNCTION U128_Divide_U128 ( Dividend , Divisor ) RESULT ( Quotient ) !** PURPOSE OF THIS SUBROUTINE: !! To perform division:  Quotient = Dividend / Divisor. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend TYPE ( UInt128 ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ) :: Quotient !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Remainder !** FLOW CALL U128_DivMod_U128 ( Dividend , Divisor , Quotient , Remainder ) RETURN END FUNCTION U128_Divide_U128 !****************************************************************************** FUNCTION U128_Mod_U32 ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform modulation:  Remainder = Dividend MOD Divisor. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Quotient !** FLOW CALL U128_DivMod_U128 ( Dividend , UInt128 ( Divisor , AsUnsigned ), Quotient , Remainder ) RETURN END FUNCTION U128_Mod_U32 !****************************************************************************** FUNCTION U128_Mod_U64 ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform modulation:  Remainder = Dividend MOD Divisor. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Quotient !** FLOW CALL U128_DivMod_U128 ( Dividend , UInt128 ( Divisor , AsUnsigned ), Quotient , Remainder ) RETURN END FUNCTION U128_Mod_U64 !****************************************************************************** FUNCTION U128_Mod_U128 ( Dividend , Divisor ) RESULT ( Remainder ) !** PURPOSE OF THIS SUBROUTINE: !! To perform modulation:  Remainder = Dividend MOD Divisor. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend TYPE ( UInt128 ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Quotient !** FLOW CALL U128_DivMod_U128 ( Dividend , Divisor , Quotient , Remainder ) RETURN END FUNCTION U128_Mod_U128 !****************************************************************************** SUBROUTINE U128_DivMod_Java ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division of two UInt128 objects (Dividend / Divisor) !   and return both the quotient and the remainder. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend TYPE ( UInt128 ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NumerLZ INTEGER ( KIND = I4B ) :: DenomLZ INTEGER ( KIND = I4B ) :: DenomTZ INTEGER ( KIND = I4B ) :: CompFlag !** FLOW IF ( Divisor == ZeroU128 ) THEN ! division by zero Quotient = ZeroU128 Remainder = ZeroU128 CALL DisplaySevereError ( 'Message from Routine ' // 'U128_DivMod_Java' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'The divisor must not be zero.' ) RETURN END IF CompFlag = CompareU128 ( Dividend % High , Dividend % Low , Divisor % High , Divisor % Low ) IF ( CompFlag < 0 ) THEN ! divisor > dividend Quotient = ZeroU128 Remainder = Dividend RETURN ELSEIF ( CompFlag == 0 ) THEN ! divisor == dividend Quotient = OneU128 Remainder = ZeroU128 RETURN END IF NumerLZ = LEADZ ( Dividend ) DenomLZ = LEADZ ( Divisor ) DenomTZ = TRAILZ ( Divisor ) IF ( DenomLZ == 128 ) THEN CALL DisplaySevereError ( 'Message from Routine ' // 'U128_DivMod_Java' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'Divide by zero.' ) RETURN ELSEIF ( IOR ( Dividend % High , Divisor % High ) == 0_I8B ) THEN ! dividend and divisor fit in an unsigned CALL UDivMod ( Dividend % Low , Divisor % Low , Quotient % Low , Remainder % Low ) Quotient % High = 0_I8B Remainder % High = 0_I8B RETURN ELSEIF ( DenomLZ == 127 ) THEN ! divisor is 1 Quotient = Dividend Remainder = ZeroU128 RETURN ELSEIF (( DenomTZ + DenomLZ ) == 127 ) THEN ! only one bit set (i.e., power of 2), so just shift Quotient = SHIFTR ( Dividend , DenomTZ ) Remainder = IAND ( Dividend , Divisor - OneU128 ) RETURN END IF IF (( DenomLZ - NumerLZ ) > 15 ) THEN ! fast divide when the values differ by this many orders of magnitude CALL FastDivision ( Dividend , Divisor , Quotient , Remainder ) ELSE CALL BinaryDivision ( Dividend , Divisor , NumerLZ , DenomLZ , Quotient , Remainder ) END IF RETURN CONTAINS SUBROUTINE BinaryDivision ( Numerator , Denominator , NumerLZ , DenomLZ , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division of two SInt128 objects (Dividend / Divisor) ! using binary-division algorithm !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Numerator , Denominator INTEGER ( KIND = I4B ), INTENT ( IN ) :: NumerLZ , DenomLZ TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift INTEGER ( KIND = I8B ) :: NumerHi , NumerLo , DenomHi , DenomLo INTEGER ( KIND = I8B ) :: QuotHi , QuotLo !** FLOW ! initialize NumerHi = Numerator % High NumerLo = Numerator % Low ! shift should always be posivite since the routine is only called ! when divisor magnitude is less than dividen magnitude Shift = DenomLZ - NumerLZ IF ( Shift >= 64 ) THEN DenomHi = SHIFTL ( Denominator % Low , Shift - 64 ) DenomLo = 0_I8B ELSE DenomHi = IOR ( SHIFTL ( Denominator % High , Shift ), SHIFTR ( Denominator % Low , 64 - Shift )) DenomLo = SHIFTL ( Denominator % Low , Shift ) END IF QuotHi = 0_I8B QuotLo = 0_I8B DO ! quotient = SHIFTL(quotient, 1) QuotHi = IOR ( SHIFTL ( QuotHi , 1 ), SHIFTR ( QuotLo , 63 )) QuotLo = SHIFTL ( QuotLo , 1 ) ! if (dividend >= divisor) IF ( CompareU128 ( NumerHi , NumerLo , DenomHi , DenomLo ) >= 0 ) THEN ! dividend = dividend - divisor IF ( IEOR ( NumerLo , MinI64 ) < IEOR ( DenomLo , MinI64 )) THEN NumerHi = NumerHi - DenomHi - 1_I8B NumerLo = NumerLo - DenomLo ELSE NumerHi = NumerHi - DenomHi NumerLo = NumerLo - DenomLo END IF ! quotient = IOR(quotient, 1) QuotLo = IOR ( QuotLo , 1_I8B ) END IF ! divisor = SHIFTR(divisor, 1) DenomLo = IOR ( SHIFTR ( DenomLo , 1 ), SHIFTL ( SHIFTL ( DenomHi , 1 ), 62 )) DenomHi = SHIFTR ( DenomHi , 1 ) IF ( Shift == 0 ) EXIT Shift = Shift - 1 END DO ! set output Quotient % High = QuotHi Quotient % Low = QuotLo Remainder % High = NumerHi Remainder % Low = NumerLo RETURN END SUBROUTINE BinaryDivision !****************************************************************************** SUBROUTINE FastDivision ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division of two SInt128 objects (Dividend / Divisor) ! using fast-division algorithm(s) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend TYPE ( UInt128 ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NLZ INTEGER ( KIND = I8B ) :: NumHi , NumLo INTEGER ( KIND = I8B ) :: V1Hi , U1Hi , U1Lo INTEGER ( KIND = I8B ) :: QLo , RLo !** FLOW IF ( Divisor % High == 0_I8B ) THEN IF ( CompareUnsigned ( Dividend % High , Divisor % Low ) < 0 ) THEN CALL DivideU128ByU64 ( Dividend % High , Dividend % Low , Divisor % Low , & Quotient % Low , Remainder % Low ) Quotient % High = 0_I8B Remainder % High = 0_I8B ELSE CALL UDivMod ( Dividend % High , Divisor % Low , Quotient % High , NumHi ) NumLo = Dividend % Low CALL DivideU128ByU64 ( NumHi , NumLo , Divisor % Low , Quotient % Low , Remainder % Low ) Remainder % High = 0_I8B END IF ELSE NLZ = LEADZ ( Divisor % High ) ! v1 = divisor << nlz IF ( NLZ < 64 ) THEN V1Hi = IOR ( SHIFTL ( Divisor % High , NLZ ), SHIFTR ( Divisor % Low , 64 - NLZ )) ELSE V1Hi = SHIFTL ( Divisor % Low , NLZ - 64 ) END IF ! u1 = dividend >>> 1 U1Lo = IOR ( SHIFTR ( Dividend % Low , 1 ), SHIFTL ( SHIFTL ( Dividend % High , 1 ), 62 )) U1Hi = SHIFTR ( Dividend % High , 1 ) CALL DivideU128ByU64 ( U1Hi , U1Lo , V1Hi , QLo , RLo ) ! q1 = q1 >>> (63 - nlz) QLo = SHIFTR ( QLo , 63 - NLZ ) ! if (q1 /= 0) IF ( QLo /= 0_I8B ) QLo = QLo - 1_I8B ! r = dividend - q1 * divisor Remainder = Dividend - ( Divisor * QLo ) Quotient % High = 0_I8B IF ( CompareU128 ( Remainder % High , Remainder % Low , Divisor % High , Divisor % Low ) >= 0 ) THEN ! quotient++ QLo = QLo + 1_I8B IF ( QLo == 0_I8B ) Quotient % High = 1_I8B ! remainder -= divisor CALL Subtract ( Remainder , Divisor ) END IF Quotient % Low = QLo END IF RETURN END SUBROUTINE FastDivision !****************************************************************************** SUBROUTINE DivideU128ByU64 ( DividendHi , DividendLo , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division of 128-bit unsigned integer by 64-bit unsigned integer ! and return quotient and remainder as 64-bit unsigned integers ! This routine is only applicable for cases where the divisor is greater !   than the upper halft of the dividend (i.e. Divisor .UGT. DividendHi). ! Note: This routine is based on 'divlu' of Hacker's delight and its derivative !       (division routine in Fast 128-bit math library for Java) !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: DividendHi , DividendLo INTEGER ( KIND = I8B ), INTENT ( IN ) :: Divisor INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Quotient INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Remainder !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: Mask = INT ( Z '00000000FFFFFFFF' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift INTEGER ( KIND = I8B ) :: NHi , NLo ! N -> numerator INTEGER ( KIND = I8B ) :: LoHi , LoLo INTEGER ( KIND = I8B ) :: RHat , UHat INTEGER ( KIND = I8B ) :: Denom , DHi , DLo ! D -> denominator INTEGER ( KIND = I8B ) :: QHi , QLo !** FLOW ! initialize Denom = Divisor NHi = DividendHi NLo = DividendLo Shift = LEADZ ( Denom ) IF ( Shift /= 0 ) THEN Denom = SHIFTL ( Denom , Shift ) NHi = IOR ( SHIFTL ( NHi , Shift ), SHIFTR ( NLo , 64 - Shift )) NLo = SHIFTL ( NLo , Shift ) END IF DHi = SHIFTR ( Denom , 32 ) DLo = IAND ( Denom , Mask ) LoHi = SHIFTR ( NLo , 32 ) LoLo = IAND ( NLo , Mask ) ! Compute NHi quotient digit. CALL UDivMod ( NHi , DHi , QHi , RHat ) ! qhat >>> 32 == qhat > base DO WHILE (( SHIFTR ( QHi , 32 ) /= 0_I8B ). OR . & ( IEOR ( QHi * DLo , MinI64 ) > IEOR ( IOR ( SHIFTL ( RHat , 32 ), LoHi ), MinI64 ))) QHi = QHi - 1_I8B RHat = RHat + DHi IF ( SHIFTR ( RHat , 32 ) /= 0_I8B ) EXIT END DO UHat = IOR ( SHIFTL ( NHi , 32 ), LoHi ) - QHi * Denom ! Compute NLo quotient digit. CALL UDivMod ( UHat , DHi , QLo , RHat ) DO WHILE (( SHIFTR ( QLo , 32 ) /= 0_I8B ). OR . & ( IEOR ( QLo * DLo , MinI64 ) > IEOR ( IOR ( SHIFTL ( RHat , 32 ), LoLo ), MinI64 ))) QLo = QLo - 1 RHat = RHat + DHi IF ( SHIFTR ( RHat , 32 ) /= 0_I8B ) EXIT END DO Quotient = IOR ( SHIFTL ( QHi , 32 ), QLo ) Remainder = SHIFTR ( IOR ( SHIFTL ( UHat , 32 ), LoLo ) - QLo * Denom , Shift ) RETURN END SUBROUTINE DivideU128ByU64 !****************************************************************************** FUNCTION CompareU128 ( LhsHi , LhsLo , RhsHi , RhsLo ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare LHS and RHS where both numbers are treated as unsigned. ! - return -1 if LHS < RHS ! - return  0 if LHS == RHS ! - return +1 if LHS > RHS IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: LhsHi , LhsLo , RhsHi , RhsLo INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: ULHS , URHS !** FLOW ULHS = IEOR ( LhsHi , MinI64 ) URHS = IEOR ( RhsHi , MinI64 ) IF ( ULHS < URHS ) THEN Flag = - 1 ELSEIF ( ULHS > URHS ) THEN Flag = + 1 ELSE Flag = 0 END IF IF ( Flag == 0 ) THEN ULHS = IEOR ( LhsLo , MinI64 ) URHS = IEOR ( RhsLo , MinI64 ) IF ( ULHS < URHS ) THEN Flag = - 1 ELSEIF ( ULHS > URHS ) THEN Flag = + 1 ELSE Flag = 0 END IF END IF RETURN END FUNCTION CompareU128 !****************************************************************************** END SUBROUTINE U128_DivMod_Java !****************************************************************************** SUBROUTINE U128_DivMod_IntX ( Dividend , Divisor , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform division of two UInt128 objects (Dividend / Divisor) !   and return both the quotient and the remainder. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend TYPE ( UInt128 ), INTENT ( IN ) :: Divisor TYPE ( UInt128 ), INTENT ( OUT ) :: Quotient TYPE ( UInt128 ), INTENT ( OUT ) :: Remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LSh , RSh INTEGER ( KIND = I8B ) :: NumerHi , NumerLo , DenomHi , DenomLo INTEGER ( KIND = I8B ) :: NumerEx , Denom , RshMask INTEGER ( KIND = I8B ) :: V , R1 , R2 , Q1 , Q2 , LHS , RHS !** FLOW IF ( Divisor == ZeroU128 ) THEN ! division by zero Quotient = ZeroU128 Remainder = ZeroU128 CALL DisplaySevereError ( 'Message from Routine ' // 'U128_DivMod_IntX' // ' in Module ' // ModName // '.' ) CALL DisplayContinueError ( 'The divisor must not be zero.' ) RETURN END IF IF ( Divisor % High == 0 ) THEN LSh = LEADZ ( Divisor % Low ) IF ( LSh == 0 ) THEN RSh = 0 RShMask = 0_I8B ELSE RSh = 64 - LSh RShMask = - 1_I8B END IF Denom = SHIFTL ( Divisor % Low , LSh ) NumerLo = SHIFTL ( Dividend % Low , LSh ) NumerHi = IOR ( SHIFTL ( Dividend % High , LSh ), IAND ( SHIFTR ( Dividend % Low , RSh ), RShMask )) NumerEx = IAND ( SHIFTR ( Dividend % High , RSh ), RShMask ) V = Reciprocal_2By1 ( Denom ) CALL UDivRem_2By1 ( NumerEx , NumerHi , Denom , V , Q1 , R1 ) CALL UDivRem_2By1 ( R1 , NumerLo , Denom , V , Q2 , R2 ) Quotient % High = Q1 Quotient % Low = Q2 Remainder % High = 0_I8B Remainder % Low = SHIFTR ( R2 , LSh ) RETURN END IF IF ( IEOR ( Divisor % High , MinI64 ) > IEOR ( Dividend % High , MinI64 )) THEN ! divisor > dividend Quotient = ZeroU128 Remainder = Dividend RETURN END IF LSh = LEADZ ( Divisor % High ) IF ( LSh == 0 ) THEN IF ( IEOR ( Divisor % High , MinI64 ) < IEOR ( Dividend % High , MinI64 )) THEN LHS = 1_I8B ELSE LHS = 0_I8B END IF IF ( IEOR ( Divisor % Low , MinI64 ) <= IEOR ( Dividend % Low , MinI64 )) THEN RHS = 1_I8B ELSE RHS = 0_I8B END IF Quotient % High = 0_I8B Quotient % Low = IOR ( LHS , RHS ) IF ( Quotient % Low == 0_I8B ) THEN Remainder = Dividend ELSE ! Remainder = Dividend - Divisor Remainder % Low = Dividend % Low - Divisor % Low IF ( IEOR ( Dividend % Low , MinI64 ) < IEOR ( Divisor % Low , MinI64 )) THEN Remainder % High = Dividend % High - Divisor % High - 1_I8B ELSE Remainder % High = Dividend % High - Divisor % High END IF END IF RETURN END IF RSh = 64 - LSh DenomLo = SHIFTL ( Divisor % Low , LSh ) DenomHi = IOR ( SHIFTL ( Divisor % High , LSh ), SHIFTR ( Divisor % Low , RSh )) NumerLo = SHIFTL ( Dividend % Low , LSh ) NumerHi = IOR ( SHIFTL ( Dividend % High , LSh ), SHIFTR ( Dividend % Low , RSh )) NumerEx = SHIFTR ( Dividend % High , RSh ) V = Reciprocal_3By2 ( DenomHi , DenomLo ) CALL UDivRem_3By2 ( NumerEx , NumerHi , NumerLo , DenomHi , DenomLo , V , Q2 , R1 , R2 ) Quotient % High = 0_I8B Quotient % Low = Q2 Remainder % High = SHIFTR ( R1 , LSh ) Remainder % Low = IOR ( SHIFTR ( R2 , LSh ), SHIFTL ( R1 , 64 - LSh )) RETURN CONTAINS FUNCTION Reciprocal_2By1 ( D ) RESULT ( R ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the reciprocal (2**128 - 1) / D - 2**64 for normalized D ! based on Algorithm 2 from \"Improved division by invariant integers\". IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: D INTEGER ( KIND = I8B ) :: R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: D0 , D9 , D40 , D63 , E , T INTEGER ( KIND = I8B ) :: PHi , PLo , V0 , V1 , V2 , V3 !** FLOW D9 = SHIFTR ( D , 55 ) V0 = INT ( RecTable ( INT ( D9 , KIND = I4B ) - 256 ), KIND = I8B ) D40 = SHIFTR ( D , 24 ) + 1 V1 = SHIFTL ( V0 , 11 ) - SHIFTR (( V0 * V0 ) * D40 , 40 ) - 1_I8B V2 = SHIFTL ( V1 , 13 ) + SHIFTR ( V1 * ( INT ( Z '1000000000000000' , KIND = I8B ) - V1 * D40 ), 47 ) D0 = IAND ( D , 1_I8B ) D63 = SHIFTR ( D , 1 ) + D0 ! ceil(D/2) E = IAND ( SHIFTR ( V2 , 1 ), ( 0_I8B - D0 )) - V2 * D63 CALL UMul128 ( V2 , E , PHi , PLo ) V3 = SHIFTR ( PHi , 1 ) + SHIFTL ( V2 , 31 ) CALL UMul128 ( V3 , D , PHi , PLo ) T = PLo + D IF ( IEOR ( T , MinI64 ) < IEOR ( PLo , MinI64 )) PHi = PHi + 1 R = V3 - PHi - D RETURN END FUNCTION Reciprocal_2By1 !****************************************************************************** FUNCTION Reciprocal_3By2 ( DHi , DLo ) RESULT ( R ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the reciprocal (2**128 - 1) / D - 2**64 for normalized D ! based on Algorithm 2 from \"Improved division by invariant integers\". IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: DHi , DLo INTEGER ( KIND = I8B ) :: R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: V , P , THi , TLo !** FLOW V = Reciprocal_2By1 ( DHi ) P = DHi * V P = P + DLo IF ( IEOR ( P , MinI64 ) < IEOR ( DLo , MinI64 )) THEN V = V - 1_I8B IF ( IEOR ( P , MinI64 ) >= IEOR ( DHi , MinI64 )) THEN V = V - 1_I8B P = P - DHi END IF P = P - DHi END IF CALL UMul128 ( V , DLo , THi , TLo ) P = P + THi IF ( IEOR ( P , MinI64 ) < IEOR ( THi , MinI64 )) THEN V = V - 1_I8B IF ( IEOR ( P , MinI64 ) >= IEOR ( DHi , MinI64 )) THEN IF (( IEOR ( P , MinI64 ) > IEOR ( DHi , MinI64 )). OR .& ( IEOR ( TLo , MinI64 ) >= IEOR ( DLo , MinI64 ))) V = V - 1_I8B END IF END IF R = V RETURN END FUNCTION Reciprocal_3By2 !****************************************************************************** SUBROUTINE UDivRem_2By1 ( UHi , ULo , D , V , Q , R ) !** PURPOSE OF THIS SUBROUTINE: ! To performm 128-bit integer division by 64-bit integer IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: UHi , ULo , D , V INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Q , R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: QHi , QLo , NewLo !** FLOW ! Q128 = V*UHi CALL UMul128 ( V , UHi , QHi , QLo ) ! Q128 = Q128 + U128 NewLo = QLo + ULo IF ( IEOR ( NewLo , MinI64 ) < IEOR ( QLo , MinI64 )) THEN QHi = QHi + UHi + 1_I8B ELSE QHi = QHi + UHi END IF QLo = NewLo QHi = QHi + 1_I8B R = ULo - QHi * D IF ( IEOR ( R , MinI64 ) > IEOR ( QLo , MinI64 )) THEN QHi = QHi - 1_I8B R = R + D END IF IF ( IEOR ( R , MinI64 ) >= IEOR ( D , MinI64 )) THEN QHi = QHi + 1_I8B R = R - D END IF Q = QHi RETURN END SUBROUTINE UDivRem_2By1 !****************************************************************************** SUBROUTINE UDivRem_3By2 ( U2 , U1 , U0 , DHi , DLo , V , Q , RHi , RLo ) !** PURPOSE OF THIS SUBROUTINE: ! To performm 128-bit integer division by 64-bit integer IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: U2 , U1 , U0 , DHi , DLo , V INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Q , RHi , RLo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: QHi , QLo , NewLo , R1 INTEGER ( KIND = I8B ) :: THi , TLo , SHi , SLo LOGICAL :: Flag !** FLOW ! Q128 = V*U2 CALL UMul128 ( V , U2 , QHi , QLo ) ! Q128 = Q128 + UInt128(U2, U1) NewLo = QLo + U1 IF ( IEOR ( NewLo , MinI64 ) < IEOR ( QLo , MinI64 )) THEN QHi = QHi + U2 + 1_I8B ELSE QHi = QHi + U2 END IF QLo = NewLo R1 = U1 - QHi * DHi ! T128 = DLo*QHi CALL UMul128 ( DLo , QHi , THi , TLo ) ! R128 = UInt128(R1, U0) - T128 - D128 SLo = U0 - TLo IF ( IEOR ( U0 , MinI64 ) < IEOR ( TLo , MinI64 )) THEN SHi = R1 - THi - 1_I8B ELSE SHi = R1 - THi END IF RLo = SLo - DLo IF ( IEOR ( SLo , MinI64 ) < IEOR ( DLo , MinI64 )) THEN RHi = SHi - DHi - 1_I8B ELSE RHi = SHi - DHi END IF R1 = RHi QHi = QHi + 1_I8B IF ( R1 . UGE . QLo ) THEN QHi = QHi - 1_I8B ! R128 = R128 + D128 NewLo = RLo + DLo IF ( IEOR ( NewLo , MinI64 ) < IEOR ( RLo , MinI64 )) THEN RHi = RHi + DHi + 1_I8B ELSE RHi = RHi + DHi END IF RLo = NewLo END IF IF ( RHi == DHi ) THEN Flag = ( IEOR ( RLo , MinI64 ) >= IEOR ( DLo , MinI64 )) ELSE Flag = ( IEOR ( RHi , MinI64 ) >= IEOR ( DHi , MinI64 )) END IF IF ( Flag ) THEN QHi = QHi + 1_I8B ! R128 = R128 - D128 NewLo = RLo - DLo IF ( IEOR ( RLo , MinI64 ) < IEOR ( DLo , MinI64 )) THEN RHi = RHi - DHi - 1_I8B ELSE RHi = RHi - DHi END IF RLo = NewLo END IF Q = QHi RETURN END SUBROUTINE UDivRem_3By2 !****************************************************************************** END SUBROUTINE U128_DivMod_IntX !------------------------------------------------------------------------------ ! !                           AUXILIARY ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE U128_Write ( U128 , Unit , IOStat , IOMsg , ShowComponent , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !! To write 'UInt128' object to the screen (or the specified unit). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U128 !! UInt128 object INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: Unit !! output logical unit INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( OUT ) :: IOStat !! io stat CHARACTER ( LEN =* ), OPTIONAL , INTENT ( OUT ) :: IOMsg !! io message LOGICAL , OPTIONAL , INTENT ( IN ) :: ShowComponent !&#94; flag indicating whether to show components or not ! if flag is present and true, write compoents of the object ! otherwise, write the object as a decimal string CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: Prefix !! prefix string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: AsString INTEGER ( KIND = I4B ) :: OutUnit INTEGER ( KIND = I4B ) :: IO_Stat CHARACTER ( LEN = 128 ) :: IO_Msg CHARACTER ( LEN = :), ALLOCATABLE :: DispStr !** FLOW ! set defaults OutUnit = OUTPUT_UNIT AsString = TrueVal ! check optional input IF ( PRESENT ( ShowComponent )) THEN IF ( ShowComponent ) AsString = FalseVal END IF IF ( PRESENT ( Unit )) OutUnit = Unit ! write the object IF ( AsString ) THEN IF ( PRESENT ( Prefix )) THEN DispStr = Prefix // ToDecString ( U128 ) ELSE DispStr = ' U128 = ' // ToDecString ( U128 ) END IF WRITE ( UNIT = OutUnit , FMT = '(A)' , IOSTAT = IO_Stat , IOMSG = IO_Msg ) DispStr ELSE DispStr = '-: ' IF ( PRESENT ( Prefix )) DispStr = Prefix WRITE ( UNIT = OutUnit , FMT = '(A, I0)' , IOSTAT = IO_Stat , IOMSG = IO_Msg ) & DispStr // 'High value = ' , U128 % High WRITE ( UNIT = OutUnit , FMT = '(A, I0)' , IOSTAT = IO_Stat , IOMSG = IO_Msg ) & DispStr // 'Low value = ' , U128 % Low END IF ! return output if requested IF ( PRESENT ( IOStat )) IOStat = IO_Stat IF ( PRESENT ( IOMsg )) IOMsg = IO_Msg RETURN END SUBROUTINE U128_Write !****************************************************************************** END MODULE ModBase_UInt128 !******************************************************************************","tags":"","loc":"sourcefile\\modbase - uint128.f90.html"},{"title":"ModBase - Error Handlers.f90 – FortCharConv","text":"Source Code MODULE ModBase_Error_Handlers !&#94; **PURPOSE OF THIS MODULE**: ! contains routines and parameters for error handling tasks !** USE STATEMENTS: USE ModBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! error parameters PUBLIC :: ErrNone PUBLIC :: ErrWarning PUBLIC :: ErrSevere PUBLIC :: ErrFatal PUBLIC :: ErrFilename ! error message procedures PUBLIC :: DisplayMessage PUBLIC :: DisplayWarningError PUBLIC :: DisplaySevereError PUBLIC :: DisplayFatalError PUBLIC :: DisplayContinueError PUBLIC :: CloseErrorFile PUBLIC :: CloseMiscOpenFiles PUBLIC :: SetStopOnError PUBLIC :: AbortProgram PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! parameters for error level INTEGER ( KIND = I1B ), PARAMETER :: ErrNone = 0 !! no error level INTEGER ( KIND = I1B ), PARAMETER :: ErrWarning = 1 !! warning error level INTEGER ( KIND = I1B ), PARAMETER :: ErrSevere = 2 !! severe error level INTEGER ( KIND = I1B ), PARAMETER :: ErrFatal = 3 !! fatal error level ! name of error file CHARACTER ( LEN =* ), PARAMETER :: ErrFilename = 'ErrorLog.txt' !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: LOGICAL :: StopOnError = FalseVal LOGICAL :: FatalError = FalseVal CONTAINS !** MODULE ELEMENTS SUBROUTINES or FUNCTIONS: !************************************************************************************** SUBROUTINE DisplayErrorMessage ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display the error message on the \"standard error output\" unit !   or the indicated file unit number if specified. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE PARAMETER DEFINITIONS: CHARACTER ( LEN =* ), PARAMETER :: ErrorFormat = '(2X,A)' !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: LOGICAL :: FileOpened LOGICAL :: Existing INTEGER ( KIND = I4B ) :: IOS INTEGER ( KIND = I4B ) :: ErrorUnit !** FLOW IF ( PRESENT ( OutUnit )) THEN ! first, check whether the specified unit number is connected to an opened file INQUIRE ( UNIT = OutUnit , OPENED = FileOpened , IOStat = IOS ) IF ( FileOpened . AND .( IOS == 0 )) THEN ! simply write message to the specified file unit number WRITE ( OutUnit , ErrorFormat ) TRIM ( ErrorMessage ) ELSE ! open file OPEN ( OutUnit , File = 'User_Error.Txt' ) ! then write message to the specified file unit number WRITE ( OutUnit , ErrorFormat ) TRIM ( ErrorMessage ) END IF ELSE ! first, check whether the General Error Report file is opened INQUIRE ( FILE = ErrFilename , EXIST = Existing , OPENED = FileOpened , IOStat = IOS ) IF ( FileOpened . AND .( IOS == 0 )) THEN ! get existing unit number for the opened file INQUIRE ( FILE = ErrFilename , NUMBER = ErrorUnit ) ! then write message to the General Error Report file WRITE ( ErrorUnit , ErrorFormat ) TRIM ( ErrorMessage ) ELSE ! open file IF ( Existing ) THEN OPEN ( NEWUNIT = ErrorUnit , FILE = ErrFilename , POSITION = 'APPEND' ) ! write separation indicator to the General Error Report file WRITE ( ErrorUnit , '(A)' ) '------------------------------------------------------------' WRITE ( ErrorUnit , '(A)' ) '' ELSE OPEN ( NEWUNIT = ErrorUnit , FILE = ErrFilename ) ! write heading to the General Error Report file WRITE ( ErrorUnit , '(A)' ) '  XPFC - General Error Report' WRITE ( ErrorUnit , '(A)' ) '  Program/Library Version = 1.0' WRITE ( ErrorUnit , '(A)' ) '------------------------------------------------------------' WRITE ( ErrorUnit , '(A)' ) '' END IF ! then write message to the General Error Report file WRITE ( ErrorUnit , ErrorFormat ) TRIM ( ErrorMessage ) END IF ENDIF RETURN END SUBROUTINE DisplayErrorMessage !****************************************************************************** SUBROUTINE DisplayWarningError ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a 'Warning Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DisplayErrorMessage ( ' ++ WARNING ++ : ' // ErrorMessage , OutUnit ) RETURN END SUBROUTINE DisplayWarningError !****************************************************************************** SUBROUTINE DisplayFatalError ( ErrorMessage , OutUnit ) !** URPOSE OF THIS SUBROUTINE: !&#94; To display a 'Fatal Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ! display message CALL DisplayErrorMessage ( ' ++ FATAL ++ : ' // ErrorMessage , OutUnit ) ! set flag FatalError = TrueVal RETURN END SUBROUTINE DisplayFatalError !****************************************************************************** SUBROUTINE DisplaySevereError ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a 'Severe Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DisplayErrorMessage ( ' ++ SEVERE ++ : ' // ErrorMessage , OutUnit ) RETURN END SUBROUTINE DisplaySevereError !****************************************************************************** SUBROUTINE DisplayContinueError ( ErrorMessage , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a 'Continued Error' message. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: ErrorMessage INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ! display message CALL DisplayErrorMessage ( ' +++++ : ' // ErrorMessage , OutUnit ) ! check error flags IF ( StopOnError . AND . FatalError ) THEN CALL AbortProgram ( OutUnit ) ELSE ! reset flag FatalError = FalseVal END IF RETURN END SUBROUTINE DisplayContinueError !****************************************************************************** SUBROUTINE DisplayMessage ( Message , OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To display a (informative) message on designated output Files. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: Message INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW CALL DisplayErrorMessage ( Message , OutUnit ) RETURN END SUBROUTINE DisplayMessage !****************************************************************************** SUBROUTINE CloseErrorFile !** PURPOSE OF THIS SUBROUTINE: !&#94; This subroutine closes the general error file. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: ! na !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: LOGICAL :: FileOpened INTEGER ( KIND = I4B ) :: IOS INTEGER ( KIND = I4B ) :: ErrorUnit !** FLOW INQUIRE ( FILE = ErrFilename , OPENED = FileOpened , IOStat = IOS ) IF ( FileOpened . AND .( IOS == 0 )) THEN ! get existing unit number for the opened file INQUIRE ( FILE = ErrFilename , NUMBER = ErrorUnit ) ! then close the General Error Report file CLOSE ( ErrorUnit ) END IF RETURN END SUBROUTINE CloseErrorFile !****************************************************************************** SUBROUTINE AbortProgram ( OutUnit ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This subroutine causes the program to halt due to a fatal error. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( INOUT ) :: OutUnit !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: CHARACTER ( LEN = :), ALLOCATABLE :: StopMessage !** FLOW StopMessage = 'XPFC Terminated -- Fatal Error(s) Detected.' CALL DisplayMessage ( StopMessage , OutUnit ) CALL CloseMiscOpenFiles () STOP 'Program Terminated -- Error(s) Detected.' RETURN END SUBROUTINE AbortProgram !****************************************************************************** SUBROUTINE SetStopOnError ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set StopOnError flag (module variable). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: LOGICAL , INTENT ( IN ) :: Flag ! true if requesting termination of the program due to fatal error(s) !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW StopOnError = Flag RETURN END SUBROUTINE SetStopOnError !****************************************************************************** SUBROUTINE CloseMiscOpenFiles !** PURPOSE OF THIS SUBROUTINE: !&#94; This subroutine scans potential Unit numbers and closes !   any that are still open. !** METHODOLOGY EMPLOYED: ! Use INQUIRE to determine if file is open. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DEFINITIONS: ! na !** SUBROUTINE PARAMETER DEFINITIONS: INTEGER ( KIND = I4B ), PARAMETER :: MaxUnitNumber = 1000 !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: LOGICAL :: EXIST , OPENED INTEGER ( KIND = I4B ) :: UnitNumber INTEGER ( KIND = I4B ) :: IOS !** FLOW DO UnitNumber = 1 , MaxUnitNumber INQUIRE ( Unit = UnitNumber , EXIST = EXIST , OPENED = OPENED , IOStat = IOS ) IF ( EXIST . AND . OPENED . AND .( IOS == 0 )) CLOSE ( UnitNumber ) END DO RETURN END SUBROUTINE CloseMiscOpenFiles !****************************************************************************** END MODULE ModBase_Error_Handlers !******************************************************************************","tags":"","loc":"sourcefile\\modbase - error handlers.f90.html"},{"title":"ModBase - Tables - CharConv.f90 – FortCharConv","text":"Source Code MODULE ModBase_Tables_CharConv !&#94; **PURPOSE OF THIS MODULE**: ! This module contains look-up tables used by \"CharConv\" routines. !** USE STATEMENTS: USE ModBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables PUBLIC !** MODULE PARAMETERS: ! ------------------------------------------------------------------------------- ! -----   parameters for powers of 10 generation used by various algorithms ----- ! ------------------------------------------------------------------------------- !# minimum exponent value of the 'Pow10_256_Small_Table' table INTEGER ( KIND = I4B ), PARAMETER :: Pow10_256_Small_MinExp = - 350 !# maximum exponent value of the Power_of_Ten table INTEGER ( KIND = I4B ), PARAMETER :: Pow10_256_Small_MaxExp = 350 !> This table contains the 256-bit mantissa (or significand) approximations of the !   powers of 10 from -350 to 350 that can cover the entire exponent ranges of both !   double- and single-precision floating point numbers. ! The 256-bit approximations are stored in each row of the array and they are stored !   in a little-endian order (i.e. the (first) element 0 of each row represents the !   least significant byte and the (fourth) element 3 is the most significand one). INTEGER ( KIND = I8B ), PARAMETER :: Pow10_256_Small_Table ( 0 : 3 , & Pow10_256_Small_MinExp : Pow10_256_Small_MaxExp ) = RESHAPE ([ & INT ( Z '4AAC6E5A51197B81' , KIND = I8B ), INT ( Z 'D72FA647259193CE' , KIND = I8B ), & INT ( Z 'A8726BC8D55CBB16' , KIND = I8B ), INT ( Z 'A05C0DD70F6E1619' , KIND = I8B ), & INT ( Z 'DD5789F0E55FDA62' , KIND = I8B ), INT ( Z '8CFB8FD8EEF5F8C1' , KIND = I8B ), & INT ( Z '128F06BB0AB3E9DC' , KIND = I8B ), INT ( Z 'C873114CD3499BA0' , KIND = I8B ), & INT ( Z '54AD6C6D1EB7D0FA' , KIND = I8B ), INT ( Z 'B03A73CF2AB376F2' , KIND = I8B ), & INT ( Z '1732C869CD60E453' , KIND = I8B ), INT ( Z 'FA8FD5A0081C0288' , KIND = I8B ), & INT ( Z '74EC63C43332E29C' , KIND = I8B ), INT ( Z '4E2488617AB02A57' , KIND = I8B ), & INT ( Z '0E7FBD42205C8EB4' , KIND = I8B ), INT ( Z '9C99E58405118195' , KIND = I8B ), & INT ( Z '52277CB53FFF9B43' , KIND = I8B ), INT ( Z '61ADAA79D95C34ED' , KIND = I8B ), & INT ( Z '521FAC92A873B261' , KIND = I8B ), INT ( Z 'C3C05EE50655E1FA' , KIND = I8B ), & INT ( Z 'A6B15BE28FFF8214' , KIND = I8B ), INT ( Z 'BA1915184FB34228' , KIND = I8B ), & INT ( Z 'E6A797B752909EF9' , KIND = I8B ), INT ( Z 'F4B0769E47EB5A78' , KIND = I8B ), & INT ( Z '682ED96D99FFB14D' , KIND = I8B ), INT ( Z '144FAD2F31D00959' , KIND = I8B ), & INT ( Z '9028BED2939A635C' , KIND = I8B ), INT ( Z '98EE4A22ECF3188B' , KIND = I8B ), & INT ( Z 'C23A8FC9007F9DA0' , KIND = I8B ), INT ( Z '1963987AFE440BAF' , KIND = I8B ), & INT ( Z '7432EE873880FC33' , KIND = I8B ), INT ( Z 'BF29DCABA82FDEAE' , KIND = I8B ), & INT ( Z 'B2C933BB409F8508' , KIND = I8B ), INT ( Z 'DFBC7E99BDD50E9B' , KIND = I8B ), & INT ( Z '113FAA2906A13B3F' , KIND = I8B ), INT ( Z 'EEF453D6923BD65A' , KIND = I8B ), & INT ( Z '4FBDC0550863B325' , KIND = I8B ), INT ( Z 'EBD5CF2016A52921' , KIND = I8B ), & INT ( Z '4AC7CA59A424C507' , KIND = I8B ), INT ( Z '9558B4661B6565F8' , KIND = I8B ), & INT ( Z 'A3AD306A4A7C9FEE' , KIND = I8B ), INT ( Z 'E6CB42E81C4E7369' , KIND = I8B ), & INT ( Z '5D79BCF00D2DF649' , KIND = I8B ), INT ( Z 'BAAEE17FA23EBF76' , KIND = I8B ), & INT ( Z '0C987C84DD1BC7EA' , KIND = I8B ), INT ( Z '607E13A223621044' , KIND = I8B ), & INT ( Z 'F4D82C2C107973DC' , KIND = I8B ), INT ( Z 'E95A99DF8ACE6F53' , KIND = I8B ), & INT ( Z '87DF4DD30A315CF2' , KIND = I8B ), INT ( Z 'BC4ECC45561D4A2A' , KIND = I8B ), & INT ( Z '79071B9B8A4BE869' , KIND = I8B ), INT ( Z '91D8A02BB6C10594' , KIND = I8B ), & INT ( Z '29D72147CCBDB42E' , KIND = I8B ), INT ( Z '2B627F56ABA49CB5' , KIND = I8B ), & INT ( Z '9748E2826CDEE284' , KIND = I8B ), INT ( Z 'B64EC836A47146F9' , KIND = I8B ), & INT ( Z '744CE999BFED213A' , KIND = I8B ), INT ( Z '363B1F2C568DC3E2' , KIND = I8B ), & INT ( Z 'FD1B1B2308169B25' , KIND = I8B ), INT ( Z 'E3E27A444D8D98B7' , KIND = I8B ), & INT ( Z '88B0120017F434C4' , KIND = I8B ), INT ( Z '41E4F37BB6189A6D' , KIND = I8B ), & INT ( Z 'FE30F0F5E50E20F7' , KIND = I8B ), INT ( Z '8E6D8C6AB0787F72' , KIND = I8B ), & INT ( Z 'EADC16801DF141F5' , KIND = I8B ), INT ( Z '125E305AA39EC108' , KIND = I8B ), & INT ( Z 'BDBD2D335E51A935' , KIND = I8B ), INT ( Z 'B208EF855C969F4F' , KIND = I8B ), & INT ( Z '25931C20256D9273' , KIND = I8B ), INT ( Z '56F5BC714C86714B' , KIND = I8B ), & INT ( Z 'AD2C788035E61382' , KIND = I8B ), INT ( Z 'DE8B2B66B3BC4723' , KIND = I8B ), & INT ( Z 'F77BF19417647B88' , KIND = I8B ), INT ( Z '765995C6CFD406CE' , KIND = I8B ), & INT ( Z '4C3BCB5021AFCC31' , KIND = I8B ), INT ( Z '8B16FB203055AC76' , KIND = I8B ), & INT ( Z 'B55AEDF91D3D9A6A' , KIND = I8B ), INT ( Z 'D3EFFB3883C90882' , KIND = I8B ), & INT ( Z 'DF4ABE242A1BBF3D' , KIND = I8B ), INT ( Z 'ADDCB9E83C6B1793' , KIND = I8B ), & INT ( Z '62B1A977648D0104' , KIND = I8B ), INT ( Z '48EBFA06A4BB4AA3' , KIND = I8B ), & INT ( Z 'D71D6DAD34A2AF0D' , KIND = I8B ), INT ( Z 'D953E8624B85DD78' , KIND = I8B ), & INT ( Z '1DAF09EA9ED820A2' , KIND = I8B ), INT ( Z '4D937C4426F50EA6' , KIND = I8B ), & INT ( Z '8672648C40E5AD68' , KIND = I8B ), INT ( Z '87D4713D6F33AA6B' , KIND = I8B ), & INT ( Z 'A51ACC65468E28CB' , KIND = I8B ), INT ( Z '60F85B5530B2524F' , KIND = I8B ), & INT ( Z '680EFDAF511F18C2' , KIND = I8B ), INT ( Z 'A9C98D8CCB009506' , KIND = I8B ), & INT ( Z '8E617F7E9831B2FE' , KIND = I8B ), INT ( Z 'F936722A7CDEE6E3' , KIND = I8B ), & INT ( Z '0212BD1B2566DEF2' , KIND = I8B ), INT ( Z 'D43BF0EFFDC0BA48' , KIND = I8B ), & INT ( Z '38FCEFAF1F1F0FDF' , KIND = I8B ), INT ( Z 'DBC2075A8E0B504E' , KIND = I8B ), & INT ( Z '014BB630F7604B57' , KIND = I8B ), INT ( Z '84A57695FE98746D' , KIND = I8B ), & INT ( Z 'C73C2B9AE6E6D3D6' , KIND = I8B ), INT ( Z 'D2B28931318E2461' , KIND = I8B ), & INT ( Z '419EA3BD35385E2D' , KIND = I8B ), INT ( Z 'A5CED43B7E3E9188' , KIND = I8B ), & INT ( Z '390B3681A0A088CC' , KIND = I8B ), INT ( Z '475F2B7D7DF1AD7A' , KIND = I8B ), & INT ( Z '52064CAC828675B9' , KIND = I8B ), INT ( Z 'CF42894A5DCE35EA' , KIND = I8B ), & INT ( Z '63A702110464557F' , KIND = I8B ), INT ( Z 'CC9B7B2E6EB70C6C' , KIND = I8B ), & INT ( Z '7343EFEBD1940993' , KIND = I8B ), INT ( Z '818995CE7AA0E1B2' , KIND = I8B ), & INT ( Z '7C90C295457D6ADF' , KIND = I8B ), INT ( Z 'BFC259FA0A64CF87' , KIND = I8B ), & INT ( Z '1014EBE6C5F90BF8' , KIND = I8B ), INT ( Z 'A1EBFB4219491A1F' , KIND = I8B ), & INT ( Z '5BB4F33A96DCC597' , KIND = I8B ), INT ( Z 'EFB2F0788CFE0369' , KIND = I8B ), & INT ( Z 'D41A26E077774EF6' , KIND = I8B ), INT ( Z 'CA66FA129F9B60A6' , KIND = I8B ), & INT ( Z 'B2A230093C93F6FD' , KIND = I8B ), INT ( Z 'AB9FAC96B03D8443' , KIND = I8B ), & INT ( Z '8920B098955522B4' , KIND = I8B ), INT ( Z 'FD00B897478238D0' , KIND = I8B ), & INT ( Z '4FA55E05C5DC7A5E' , KIND = I8B ), INT ( Z 'EB43CBDE2E2672AA' , KIND = I8B ), & INT ( Z '55B46E5F5D5535B0' , KIND = I8B ), INT ( Z '9E20735E8CB16382' , KIND = I8B ), & INT ( Z 'E38EB587375398F6' , KIND = I8B ), INT ( Z '2614BED5B9B00F54' , KIND = I8B ), & INT ( Z 'EB2189F734AA831D' , KIND = I8B ), INT ( Z 'C5A890362FDDBC62' , KIND = I8B ), & INT ( Z '1C7262E905287F33' , KIND = I8B ), INT ( Z '6F99EE8B281C132A' , KIND = I8B ), & INT ( Z 'A5E9EC7501D523E4' , KIND = I8B ), INT ( Z 'F712B443BBD52B7B' , KIND = I8B ), & INT ( Z '51C77DD1A3394F80' , KIND = I8B ), INT ( Z 'C5C03516F9118BFA' , KIND = I8B ), & INT ( Z '47B233C92125366E' , KIND = I8B ), INT ( Z '9A6BB0AA55653B2D' , KIND = I8B ), & INT ( Z 'E6395D460C07A360' , KIND = I8B ), INT ( Z '7730425CB755EEF8' , KIND = I8B ), & INT ( Z '999EC0BB696E840A' , KIND = I8B ), INT ( Z 'C1069CD4EABE89F8' , KIND = I8B ), & INT ( Z '1FC7B4978F098C38' , KIND = I8B ), INT ( Z '14FC52F3E52B6AB7' , KIND = I8B ), & INT ( Z 'C00670EA43CA250D' , KIND = I8B ), INT ( Z 'F148440A256E2C76' , KIND = I8B ), & INT ( Z '73DCD0DEB965F7A3' , KIND = I8B ), INT ( Z '2D1DB3D86F3B22B2' , KIND = I8B ), & INT ( Z '380406926A5E5728' , KIND = I8B ), INT ( Z '96CD2A865764DBCA' , KIND = I8B ), & INT ( Z '10D4051667BF758C' , KIND = I8B ), INT ( Z '386520CE8B09EB5F' , KIND = I8B ), & INT ( Z 'C605083704F5ECF2' , KIND = I8B ), INT ( Z 'BC807527ED3E12BC' , KIND = I8B ), & INT ( Z 'D509065C01AF52EF' , KIND = I8B ), INT ( Z 'C67E69022DCC6636' , KIND = I8B ), & INT ( Z 'F7864A44C633682E' , KIND = I8B ), INT ( Z 'EBA09271E88D976B' , KIND = I8B ), & INT ( Z '4525A3F9810D93D5' , KIND = I8B ), INT ( Z '3C0F01A15C9FBFE2' , KIND = I8B ), & INT ( Z '7AB3EE6AFBE0211D' , KIND = I8B ), INT ( Z '93445B8731587EA3' , KIND = I8B ), & INT ( Z 'D66F0CF7E150F8CA' , KIND = I8B ), INT ( Z '8B12C209B3C7AFDA' , KIND = I8B ), & INT ( Z '5960EA05BAD82964' , KIND = I8B ), INT ( Z 'B8157268FDAE9E4C' , KIND = I8B ), & INT ( Z '8C0AD035D9A536FD' , KIND = I8B ), INT ( Z 'ADD7728C20B99BD1' , KIND = I8B ), & INT ( Z '6FB92487298E33BD' , KIND = I8B ), INT ( Z 'E61ACF033D1A45DF' , KIND = I8B ), & INT ( Z 'F786C221A807425E' , KIND = I8B ), INT ( Z '8CA6A79794740162' , KIND = I8B ), & INT ( Z 'A5D3B6D479F8E056' , KIND = I8B ), INT ( Z '8FD0C16206306BAB' , KIND = I8B ), & INT ( Z 'B56872AA120912F6' , KIND = I8B ), INT ( Z '2FD0517D799101BB' , KIND = I8B ), & INT ( Z '8F48A4899877186C' , KIND = I8B ), INT ( Z 'B3C4F1BA87BC8696' , KIND = I8B ), & INT ( Z 'A2C28F54968B57B3' , KIND = I8B ), INT ( Z '3BC465DCD7F5422A' , KIND = I8B ), & INT ( Z '331ACDABFE94DE87' , KIND = I8B ), INT ( Z 'E0B62E2929ABA83C' , KIND = I8B ), & INT ( Z 'A5B99994DE1716D0' , KIND = I8B ), INT ( Z '855ABFAA06F9495A' , KIND = I8B ), & INT ( Z '9FF0C08B7F1D0B14' , KIND = I8B ), INT ( Z '8C71DCD9BA0B4925' , KIND = I8B ), & INT ( Z '4F27FFFA159CDC84' , KIND = I8B ), INT ( Z 'A6B16F9488B79BB1' , KIND = I8B ), & INT ( Z '07ECF0AE5EE44DD9' , KIND = I8B ), INT ( Z 'AF8E5410288E1B6F' , KIND = I8B ), & INT ( Z 'A2F1FFF89B0413A5' , KIND = I8B ), INT ( Z '105DCB79AAE5829D' , KIND = I8B ), & INT ( Z 'C9E82CD9F69D6150' , KIND = I8B ), INT ( Z 'DB71E91432B1A24A' , KIND = I8B ), & INT ( Z '85D73FFB60E28C47' , KIND = I8B ), INT ( Z '0A3A9F2C0ACF71A2' , KIND = I8B ), & INT ( Z 'BE311C083A225CD2' , KIND = I8B ), INT ( Z '892731AC9FAF056E' , KIND = I8B ), & INT ( Z '274D0FFA391B2F59' , KIND = I8B ), INT ( Z '8CC946F70D834E0B' , KIND = I8B ), & INT ( Z '6DBD630A48AAF406' , KIND = I8B ), INT ( Z 'AB70FE17C79AC6CA' , KIND = I8B ), & INT ( Z 'F12053F8C761FB2F' , KIND = I8B ), INT ( Z '2FFB98B4D0E4218D' , KIND = I8B ), & INT ( Z '092CBBCCDAD5B108' , KIND = I8B ), INT ( Z 'D64D3D9DB981787D' , KIND = I8B ), & INT ( Z 'B6B4347B7C9D3CFD' , KIND = I8B ), INT ( Z '1DFD3F71028E94F8' , KIND = I8B ), & INT ( Z '25BBF56008C58EA5' , KIND = I8B ), INT ( Z '85F0468293F0EB4E' , KIND = I8B ), & INT ( Z 'E461419A5BC48C3D' , KIND = I8B ), INT ( Z '657C8F4D43323A36' , KIND = I8B ), & INT ( Z 'AF2AF2B80AF6F24E' , KIND = I8B ), INT ( Z 'A76C582338ED2621' , KIND = I8B ), & INT ( Z '9D799200F2B5AF4C' , KIND = I8B ), INT ( Z 'FEDBB32093FEC8C4' , KIND = I8B ), & INT ( Z '1AF5AF660DB4AEE1' , KIND = I8B ), INT ( Z 'D1476E2C07286FAA' , KIND = I8B ), & INT ( Z 'E26BFB4097B18D8F' , KIND = I8B ), INT ( Z '3F494FF45C7F3D7A' , KIND = I8B ), & INT ( Z '50D98D9FC890ED4D' , KIND = I8B ), INT ( Z '82CCA4DB847945CA' , KIND = I8B ), & INT ( Z '9B06FA10BD9DF0F3' , KIND = I8B ), INT ( Z '8F1BA3F1739F0CD9' , KIND = I8B ), & INT ( Z 'E50FF107BAB528A0' , KIND = I8B ), INT ( Z 'A37FCE126597973C' , KIND = I8B ), & INT ( Z '01C8B894ED056D30' , KIND = I8B ), INT ( Z 'B2E28CEDD086D010' , KIND = I8B ), & INT ( Z '1E53ED49A96272C8' , KIND = I8B ), INT ( Z 'CC5FC196FEFD7D0C' , KIND = I8B ), & INT ( Z '023AE6BA2846C87C' , KIND = I8B ), INT ( Z 'DF9B302944A88414' , KIND = I8B ), & INT ( Z '25E8E89C13BB0F7A' , KIND = I8B ), INT ( Z 'FF77B1FCBEBCDC4F' , KIND = I8B ), & INT ( Z '8164D034592C3D4E' , KIND = I8B ), INT ( Z 'CBC0FE19CAE9528C' , KIND = I8B ), & INT ( Z '77B191618C54E9AC' , KIND = I8B ), INT ( Z '9FAACF3DF73609B1' , KIND = I8B ), & INT ( Z 'A1BE04416F774CA1' , KIND = I8B ), INT ( Z 'FEB13DA03DA3A72F' , KIND = I8B ), & INT ( Z 'D59DF5B9EF6A2417' , KIND = I8B ), INT ( Z 'C795830D75038C1D' , KIND = I8B ), & INT ( Z '8A2D8551CB551FC9' , KIND = I8B ), INT ( Z 'FE5D8D084D0C90FB' , KIND = I8B ), & INT ( Z '4B0573286B44AD1D' , KIND = I8B ), INT ( Z 'F97AE3D0D2446F25' , KIND = I8B ), & INT ( Z '365C73531F1533DE' , KIND = I8B ), INT ( Z 'BEFA78253027DA9D' , KIND = I8B ), & INT ( Z '4EE367F9430AEC32' , KIND = I8B ), INT ( Z '9BECCE62836AC577' , KIND = I8B ), & INT ( Z '83F39027E6DA80D5' , KIND = I8B ), INT ( Z '6EB9162E7C31D144' , KIND = I8B ), & INT ( Z '229C41F793CDA73F' , KIND = I8B ), INT ( Z 'C2E801FB244576D5' , KIND = I8B ), & INT ( Z 'A4F07431E091210B' , KIND = I8B ), INT ( Z '4A675BBA1B3E4595' , KIND = I8B ), & INT ( Z '6B43527578C1110F' , KIND = I8B ), INT ( Z 'F3A20279ED56D48A' , KIND = I8B ), & INT ( Z '8716489F2C5AB4A6' , KIND = I8B ), INT ( Z '8E8099545106EB7D' , KIND = I8B ), & INT ( Z '830A13896B78AAA9' , KIND = I8B ), INT ( Z '9845418C345644D6' , KIND = I8B ), & INT ( Z 'E8DBDAC6F77161D0' , KIND = I8B ), INT ( Z 'F220BFA96548A65C' , KIND = I8B ), & INT ( Z '23CC986BC656D553' , KIND = I8B ), INT ( Z 'BE5691EF416BD60C' , KIND = I8B ), & INT ( Z '2312D178B54DBA44' , KIND = I8B ), INT ( Z 'EEA8EF93BE9ACFF4' , KIND = I8B ), & INT ( Z '2CBFBE86B7EC8AA8' , KIND = I8B ), INT ( Z 'EDEC366B11C6CB8F' , KIND = I8B ), & INT ( Z '95EBC2EB7150946B' , KIND = I8B ), INT ( Z '952995BC5720C1F8' , KIND = I8B ), & INT ( Z '7BF7D71432F3D6A9' , KIND = I8B ), INT ( Z '94B3A202EB1C3F39' , KIND = I8B ), & INT ( Z 'BB66B3A64DA4B985' , KIND = I8B ), INT ( Z 'FA73FB2B6CE8F276' , KIND = I8B ), & INT ( Z 'DAF5CCD93FB0CC53' , KIND = I8B ), INT ( Z 'B9E08A83A5E34F07' , KIND = I8B ), & INT ( Z '6A40608FE10DE7E7' , KIND = I8B ), INT ( Z 'F910F9F648232F14' , KIND = I8B ), & INT ( Z 'D1B3400F8F9CFF68' , KIND = I8B ), INT ( Z 'E858AD248F5C22C9' , KIND = I8B ), & INT ( Z 'C2683C59ECA8B0F0' , KIND = I8B ), INT ( Z '9BAA9C39ED15FD6C' , KIND = I8B ), & INT ( Z '23100809B9C21FA1' , KIND = I8B ), INT ( Z '91376C36D99995BE' , KIND = I8B ), & INT ( Z 'F3024B7067D2DD2C' , KIND = I8B ), INT ( Z '02954348685B7CC7' , KIND = I8B ), & INT ( Z 'ABD40A0C2832A78A' , KIND = I8B ), INT ( Z 'B58547448FFFFB2D' , KIND = I8B ), & INT ( Z 'EFC2DE4C81C79477' , KIND = I8B ), INT ( Z '833A941A82725BF9' , KIND = I8B ), & INT ( Z '16C90C8F323F516C' , KIND = I8B ), INT ( Z 'E2E69915B3FFF9F9' , KIND = I8B ), & INT ( Z '35D9CAEFD11CBCCA' , KIND = I8B ), INT ( Z 'D2049C909187797C' , KIND = I8B ), & INT ( Z 'AE3DA7D97F6792E3' , KIND = I8B ), INT ( Z '8DD01FAD907FFC3B' , KIND = I8B ), & INT ( Z '43503DABC563EBFD' , KIND = I8B ), INT ( Z 'C685C3B4B5E957DB' , KIND = I8B ), & INT ( Z '99CD11CFDF41779C' , KIND = I8B ), INT ( Z 'B1442798F49FFB4A' , KIND = I8B ), & INT ( Z '14244D16B6BCE6FD' , KIND = I8B ), INT ( Z 'F82734A1E363ADD2' , KIND = I8B ), & INT ( Z '40405643D711D583' , KIND = I8B ), INT ( Z 'DD95317F31C7FA1D' , KIND = I8B ), & INT ( Z '4C96B02E3236105E' , KIND = I8B ), INT ( Z '7B1880E52E1E4CA3' , KIND = I8B ), & INT ( Z '482835EA666B2572' , KIND = I8B ), INT ( Z '8A7D3EEF7F1CFC52' , KIND = I8B ), & INT ( Z '1FBC5C39BEC39475' , KIND = I8B ), INT ( Z '19DEA11E79A5DFCC' , KIND = I8B ), & INT ( Z 'DA3243650005EECF' , KIND = I8B ), INT ( Z 'AD1C8EAB5EE43B66' , KIND = I8B ), & INT ( Z '27AB73482E747993' , KIND = I8B ), INT ( Z 'E0564966180F57BF' , KIND = I8B ), & INT ( Z '90BED43E40076A82' , KIND = I8B ), INT ( Z 'D863B256369D4A40' , KIND = I8B ), & INT ( Z '78CB280D1D08CBFB' , KIND = I8B ), INT ( Z 'CC35EDDFCF0996D7' , KIND = I8B ), & INT ( Z '5A7744A6E804A291' , KIND = I8B ), INT ( Z '873E4F75E2224E68' , KIND = I8B ), & INT ( Z '56FDF210644AFEFA' , KIND = I8B ), INT ( Z '3F436957C2CBFC8D' , KIND = I8B ), & INT ( Z '711515D0A205CB36' , KIND = I8B ), INT ( Z 'A90DE3535AAAE202' , KIND = I8B ), & INT ( Z 'ACBD6E947D5DBEB9' , KIND = I8B ), INT ( Z 'CF1443ADB37EFBB0' , KIND = I8B ), & INT ( Z '0D5A5B44CA873E03' , KIND = I8B ), INT ( Z 'D3515C2831559A83' , KIND = I8B ), & INT ( Z '6BF6651CCE5A9734' , KIND = I8B ), INT ( Z '616CAA4C902F5D4E' , KIND = I8B ), & INT ( Z 'E858790AFE9486C2' , KIND = I8B ), INT ( Z '8412D9991ED58091' , KIND = I8B ), & INT ( Z '06F3FE6401F13D01' , KIND = I8B ), INT ( Z 'F9C7D4DFB43B34A2' , KIND = I8B ), & INT ( Z '626E974DBE39A872' , KIND = I8B ), INT ( Z 'A5178FFF668AE0B6' , KIND = I8B ), & INT ( Z '88B0FDFD026D8C41' , KIND = I8B ), INT ( Z 'B839CA17A14A01CA' , KIND = I8B ), & INT ( Z 'FB0A3D212DC8128F' , KIND = I8B ), INT ( Z 'CE5D73FF402D98E3' , KIND = I8B ), & INT ( Z '956E9EBE218477A8' , KIND = I8B ), INT ( Z 'D3241E4EC4CE411E' , KIND = I8B ), & INT ( Z '7CE66634BC9D0B99' , KIND = I8B ), INT ( Z '80FA687F881C7F8E' , KIND = I8B ), & INT ( Z '3ACA466DA9E59593' , KIND = I8B ), INT ( Z '47ED25E27601D166' , KIND = I8B ), & INT ( Z '1C1FFFC1EBC44E80' , KIND = I8B ), INT ( Z 'A139029F6A239F72' , KIND = I8B ), & INT ( Z 'C97CD809145EFAF7' , KIND = I8B ), INT ( Z '59E86F5B138245BF' , KIND = I8B ), & INT ( Z 'A327FFB266B56220' , KIND = I8B ), INT ( Z 'C987434744AC874E' , KIND = I8B ), & INT ( Z 'BBDC0E0B5976B9B5' , KIND = I8B ), INT ( Z '70628B31D862D72F' , KIND = I8B ), & INT ( Z '4BF1FF9F0062BAA8' , KIND = I8B ), INT ( Z 'FBE9141915D7A922' , KIND = I8B ), & INT ( Z 'D56988C717EA3411' , KIND = I8B ), INT ( Z '463D96FF273DC67D' , KIND = I8B ), & INT ( Z '6F773FC3603DB4A9' , KIND = I8B ), INT ( Z '9D71AC8FADA6C9B5' , KIND = I8B ), & INT ( Z '4AC3EAF8DDE4C115' , KIND = I8B ), INT ( Z '97CCFCBEF10D381D' , KIND = I8B ), & INT ( Z 'CB550FB4384D21D3' , KIND = I8B ), INT ( Z 'C4CE17B399107C22' , KIND = I8B ), & INT ( Z '9D74E5B7155DF15B' , KIND = I8B ), INT ( Z '7DC03BEEAD508624' , KIND = I8B ), & INT ( Z '7E2A53A146606A48' , KIND = I8B ), INT ( Z 'F6019DA07F549B2B' , KIND = I8B ), & INT ( Z 'E2690F926D5AB6D9' , KIND = I8B ), INT ( Z '4E9825752C5253D6' , KIND = I8B ), & INT ( Z '2EDA7444CBFC426D' , KIND = I8B ), INT ( Z '99C102844F94E0FB' , KIND = I8B ), & INT ( Z '9B03537708B1648F' , KIND = I8B ), INT ( Z 'A23E2ED27766E8CC' , KIND = I8B ), & INT ( Z 'FA911155FEFB5308' , KIND = I8B ), INT ( Z 'C0314325637A1939' , KIND = I8B ), & INT ( Z 'C1C42854CADDBDB3' , KIND = I8B ), INT ( Z 'CACDBA871540A2FF' , KIND = I8B ), & INT ( Z '793555AB7EBA27CA' , KIND = I8B ), INT ( Z 'F03D93EEBC589F88' , KIND = I8B ), & INT ( Z 'D91A9934FECA9690' , KIND = I8B ), INT ( Z 'BEC094946D4865DF' , KIND = I8B ), & INT ( Z '4BC1558B2F3458DE' , KIND = I8B ), INT ( Z '96267C7535B763B5' , KIND = I8B ), & INT ( Z 'CF613F823E7D3C34' , KIND = I8B ), INT ( Z '6E70B9B9889A7F57' , KIND = I8B ), & INT ( Z '9EB1AAEDFB016F16' , KIND = I8B ), INT ( Z 'BBB01B9283253CA2' , KIND = I8B ), & INT ( Z 'C3398F62CE1C8B41' , KIND = I8B ), INT ( Z '0A0CE827EAC11F2D' , KIND = I8B ), & INT ( Z '465E15A979C1CADC' , KIND = I8B ), INT ( Z 'EA9C227723EE8BCB' , KIND = I8B ), & INT ( Z '9A03F99DC0D1D708' , KIND = I8B ), INT ( Z '86481118F2B8B37C' , KIND = I8B ), & INT ( Z '0BFACD89EC191EC9' , KIND = I8B ), INT ( Z '92A1958A7675175F' , KIND = I8B ), & INT ( Z 'C084F80531064CCA' , KIND = I8B ), INT ( Z 'E7DA155F2F66E05B' , KIND = I8B ), & INT ( Z 'CEF980EC671F667B' , KIND = I8B ), INT ( Z 'B749FAED14125D36' , KIND = I8B ), & INT ( Z 'B0A636067D47DFFD' , KIND = I8B ), INT ( Z 'E1D09AB6FB409872' , KIND = I8B ), & INT ( Z '82B7E12780E7401A' , KIND = I8B ), INT ( Z 'E51C79A85916F484' , KIND = I8B ), & INT ( Z 'AE67E1C40E4CEBFE' , KIND = I8B ), INT ( Z 'CD2260B25D085F47' , KIND = I8B ), & INT ( Z 'D1B2ECB8B0908810' , KIND = I8B ), INT ( Z '8F31CC0937AE58D2' , KIND = I8B ), & INT ( Z '9A01DA3511E026FE' , KIND = I8B ), INT ( Z '006AF8DEF44A7719' , KIND = I8B ), & INT ( Z '861FA7E6DCB4AA15' , KIND = I8B ), INT ( Z 'B2FE3F0B8599EF07' , KIND = I8B ), & INT ( Z '008250C2565830BD' , KIND = I8B ), INT ( Z '4085B716B15D14E0' , KIND = I8B ), & INT ( Z '67A791E093E1D49A' , KIND = I8B ), INT ( Z 'DFBDCECE67006AC9' , KIND = I8B ), & INT ( Z '0051727975F71E76' , KIND = I8B ), INT ( Z '6853926E2EDA2D0C' , KIND = I8B ), & INT ( Z 'E0C8BB2C5C6D24E0' , KIND = I8B ), INT ( Z '8BD6A141006042BD' , KIND = I8B ), & INT ( Z '0065CF17D374E614' , KIND = I8B ), INT ( Z '82687709BA90B84F' , KIND = I8B ), & INT ( Z '58FAE9F773886E18' , KIND = I8B ), INT ( Z 'AECC49914078536D' , KIND = I8B ), & INT ( Z 'C07F42DDC8521F99' , KIND = I8B ), INT ( Z 'A30294CC2934E662' , KIND = I8B ), & INT ( Z 'AF39A475506A899E' , KIND = I8B ), INT ( Z 'DA7F5BF590966848' , KIND = I8B ), & INT ( Z 'B84F89CA9D3353BF' , KIND = I8B ), INT ( Z '25E19CFF99C10FFD' , KIND = I8B ), & INT ( Z '6D8406C952429603' , KIND = I8B ), INT ( Z '888F99797A5E012D' , KIND = I8B ), & INT ( Z '26636C3D448028AF' , KIND = I8B ), INT ( Z 'EF5A043F803153FD' , KIND = I8B ), & INT ( Z 'C8E5087BA6D33B83' , KIND = I8B ), INT ( Z 'AAB37FD7D8F58178' , KIND = I8B ), & INT ( Z '6FFC474C95A032DB' , KIND = I8B ), INT ( Z 'EB30854F603DA8FC' , KIND = I8B ), & INT ( Z 'FB1E4A9A90880A64' , KIND = I8B ), INT ( Z 'D5605FCDCF32E1D6' , KIND = I8B ), & INT ( Z 'C5FDAC8FDD841FC9' , KIND = I8B ), INT ( Z '12FE53519C26899D' , KIND = I8B ), & INT ( Z '5CF2EEA09A55067F' , KIND = I8B ), INT ( Z '855C3BE0A17FCD26' , KIND = I8B ), & INT ( Z '377D17B3D4E527BB' , KIND = I8B ), INT ( Z 'D7BDE82603302C05' , KIND = I8B ), & INT ( Z 'F42FAA48C0EA481E' , KIND = I8B ), INT ( Z 'A6B34AD8C9DFC06F' , KIND = I8B ), & INT ( Z '855C5DA0CA1E71AA' , KIND = I8B ), INT ( Z '8DAD622F83FC3706' , KIND = I8B ), & INT ( Z 'F13B94DAF124DA26' , KIND = I8B ), INT ( Z 'D0601D8EFC57B08B' , KIND = I8B ), & INT ( Z '1359BA847E53070A' , KIND = I8B ), INT ( Z '188C5D5DB27DA264' , KIND = I8B ), & INT ( Z '76C53D08D6B70858' , KIND = I8B ), INT ( Z '823C12795DB6CE57' , KIND = I8B ), & INT ( Z '183029259DE7C8CD' , KIND = I8B ), INT ( Z '1EAF74B51F1D0AFD' , KIND = I8B ), & INT ( Z '54768C4B0C64CA6E' , KIND = I8B ), INT ( Z 'A2CB1717B52481ED' , KIND = I8B ), & INT ( Z '5E3C336F0561BB00' , KIND = I8B ), INT ( Z 'A65B51E266E44DBC' , KIND = I8B ), & INT ( Z 'A9942F5DCF7DFD09' , KIND = I8B ), INT ( Z 'CB7DDCDDA26DA268' , KIND = I8B ), & INT ( Z '75CB404AC6BA29C0' , KIND = I8B ), INT ( Z '0FF2265B009D612B' , KIND = I8B ), & INT ( Z 'D3F93B35435D7C4C' , KIND = I8B ), INT ( Z 'FE5D54150B090B02' , KIND = I8B ), & INT ( Z '299F082EBC345A18' , KIND = I8B ), INT ( Z '89F757F8E0625CBB' , KIND = I8B ), & INT ( Z 'C47BC5014A1A6DAF' , KIND = I8B ), INT ( Z '9EFA548D26E5A6E1' , KIND = I8B ), & INT ( Z 'F406CA3A6B41709E' , KIND = I8B ), INT ( Z '6C752DF7187AF3E9' , KIND = I8B ), & INT ( Z '359AB6419CA1091B' , KIND = I8B ), INT ( Z 'C6B8E9B0709F109A' , KIND = I8B ), & INT ( Z '71087CC90611CCC6' , KIND = I8B ), INT ( Z '47927974DE99B0E4' , KIND = I8B ), & INT ( Z 'C30163D203C94B62' , KIND = I8B ), INT ( Z 'F867241C8CC6D4C0' , KIND = I8B ), & INT ( Z 'C6A54DFDA3CB1FFB' , KIND = I8B ), INT ( Z '6CBB8BE90B200E8E' , KIND = I8B ), & INT ( Z '79E0DE63425DCF1D' , KIND = I8B ), INT ( Z '9B407691D7FC44F8' , KIND = I8B ), & INT ( Z '784EA17D0CBDE7FA' , KIND = I8B ), INT ( Z 'C7EA6EE34DE81232' , KIND = I8B ), & INT ( Z '985915FC12F542E4' , KIND = I8B ), INT ( Z 'C21094364DFB5636' , KIND = I8B ), & INT ( Z '166249DC4FED61F9' , KIND = I8B ), INT ( Z 'F9E50A9C216216BF' , KIND = I8B ), & INT ( Z '3E6F5B7B17B2939D' , KIND = I8B ), INT ( Z 'F294B943E17A2BC4' , KIND = I8B ), & INT ( Z '6DFD6E29B1F45D3B' , KIND = I8B ), INT ( Z 'BC2F26A194DD4E37' , KIND = I8B ), & INT ( Z 'A705992CEECF9C42' , KIND = I8B ), INT ( Z '979CF3CA6CEC5B5A' , KIND = I8B ), & INT ( Z '497CC9B41E71748A' , KIND = I8B ), INT ( Z '6B3AF049FA14A1C5' , KIND = I8B ), & INT ( Z '50C6FF782A838353' , KIND = I8B ), INT ( Z 'BD8430BD08277231' , KIND = I8B ), & INT ( Z '9BDBFC21260DD1AD' , KIND = I8B ), INT ( Z '4609AC5C7899CA36' , KIND = I8B ), & INT ( Z 'A4F8BF5635246428' , KIND = I8B ), INT ( Z 'ECE53CEC4A314EBD' , KIND = I8B ), & INT ( Z '21697D94B7C8A30C' , KIND = I8B ), INT ( Z '2BC60BB9CB601E62' , KIND = I8B ), & INT ( Z '871B7795E136BE99' , KIND = I8B ), INT ( Z '940F4613AE5ED136' , KIND = I8B ), & INT ( Z 'A9C3DCF9E5BACBCF' , KIND = I8B ), INT ( Z '76B78EA83E3825FA' , KIND = I8B ), & INT ( Z '28E2557B59846E3F' , KIND = I8B ), INT ( Z 'B913179899F68584' , KIND = I8B ), & INT ( Z '5434D4385F297EC3' , KIND = I8B ), INT ( Z '546572524DC62F79' , KIND = I8B ), & INT ( Z '331AEADA2FE589CF' , KIND = I8B ), INT ( Z 'E757DD7EC07426E5' , KIND = I8B ), & INT ( Z 'D4A104A33B79EF3A' , KIND = I8B ), INT ( Z '94BF6773709BDDAB' , KIND = I8B ), & INT ( Z '3FF0D2C85DEF7621' , KIND = I8B ), INT ( Z '9096EA6F3848984F' , KIND = I8B ), & INT ( Z 'C9C945CC0A586B08' , KIND = I8B ), INT ( Z 'F9EF41504CC2D516' , KIND = I8B ), & INT ( Z '0FED077A756B53A9' , KIND = I8B ), INT ( Z 'B4BCA50B065ABE63' , KIND = I8B ), & INT ( Z '7C3B973F0CEE85CA' , KIND = I8B ), INT ( Z '786B11A45FF38A5C' , KIND = I8B ), & INT ( Z 'D3E8495912C62894' , KIND = I8B ), INT ( Z 'E1EBCE4DC7F16DFB' , KIND = I8B ), & INT ( Z 'CDA53E876815139E' , KIND = I8B ), INT ( Z 'CB42EB06BBF83679' , KIND = I8B ), & INT ( Z '64712DD7ABBBD95C' , KIND = I8B ), INT ( Z '8D3360F09CF6E4BD' , KIND = I8B ), & INT ( Z '410E8E29421A5886' , KIND = I8B ), INT ( Z 'FE13A5C86AF64418' , KIND = I8B ), & INT ( Z 'BD8D794D96AACFB3' , KIND = I8B ), INT ( Z 'B080392CC4349DEC' , KIND = I8B ), & INT ( Z '515231B392A0EEA8' , KIND = I8B ), INT ( Z 'FD988F3A85B3D51E' , KIND = I8B ), & INT ( Z 'ECF0D7A0FC5583A0' , KIND = I8B ), INT ( Z 'DCA04777F541C567' , KIND = I8B ), & INT ( Z 'F2D35F103BA49529' , KIND = I8B ), INT ( Z '9E7F598493906532' , KIND = I8B ), & INT ( Z 'F41686C49DB57244' , KIND = I8B ), INT ( Z '89E42CAAF9491B60' , KIND = I8B ), & INT ( Z 'AF8836D44A8DBA73' , KIND = I8B ), INT ( Z 'C61F2FE5B8747E7F' , KIND = I8B ), & INT ( Z '311C2875C522CED5' , KIND = I8B ), INT ( Z 'AC5D37D5B79B6239' , KIND = I8B ), & INT ( Z '9B6A44895D312910' , KIND = I8B ), INT ( Z '37A6FBDF26919E1F' , KIND = I8B ), & INT ( Z '7D633293366B828B' , KIND = I8B ), INT ( Z 'D77485CB25823AC7' , KIND = I8B ), & INT ( Z 'C1226AD5DA3EB9AA' , KIND = I8B ), INT ( Z '02C85D6B781B02D3' , KIND = I8B ), & INT ( Z 'AE5DFF9C02033197' , KIND = I8B ), INT ( Z '86A8D39EF77164BC' , KIND = I8B ), & INT ( Z 'B16B058B50CE6814' , KIND = I8B ), INT ( Z 'C37A74C65621C388' , KIND = I8B ), & INT ( Z 'D9F57F830283FDFC' , KIND = I8B ), INT ( Z 'A8530886B54DBDEB' , KIND = I8B ), & INT ( Z 'DDC5C6EE25020219' , KIND = I8B ), INT ( Z 'F45911F7EBAA346A' , KIND = I8B ), & INT ( Z 'D072DF63C324FD7B' , KIND = I8B ), INT ( Z 'D267CAA862A12D66' , KIND = I8B ), & INT ( Z 'CA9B9C54D7214150' , KIND = I8B ), INT ( Z '78B7AB3AF34A60C2' , KIND = I8B ), & INT ( Z '4247CB9E59F71E6D' , KIND = I8B ), INT ( Z '8380DEA93DA4BC60' , KIND = I8B ), & INT ( Z '7D42836A0CE991A4' , KIND = I8B ), INT ( Z 'D6E59609B01CF8F3' , KIND = I8B ), & INT ( Z '52D9BE85F074E608' , KIND = I8B ), INT ( Z 'A46116538D0DEB78' , KIND = I8B ), & INT ( Z '5C9324449023F60D' , KIND = I8B ), INT ( Z '0C9EFB8C1C243730' , KIND = I8B ), & INT ( Z '67902E276C921F8B' , KIND = I8B ), INT ( Z 'CD795BE870516656' , KIND = I8B ), & INT ( Z '39DBF6AADA1679C8' , KIND = I8B ), INT ( Z 'E7E35D379196A27E' , KIND = I8B ), & INT ( Z '00BA1CD8A3DB53B6' , KIND = I8B ), INT ( Z '806BD9714632DFF6' , KIND = I8B ), & INT ( Z 'C852F455909C183A' , KIND = I8B ), INT ( Z 'A1DC348575FC4B1D' , KIND = I8B ), & INT ( Z '80E8A40ECCD228A4' , KIND = I8B ), INT ( Z 'A086CFCD97BF97F3' , KIND = I8B ), & INT ( Z '3A67B16AF4C31E48' , KIND = I8B ), INT ( Z 'CA5341A6D37B5DE5' , KIND = I8B ), & INT ( Z '6122CD128006B2CD' , KIND = I8B ), INT ( Z 'C8A883C0FDAF7DF0' , KIND = I8B ), & INT ( Z '89019DC5B1F3E5DB' , KIND = I8B ), INT ( Z '3CE81210885A355E' , KIND = I8B ), & INT ( Z '796B805720085F81' , KIND = I8B ), INT ( Z 'FAD2A4B13D1B5D6C' , KIND = I8B ), & INT ( Z '15A1029B8F386FA9' , KIND = I8B ), INT ( Z 'C6110B4A5538615B' , KIND = I8B ), & INT ( Z 'CBE3303674053BB0' , KIND = I8B ), INT ( Z '9CC3A6EEC6311A63' , KIND = I8B ), & INT ( Z 'DB09434273068B93' , KIND = I8B ), INT ( Z 'F7954E1CEA8679B1' , KIND = I8B ), & INT ( Z 'BEDBFC4411068A9C' , KIND = I8B ), INT ( Z 'C3F490AA77BD60FC' , KIND = I8B ), & INT ( Z '51CB94130FC82E78' , KIND = I8B ), INT ( Z '357AA1A42528181E' , KIND = I8B ), & INT ( Z 'EE92FB5515482D44' , KIND = I8B ), INT ( Z 'F4F1B4D515ACB93B' , KIND = I8B ), & INT ( Z 'F31F3C8BE9DD1D0B' , KIND = I8B ), INT ( Z 'A16CA50697390F12' , KIND = I8B ), & INT ( Z '751BDD152D4D1C4A' , KIND = I8B ), INT ( Z '991711052D8BF3C5' , KIND = I8B ), & INT ( Z 'AFE70BAEE454644D' , KIND = I8B ), INT ( Z '49C7CE483D0752D7' , KIND = I8B ), & INT ( Z 'D262D45A78A0635D' , KIND = I8B ), INT ( Z 'BF5CD54678EEF0B6' , KIND = I8B ), & INT ( Z '9BE0CE9A9D697D61' , KIND = I8B ), INT ( Z '9C39C1DA4C49278D' , KIND = I8B ), & INT ( Z '86FB897116C87C34' , KIND = I8B ), INT ( Z 'EF340A98172AACE4' , KIND = I8B ), & INT ( Z '816C8120A261EE5C' , KIND = I8B ), INT ( Z 'E1A419286FADB8B8' , KIND = I8B ), & INT ( Z 'D45D35E6AE3D4DA0' , KIND = I8B ), INT ( Z '9580869F0E7AAC0E' , KIND = I8B ), & INT ( Z 'A1C7A168CAFA69F3' , KIND = I8B ), INT ( Z '1A0D1F728B9926E6' , KIND = I8B ), & INT ( Z '8974836059CCA109' , KIND = I8B ), INT ( Z 'BAE0A846D2195712' , KIND = I8B ), & INT ( Z '4A3989C2FDB90470' , KIND = I8B ), INT ( Z '6090674F2E7F70A0' , KIND = I8B ), & INT ( Z '2BD1A438703FC94B' , KIND = I8B ), INT ( Z 'E998D258869FACD7' , KIND = I8B ), & INT ( Z '2E63F619DE93A2C6' , KIND = I8B ), INT ( Z '1C5A40917D0FA664' , KIND = I8B ), & INT ( Z '7B6306A34627DDCF' , KIND = I8B ), INT ( Z '91FF83775423CC06' , KIND = I8B ), & INT ( Z '39FCF3A056388B78' , KIND = I8B ), INT ( Z 'E370D0B5DC538FFD' , KIND = I8B ), & INT ( Z '1A3BC84C17B1D542' , KIND = I8B ), INT ( Z 'B67F6455292CBF08' , KIND = I8B ), & INT ( Z '887C30886BC6AE56' , KIND = I8B ), INT ( Z '9C4D04E3536873FC' , KIND = I8B ), & INT ( Z '20CABA5F1D9E4A93' , KIND = I8B ), INT ( Z 'E41F3D6A7377EECA' , KIND = I8B ), & INT ( Z 'D54D9E55435C2CF5' , KIND = I8B ), INT ( Z '41B0230E1421487D' , KIND = I8B ), & INT ( Z '547EB47B7282EE9C' , KIND = I8B ), INT ( Z '8E938662882AF53E' , KIND = I8B ), & INT ( Z '4AA105EA94333833' , KIND = I8B ), INT ( Z '521C2BD199299A9D' , KIND = I8B ), & INT ( Z 'E99E619A4F23AA43' , KIND = I8B ), INT ( Z 'B23867FB2A35B28D' , KIND = I8B ), & INT ( Z '9D49476539400640' , KIND = I8B ), INT ( Z '26A336C5FF740144' , KIND = I8B ), & INT ( Z '6405FA00E2EC94D4' , KIND = I8B ), INT ( Z 'DEC681F9F4C31F31' , KIND = I8B ), & INT ( Z 'E24DCC9F43C803E8' , KIND = I8B ), INT ( Z '9826023BBFA880CA' , KIND = I8B ), & INT ( Z 'DE83BC408DD3DD04' , KIND = I8B ), INT ( Z '8B3C113C38F9F37E' , KIND = I8B ), & INT ( Z '9AE13FC714BA04E2' , KIND = I8B ), INT ( Z 'BE2F82CAAF92A0FD' , KIND = I8B ), & INT ( Z '9624AB50B148D445' , KIND = I8B ), INT ( Z 'AE0B158B4738705E' , KIND = I8B ), & INT ( Z '01998FB8D9E8861A' , KIND = I8B ), INT ( Z '2DBB637D5B77493D' , KIND = I8B ), & INT ( Z '3BADD624DD9B0957' , KIND = I8B ), INT ( Z 'D98DDAEE19068C76' , KIND = I8B ), & INT ( Z '20FFF9D3883153D0' , KIND = I8B ), INT ( Z '7C951E2E592A8DC6' , KIND = I8B ), & INT ( Z 'E54CA5D70A80E5D6' , KIND = I8B ), INT ( Z '87F8A8D4CFA417C9' , KIND = I8B ), & INT ( Z 'A93FF8486A3DA8C4' , KIND = I8B ), INT ( Z '1BBA65B9EF753137' , KIND = I8B ), & INT ( Z '5E9FCF4CCD211F4C' , KIND = I8B ), INT ( Z 'A9F6D30A038D1DBC' , KIND = I8B ), & INT ( Z '938FF65A84CD12F6' , KIND = I8B ), INT ( Z '22A8FF286B527D85' , KIND = I8B ), & INT ( Z '7647C3200069671F' , KIND = I8B ), INT ( Z 'D47487CC8470652B' , KIND = I8B ), & INT ( Z '7C39F9F893002BD9' , KIND = I8B ), INT ( Z '75A99F7943138E73' , KIND = I8B ), & INT ( Z '29ECD9F40041E073' , KIND = I8B ), INT ( Z '84C8D4DFD2C63F3B' , KIND = I8B ), & INT ( Z '5B487876B7C036D0' , KIND = I8B ), INT ( Z '5314075793D87210' , KIND = I8B ), & INT ( Z 'F468107100525890' , KIND = I8B ), INT ( Z 'A5FB0A17C777CF09' , KIND = I8B ), & INT ( Z '721A969465B04484' , KIND = I8B ), INT ( Z '67D9092D78CE8E94' , KIND = I8B ), & INT ( Z '7182148D4066EEB4' , KIND = I8B ), INT ( Z 'CF79CC9DB955C2CC' , KIND = I8B ), & INT ( Z 'C7509E1CBF8E2AD2' , KIND = I8B ), INT ( Z 'C0E7A5BC6B81191C' , KIND = I8B ), & INT ( Z 'C6F14CD848405530' , KIND = I8B ), INT ( Z '81AC1FE293D599BF' , KIND = I8B ), & INT ( Z 'F924C5A3EF71B587' , KIND = I8B ), INT ( Z 'F1218F2B86615F63' , KIND = I8B ), & INT ( Z 'B8ADA00E5A506A7C' , KIND = I8B ), INT ( Z 'A21727DB38CB002F' , KIND = I8B ), & INT ( Z 'F76DF70CEB4E22E9' , KIND = I8B ), INT ( Z '2D69F2F667F9B73C' , KIND = I8B ), & INT ( Z 'A6D90811F0E4851C' , KIND = I8B ), INT ( Z 'CA9CF1D206FDC03B' , KIND = I8B ), & INT ( Z '354974D02621ABA3' , KIND = I8B ), INT ( Z '38C46FB401F8250C' , KIND = I8B ), & INT ( Z '908F4A166D1DA663' , KIND = I8B ), INT ( Z 'FD442E4688BD304A' , KIND = I8B ), & INT ( Z 'A14DE90217D50B46' , KIND = I8B ), INT ( Z '037AC5D0813B1727' , KIND = I8B ), & INT ( Z '9A598E4E043287FE' , KIND = I8B ), INT ( Z '9E4A9CEC15763E2E' , KIND = I8B ), & INT ( Z '89A163429DCA4E17' , KIND = I8B ), INT ( Z '84597744A189DCF1' , KIND = I8B ), & INT ( Z '40EFF1E1853F29FD' , KIND = I8B ), INT ( Z 'C5DD44271AD3CDBA' , KIND = I8B ), & INT ( Z 'EC09BC13453CE19D' , KIND = I8B ), INT ( Z 'E56FD515C9EC542D' , KIND = I8B ), & INT ( Z 'D12BEE59E68EF47C' , KIND = I8B ), INT ( Z 'F7549530E188C128' , KIND = I8B ), & INT ( Z 'B386158C0B460D02' , KIND = I8B ), INT ( Z '0F65E52D9E33B49C' , KIND = I8B ), & INT ( Z '82BB74F8301958CE' , KIND = I8B ), INT ( Z '9A94DD3E8CF578B9' , KIND = I8B ), & INT ( Z 'E0679AEF0E179043' , KIND = I8B ), INT ( Z '933F5E7905C0A1C3' , KIND = I8B ), & INT ( Z 'E36A52363C1FAF01' , KIND = I8B ), INT ( Z 'C13A148E3032D6E7' , KIND = I8B ), & INT ( Z 'D88181AAD19D7454' , KIND = I8B ), INT ( Z 'F80F36174730CA34' , KIND = I8B ), & INT ( Z 'DC44E6C3CB279AC1' , KIND = I8B ), INT ( Z 'F18899B1BC3F8CA1' , KIND = I8B ), & INT ( Z '0750F10AC30268B4' , KIND = I8B ), INT ( Z '3B0981CE8C7E7E61' , KIND = I8B ), & INT ( Z '29AB103A5EF8C0B9' , KIND = I8B ), INT ( Z '96F5600F15A7B7E5' , KIND = I8B ), & INT ( Z '49252D4D73C302E1' , KIND = I8B ), INT ( Z '89CBE2422F9E1DF9' , KIND = I8B ), & INT ( Z '7415D448F6B6F0E7' , KIND = I8B ), INT ( Z 'BCB2B812DB11A5DE' , KIND = I8B ), & INT ( Z '9B6E78A0D0B3C39A' , KIND = I8B ), INT ( Z '6C3EDAD2BB85A577' , KIND = I8B ), & INT ( Z '111B495B3464AD21' , KIND = I8B ), INT ( Z 'EBDF661791D60F56' , KIND = I8B ), & INT ( Z 'C1250B6482705A40' , KIND = I8B ), INT ( Z 'E3A748C3B533876A' , KIND = I8B ), & INT ( Z 'CAB10DD900BEEC34' , KIND = I8B ), INT ( Z '936B9FCEBB25C995' , KIND = I8B ), & INT ( Z '716E4E3DA30C70D0' , KIND = I8B ), INT ( Z '1C911AF4A2806945' , KIND = I8B ), & INT ( Z '3D5D514F40EEA742' , KIND = I8B ), INT ( Z 'B84687C269EF3BFB' , KIND = I8B ), & INT ( Z 'CDC9E1CD0BCF8D04' , KIND = I8B ), INT ( Z 'A3B561B1CB208396' , KIND = I8B ), & INT ( Z '0CB4A5A3112A5112' , KIND = I8B ), INT ( Z 'E65829B3046B0AFA' , KIND = I8B ), & INT ( Z '409E2D202761B822' , KIND = I8B ), INT ( Z 'A6515D0F1EF4523E' , KIND = I8B ), & INT ( Z '47F0E785EABA72AB' , KIND = I8B ), INT ( Z '8FF71A0FE2C2E6DC' , KIND = I8B ), & INT ( Z 'D0C5B868313A262B' , KIND = I8B ), INT ( Z '8FE5B452E6B166CD' , KIND = I8B ), & INT ( Z '59ED216765690F56' , KIND = I8B ), INT ( Z 'B3F4E093DB73A093' , KIND = I8B ), & INT ( Z '44F726823D88AFB6' , KIND = I8B ), INT ( Z '33DF2167A05DC081' , KIND = I8B ), & INT ( Z '306869C13EC3532C' , KIND = I8B ), INT ( Z 'E0F218B8D25088B8' , KIND = I8B ), & INT ( Z 'CB1A781166756DD1' , KIND = I8B ), INT ( Z 'A06B74E0C43A9850' , KIND = I8B ), & INT ( Z '1E414218C73A13FB' , KIND = I8B ), INT ( Z '8C974F7383725573' , KIND = I8B ), & INT ( Z 'FDE11615C012C946' , KIND = I8B ), INT ( Z '88865218F5493E64' , KIND = I8B ), & INT ( Z 'E5D1929EF90898FA' , KIND = I8B ), INT ( Z 'AFBD2350644EEACF' , KIND = I8B ), & INT ( Z '3D595B9B30177B98' , KIND = I8B ), INT ( Z '2AA7E69F329B8DFE' , KIND = I8B ), & INT ( Z 'DF45F746B74ABF39' , KIND = I8B ), INT ( Z 'DBAC6C247D62A583' , KIND = I8B ), & INT ( Z 'E657D940FE0EAD3F' , KIND = I8B ), INT ( Z 'BAA8F0237FA138BE' , KIND = I8B ), & INT ( Z '6B8BBA8C328EB783' , KIND = I8B ), INT ( Z '894BC396CE5DA772' , KIND = I8B ), & INT ( Z '9FEDCF913D92588E' , KIND = I8B ), INT ( Z 'A9532C2C5F8986EE' , KIND = I8B ), & INT ( Z '066EA92F3F326564' , KIND = I8B ), INT ( Z 'AB9EB47C81F5114F' , KIND = I8B ), & INT ( Z '47E943758CF6EEB2' , KIND = I8B ), INT ( Z 'D3A7F737776BE8AA' , KIND = I8B ), & INT ( Z 'C80A537B0EFEFEBD' , KIND = I8B ), INT ( Z 'D686619BA27255A2' , KIND = I8B ), & INT ( Z '6CF1CA29781A552F' , KIND = I8B ), INT ( Z 'A448FA82AAA3716A' , KIND = I8B ), & INT ( Z 'BD06742CE95F5F36' , KIND = I8B ), INT ( Z '8613FD0145877585' , KIND = I8B ), & INT ( Z '082E3CB3D620EA7B' , KIND = I8B ), INT ( Z '4D5B3923554C4DC5' , KIND = I8B ), & INT ( Z '2C48113823B73704' , KIND = I8B ), INT ( Z 'A798FC4196E952E7' , KIND = I8B ), & INT ( Z '4A39CBE0CBA9251A' , KIND = I8B ), INT ( Z '60B2076C2A9F6136' , KIND = I8B ), & INT ( Z 'F75A15862CA504C5' , KIND = I8B ), INT ( Z 'D17F3B51FCA3A7A0' , KIND = I8B ), & INT ( Z 'EE641F6C7F49B730' , KIND = I8B ), INT ( Z '5C6F44A39AA39CC1' , KIND = I8B ), & INT ( Z '9A984D73DBE722FB' , KIND = I8B ), INT ( Z '82EF85133DE648C4' , KIND = I8B ), & INT ( Z '69FD27479F1C24FC' , KIND = I8B ), INT ( Z '338B15CC814C83F2' , KIND = I8B ), & INT ( Z 'C13E60D0D2E0EBBA' , KIND = I8B ), INT ( Z 'A3AB66580D5FDAF5' , KIND = I8B ), & INT ( Z '047C711986E32E3B' , KIND = I8B ), INT ( Z 'C06DDB3FA19FA4EF' , KIND = I8B ), & INT ( Z '318DF905079926A8' , KIND = I8B ), INT ( Z 'CC963FEE10B7D1B3' , KIND = I8B ), & INT ( Z 'C59B8D5FE89BF9CA' , KIND = I8B ), INT ( Z 'F089520F8A078E2A' , KIND = I8B ), & INT ( Z 'FDF17746497F7052' , KIND = I8B ), INT ( Z 'FFBBCFE994E5C61F' , KIND = I8B ), & INT ( Z 'BB81385BF1617C1E' , KIND = I8B ), INT ( Z 'D655D349B644B8DA' , KIND = I8B ), & INT ( Z 'FEB6EA8BEDEFA633' , KIND = I8B ), INT ( Z '9FD561F1FD0F9BD3' , KIND = I8B ), & INT ( Z '6A618672EDB9DB26' , KIND = I8B ), INT ( Z 'CBEB481C23D5E711' , KIND = I8B ), & INT ( Z 'FE64A52EE96B8FC0' , KIND = I8B ), INT ( Z 'C7CABA6E7C5382C8' , KIND = I8B ), & INT ( Z 'C4F9E80FA92851EF' , KIND = I8B ), INT ( Z 'FEE61A232CCB60D5' , KIND = I8B ), & INT ( Z '3DFDCE7AA3C673B0' , KIND = I8B ), INT ( Z 'F9BD690A1B68637B' , KIND = I8B ), & INT ( Z '9B1C3109C9B93335' , KIND = I8B ), INT ( Z '9F4FD055FBFF1C85' , KIND = I8B ), & INT ( Z '06BEA10CA65C084E' , KIND = I8B ), INT ( Z '9C1661A651213E2D' , KIND = I8B ), & INT ( Z '01E33D4C3C278003' , KIND = I8B ), INT ( Z '4723C46B7AFEE3A7' , KIND = I8B ), & INT ( Z '486E494FCFF30A62' , KIND = I8B ), INT ( Z 'C31BFA0FE5698DB8' , KIND = I8B ), & INT ( Z 'C25C0C9F4B316004' , KIND = I8B ), INT ( Z 'D8ECB58659BE9C90' , KIND = I8B ), & INT ( Z '5A89DBA3C3EFCCFA' , KIND = I8B ), INT ( Z 'F3E2F893DEC3F126' , KIND = I8B ), & INT ( Z '797987E38EFEDC02' , KIND = I8B ), INT ( Z 'C793F173F81721DA' , KIND = I8B ), & INT ( Z 'F89629465A75E01C' , KIND = I8B ), INT ( Z '986DDB5C6B3A76B7' , KIND = I8B ), & INT ( Z '17D7E9DC72BE9303' , KIND = I8B ), INT ( Z 'F978EDD0F61CEA51' , KIND = I8B ), & INT ( Z 'F6BBB397F1135823' , KIND = I8B ), INT ( Z 'BE89523386091465' , KIND = I8B ), & INT ( Z '5DCDE4538F6E37C4' , KIND = I8B ), INT ( Z 'F7D7294533A424E5' , KIND = I8B ), & INT ( Z '746AA07DED582E2C' , KIND = I8B ), INT ( Z 'EE2BA6C0678B597F' , KIND = I8B ), & INT ( Z '5AA0AEB439A4E2DA' , KIND = I8B ), INT ( Z '1AE679CB4046970F' , KIND = I8B ), & INT ( Z 'A8C2A44EB4571CDC' , KIND = I8B ), INT ( Z '94DB483840B717EF' , KIND = I8B ), & INT ( Z '3148DA61480E1B91' , KIND = I8B ), INT ( Z '21A0183E10583CD3' , KIND = I8B ), & INT ( Z '92F34D62616CE413' , KIND = I8B ), INT ( Z 'BA121A4650E4DDEB' , KIND = I8B ), & INT ( Z 'FD9B10F99A11A275' , KIND = I8B ), INT ( Z 'EA081E4D946E4C07' , KIND = I8B ), & INT ( Z '77B020BAF9C81D17' , KIND = I8B ), INT ( Z 'E896A0D7E51E1566' , KIND = I8B ), & INT ( Z 'FE80EA9C004B0589' , KIND = I8B ), INT ( Z 'F24512F07CC4EF84' , KIND = I8B ), & INT ( Z '0ACE1474DC1D122E' , KIND = I8B ), INT ( Z '915E2486EF32CD60' , KIND = I8B ), & INT ( Z '3E212543005DC6EB' , KIND = I8B ), INT ( Z 'AED657AC9BF62B66' , KIND = I8B ), & INT ( Z '0D819992132456BA' , KIND = I8B ), INT ( Z 'B5B5ADA8AAFF80B8' , KIND = I8B ), & INT ( Z 'CDA96E93C07538A6' , KIND = I8B ), INT ( Z '5A8BED97C2F3B63F' , KIND = I8B ), & INT ( Z '10E1FFF697ED6C69' , KIND = I8B ), INT ( Z 'E3231912D5BF60E6' , KIND = I8B ), & INT ( Z 'E089E51C58494368' , KIND = I8B ), INT ( Z 'D897747ED9D851E7' , KIND = I8B ), & INT ( Z 'CA8D3FFA1EF463C1' , KIND = I8B ), INT ( Z '8DF5EFABC5979C8F' , KIND = I8B ), & INT ( Z 'D8AC5E636E5B9442' , KIND = I8B ), INT ( Z '4EBD519E904E6661' , KIND = I8B ), & INT ( Z 'BD308FF8A6B17CB2' , KIND = I8B ), INT ( Z 'B1736B96B6FD83B3' , KIND = I8B ), & INT ( Z '4ED775FC49F27952' , KIND = I8B ), INT ( Z 'E26CA6063461FFFA' , KIND = I8B ), & INT ( Z 'AC7CB3F6D05DDBDE' , KIND = I8B ), INT ( Z 'DDD0467C64BCE4A0' , KIND = I8B ), & INT ( Z '7146A9BDAE378BD3' , KIND = I8B ), INT ( Z '4D83E7C3E0BD3FFC' , KIND = I8B ), & INT ( Z '6BCDF07A423AA96B' , KIND = I8B ), INT ( Z '8AA22C0DBEF60EE4' , KIND = I8B ), & INT ( Z '8D98542D19C56EC8' , KIND = I8B ), INT ( Z '20E4E1B4D8EC8FFB' , KIND = I8B ), & INT ( Z '86C16C98D2C953C6' , KIND = I8B ), INT ( Z 'AD4AB7112EB3929D' , KIND = I8B ), & INT ( Z '70FE69386036CA7B' , KIND = I8B ), INT ( Z 'A91E1A220F27B3FA' , KIND = I8B ), & INT ( Z 'E871C7BF077BA8B7' , KIND = I8B ), INT ( Z 'D89D64D57A607744' , KIND = I8B ), & INT ( Z '869F01C33C223E8C' , KIND = I8B ), INT ( Z 'C9B2D0554978D07C' , KIND = I8B ), & INT ( Z '11471CD764AD4972' , KIND = I8B ), INT ( Z '87625F056C7C4A8B' , KIND = I8B ), & INT ( Z 'A846C2340B2ACE30' , KIND = I8B ), INT ( Z '7C1F846A9BD7049B' , KIND = I8B ), & INT ( Z 'D598E40D3DD89BCF' , KIND = I8B ), INT ( Z 'A93AF6C6C79B5D2D' , KIND = I8B ), & INT ( Z '925872C10DF581BC' , KIND = I8B ), INT ( Z '5B27658542CCC5C2' , KIND = I8B ), & INT ( Z '4AFF1D108D4EC2C3' , KIND = I8B ), INT ( Z 'D389B47879823479' , KIND = I8B ), & INT ( Z '9B7747B8A8B97115' , KIND = I8B ), INT ( Z '18F89F7349BFFB99' , KIND = I8B ), & INT ( Z 'CEDF722A585139BA' , KIND = I8B ), INT ( Z '843610CB4BF160CB' , KIND = I8B ), & INT ( Z '025519A6D2E7CD5A' , KIND = I8B ), INT ( Z '9F36C7501C2FFA80' , KIND = I8B ), & INT ( Z 'C2974EB4EE658828' , KIND = I8B ), INT ( Z 'A54394FE1EEDB8FE' , KIND = I8B ), & INT ( Z '02EA601087A1C0B1' , KIND = I8B ), INT ( Z 'C7047924233BF920' , KIND = I8B ), & INT ( Z '733D226229FEEA32' , KIND = I8B ), INT ( Z 'CE947A3DA6A9273E' , KIND = I8B ), & INT ( Z '01D27C0A54C5186F' , KIND = I8B ), INT ( Z 'BC62CBB696057BB4' , KIND = I8B ), & INT ( Z '0806357D5A3F525F' , KIND = I8B ), INT ( Z '811CCC668829B887' , KIND = I8B ), & INT ( Z '02471B0CE9F65E8A' , KIND = I8B ), INT ( Z 'AB7B7EA43B86DAA1' , KIND = I8B ), & INT ( Z 'CA07C2DCB0CF26F7' , KIND = I8B ), INT ( Z 'A163FF802A3426A8' , KIND = I8B ), & INT ( Z '42D8E1D02473F62D' , KIND = I8B ), INT ( Z '965A5E4D4A689149' , KIND = I8B ), & INT ( Z 'FC89B393DD02F0B5' , KIND = I8B ), INT ( Z 'C9BCFF6034C13052' , KIND = I8B ), & INT ( Z '938F1A442D90F3B8' , KIND = I8B ), INT ( Z 'FBF0F5E09D02B59B' , KIND = I8B ), & INT ( Z 'BBAC2078D443ACE2' , KIND = I8B ), INT ( Z 'FC2C3F3841F17C67' , KIND = I8B ), & INT ( Z '3C39706A9C7A9853' , KIND = I8B ), INT ( Z 'DD7699AC6221B181' , KIND = I8B ), & INT ( Z 'D54B944B84AA4C0D' , KIND = I8B ), INT ( Z '9D9BA7832936EDC0' , KIND = I8B ), & INT ( Z '8B47CC8543993E68' , KIND = I8B ), INT ( Z '54D440177AAA1DE1' , KIND = I8B ), & INT ( Z '0A9E795E65D4DF11' , KIND = I8B ), INT ( Z 'C5029163F384A931' , KIND = I8B ), & INT ( Z 'EE19BFA6947F8E02' , KIND = I8B ), INT ( Z 'AA09501D5954A559' , KIND = I8B ), & INT ( Z '4D4617B5FF4A16D5' , KIND = I8B ), INT ( Z 'F64335BCF065D37D' , KIND = I8B ), & INT ( Z '34D017C81CCFB8C1' , KIND = I8B ), INT ( Z '8A45D21257D4E758' , KIND = I8B ), & INT ( Z '504BCED1BF8E4E45' , KIND = I8B ), INT ( Z '99EA0196163FA42E' , KIND = I8B ), & INT ( Z '42041DBA2403A6F2' , KIND = I8B ), INT ( Z 'ECD74696EDCA212E' , KIND = I8B ), & INT ( Z 'E45EC2862F71E1D6' , KIND = I8B ), INT ( Z 'C06481FB9BCF8D39' , KIND = I8B ), & INT ( Z 'D2852528AD0490AE' , KIND = I8B ), INT ( Z 'A80D183CA93CA979' , KIND = I8B ), & INT ( Z '5D767327BB4E5A4C' , KIND = I8B ), INT ( Z 'F07DA27A82C37088' , KIND = I8B ), & INT ( Z '239337396C22DA6D' , KIND = I8B ), INT ( Z 'E9082F25E9C5E9EC' , KIND = I8B ), & INT ( Z '3A6A07F8D510F86F' , KIND = I8B ), INT ( Z '964E858C91BA2655' , KIND = I8B ), & INT ( Z '2C780507C72B9108' , KIND = I8B ), INT ( Z 'E34A3AEF64376467' , KIND = I8B ), & INT ( Z '890489F70A55368B' , KIND = I8B ), INT ( Z 'BBE226EFB628AFEA' , KIND = I8B ), & INT ( Z 'F7960649B8F6754A' , KIND = I8B ), INT ( Z 'DC1CC9AB3D453D80' , KIND = I8B ), & INT ( Z '2B45AC74CCEA842E' , KIND = I8B ), INT ( Z 'EADAB0ABA3B2DBE5' , KIND = I8B ), & INT ( Z '9ABDC3EE139A094E' , KIND = I8B ), INT ( Z '4991FE0B064B4670' , KIND = I8B ), & INT ( Z '3B0B8BC90012929D' , KIND = I8B ), INT ( Z '92C8AE6B464FC96F' , KIND = I8B ), & INT ( Z 'C16D34E998808BA2' , KIND = I8B ), INT ( Z '9BF67D8DC7DE180C' , KIND = I8B ), & INT ( Z '09CE6EBB40173744' , KIND = I8B ), INT ( Z 'B77ADA0617E3BBCB' , KIND = I8B ), & INT ( Z 'F1C88223FEA0AE8A' , KIND = I8B ), INT ( Z 'C2F41CF139D59E0F' , KIND = I8B ), & INT ( Z 'CC420A6A101D0515' , KIND = I8B ), INT ( Z 'E55990879DDCAABD' , KIND = I8B ), & INT ( Z 'F71D51567F246D16' , KIND = I8B ), INT ( Z '99D89216C42582C9' , KIND = I8B ), & INT ( Z '9FA946824A12232D' , KIND = I8B ), INT ( Z '8F57FA54C2A9EAB6' , KIND = I8B ), & INT ( Z '74E4A5AC1EED885C' , KIND = I8B ), INT ( Z '004EB69C752EE37C' , KIND = I8B ), & INT ( Z '47939822DC96ABF9' , KIND = I8B ), INT ( Z 'B32DF8E9F3546564' , KIND = I8B ), & INT ( Z '921DCF1726A8EA73' , KIND = I8B ), INT ( Z '40626443927A9C5B' , KIND = I8B ), & INT ( Z '59787E2B93BC56F7' , KIND = I8B ), INT ( Z 'DFF9772470297EBD' , KIND = I8B ), & INT ( Z '3B52A16E78299288' , KIND = I8B ), INT ( Z '883D7EAA3B8CA1B9' , KIND = I8B ), & INT ( Z '57EB4EDB3C55B65A' , KIND = I8B ), INT ( Z '8BFBEA76C619EF36' , KIND = I8B ), & INT ( Z '8A2749CA1633F72A' , KIND = I8B ), INT ( Z '2A4CDE54CA6FCA27' , KIND = I8B ), & INT ( Z 'EDE622920B6B23F1' , KIND = I8B ), INT ( Z 'AEFAE51477A06B03' , KIND = I8B ), & INT ( Z '6CB11C3C9BC0F4F4' , KIND = I8B ), INT ( Z '74E015E9FD0BBCB1' , KIND = I8B ), & INT ( Z 'E95FAB368E45ECED' , KIND = I8B ), INT ( Z 'DAB99E59958885C4' , KIND = I8B ), & INT ( Z 'E3EEB1A5E1589918' , KIND = I8B ), INT ( Z '690C0DB23E2755EE' , KIND = I8B ), & INT ( Z '11DBCB0218EBB414' , KIND = I8B ), INT ( Z '88B402F7FD75539B' , KIND = I8B ), & INT ( Z '9CEA5E0F59AEBF5F' , KIND = I8B ), INT ( Z '834F111ECDB12B6A' , KIND = I8B ), & INT ( Z 'D652BDC29F26A119' , KIND = I8B ), INT ( Z 'AAE103B5FCD2A881' , KIND = I8B ), & INT ( Z '4424F593301A6F37' , KIND = I8B ), INT ( Z 'E422D566811D7645' , KIND = I8B ), & INT ( Z '4BE76D3346F0495F' , KIND = I8B ), INT ( Z 'D59944A37C0752A2' , KIND = I8B ), & INT ( Z '4A97197BFE108582' , KIND = I8B ), INT ( Z 'EE95C56010B269EB' , KIND = I8B ), & INT ( Z '6F70A4400C562DDB' , KIND = I8B ), INT ( Z '857FCAE62D8493A5' , KIND = I8B ), & INT ( Z '1D3CDFDAFD94A6E2' , KIND = I8B ), INT ( Z 'EA3B36B814DF0466' , KIND = I8B ), & INT ( Z 'CB4CCD500F6BB952' , KIND = I8B ), INT ( Z 'A6DFBD9FB8E5B88E' , KIND = I8B ), & INT ( Z 'A48C17D1BCF9D09B' , KIND = I8B ), INT ( Z 'A4CA04661A16C57F' , KIND = I8B ), & INT ( Z '7E2000A41346A7A7' , KIND = I8B ), INT ( Z 'D097AD07A71F26B2' , KIND = I8B ), & INT ( Z 'C6D78EE3161C2261' , KIND = I8B ), INT ( Z 'C6FE42BFD04E3B6F' , KIND = I8B ), & INT ( Z '8ED400668C0C28C8' , KIND = I8B ), INT ( Z '825ECC24C873782F' , KIND = I8B ), & INT ( Z 'B88D729BDBA32AF9' , KIND = I8B ), INT ( Z 'F8BDD36FC461CA4B' , KIND = I8B ), & INT ( Z '728900802F0F32FA' , KIND = I8B ), INT ( Z 'A2F67F2DFA90563B' , KIND = I8B ), & INT ( Z 'A6B0CF42D28BF5B8' , KIND = I8B ), INT ( Z 'B6ED484BB57A3CDE' , KIND = I8B ), & INT ( Z '4F2B40A03AD2FFB9' , KIND = I8B ), INT ( Z 'CBB41EF979346BCA' , KIND = I8B ), & INT ( Z '505D0313872EF326' , KIND = I8B ), INT ( Z '24A89A5EA2D8CC16' , KIND = I8B ), & INT ( Z 'E2F610C84987BFA8' , KIND = I8B ), INT ( Z 'FEA126B7D78186BC' , KIND = I8B ), & INT ( Z 'F23A21EC347D57F7' , KIND = I8B ), INT ( Z '16E9607B25C77F8D' , KIND = I8B ), & INT ( Z '0DD9CA7D2DF4D7C9' , KIND = I8B ), INT ( Z '9F24B832E6B0F436' , KIND = I8B ), & INT ( Z '6EC8AA67419CADF5' , KIND = I8B ), INT ( Z '5CA3B899EF395F71' , KIND = I8B ), & INT ( Z '91503D1C79720DBB' , KIND = I8B ), INT ( Z 'C6EDE63FA05D3143' , KIND = I8B ), & INT ( Z 'CA7AD5011203D973' , KIND = I8B ), INT ( Z '33CCA6C06B07B74D' , KIND = I8B ), & INT ( Z '75A44C6397CE912A' , KIND = I8B ), INT ( Z 'F8A95FCF88747D94' , KIND = I8B ), & INT ( Z '9E8CC520AB4267E7' , KIND = I8B ), INT ( Z '605FE83842E4D290' , KIND = I8B ), & INT ( Z 'C986AFBE3EE11ABA' , KIND = I8B ), INT ( Z '9B69DBE1B548CE7C' , KIND = I8B ), & INT ( Z 'C62FF668D61301E1' , KIND = I8B ), INT ( Z 'F877E246539E0734' , KIND = I8B ), & INT ( Z 'FBE85BADCE996168' , KIND = I8B ), INT ( Z 'C24452DA229B021B' , KIND = I8B ), & INT ( Z 'F7BBF4030B97C25A' , KIND = I8B ), INT ( Z '3695DAD7E8858901' , KIND = I8B ), & INT ( Z 'FAE27299423FB9C3' , KIND = I8B ), INT ( Z 'F2D56790AB41C2A2' , KIND = I8B ), & INT ( Z '3AD57881E73ED978' , KIND = I8B ), INT ( Z '021DA8C6F15375A1' , KIND = I8B ), & INT ( Z 'DCCD879FC967D41A' , KIND = I8B ), INT ( Z '97C560BA6B0919A5' , KIND = I8B ), & INT ( Z '898AD6A2610E8FD6' , KIND = I8B ), INT ( Z '82A512F8ADA85309' , KIND = I8B ), & INT ( Z '5400E987BBC1C920' , KIND = I8B ), INT ( Z 'BDB6B8E905CB600F' , KIND = I8B ), & INT ( Z 'EBED8C4AF95233CC' , KIND = I8B ), INT ( Z 'A34E57B6D91267CB' , KIND = I8B ), & INT ( Z '290123E9AAB23B68' , KIND = I8B ), INT ( Z 'ED246723473E3813' , KIND = I8B ), & INT ( Z '737477AEDBD3605F' , KIND = I8B ), INT ( Z '6610F6D247AB80DF' , KIND = I8B ), & INT ( Z 'F9A0B6720AAF6521' , KIND = I8B ), INT ( Z '9436C0760C86E30B' , KIND = I8B ), & INT ( Z '5051959A92C83877' , KIND = I8B ), INT ( Z 'BF953486D9966117' , KIND = I8B ), & INT ( Z 'F808E40E8D5B3E69' , KIND = I8B ), INT ( Z 'B94470938FA89BCE' , KIND = I8B ), & INT ( Z '2465FB01377A4695' , KIND = I8B ), INT ( Z '2F7A81A88FFBF95D' , KIND = I8B ), & INT ( Z 'B60B1D1230B20E04' , KIND = I8B ), INT ( Z 'E7958CB87392C2C2' , KIND = I8B ), & INT ( Z '36BFBCE0C2AC6C1D' , KIND = I8B ), INT ( Z '9DAC910959FD7BDA' , KIND = I8B ), & INT ( Z 'B1C6F22B5E6F48C2' , KIND = I8B ), INT ( Z '90BD77F3483BB9B9' , KIND = I8B ), & INT ( Z 'C46FAC18F3578724' , KIND = I8B ), INT ( Z '4517B54BB07CDAD0' , KIND = I8B ), & INT ( Z '1E38AEB6360B1AF3' , KIND = I8B ), INT ( Z 'B4ECD5F01A4AA828' , KIND = I8B ), & INT ( Z 'F58B971F302D68EE' , KIND = I8B ), INT ( Z '165DA29E9C9C1184' , KIND = I8B ), & INT ( Z '25C6DA63C38DE1B0' , KIND = I8B ), INT ( Z 'E2280B6C20DD5232' , KIND = I8B ), & INT ( Z '19773E737E1C6194' , KIND = I8B ), INT ( Z '0DFA85A321E18AF3' , KIND = I8B ), & INT ( Z '579C487E5A38AD0E' , KIND = I8B ), INT ( Z '8D590723948A535F' , KIND = I8B ), & INT ( Z 'DFD50E105DA379F9' , KIND = I8B ), INT ( Z '9179270BEA59EDAF' , KIND = I8B ), & INT ( Z '2D835A9DF0C6D851' , KIND = I8B ), INT ( Z 'B0AF48EC79ACE837' , KIND = I8B ), & INT ( Z 'D7CA5194750C5878' , KIND = I8B ), INT ( Z 'F5D770CEE4F0691B' , KIND = I8B ), & INT ( Z 'F8E431456CF88E65' , KIND = I8B ), INT ( Z 'DCDB1B2798182244' , KIND = I8B ), & INT ( Z '66DE72FCC927B74B' , KIND = I8B ), INT ( Z 'B9A6A6814F1641B1' , KIND = I8B ), & INT ( Z '1B8E9ECB641B58FF' , KIND = I8B ), INT ( Z '8A08F0F8BF0F156B' , KIND = I8B ), & INT ( Z 'C0960FBBFB71A51E' , KIND = I8B ), INT ( Z 'A8105021A2DBD21D' , KIND = I8B ), & INT ( Z 'E272467E3D222F3F' , KIND = I8B ), INT ( Z 'AC8B2D36EED2DAC5' , KIND = I8B ), & INT ( Z '30BB93AAFA4E0E65' , KIND = I8B ), INT ( Z '9214642A0B92C6A5' , KIND = I8B ), & INT ( Z '5B0ED81DCC6ABB0F' , KIND = I8B ), INT ( Z 'D7ADF884AA879177' , KIND = I8B ), & INT ( Z '3E753C4ADC70C8FF' , KIND = I8B ), INT ( Z 'BB4CBE9A473BBC27' , KIND = I8B ), & INT ( Z '98E947129FC2B4E9' , KIND = I8B ), INT ( Z '86CCBB52EA94BAEA' , KIND = I8B ), & INT ( Z '0E128B5D938CFB3F' , KIND = I8B ), INT ( Z '2A1FEE40D90AAB31' , KIND = I8B ), & INT ( Z '3F2398D747B36224' , KIND = I8B ), INT ( Z 'A87FEA27A539E9A5' , KIND = I8B ), & INT ( Z '51972E34F8703A0F' , KIND = I8B ), INT ( Z '34A7E9D10F4D55FD' , KIND = I8B ), & INT ( Z '8EEC7F0D19A03AAD' , KIND = I8B ), INT ( Z 'D29FE4B18E88640E' , KIND = I8B ), & INT ( Z '52FE7CE11B462449' , KIND = I8B ), INT ( Z '40E8F222A99055BE' , KIND = I8B ), & INT ( Z '1953CF68300424AC' , KIND = I8B ), INT ( Z '83A3EEEEF9153E89' , KIND = I8B ), & INT ( Z 'E7BE1C196217AD5B' , KIND = I8B ), INT ( Z '51232EAB53F46B2D' , KIND = I8B ), & INT ( Z '5FA8C3423C052DD7' , KIND = I8B ), INT ( Z 'A48CEAAAB75A8E2B' , KIND = I8B ), & INT ( Z '61ADA31FBA9D98B2' , KIND = I8B ), INT ( Z '256BFA5628F185F9' , KIND = I8B ), & INT ( Z '3792F412CB06794D' , KIND = I8B ), INT ( Z 'CDB02555653131B6' , KIND = I8B ), & INT ( Z 'DD0C85F3D4A27F6F' , KIND = I8B ), INT ( Z '37637C75D996F3BB' , KIND = I8B ), & INT ( Z 'E2BBD88BBEE40BD0' , KIND = I8B ), INT ( Z '808E17555F3EBF11' , KIND = I8B ), & INT ( Z 'D44FA770C9CB1F4B' , KIND = I8B ), INT ( Z '453C5B934FFCB0AA' , KIND = I8B ), & INT ( Z '5B6ACEAEAE9D0EC4' , KIND = I8B ), INT ( Z 'A0B19D2AB70E6ED6' , KIND = I8B ), & INT ( Z '8963914CFC3DE71E' , KIND = I8B ), INT ( Z '568B727823FBDCD5' , KIND = I8B ), & INT ( Z 'F245825A5A445275' , KIND = I8B ), INT ( Z 'C8DE047564D20A8B' , KIND = I8B ), & INT ( Z 'EBBC75A03B4D60E6' , KIND = I8B ), INT ( Z 'AC2E4F162CFAD40A' , KIND = I8B ), & INT ( Z 'EED6E2F0F0D56712' , KIND = I8B ), INT ( Z 'FB158592BE068D2E' , KIND = I8B ), & INT ( Z 'D355C98425105C90' , KIND = I8B ), INT ( Z 'AB9CF16DDC1CC486' , KIND = I8B ), & INT ( Z '55464DD69685606B' , KIND = I8B ), INT ( Z '9CED737BB6C4183D' , KIND = I8B ), & INT ( Z '882B3BE52E5473B4' , KIND = I8B ), INT ( Z '96842DC95323F5A8' , KIND = I8B ), & INT ( Z 'AA97E14C3C26B886' , KIND = I8B ), INT ( Z 'C428D05AA4751E4C' , KIND = I8B ), & INT ( Z 'AA360ADE79E990A1' , KIND = I8B ), INT ( Z '3C25393BA7ECF312' , KIND = I8B ), & INT ( Z 'D53DD99F4B3066A8' , KIND = I8B ), INT ( Z 'F53304714D9265DF' , KIND = I8B ), & INT ( Z 'AA61C6CB0C31FA64' , KIND = I8B ), INT ( Z '259743C548F417EB' , KIND = I8B ), & INT ( Z 'E546A8038EFE4029' , KIND = I8B ), INT ( Z '993FE2C6D07B7FAB' , KIND = I8B ), & INT ( Z '94FA387DCF3E78FD' , KIND = I8B ), INT ( Z '6EFD14B69B311DE6' , KIND = I8B ), & INT ( Z 'DE98520472BDD033' , KIND = I8B ), INT ( Z 'BF8FDB78849A5F96' , KIND = I8B ), & INT ( Z '3A38C69D430E173D' , KIND = I8B ), INT ( Z '4ABC59E441FD6560' , KIND = I8B ), & INT ( Z '963E66858F6D4440' , KIND = I8B ), INT ( Z 'EF73D256A5C0F77C' , KIND = I8B ), & INT ( Z '24637C2249E8CE86' , KIND = I8B ), INT ( Z '2EB5B82EA93E5F5C' , KIND = I8B ), & INT ( Z 'DDE7001379A44AA8' , KIND = I8B ), INT ( Z '95A8637627989AAD' , KIND = I8B ), & INT ( Z '2D7C5B2ADC630227' , KIND = I8B ), INT ( Z '3A63263A538DF733' , KIND = I8B ), & INT ( Z '5560C018580D5D52' , KIND = I8B ), INT ( Z 'BB127C53B17EC159' , KIND = I8B ), & INT ( Z 'F8DB71F5937BC2B1' , KIND = I8B ), INT ( Z 'C8FBEFC8E87174FF' , KIND = I8B ), & INT ( Z 'AAB8F01E6E10B4A6' , KIND = I8B ), INT ( Z 'E9D71B689DDE71AF' , KIND = I8B ), & INT ( Z 'FB8927397C2D59AF' , KIND = I8B ), INT ( Z '3D9D75DD9146E91F' , KIND = I8B ), & INT ( Z 'CAB3961304CA70E8' , KIND = I8B ), INT ( Z '9226712162AB070D' , KIND = I8B ), & INT ( Z 'FA6B7107DB38B01A' , KIND = I8B ), INT ( Z '4D04D354F598A367' , KIND = I8B ), & INT ( Z '3D607B97C5FD0D22' , KIND = I8B ), INT ( Z 'B6B00D69BB55C8D1' , KIND = I8B ), & INT ( Z 'F9064D49D206DC21' , KIND = I8B ), INT ( Z 'E046082A32FECC41' , KIND = I8B ), & INT ( Z '8CB89A7DB77C506A' , KIND = I8B ), INT ( Z 'E45C10C42A2B3B05' , KIND = I8B ), & INT ( Z '3BA3F04E23444995' , KIND = I8B ), INT ( Z 'CC2BC51A5FDF3FA9' , KIND = I8B ), & INT ( Z '77F3608E92ADB242' , KIND = I8B ), INT ( Z '8EB98A7A9A5B04E3' , KIND = I8B ), & INT ( Z '8A8CEC61AC155BFA' , KIND = I8B ), INT ( Z '7F36B660F7D70F93' , KIND = I8B ), & INT ( Z '55F038B237591ED3' , KIND = I8B ), INT ( Z 'B267ED1940F1C61C' , KIND = I8B ), & INT ( Z '6D30277A171AB2F8' , KIND = I8B ), INT ( Z '5F0463F935CCD378' , KIND = I8B ), & INT ( Z '6B6C46DEC52F6688' , KIND = I8B ), INT ( Z 'DF01E85F912E37A3' , KIND = I8B ), & INT ( Z '443E18AC4E70AFDB' , KIND = I8B ), INT ( Z '3B62BE7BC1A0042B' , KIND = I8B ), & INT ( Z '2323AC4B3B3DA015' , KIND = I8B ), INT ( Z '8B61313BBABCE2C6' , KIND = I8B ), & INT ( Z '154D9ED7620CDBD2' , KIND = I8B ), INT ( Z '8A3B6E1AB2080536' , KIND = I8B ), & INT ( Z 'ABEC975E0A0D081A' , KIND = I8B ), INT ( Z 'AE397D8AA96C1B77' , KIND = I8B ), & INT ( Z '9AA1068D3A9012C7' , KIND = I8B ), INT ( Z '2CCA49A15E8A0683' , KIND = I8B ), & INT ( Z '96E7BD358C904A21' , KIND = I8B ), INT ( Z 'D9C7DCED53C72255' , KIND = I8B ), & INT ( Z '40A4A418449A0BBC' , KIND = I8B ), INT ( Z 'BBFE6E04DB164412' , KIND = I8B ), & INT ( Z '7E50D64177DA2E54' , KIND = I8B ), INT ( Z '881CEA14545C7575' , KIND = I8B ), & INT ( Z 'D0CDCD1E55C08EAB' , KIND = I8B ), INT ( Z 'EAFE098611DBD516' , KIND = I8B ), & INT ( Z 'DDE50BD1D5D0B9E9' , KIND = I8B ), INT ( Z 'AA242499697392D2' , KIND = I8B ), & INT ( Z '85014065EB30B256' , KIND = I8B ), INT ( Z '65BD8BE79652CA5C' , KIND = I8B ), & INT ( Z '955E4EC64B44E864' , KIND = I8B ), INT ( Z 'D4AD2DBFC3D07787' , KIND = I8B ), & INT ( Z 'D320C83FB2FE6F75' , KIND = I8B ), INT ( Z 'BF967770BDF3BE79' , KIND = I8B ), & INT ( Z 'BD5AF13BEF0B113E' , KIND = I8B ), INT ( Z '84EC3C97DA624AB4' , KIND = I8B ), & INT ( Z '47E8FA4F9FBE0B53' , KIND = I8B ), INT ( Z '6F7C154CED70AE18' , KIND = I8B ), & INT ( Z 'ECB1AD8AEACDD58E' , KIND = I8B ), INT ( Z 'A6274BBDD0FADD61' , KIND = I8B ), & INT ( Z '59E338E387AD8E28' , KIND = I8B ), INT ( Z '0B5B1AA028CCD99E' , KIND = I8B ), & INT ( Z '67DE18EDA5814AF2' , KIND = I8B ), INT ( Z 'CFB11EAD453994BA' , KIND = I8B ), & INT ( Z 'F82E038E34CC78D9' , KIND = I8B ), INT ( Z '4718F0A419800802' , KIND = I8B ), & INT ( Z '80EACF948770CED7' , KIND = I8B ), INT ( Z '81CEB32C4B43FCF4' , KIND = I8B ), & INT ( Z 'B6398471C1FF970F' , KIND = I8B ), INT ( Z '18DF2CCD1FE00A03' , KIND = I8B ), & INT ( Z 'A1258379A94D028D' , KIND = I8B ), INT ( Z 'A2425FF75E14FC31' , KIND = I8B ), & INT ( Z 'A3C7E58E327F7CD3' , KIND = I8B ), INT ( Z '5F16F80067D80C84' , KIND = I8B ), & INT ( Z '096EE45813A04330' , KIND = I8B ), INT ( Z 'CAD2F7F5359A3B3E' , KIND = I8B ), & INT ( Z 'CCB9DEF1BF1F5C08' , KIND = I8B ), INT ( Z '76DCB60081CE0FA5' , KIND = I8B ), & INT ( Z '8BCA9D6E188853FC' , KIND = I8B ), INT ( Z 'FD87B5F28300CA0D' , KIND = I8B ), & INT ( Z '9FF42B5717739985' , KIND = I8B ), INT ( Z 'CA49F1C05120C9C7' , KIND = I8B ), & INT ( Z '775EA264CF55347D' , KIND = I8B ), INT ( Z '9E74D1B791E07E48' , KIND = I8B ), & INT ( Z '87F1362CDD507FE6' , KIND = I8B ), INT ( Z '3CDC6E306568FC39' , KIND = I8B ), & INT ( Z '95364AFE032A819D' , KIND = I8B ), INT ( Z 'C612062576589DDA' , KIND = I8B ), & INT ( Z 'E9ED83B814A49FE0' , KIND = I8B ), INT ( Z '8C1389BC7EC33B47' , KIND = I8B ), & INT ( Z '3A83DDBD83F52204' , KIND = I8B ), INT ( Z 'F79687AED3EEC551' , KIND = I8B ), & INT ( Z 'F23472530CE6E3EC' , KIND = I8B ), INT ( Z 'D78C3615CF3A050C' , KIND = I8B ), & INT ( Z 'C4926A9672793542' , KIND = I8B ), INT ( Z '9ABE14CD44753B52' , KIND = I8B ), & INT ( Z '2EC18EE7D0209CE7' , KIND = I8B ), INT ( Z '8D6F439B43088650' , KIND = I8B ), & INT ( Z '75B7053C0F178293' , KIND = I8B ), INT ( Z 'C16D9A0095928A27' , KIND = I8B ), & INT ( Z '3A71F2A1C428C420' , KIND = I8B ), INT ( Z '70CB148213CAA7E4' , KIND = I8B ), & INT ( Z '5324C68B12DD6338' , KIND = I8B ), INT ( Z 'F1C90080BAF72CB1' , KIND = I8B ), & INT ( Z 'A48737A51A997A94' , KIND = I8B ), INT ( Z '467EECD14C5EA8EE' , KIND = I8B ), & INT ( Z 'D3F6FC16EBCA5E03' , KIND = I8B ), INT ( Z '971DA05074DA7BEE' , KIND = I8B ), & INT ( Z '4DA9058E613FD939' , KIND = I8B ), INT ( Z '181EA8059F76532A' , KIND = I8B ), & INT ( Z '88F4BB1CA6BCF584' , KIND = I8B ), INT ( Z 'BCE5086492111AEA' , KIND = I8B ), & INT ( Z 'E11346F1F98FCF88' , KIND = I8B ), INT ( Z '1E2652070753E7F4' , KIND = I8B ), & INT ( Z '2B31E9E3D06C32E5' , KIND = I8B ), INT ( Z 'EC1E4A7DB69561A5' , KIND = I8B ), & INT ( Z '0CAC0C573BF9E1B5' , KIND = I8B ), INT ( Z '32D7F344649470F9' , KIND = I8B ), & INT ( Z '3AFF322E62439FCF' , KIND = I8B ), INT ( Z '9392EE8E921D5D07' , KIND = I8B ), & INT ( Z '4FD70F6D0AF85A22' , KIND = I8B ), INT ( Z 'FF8DF0157DB98D37' , KIND = I8B ), & INT ( Z '09BEFEB9FAD487C2' , KIND = I8B ), INT ( Z 'B877AA3236A4B449' , KIND = I8B ), & INT ( Z '23CCD3484DB670AA' , KIND = I8B ), INT ( Z 'BF716C1ADD27F085' , KIND = I8B ), & INT ( Z '4C2EBE687989A9B3' , KIND = I8B ), INT ( Z 'E69594BEC44DE15B' , KIND = I8B ), & INT ( Z '3660040D3092066A' , KIND = I8B ), INT ( Z '57A6E390CA38F653' , KIND = I8B ), & INT ( Z '0F9D37014BF60A10' , KIND = I8B ), INT ( Z '901D7CF73AB0ACD9' , KIND = I8B ), & INT ( Z '03F805107CB68805' , KIND = I8B ), INT ( Z '6D909C74FCC733E8' , KIND = I8B ), & INT ( Z '538484C19EF38C94' , KIND = I8B ), INT ( Z 'B424DC35095CD80F' , KIND = I8B ), & INT ( Z '04F606549BE42A06' , KIND = I8B ), INT ( Z '88F4C3923BF900E2' , KIND = I8B ), & INT ( Z '2865A5F206B06FB9' , KIND = I8B ), INT ( Z 'E12E13424BB40E13' , KIND = I8B ), & INT ( Z '4319C3F4E16E9A44' , KIND = I8B ), INT ( Z 'F598FA3B657BA08D' , KIND = I8B ), & INT ( Z 'F93F87B7442E45D3' , KIND = I8B ), INT ( Z '8CBCCC096F5088CB' , KIND = I8B ), & INT ( Z '93E034F219CA40D5' , KIND = I8B ), INT ( Z 'F2FF38CA3EDA88B0' , KIND = I8B ), & INT ( Z 'F78F69A51539D748' , KIND = I8B ), INT ( Z 'AFEBFF0BCB24AAFE' , KIND = I8B ), & INT ( Z 'B8D8422EA03CD10A' , KIND = I8B ), INT ( Z '2FBF06FCCE912ADC' , KIND = I8B ), & INT ( Z 'B573440E5A884D1B' , KIND = I8B ), INT ( Z 'DBE6FECEBDEDD5BE' , KIND = I8B ), & INT ( Z 'F387295D242602A6' , KIND = I8B ), INT ( Z 'FDD7645E011ABAC9' , KIND = I8B ), & INT ( Z '31680A88F8953030' , KIND = I8B ), INT ( Z '89705F4136B4A597' , KIND = I8B ), & INT ( Z '7068F3B46D2F8350' , KIND = I8B ), INT ( Z '3D4D3D758161697C' , KIND = I8B ), & INT ( Z 'FDC20D2B36BA7C3D' , KIND = I8B ), INT ( Z 'ABCC77118461CEFC' , KIND = I8B ), & INT ( Z '8C8330A1887B6424' , KIND = I8B ), INT ( Z '8CA08CD2E1B9C3DB' , KIND = I8B ), & INT ( Z '3D32907604691B4C' , KIND = I8B ), INT ( Z 'D6BF94D5E57A42BC' , KIND = I8B ), & INT ( Z '37D1FE64F54D1E96' , KIND = I8B ), INT ( Z 'D7E45803CD141A69' , KIND = I8B ), & INT ( Z 'A63F9A49C2C1B10F' , KIND = I8B ), INT ( Z '8637BD05AF6C69B5' , KIND = I8B ), & INT ( Z '85C67DFE32A0663C' , KIND = I8B ), INT ( Z 'CDDD6E04C0592103' , KIND = I8B ), & INT ( Z '0FCF80DC33721D53' , KIND = I8B ), INT ( Z 'A7C5AC471B478423' , KIND = I8B ), & INT ( Z '67381D7DBF487FCB' , KIND = I8B ), INT ( Z 'C154C985F06F6944' , KIND = I8B ), & INT ( Z 'D3C36113404EA4A8' , KIND = I8B ), INT ( Z 'D1B71758E219652B' , KIND = I8B ), & INT ( Z 'C083126E978D4FDF' , KIND = I8B ), INT ( Z '78D4FDF3B645A1CA' , KIND = I8B ), & INT ( Z '645A1CAC083126E9' , KIND = I8B ), INT ( Z '83126E978D4FDF3B' , KIND = I8B ), & INT ( Z '70A3D70A3D70A3D7' , KIND = I8B ), INT ( Z 'D70A3D70A3D70A3D' , KIND = I8B ), & INT ( Z '3D70A3D70A3D70A3' , KIND = I8B ), INT ( Z 'A3D70A3D70A3D70A' , KIND = I8B ), & INT ( Z 'CCCCCCCCCCCCCCCC' , KIND = I8B ), INT ( Z 'CCCCCCCCCCCCCCCC' , KIND = I8B ), & INT ( Z 'CCCCCCCCCCCCCCCC' , KIND = I8B ), INT ( Z 'CCCCCCCCCCCCCCCC' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '8000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'A000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'C800000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'FA00000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '9C40000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'C350000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'F424000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '9896800000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'BEBC200000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'EE6B280000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '9502F90000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'BA43B74000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'E8D4A51000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '9184E72A00000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'B5E620F480000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'E35FA931A0000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '8E1BC9BF04000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'B1A2BC2EC5000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'DE0B6B3A76400000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '8AC7230489E80000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'AD78EBC5AC620000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'D8D726B7177A8000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '878678326EAC9000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'A968163F0A57B400' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'D3C21BCECCEDA100' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '84595161401484A0' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'A56FA5B99019A5C8' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'CECB8F27F4200F3A' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '4000000000000000' , KIND = I8B ), INT ( Z '813F3978F8940984' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '5000000000000000' , KIND = I8B ), INT ( Z 'A18F07D736B90BE5' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'A400000000000000' , KIND = I8B ), INT ( Z 'C9F2C9CD04674EDE' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '4D00000000000000' , KIND = I8B ), INT ( Z 'FC6F7C4045812296' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'F020000000000000' , KIND = I8B ), INT ( Z '9DC5ADA82B70B59D' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '6C28000000000000' , KIND = I8B ), INT ( Z 'C5371912364CE305' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'C732000000000000' , KIND = I8B ), INT ( Z 'F684DF56C3E01BC6' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '3C7F400000000000' , KIND = I8B ), INT ( Z '9A130B963A6C115C' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '4B9F100000000000' , KIND = I8B ), INT ( Z 'C097CE7BC90715B3' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '1E86D40000000000' , KIND = I8B ), INT ( Z 'F0BDC21ABB48DB20' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '1314448000000000' , KIND = I8B ), INT ( Z '96769950B50D88F4' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '17D955A000000000' , KIND = I8B ), INT ( Z 'BC143FA4E250EB31' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '5DCFAB0800000000' , KIND = I8B ), INT ( Z 'EB194F8E1AE525FD' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '5AA1CAE500000000' , KIND = I8B ), INT ( Z '92EFD1B8D0CF37BE' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'F14A3D9E40000000' , KIND = I8B ), INT ( Z 'B7ABC627050305AD' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '6D9CCD05D0000000' , KIND = I8B ), INT ( Z 'E596B7B0C643C719' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'E4820023A2000000' , KIND = I8B ), INT ( Z '8F7E32CE7BEA5C6F' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'DDA2802C8A800000' , KIND = I8B ), INT ( Z 'B35DBF821AE4F38B' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'D50B2037AD200000' , KIND = I8B ), INT ( Z 'E0352F62A19E306E' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '4526F422CC340000' , KIND = I8B ), INT ( Z '8C213D9DA502DE45' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '9670B12B7F410000' , KIND = I8B ), INT ( Z 'AF298D050E4395D6' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '3C0CDD765F114000' , KIND = I8B ), INT ( Z 'DAF3F04651D47B4C' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'A5880A69FB6AC800' , KIND = I8B ), INT ( Z '88D8762BF324CD0F' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '8EEA0D047A457A00' , KIND = I8B ), INT ( Z 'AB0E93B6EFEE0053' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '72A4904598D6D880' , KIND = I8B ), INT ( Z 'D5D238A4ABE98068' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '47A6DA2B7F864750' , KIND = I8B ), INT ( Z '85A36366EB71F041' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '999090B65F67D924' , KIND = I8B ), INT ( Z 'A70C3C40A64E6C51' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'FFF4B4E3F741CF6D' , KIND = I8B ), INT ( Z 'D0CF4B50CFE20765' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '2000000000000000' , KIND = I8B ), & INT ( Z 'BFF8F10E7A8921A4' , KIND = I8B ), INT ( Z '82818F1281ED449F' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '2800000000000000' , KIND = I8B ), & INT ( Z 'AFF72D52192B6A0D' , KIND = I8B ), INT ( Z 'A321F2D7226895C7' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '7200000000000000' , KIND = I8B ), & INT ( Z '9BF4F8A69F764490' , KIND = I8B ), INT ( Z 'CBEA6F8CEB02BB39' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '8E80000000000000' , KIND = I8B ), & INT ( Z '02F236D04753D5B4' , KIND = I8B ), INT ( Z 'FEE50B7025C36A08' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'D910000000000000' , KIND = I8B ), & INT ( Z '01D762422C946590' , KIND = I8B ), INT ( Z '9F4F2726179A2245' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0F54000000000000' , KIND = I8B ), & INT ( Z '424D3AD2B7B97EF5' , KIND = I8B ), INT ( Z 'C722F0EF9D80AAD6' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '5329000000000000' , KIND = I8B ), & INT ( Z 'D2E0898765A7DEB2' , KIND = I8B ), INT ( Z 'F8EBAD2B84E0D58B' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '73F9A00000000000' , KIND = I8B ), & INT ( Z '63CC55F49F88EB2F' , KIND = I8B ), INT ( Z '9B934C3B330C8577' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '50F8080000000000' , KIND = I8B ), & INT ( Z '3CBF6B71C76B25FB' , KIND = I8B ), INT ( Z 'C2781F49FFCFA6D5' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '25360A0000000000' , KIND = I8B ), & INT ( Z '8BEF464E3945EF7A' , KIND = I8B ), INT ( Z 'F316271C7FC3908A' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '5741C64000000000' , KIND = I8B ), & INT ( Z '97758BF0E3CBB5AC' , KIND = I8B ), INT ( Z '97EDD871CFDA3A56' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '6D1237D000000000' , KIND = I8B ), & INT ( Z '3D52EEED1CBEA317' , KIND = I8B ), INT ( Z 'BDE94E8E43D0C8EC' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '4856C5C400000000' , KIND = I8B ), & INT ( Z '4CA7AAA863EE4BDD' , KIND = I8B ), INT ( Z 'ED63A231D4C4FB27' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '4D363B9A80000000' , KIND = I8B ), & INT ( Z '8FE8CAA93E74EF6A' , KIND = I8B ), INT ( Z '945E455F24FB1CF8' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'E083CA8120000000' , KIND = I8B ), & INT ( Z 'B3E2FD538E122B44' , KIND = I8B ), INT ( Z 'B975D6B6EE39E436' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '18A4BD2168000000' , KIND = I8B ), & INT ( Z '60DBBCA87196B616' , KIND = I8B ), INT ( Z 'E7D34C64A9C85D44' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'CF66F634E1000000' , KIND = I8B ), & INT ( Z 'BC8955E946FE31CD' , KIND = I8B ), INT ( Z '90E40FBEEA1D3A4A' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '4340B3C219400000' , KIND = I8B ), & INT ( Z '6BABAB6398BDBE41' , KIND = I8B ), INT ( Z 'B51D13AEA4A488DD' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '9410E0B29F900000' , KIND = I8B ), & INT ( Z 'C696963C7EED2DD1' , KIND = I8B ), INT ( Z 'E264589A4DCDAB14' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'FC8A8C6FA3BA0000' , KIND = I8B ), & INT ( Z 'FC1E1DE5CF543CA2' , KIND = I8B ), INT ( Z '8D7EB76070A08AEC' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'BBAD2F8B8CA88000' , KIND = I8B ), & INT ( Z '3B25A55F43294BCB' , KIND = I8B ), INT ( Z 'B0DE65388CC8ADA8' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'AA987B6E6FD2A000' , KIND = I8B ), & INT ( Z '49EF0EB713F39EBE' , KIND = I8B ), INT ( Z 'DD15FE86AFFAD912' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '2A9F4D2505E3A400' , KIND = I8B ), & INT ( Z '6E3569326C784337' , KIND = I8B ), INT ( Z '8A2DBF142DFCC7AB' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'F547206E475C8D00' , KIND = I8B ), & INT ( Z '49C2C37F07965404' , KIND = I8B ), INT ( Z 'ACB92ED9397BF996' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '3298E889D933B040' , KIND = I8B ), & INT ( Z 'DC33745EC97BE906' , KIND = I8B ), INT ( Z 'D7E77A8F87DAF7FB' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'DF9F915627C04E28' , KIND = I8B ), & INT ( Z '69A028BB3DED71A3' , KIND = I8B ), INT ( Z '86F0AC99B4E8DAFD' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z 'D78775ABB1B061B2' , KIND = I8B ), & INT ( Z 'C40832EA0D68CE0C' , KIND = I8B ), INT ( Z 'A8ACD7C0222311BC' , KIND = I8B ), & INT ( Z '8000000000000000' , KIND = I8B ), INT ( Z '0D6953169E1C7A1E' , KIND = I8B ), & INT ( Z 'F50A3FA490C30190' , KIND = I8B ), INT ( Z 'D2D80DB02AABD62B' , KIND = I8B ), & INT ( Z '1000000000000000' , KIND = I8B ), INT ( Z '0861D3EE22D1CC53' , KIND = I8B ), & INT ( Z '792667C6DA79E0FA' , KIND = I8B ), INT ( Z '83C7088E1AAB65DB' , KIND = I8B ), & INT ( Z 'D400000000000000' , KIND = I8B ), INT ( Z '8A7A48E9AB863F67' , KIND = I8B ), & INT ( Z '577001B891185938' , KIND = I8B ), INT ( Z 'A4B8CAB1A1563F52' , KIND = I8B ), & INT ( Z 'C900000000000000' , KIND = I8B ), INT ( Z 'AD18DB241667CF41' , KIND = I8B ), & INT ( Z 'ED4C0226B55E6F86' , KIND = I8B ), INT ( Z 'CDE6FD5E09ABCF26' , KIND = I8B ), & INT ( Z '1DA0000000000000' , KIND = I8B ), INT ( Z '2C2F88F68E00E189' , KIND = I8B ), & INT ( Z '544F8158315B05B4' , KIND = I8B ), INT ( Z '80B05E5AC60B6178' , KIND = I8B ), & INT ( Z '6508000000000000' , KIND = I8B ), INT ( Z '373B6B34318119EB' , KIND = I8B ), & INT ( Z '696361AE3DB1C721' , KIND = I8B ), INT ( Z 'A0DC75F1778E39D6' , KIND = I8B ), & INT ( Z '3E4A000000000000' , KIND = I8B ), INT ( Z '850A46013DE16066' , KIND = I8B ), & INT ( Z '03BC3A19CD1E38E9' , KIND = I8B ), INT ( Z 'C913936DD571C84C' , KIND = I8B ), & INT ( Z 'CDDC800000000000' , KIND = I8B ), INT ( Z 'E64CD7818D59B87F' , KIND = I8B ), & INT ( Z '04AB48A04065C723' , KIND = I8B ), INT ( Z 'FB5878494ACE3A5F' , KIND = I8B ), & INT ( Z 'E0A9D00000000000' , KIND = I8B ), INT ( Z '6FF006B0F858134F' , KIND = I8B ), & INT ( Z '62EB0D64283F9C76' , KIND = I8B ), INT ( Z '9D174B2DCEC0E47B' , KIND = I8B ), & INT ( Z 'D8D4440000000000' , KIND = I8B ), INT ( Z '0BEC085D366E1823' , KIND = I8B ), & INT ( Z '3BA5D0BD324F8394' , KIND = I8B ), INT ( Z 'C45D1DF942711D9A' , KIND = I8B ), & INT ( Z 'CF09550000000000' , KIND = I8B ), INT ( Z '0EE70A7484099E2C' , KIND = I8B ), & INT ( Z 'CA8F44EC7EE36479' , KIND = I8B ), INT ( Z 'F5746577930D6500' , KIND = I8B ), & INT ( Z '0165D52000000000' , KIND = I8B ), INT ( Z 'A9506688D28602DC' , KIND = I8B ), & INT ( Z '7E998B13CF4E1ECB' , KIND = I8B ), INT ( Z '9968BF6ABBE85F20' , KIND = I8B ), & INT ( Z '01BF4A6800000000' , KIND = I8B ), INT ( Z '93A4802B07278393' , KIND = I8B ), & INT ( Z '9E3FEDD8C321A67E' , KIND = I8B ), INT ( Z 'BFC2EF456AE276E8' , KIND = I8B ), & INT ( Z 'C22F1D0200000000' , KIND = I8B ), INT ( Z '388DA035C8F16477' , KIND = I8B ), & INT ( Z 'C5CFE94EF3EA101E' , KIND = I8B ), INT ( Z 'EFB3AB16C59B14A2' , KIND = I8B ), & INT ( Z 'D95D722140000000' , KIND = I8B ), INT ( Z 'E35884219D96DECA' , KIND = I8B ), & INT ( Z 'BBA1F1D158724A12' , KIND = I8B ), INT ( Z '95D04AEE3B80ECE5' , KIND = I8B ), & INT ( Z '8FB4CEA990000000' , KIND = I8B ), INT ( Z '9C2EA52A04FC967D' , KIND = I8B ), & INT ( Z '2A8A6E45AE8EDC97' , KIND = I8B ), INT ( Z 'BB445DA9CA61281F' , KIND = I8B ), & INT ( Z 'F3A20253F4000000' , KIND = I8B ), INT ( Z '833A4E74863BBC1C' , KIND = I8B ), & INT ( Z 'F52D09D71A3293BD' , KIND = I8B ), INT ( Z 'EA1575143CF97226' , KIND = I8B ), & INT ( Z '1845417478800000' , KIND = I8B ), INT ( Z '72047108D3E55592' , KIND = I8B ), & INT ( Z '593C2626705F9C56' , KIND = I8B ), INT ( Z '924D692CA61BE758' , KIND = I8B ), & INT ( Z '9E5691D196A00000' , KIND = I8B ), INT ( Z '0E858D4B08DEAAF6' , KIND = I8B ), & INT ( Z '6F8B2FB00C77836C' , KIND = I8B ), INT ( Z 'B6E0C377CFA2E12E' , KIND = I8B ), & INT ( Z '45EC3645FC480000' , KIND = I8B ), INT ( Z '1226F09DCB1655B4' , KIND = I8B ), & INT ( Z '0B6DFB9C0F956447' , KIND = I8B ), INT ( Z 'E498F455C38B997A' , KIND = I8B ), & INT ( Z 'ABB3A1EBBDAD0000' , KIND = I8B ), INT ( Z '6B5856629EEDF590' , KIND = I8B ), & INT ( Z '4724BD4189BD5EAC' , KIND = I8B ), INT ( Z '8EDF98B59A373FEC' , KIND = I8B ), & INT ( Z 'D6A08A66AD184000' , KIND = I8B ), INT ( Z '862E6BFB46A972F4' , KIND = I8B ), & INT ( Z '58EDEC91EC2CB657' , KIND = I8B ), INT ( Z 'B2977EE300C50FE7' , KIND = I8B ), & INT ( Z '0C48AD00585E5000' , KIND = I8B ), INT ( Z '67BA06FA1853CFB2' , KIND = I8B ), & INT ( Z '2F2967B66737E3ED' , KIND = I8B ), INT ( Z 'DF3D5E9BC0F653E1' , KIND = I8B ), & INT ( Z '47AD6C20373AF200' , KIND = I8B ), INT ( Z '60D4445C4F3461CF' , KIND = I8B ), & INT ( Z 'BD79E0D20082EE74' , KIND = I8B ), INT ( Z '8B865B215899F46C' , KIND = I8B ), & INT ( Z '1998C7284509AE80' , KIND = I8B ), INT ( Z '7909557363017A43' , KIND = I8B ), & INT ( Z 'ECD8590680A3AA11' , KIND = I8B ), INT ( Z 'AE67F1E9AEC07187' , KIND = I8B ), & INT ( Z 'DFFEF8F2564C1A20' , KIND = I8B ), INT ( Z 'D74BAAD03BC1D8D3' , KIND = I8B ), & INT ( Z 'E80E6F4820CC9495' , KIND = I8B ), INT ( Z 'DA01EE641A708DE9' , KIND = I8B ), & INT ( Z '6BFF5B9775EF9054' , KIND = I8B ), INT ( Z 'A68F4AC225592784' , KIND = I8B ), & INT ( Z '3109058D147FDCDD' , KIND = I8B ), INT ( Z '884134FE908658B2' , KIND = I8B ), & INT ( Z '86FF327D536B7469' , KIND = I8B ), INT ( Z '10331D72AEAF7165' , KIND = I8B ), & INT ( Z 'BD4B46F0599FD415' , KIND = I8B ), INT ( Z 'AA51823E34A7EEDE' , KIND = I8B ), & INT ( Z 'E8BEFF1CA8465183' , KIND = I8B ), INT ( Z '543FE4CF5A5B4DBE' , KIND = I8B ), & INT ( Z '6C9E18AC7007C91A' , KIND = I8B ), INT ( Z 'D4E5E2CDC1D1EA96' , KIND = I8B ), & INT ( Z '51775F71E92BF2F2' , KIND = I8B ), INT ( Z '74A7EF0198791097' , KIND = I8B ), & INT ( Z '03E2CF6BC604DDB0' , KIND = I8B ), INT ( Z '850FADC09923329E' , KIND = I8B ), & INT ( Z '25D5374E6376EFAE' , KIND = I8B ), INT ( Z '91D1EAC1FE9754BD' , KIND = I8B ), & INT ( Z '84DB8346B786151C' , KIND = I8B ), INT ( Z 'A6539930BF6BFF45' , KIND = I8B ), & INT ( Z '6F4A8521FC54AB9A' , KIND = I8B ), INT ( Z 'B64665727E3D29EC' , KIND = I8B ), & INT ( Z 'E612641865679A63' , KIND = I8B ), INT ( Z 'CFE87F7CEF46FF16' , KIND = I8B ), & INT ( Z 'C58E93353DB4EB40' , KIND = I8B ), INT ( Z '51EBFF678EE63A33' , KIND = I8B ), & INT ( Z '4FCB7E8F3F60C07E' , KIND = I8B ), INT ( Z '81F14FAE158C5F6E' , KIND = I8B ), & INT ( Z 'B6F238028D222610' , KIND = I8B ), INT ( Z 'E666FF41729FC8C0' , KIND = I8B ), & INT ( Z 'E3BE5E330F38F09D' , KIND = I8B ), INT ( Z 'A26DA3999AEF7749' , KIND = I8B ), & INT ( Z 'E4AEC603306AAF94' , KIND = I8B ), INT ( Z '6000BF11CF47BAF0' , KIND = I8B ), & INT ( Z '5CADF5BFD3072CC5' , KIND = I8B ), INT ( Z 'CB090C8001AB551C' , KIND = I8B ), & INT ( Z '1DDA7783FC855B79' , KIND = I8B ), INT ( Z 'B800EED64319A9AD' , KIND = I8B ), & INT ( Z '73D9732FC7C8F7F6' , KIND = I8B ), INT ( Z 'FDCB4FA002162A63' , KIND = I8B ), & INT ( Z '32A88AB27DD3592C' , KIND = I8B ), INT ( Z '33009545E9F00A0C' , KIND = I8B ), & INT ( Z '2867E7FDDCDD9AFA' , KIND = I8B ), INT ( Z '9E9F11C4014DDA7E' , KIND = I8B ), & INT ( Z '3F52AD5F1D482F77' , KIND = I8B ), INT ( Z 'BFC0BA97646C0C8F' , KIND = I8B ), & INT ( Z 'B281E1FD541501B8' , KIND = I8B ), INT ( Z 'C646D63501A1511D' , KIND = I8B ), & INT ( Z '0F2758B6E49A3B54' , KIND = I8B ), INT ( Z 'EFB0E93D3D870FB3' , KIND = I8B ), & INT ( Z '1F225A7CA91A4226' , KIND = I8B ), INT ( Z 'F7D88BC24209A565' , KIND = I8B ), & INT ( Z 'E97897724EE06515' , KIND = I8B ), INT ( Z '55CE91C6467469CF' , KIND = I8B ), & INT ( Z '3375788DE9B06958' , KIND = I8B ), INT ( Z '9AE757596946075F' , KIND = I8B ), & INT ( Z 'E3D6BD4EE2987E5A' , KIND = I8B ), INT ( Z '6B423637D8118443' , KIND = I8B ), & INT ( Z '0052D6B1641C83AE' , KIND = I8B ), INT ( Z 'C1A12D2FC3978937' , KIND = I8B ), & INT ( Z 'DCCC6CA29B3E9DF0' , KIND = I8B ), INT ( Z '0612C3C5CE15E554' , KIND = I8B ), & INT ( Z 'C0678C5DBD23A49A' , KIND = I8B ), INT ( Z 'F209787BB47D6B84' , KIND = I8B ), & INT ( Z '09FFC3E5A10722B6' , KIND = I8B ), INT ( Z '43CBBA5BA0CDAF55' , KIND = I8B ), & INT ( Z 'F840B7BA963646E0' , KIND = I8B ), INT ( Z '9745EB4D50CE6332' , KIND = I8B ), & INT ( Z '4C7FB4DF0948EB64' , KIND = I8B ), INT ( Z '54BEA8F289011B2A' , KIND = I8B ), & INT ( Z 'B650E5A93BC3D898' , KIND = I8B ), INT ( Z 'BD176620A501FBFF' , KIND = I8B ), & INT ( Z 'DF9FA216CB9B263D' , KIND = I8B ), INT ( Z '69EE532F2B4161F4' , KIND = I8B ), & INT ( Z 'A3E51F138AB4CEBE' , KIND = I8B ), INT ( Z 'EC5D3FA8CE427AFF' , KIND = I8B ), & INT ( Z '0BC3C54E3F40F7E6' , KIND = I8B ), INT ( Z '0234F3FD7B08DD39' , KIND = I8B ), & INT ( Z 'C66F336C36B10137' , KIND = I8B ), INT ( Z '93BA47C980E98CDF' , KIND = I8B ), & INT ( Z '4EB4B6A1CF1135DF' , KIND = I8B ), INT ( Z 'C2C230FCD9CB1487' , KIND = I8B ), & INT ( Z 'B80B0047445D4184' , KIND = I8B ), INT ( Z 'B8A8D9BBE123F017' , KIND = I8B ), & INT ( Z '2261E44A42D58357' , KIND = I8B ), INT ( Z 'F372BD3C103DD9A9' , KIND = I8B ), & INT ( Z 'A60DC059157491E5' , KIND = I8B ), INT ( Z 'E6D3102AD96CEC1D' , KIND = I8B ), & INT ( Z 'B57D2EAE69C57216' , KIND = I8B ), INT ( Z 'B827B6458A26A809' , KIND = I8B ), & INT ( Z '87C89837AD68DB2F' , KIND = I8B ), INT ( Z '9043EA1AC7E41392' , KIND = I8B ), & INT ( Z '22DC7A5A0436CE9C' , KIND = I8B ), INT ( Z 'A631A3D6ECB0520C' , KIND = I8B ), & INT ( Z '29BABE4598C311FB' , KIND = I8B ), INT ( Z 'B454E4A179DD1877' , KIND = I8B ), & INT ( Z '2B9398F085448243' , KIND = I8B ), INT ( Z '8FBE0CCCA7DC668F' , KIND = I8B ), & INT ( Z 'F4296DD6FEF3D67A' , KIND = I8B ), INT ( Z 'E16A1DC9D8545E94' , KIND = I8B ), & INT ( Z '7B3C3F96534AD16A' , KIND = I8B ), INT ( Z '99D6C7FFE8E9C019' , KIND = I8B ), & INT ( Z '1899E4A65F58660C' , KIND = I8B ), INT ( Z '8CE2529E2734BB1D' , KIND = I8B ), & INT ( Z 'DA0B4F7BE81D85C4' , KIND = I8B ), INT ( Z 'C04C79FFE324301F' , KIND = I8B ), & INT ( Z '5EC05DCFF72E7F8F' , KIND = I8B ), INT ( Z 'B01AE745B101E9E4' , KIND = I8B ), & INT ( Z 'D08E235AE224E736' , KIND = I8B ), INT ( Z 'B05F987FDBED3C27' , KIND = I8B ), & INT ( Z '76707543F4FA1F73' , KIND = I8B ), INT ( Z 'DC21A1171D42645D' , KIND = I8B ), & INT ( Z 'E258D618CD571081' , KIND = I8B ), INT ( Z '4E3BBF4FE9744598' , KIND = I8B ), & INT ( Z '6A06494A791C53A8' , KIND = I8B ), INT ( Z '899504AE72497EBA' , KIND = I8B ), & INT ( Z '1AEF0B9F00ACD4A2' , KIND = I8B ), INT ( Z '61CAAF23E3D156FF' , KIND = I8B ), & INT ( Z '0487DB9D17636892' , KIND = I8B ), INT ( Z 'ABFA45DA0EDBDE69' , KIND = I8B ), & INT ( Z 'E1AACE86C0D809CA' , KIND = I8B ), INT ( Z 'FA3D5AECDCC5ACBE' , KIND = I8B ), & INT ( Z '45A9D2845D3C42B6' , KIND = I8B ), INT ( Z 'D6F8D7509292D603' , KIND = I8B ), & INT ( Z '4D0AC1143887061E' , KIND = I8B ), INT ( Z '5C6658D409FB8BF7' , KIND = I8B ), & INT ( Z '0B8A2392BA45A9B2' , KIND = I8B ), INT ( Z '865B86925B9BC5C2' , KIND = I8B ), & INT ( Z '204D715946A8C7A6' , KIND = I8B ), INT ( Z 'F37FEF090C7A6EF5' , KIND = I8B ), & INT ( Z '8E6CAC7768D7141E' , KIND = I8B ), INT ( Z 'A7F26836F282B732' , KIND = I8B ), & INT ( Z '6860CDAF9852F990' , KIND = I8B ), INT ( Z 'B05FEACB4F990AB2' , KIND = I8B ), & INT ( Z '3207D795430CD926' , KIND = I8B ), INT ( Z 'D1EF0244AF2364FF' , KIND = I8B ), & INT ( Z '813C808DBF33DBFA' , KIND = I8B ), INT ( Z '2E3BF2BF11BFA6AF' , KIND = I8B ), & INT ( Z '7F44E6BD49E807B8' , KIND = I8B ), INT ( Z '8335616AED761F1F' , KIND = I8B ), & INT ( Z '618BA0B12F00D2F8' , KIND = I8B ), INT ( Z '39CAEF6ED62F905B' , KIND = I8B ), & INT ( Z '5F16206C9C6209A6' , KIND = I8B ), INT ( Z 'A402B9C5A8D3A6E7' , KIND = I8B ), & INT ( Z '39EE88DD7AC107B6' , KIND = I8B ), INT ( Z 'C83DAB4A8BBB7472' , KIND = I8B ), & INT ( Z '36DBA887C37A8C0F' , KIND = I8B ), INT ( Z 'CD036837130890A1' , KIND = I8B ), & INT ( Z '6435158A6CB8A4D2' , KIND = I8B ), INT ( Z 'DD268B0E975528C7' , KIND = I8B ), & INT ( Z 'C2494954DA2C9789' , KIND = I8B ), INT ( Z '802221226BE55A64' , KIND = I8B ), & INT ( Z '3D425AED07E6CE06' , KIND = I8B ), INT ( Z '54702DD23D2A72F9' , KIND = I8B ), & INT ( Z 'F2DB9BAA10B7BD6C' , KIND = I8B ), INT ( Z 'A02AA96B06DEB0FD' , KIND = I8B ), & INT ( Z '8C92F1A849E08188' , KIND = I8B ), INT ( Z '698C3946CC750FB7' , KIND = I8B ), & INT ( Z '6F92829494E5ACC7' , KIND = I8B ), INT ( Z 'C83553C5C8965D3D' , KIND = I8B ), & INT ( Z '6FB7AE125C58A1EA' , KIND = I8B ), INT ( Z '43EF47987F9253A5' , KIND = I8B ), & INT ( Z 'CB772339BA1F17F9' , KIND = I8B ), INT ( Z 'FA42A8B73ABBF48C' , KIND = I8B ), & INT ( Z '65D2CCCB79B76532' , KIND = I8B ), INT ( Z 'CA758CBF4FBB7447' , KIND = I8B ), & INT ( Z 'FF2A760414536EFB' , KIND = I8B ), INT ( Z '9C69A97284B578D7' , KIND = I8B ), & INT ( Z '3F477FFE58253E7F' , KIND = I8B ), INT ( Z 'BD12EFEF23AA5159' , KIND = I8B ), & INT ( Z 'FEF5138519684ABA' , KIND = I8B ), INT ( Z 'C38413CF25E2D70D' , KIND = I8B ), & INT ( Z '8F195FFDEE2E8E1F' , KIND = I8B ), INT ( Z '6C57ABEAEC94E5AF' , KIND = I8B ), & INT ( Z '7EB258665FC25D69' , KIND = I8B ), INT ( Z 'F46518C2EF5B8CD1' , KIND = I8B ), & INT ( Z 'B96FDBFEB4DD18D3' , KIND = I8B ), INT ( Z 'E3B6CB72D3DD0F8D' , KIND = I8B ), & INT ( Z 'EF2F773FFBD97A61' , KIND = I8B ), INT ( Z '98BF2F79D5993802' , KIND = I8B ), & INT ( Z '27CBD2FE62145F08' , KIND = I8B ), INT ( Z '5CA47E4F88D45371' , KIND = I8B ), & INT ( Z 'AAFB550FFACFD8FA' , KIND = I8B ), INT ( Z 'BEEEFB584AFF8603' , KIND = I8B ), & INT ( Z '71BEC7BDFA9976CA' , KIND = I8B ), INT ( Z 'F3CD9DE36B09684D' , KIND = I8B ), & INT ( Z '95BA2A53F983CF38' , KIND = I8B ), INT ( Z 'EEAABA2E5DBF6784' , KIND = I8B ), & INT ( Z '67173CD6BC9FEA3E' , KIND = I8B ), INT ( Z '986082AE22E5E130' , KIND = I8B ), & INT ( Z 'DD945A747BF26183' , KIND = I8B ), INT ( Z '952AB45CFA97A0B2' , KIND = I8B ), & INT ( Z '80DD0C0C6BC7E4CE' , KIND = I8B ), INT ( Z '7E78A359AB9F597C' , KIND = I8B ), & INT ( Z '94F971119AEEF9E4' , KIND = I8B ), INT ( Z 'BA756174393D88DF' , KIND = I8B ), & INT ( Z 'A1144F0F86B9DE01' , KIND = I8B ), INT ( Z '9E16CC3016872FDB' , KIND = I8B ), & INT ( Z '7A37CD5601AAB85D' , KIND = I8B ), INT ( Z 'E912B9D1478CEB17' , KIND = I8B ), & INT ( Z '44ACB169B4342AC0' , KIND = I8B ), INT ( Z '82CE3F9E0E147DE9' , KIND = I8B ), & INT ( Z 'AC62E055C10AB33A' , KIND = I8B ), INT ( Z '91ABB422CCB812EE' , KIND = I8B ), & INT ( Z '95D7DDC421413571' , KIND = I8B ), INT ( Z '2381CF8591999D63' , KIND = I8B ), & INT ( Z '577B986B314D6009' , KIND = I8B ), INT ( Z 'B616A12B7FE617AA' , KIND = I8B ), & INT ( Z '7B4DD535299182CD' , KIND = I8B ), INT ( Z '6C624366F60004BC' , KIND = I8B ), & INT ( Z 'ED5A7E85FDA0B80B' , KIND = I8B ), INT ( Z 'E39C49765FDF9D94' , KIND = I8B ), & INT ( Z 'CD10A54139FAF1C0' , KIND = I8B ), INT ( Z '23BD6A2059C002F5' , KIND = I8B ), & INT ( Z '14588F13BE847307' , KIND = I8B ), INT ( Z '8E41ADE9FBEBC27D' , KIND = I8B ), & INT ( Z '4054CE918879AE30' , KIND = I8B ), INT ( Z 'ECACC4A8703003B3' , KIND = I8B ), & INT ( Z '596EB2D8AE258FC8' , KIND = I8B ), INT ( Z 'B1D219647AE6B31C' , KIND = I8B ), & INT ( Z '106A0235EA9819BC' , KIND = I8B ), INT ( Z '27D7F5D28C3C04A0' , KIND = I8B ), & INT ( Z '6FCA5F8ED9AEF3BB' , KIND = I8B ), INT ( Z 'DE469FBD99A05FE3' , KIND = I8B ), & INT ( Z '0A424161B29F1015' , KIND = I8B ), INT ( Z 'F8E6F9A397A582E4' , KIND = I8B ), & INT ( Z '25DE7BB9480D5854' , KIND = I8B ), INT ( Z '8AEC23D680043BEE' , KIND = I8B ), & INT ( Z '0CD2D1BA1F46D41B' , KIND = I8B ), INT ( Z '3720B80C7D8EE39D' , KIND = I8B ), & INT ( Z 'AF561AA79A10AE6A' , KIND = I8B ), INT ( Z 'ADA72CCC20054AE9' , KIND = I8B ), & INT ( Z '50078628A7188922' , KIND = I8B ), INT ( Z 'C4E8E60F9CF29C84' , KIND = I8B ), & INT ( Z '1B2BA1518094DA04' , KIND = I8B ), INT ( Z 'D910F7FF28069DA4' , KIND = I8B ), & INT ( Z 'B204B3D9686F55B5' , KIND = I8B ), INT ( Z 'FB118FC9C217A1D2' , KIND = I8B ), & INT ( Z '90FB44D2F05D0842' , KIND = I8B ), INT ( Z '87AA9AFF79042286' , KIND = I8B ), & INT ( Z '5E85E0CFC28B2B22' , KIND = I8B ), INT ( Z 'B9D5F3BC329D8A47' , KIND = I8B ), & INT ( Z '353A1607AC744A53' , KIND = I8B ), INT ( Z 'A99541BF57452B28' , KIND = I8B ), & INT ( Z '36275903B32DF5EB' , KIND = I8B ), INT ( Z 'A84B70AB3F44ECD9' , KIND = I8B ), & INT ( Z '42889B8997915CE8' , KIND = I8B ), INT ( Z 'D3FA922F2D1675F2' , KIND = I8B ), & INT ( Z 'C1D897A24FFCB9B3' , KIND = I8B ), INT ( Z '692F266B078B1407' , KIND = I8B ), & INT ( Z '69956135FEBADA11' , KIND = I8B ), INT ( Z '847C9B5D7C2E09B7' , KIND = I8B ), & INT ( Z 'B24EBD8AE3FBE81F' , KIND = I8B ), INT ( Z 'C37AF005C96DD909' , KIND = I8B ), & INT ( Z '43FAB9837E699095' , KIND = I8B ), INT ( Z 'A59BC234DB398C25' , KIND = I8B ), & INT ( Z '1EE26CED9CFAE227' , KIND = I8B ), INT ( Z '3459AC073BC94F4C' , KIND = I8B ), & INT ( Z '94F967E45E03F4BB' , KIND = I8B ), INT ( Z 'CF02B2C21207EF2E' , KIND = I8B ), & INT ( Z '934D8414821CCD58' , KIND = I8B ), INT ( Z '00B80B84855DD18F' , KIND = I8B ), & INT ( Z '1D1BE0EEBAC278F5' , KIND = I8B ), INT ( Z '8161AFB94B44F57D' , KIND = I8B ), & INT ( Z '7820E519A2A400AF' , KIND = I8B ), INT ( Z '40E60E65A6B545F3' , KIND = I8B ), & INT ( Z '6462D92A69731732' , KIND = I8B ), INT ( Z 'A1BA1BA79E1632DC' , KIND = I8B ), & INT ( Z '56291E600B4D00DB' , KIND = I8B ), INT ( Z 'D11F91FF10629770' , KIND = I8B ), & INT ( Z '7D7B8F7503CFDCFE' , KIND = I8B ), INT ( Z 'CA28A291859BBF93' , KIND = I8B ), & INT ( Z '6BB365F80E204111' , KIND = I8B ), INT ( Z '8567767ED47B3D4C' , KIND = I8B ), & INT ( Z '5CDA735244C3D43E' , KIND = I8B ), INT ( Z 'FCB2CB35E702AF78' , KIND = I8B ), & INT ( Z 'C3501FBB08D428AB' , KIND = I8B ), INT ( Z '1360AA0F44CD064F' , KIND = I8B ), & INT ( Z '3A0888136AFA64A7' , KIND = I8B ), INT ( Z '9DEFBF01B061ADAB' , KIND = I8B ), & INT ( Z 'B42427A9CB0932D5' , KIND = I8B ), INT ( Z 'D838D493160047E3' , KIND = I8B ), & INT ( Z '088AAA1845B8FDD0' , KIND = I8B ), INT ( Z 'C56BAEC21C7A1916' , KIND = I8B ), & INT ( Z 'A12D31943DCB7F8B' , KIND = I8B ), INT ( Z '0E4709B7DB8059DC' , KIND = I8B ), & INT ( Z '8AAD549E57273D45' , KIND = I8B ), INT ( Z 'F6C69A72A3989F5B' , KIND = I8B ), & INT ( Z 'E4BC3EFCA69F2FB7' , KIND = I8B ), INT ( Z '28EC6612E9303829' , KIND = I8B ), & INT ( Z '36AC54E2F678864B' , KIND = I8B ), INT ( Z '9A3C2087A63F6399' , KIND = I8B ), & INT ( Z '5DEB4EBBD046FBA4' , KIND = I8B ), INT ( Z 'F3277F97A37C4634' , KIND = I8B ), & INT ( Z '84576A1BB416A7DD' , KIND = I8B ), INT ( Z 'C0CB28A98FCF3C7F' , KIND = I8B ), & INT ( Z '7566226AC458BA8E' , KIND = I8B ), INT ( Z '6FF15F7D8C5B57C1' , KIND = I8B ), & INT ( Z '656D44A2A11C51D5' , KIND = I8B ), INT ( Z 'F0FDF2D3F3C30B9F' , KIND = I8B ), & INT ( Z 'E95FD582BAB77498' , KIND = I8B ), INT ( Z '65F6DBAE77B916D8' , KIND = I8B ), & INT ( Z '9F644AE5A4B1B325' , KIND = I8B ), INT ( Z '969EB7C47859E743' , KIND = I8B ), & INT ( Z '23B7CAE3696551BF' , KIND = I8B ), INT ( Z 'BF74929A15A75C8F' , KIND = I8B ), & INT ( Z '873D5D9F0DDE1FEE' , KIND = I8B ), INT ( Z 'BC4665B596706114' , KIND = I8B ), & INT ( Z 'ECA5BD9C43BEA62E' , KIND = I8B ), INT ( Z '6F51B7409B1133B2' , KIND = I8B ), & INT ( Z 'A90CB506D155A7EA' , KIND = I8B ), INT ( Z 'EB57FF22FC0C7959' , KIND = I8B ), & INT ( Z 'D3E79681AA5727DD' , KIND = I8B ), INT ( Z '8593128860EAC04F' , KIND = I8B ), & INT ( Z '09A7F12442D588F2' , KIND = I8B ), INT ( Z '9316FF75DD87CBD8' , KIND = I8B ), & INT ( Z 'C8E17C2214ECF1D4' , KIND = I8B ), INT ( Z '26F7D72A79257063' , KIND = I8B ), & INT ( Z '0C11ED6D538AEB2F' , KIND = I8B ), INT ( Z 'B7DCBF5354E9BECE' , KIND = I8B ), & INT ( Z 'BB19DB2A9A282E49' , KIND = I8B ), INT ( Z 'F0B5CCF5176ECC7C' , KIND = I8B ), & INT ( Z '8F1668C8A86DA5FA' , KIND = I8B ), INT ( Z 'E5D3EF282A242E81' , KIND = I8B ), & INT ( Z 'F4F028FAA0591CEE' , KIND = I8B ), INT ( Z 'D671A0192EA53FCD' , KIND = I8B ), & INT ( Z 'F96E017D694487BC' , KIND = I8B ), INT ( Z '8FA475791A569D10' , KIND = I8B ), & INT ( Z '722C3339486F6429' , KIND = I8B ), INT ( Z '0C0E081F7A4E8FC1' , KIND = I8B ), & INT ( Z '37C981DCC395A9AC' , KIND = I8B ), INT ( Z 'B38D92D760EC4455' , KIND = I8B ), & INT ( Z 'CEB740079A8B3D33' , KIND = I8B ), INT ( Z '0F118A2758E233B1' , KIND = I8B ), & INT ( Z '85BBE253F47B1417' , KIND = I8B ), INT ( Z 'E070F78D3927556A' , KIND = I8B ), & INT ( Z '21328804C0970640' , KIND = I8B ), INT ( Z '696AF658978D604F' , KIND = I8B ), & INT ( Z '93956D7478CCEC8E' , KIND = I8B ), INT ( Z '8C469AB843B89562' , KIND = I8B ), & INT ( Z 'E97F2A05F0BCC7D0' , KIND = I8B ), INT ( Z '03C5B3EEBD70B862' , KIND = I8B ), & INT ( Z '387AC8D1970027B2' , KIND = I8B ), INT ( Z 'AF58416654A6BABB' , KIND = I8B ), & INT ( Z 'A3DEF4876CEBF9C4' , KIND = I8B ), INT ( Z '84B720EA6CCCE67B' , KIND = I8B ), & INT ( Z '06997B05FCC0319E' , KIND = I8B ), INT ( Z 'DB2E51BFE9D0696A' , KIND = I8B ), & INT ( Z '466B58D4A4137C1A' , KIND = I8B ), INT ( Z '12F274928400100D' , KIND = I8B ), & INT ( Z '441FECE3BDF81F03' , KIND = I8B ), INT ( Z '88FCF317F22241E2' , KIND = I8B ), & INT ( Z '98062F09CD185B21' , KIND = I8B ), INT ( Z 'D7AF11B725001410' , KIND = I8B ), & INT ( Z 'D527E81CAD7626C3' , KIND = I8B ), INT ( Z 'AB3C2FDDEEAAD25A' , KIND = I8B ), & INT ( Z 'BE07BACC405E71EA' , KIND = I8B ), INT ( Z 'CD9AD624EE401914' , KIND = I8B ), & INT ( Z '8A71E223D8D3B074' , KIND = I8B ), INT ( Z 'D60B3BD56A5586F1' , KIND = I8B ), & INT ( Z 'F6C4D4BFA83B0732' , KIND = I8B ), INT ( Z '0080C5D714E80FAC' , KIND = I8B ), & INT ( Z 'F6872D5667844E49' , KIND = I8B ), INT ( Z '85C7056562757456' , KIND = I8B ), & INT ( Z '347609EF9249C8FE' , KIND = I8B ), INT ( Z '40A0F74CDA221398' , KIND = I8B ), & INT ( Z 'B428F8AC016561DB' , KIND = I8B ), INT ( Z 'A738C6BEBB12D16C' , KIND = I8B ), & INT ( Z '41938C6B76DC3B3E' , KIND = I8B ), INT ( Z '10C9352010AA987E' , KIND = I8B ), & INT ( Z 'E13336D701BEBA52' , KIND = I8B ), INT ( Z 'D106F86E69D785C7' , KIND = I8B ), & INT ( Z 'E8FC37C32A49A507' , KIND = I8B ), INT ( Z '4A7DC1340A6A9F4E' , KIND = I8B ), & INT ( Z 'ECC0024661173473' , KIND = I8B ), INT ( Z '82A45B450226B39C' , KIND = I8B ), & INT ( Z 'A33B45B3F4DC0E48' , KIND = I8B ), INT ( Z '1D1D31810D054722' , KIND = I8B ), & INT ( Z '27F002D7F95D0190' , KIND = I8B ), INT ( Z 'A34D721642B06084' , KIND = I8B ), & INT ( Z '4C0A1720F21311DB' , KIND = I8B ), INT ( Z '24647DE1504698EB' , KIND = I8B ), & INT ( Z '31EC038DF7B441F4' , KIND = I8B ), INT ( Z 'CC20CE9BD35C78A5' , KIND = I8B ), & INT ( Z '1F0C9CE92E97D651' , KIND = I8B ), INT ( Z '2D7D9D59A4583F26' , KIND = I8B ), & INT ( Z '7E67047175A15271' , KIND = I8B ), INT ( Z 'FF290242C83396CE' , KIND = I8B ), & INT ( Z 'D367E211BD1EE5F3' , KIND = I8B ), INT ( Z 'BC6E825806B72777' , KIND = I8B ), & INT ( Z '0F0062C6E984D386' , KIND = I8B ), INT ( Z '9F79A169BD203E41' , KIND = I8B ), & INT ( Z 'C841DA962C669F70' , KIND = I8B ), INT ( Z '6B8A22EE0864F155' , KIND = I8B ), & INT ( Z '52C07B78A3E60868' , KIND = I8B ), INT ( Z 'C75809C42C684DD1' , KIND = I8B ), & INT ( Z '3A52513BB780474C' , KIND = I8B ), INT ( Z '866CABA98A7E2DAB' , KIND = I8B ), & INT ( Z 'A7709A56CCDF8A82' , KIND = I8B ), INT ( Z 'F92E0C3537826145' , KIND = I8B ), & INT ( Z '047372C552B02C8F' , KIND = I8B ), INT ( Z '9403EB49F68EDC8B' , KIND = I8B ), & INT ( Z '88A66076400BB691' , KIND = I8B ), INT ( Z '9BBCC7A142B17CCB' , KIND = I8B ), & INT ( Z 'C5904F76A75C37B3' , KIND = I8B ), INT ( Z 'F904E61C743293AD' , KIND = I8B ), & INT ( Z '6ACFF893D00EA435' , KIND = I8B ), INT ( Z 'C2ABF989935DDBFE' , KIND = I8B ), & INT ( Z '36F46354513345A0' , KIND = I8B ), INT ( Z '77461FA3913F3899' , KIND = I8B ), & INT ( Z '0583F6B8C4124D43' , KIND = I8B ), INT ( Z 'F356F7EBF83552FE' , KIND = I8B ), & INT ( Z 'C258BE14B2C00B84' , KIND = I8B ), INT ( Z '2A8BD3C63AC7835F' , KIND = I8B ), & INT ( Z 'C3727A337A8B704A' , KIND = I8B ), INT ( Z '98165AF37B2153DE' , KIND = I8B ), & INT ( Z 'B2EEED99DF700E65' , KIND = I8B ), INT ( Z 'B52EC8B7C9796437' , KIND = I8B ), & INT ( Z '744F18C0592E4C5C' , KIND = I8B ), INT ( Z 'BE1BF1B059E9A8D6' , KIND = I8B ), & INT ( Z '9FAAA900574C11FE' , KIND = I8B ), INT ( Z 'E27A7AE5BBD7BD45' , KIND = I8B ), & INT ( Z '1162DEF06F79DF73' , KIND = I8B ), INT ( Z 'EDA2EE1C7064130C' , KIND = I8B ), & INT ( Z '83CAA9A0368F8B3F' , KIND = I8B ), INT ( Z '6D8C8CCF9566D64B' , KIND = I8B ), & INT ( Z '8ADDCB5645AC2BA8' , KIND = I8B ), INT ( Z '9485D4D1C63E8BE7' , KIND = I8B ), & INT ( Z '64BD540844336E0E' , KIND = I8B ), INT ( Z '88EFB0037AC08BDE' , KIND = I8B ), & INT ( Z '6D953E2BD7173692' , KIND = I8B ), INT ( Z 'B9A74A0637CE2EE1' , KIND = I8B ), & INT ( Z 'FDECA90A55404992' , KIND = I8B ), INT ( Z '2B2B9C045970AED5' , KIND = I8B ), & INT ( Z 'C8FA8DB6CCDD0437' , KIND = I8B ), INT ( Z 'E8111C87C5C1BA99' , KIND = I8B ), & INT ( Z 'BEB3E9A675482DFB' , KIND = I8B ), INT ( Z '7AFB4182B7E66D45' , KIND = I8B ), & INT ( Z '1D9C9892400A22A2' , KIND = I8B ), INT ( Z '910AB1D4DB9914A0' , KIND = I8B ), & INT ( Z '2E60E410129A397A' , KIND = I8B ), INT ( Z '19BA11E365E00897' , KIND = I8B ), & INT ( Z '2503BEB6D00CAB4B' , KIND = I8B ), INT ( Z 'B54D5E4A127F59C8' , KIND = I8B ), & INT ( Z 'F9F91D141740C7D9' , KIND = I8B ), INT ( Z 'E028965C3F580ABC' , KIND = I8B ), & INT ( Z '2E44AE64840FD61D' , KIND = I8B ), INT ( Z 'E2A0B5DC971F303A' , KIND = I8B ), & INT ( Z '1C3BB22C8E887CE7' , KIND = I8B ), INT ( Z 'AC195DF9A79706B6' , KIND = I8B ), & INT ( Z '5CEAECFED289E5D2' , KIND = I8B ), INT ( Z '8DA471A9DE737E24' , KIND = I8B ), & INT ( Z 'A34A9EB7B22A9C21' , KIND = I8B ), INT ( Z '571FB578117CC863' , KIND = I8B ), & INT ( Z '7425A83E872C5F47' , KIND = I8B ), INT ( Z 'B10D8E1456105DAD' , KIND = I8B ), & INT ( Z '8C1D46659EB5432A' , KIND = I8B ), INT ( Z '2CE7A2D615DBFA7C' , KIND = I8B ), & INT ( Z 'D12F124E28F77719' , KIND = I8B ), INT ( Z 'DD50F1996B947518' , KIND = I8B ), & INT ( Z 'D7924BFF833149FA' , KIND = I8B ), INT ( Z 'BC10C5C5CDA97C8D' , KIND = I8B ), & INT ( Z '82BD6B70D99AAA6F' , KIND = I8B ), INT ( Z '8A5296FFE33CC92F' , KIND = I8B ), & INT ( Z '4D76DEFF63FD9C78' , KIND = I8B ), INT ( Z 'AB14F7374113DBB1' , KIND = I8B ), & INT ( Z '636CC64D1001550B' , KIND = I8B ), INT ( Z 'ACE73CBFDC0BFB7B' , KIND = I8B ), & INT ( Z 'A0D496BF3CFD0397' , KIND = I8B ), INT ( Z '95DA35051158D29D' , KIND = I8B ), & INT ( Z '3C47F7E05401AA4E' , KIND = I8B ), INT ( Z 'D8210BEFD30EFA5A' , KIND = I8B ), & INT ( Z '8484DE37861E223E' , KIND = I8B ), INT ( Z '1DA861232AD783A2' , KIND = I8B ), & INT ( Z '65ACFAEC34810A71' , KIND = I8B ), INT ( Z '8714A775E3E95C78' , KIND = I8B ), & INT ( Z '25A615C567A5AACE' , KIND = I8B ), INT ( Z '6512796BF58D648B' , KIND = I8B ), & INT ( Z '7F1839A741A14D0D' , KIND = I8B ), INT ( Z 'A8D9D1535CE3B396' , KIND = I8B ), & INT ( Z 'EF0F9B36C18F1581' , KIND = I8B ), INT ( Z 'BE5717C6F2F0BDAD' , KIND = I8B ), & INT ( Z '1EDE48111209A050' , KIND = I8B ), INT ( Z 'D31045A8341CA07C' , KIND = I8B ), & INT ( Z 'B569C10238F96D70' , KIND = I8B ), INT ( Z '76F66EDC57D6768C' , KIND = I8B ), & INT ( Z '934AED0AAB460432' , KIND = I8B ), INT ( Z '83EA2B892091E44D' , KIND = I8B ), & INT ( Z 'E2C43142C737C8CD' , KIND = I8B ), INT ( Z '14B40A936DCC142F' , KIND = I8B ), & INT ( Z 'F81DA84D5617853F' , KIND = I8B ), INT ( Z 'A4E4B66B68B65D60' , KIND = I8B ), & INT ( Z 'DB753D937905BB00' , KIND = I8B ), INT ( Z 'D9E10D38493F193B' , KIND = I8B ), & INT ( Z '36251260AB9D668E' , KIND = I8B ), INT ( Z 'CE1DE40642E3F4B9' , KIND = I8B ), & INT ( Z '6929467C2BA394E0' , KIND = I8B ), INT ( Z '482CA8432DC76FC5' , KIND = I8B ), & INT ( Z 'C1D72B7C6B426019' , KIND = I8B ), INT ( Z '80D2AE83E9CE78F3' , KIND = I8B ), & INT ( Z 'C373981B368C7A18' , KIND = I8B ), INT ( Z '9A37D253F9394BB6' , KIND = I8B ), & INT ( Z 'B24CF65B8612F81F' , KIND = I8B ), INT ( Z 'A1075A24E4421730' , KIND = I8B ), & INT ( Z '74507E22042F989E' , KIND = I8B ), INT ( Z '80C5C6E8F7879EA4' , KIND = I8B ), & INT ( Z 'DEE033F26797B627' , KIND = I8B ), INT ( Z 'C94930AE1D529CFC' , KIND = I8B ), & INT ( Z '91649DAA853B7EC6' , KIND = I8B ), INT ( Z '60F738A33569864D' , KIND = I8B ), & INT ( Z '169840EF017DA3B1' , KIND = I8B ), INT ( Z 'FB9B7CD9A4A7443C' , KIND = I8B ), & INT ( Z '7ADEE28A93452F3B' , KIND = I8B ), INT ( Z 'DC9A83660161F3F0' , KIND = I8B ), & INT ( Z '8E1F289560EE864E' , KIND = I8B ), INT ( Z '9D412E0806E88AA5' , KIND = I8B ), & INT ( Z '99969B2D38167B0A' , KIND = I8B ), INT ( Z '93C1243F81BA70EC' , KIND = I8B ), & INT ( Z 'F1A6F2BAB92A27E2' , KIND = I8B ), INT ( Z 'C491798A08A2AD4E' , KIND = I8B ), & INT ( Z 'BFFC41F8861C19CD' , KIND = I8B ), INT ( Z '38B16D4F62290D27' , KIND = I8B ), & INT ( Z 'AE10AF696774B1DB' , KIND = I8B ), INT ( Z 'F5B5D7EC8ACB58A2' , KIND = I8B ), & INT ( Z 'D7FDA93B53D19020' , KIND = I8B ), INT ( Z '036EE4519D59A838' , KIND = I8B ), & INT ( Z 'ACCA6DA1E0A8EF29' , KIND = I8B ), INT ( Z '9991A6F3D6BF1765' , KIND = I8B ), & INT ( Z '0DFD138A28C5F428' , KIND = I8B ), INT ( Z '444A9D6604B01247' , KIND = I8B ), & INT ( Z '17FD090A58D32AF3' , KIND = I8B ), INT ( Z 'BFF610B0CC6EDD3F' , KIND = I8B ), & INT ( Z 'D17C586CB2F77132' , KIND = I8B ), INT ( Z '155D44BF85DC16D8' , KIND = I8B ), & INT ( Z 'DDFC4B4CEF07F5B0' , KIND = I8B ), INT ( Z 'EFF394DCFF8A948E' , KIND = I8B ), & INT ( Z '82EDB743EFDAA6BF' , KIND = I8B ), INT ( Z '0D5A4AF7B3A98E47' , KIND = I8B ), & INT ( Z '4ABDAF101564F98E' , KIND = I8B ), INT ( Z '95F83D0A1FB69CD9' , KIND = I8B ), & INT ( Z '63A92514EBD1506F' , KIND = I8B ), INT ( Z '90B0DDB5A093F1D9' , KIND = I8B ), & INT ( Z '9D6D1AD41ABE37F1' , KIND = I8B ), INT ( Z 'BB764C4CA7A4440F' , KIND = I8B ), & INT ( Z 'BC936E5A26C5A48B' , KIND = I8B ), INT ( Z 'F4DD152308B8EE4F' , KIND = I8B ), & INT ( Z '84C86189216DC5ED' , KIND = I8B ), INT ( Z 'EA53DF5FD18D5513' , KIND = I8B ), & INT ( Z 'D5DC24F8583B86D7' , KIND = I8B ), INT ( Z 'B90A2D35E57394F1' , KIND = I8B ), & INT ( Z '32FD3CF5B4E49BB4' , KIND = I8B ), INT ( Z '92746B9BE2F8552C' , KIND = I8B ), & INT ( Z '4B532E366E4A688C' , KIND = I8B ), INT ( Z 'E74CB8835ED07A2E' , KIND = I8B ), & INT ( Z '3FBC8C33221DC2A1' , KIND = I8B ), INT ( Z 'B7118682DBB66A77' , KIND = I8B ), & INT ( Z 'DE27F9C409DD02B0' , KIND = I8B ), INT ( Z '611FE6A4368498B9' , KIND = I8B ), & INT ( Z '0FABAF3FEAA5334A' , KIND = I8B ), INT ( Z 'E4D5E82392A40515' , KIND = I8B ), & INT ( Z '2AD8FC1A862A21AE' , KIND = I8B ), INT ( Z '7CB3F026A212DF74' , KIND = I8B ), & INT ( Z '29CB4D87F2A7400E' , KIND = I8B ), INT ( Z '8F05B1163BA6832D' , KIND = I8B ), & INT ( Z '358F3B2127B4AA19' , KIND = I8B ), INT ( Z '1BE0EC304A979751' , KIND = I8B ), & INT ( Z '743E20E9EF511012' , KIND = I8B ), INT ( Z 'B2C71D5BCA9023F8' , KIND = I8B ), & INT ( Z '82F309E971A1D4A0' , KIND = I8B ), INT ( Z 'A2D9273C5D3D7D25' , KIND = I8B ), & INT ( Z '914DA9246B255416' , KIND = I8B ), INT ( Z 'DF78E4B2BD342CF6' , KIND = I8B ), & INT ( Z '71D7E631E70524E4' , KIND = I8B ), INT ( Z '25C7B885BA466E37' , KIND = I8B ), & INT ( Z '1AD089B6C2F7548E' , KIND = I8B ), INT ( Z '8BAB8EEFB6409C1A' , KIND = I8B ), & INT ( Z '4E4DDFBE60C66E1D' , KIND = I8B ), INT ( Z 'AF39A6A728D809C5' , KIND = I8B ), & INT ( Z 'A184AC2473B529B1' , KIND = I8B ), INT ( Z 'AE9672ABA3D0C320' , KIND = I8B ), & INT ( Z 'A1E157ADF8F809A4' , KIND = I8B ), INT ( Z '1B081050F30E0C36' , KIND = I8B ), & INT ( Z 'C9E5D72D90A2741E' , KIND = I8B ), INT ( Z 'DA3C0F568CC4F3E8' , KIND = I8B ), & INT ( Z '252CD6CCBB9B0606' , KIND = I8B ), INT ( Z 'D0E50A3297E8C7A2' , KIND = I8B ), & INT ( Z '7E2FA67C7A658892' , KIND = I8B ), INT ( Z '8865899617FB1871' , KIND = I8B ), & INT ( Z 'AE780C7FEA81C788' , KIND = I8B ), INT ( Z '851E4CBF3DE2F98A' , KIND = I8B ), & INT ( Z 'DDBB901B98FEEAB7' , KIND = I8B ), INT ( Z 'AA7EEBFB9DF9DE8D' , KIND = I8B ), & INT ( Z '5A160F9FE522396A' , KIND = I8B ), INT ( Z '6665DFEF0D5BB7ED' , KIND = I8B ), & INT ( Z '552A74227F3EA565' , KIND = I8B ), INT ( Z 'D51EA6FA85785631' , KIND = I8B ), & INT ( Z '584DC9C3EF3563E2' , KIND = I8B ), INT ( Z '5FFFABF5685952F4' , KIND = I8B ), & INT ( Z 'D53A88958F87275F' , KIND = I8B ), INT ( Z '8533285C936B35DE' , KIND = I8B ), & INT ( Z '6E613C34EB02BCDB' , KIND = I8B ), INT ( Z '37FF96F2C26FA7B1' , KIND = I8B ), & INT ( Z '8A892ABAF368F137' , KIND = I8B ), INT ( Z 'A67FF273B8460356' , KIND = I8B ), & INT ( Z 'C9F98B4225C36C11' , KIND = I8B ), INT ( Z '05FF7CAF730B919D' , KIND = I8B ), & INT ( Z '2D2B7569B0432D85' , KIND = I8B ), INT ( Z 'D01FEF10A657842C' , KIND = I8B ), & INT ( Z '9E3BF709579A238B' , KIND = I8B ), INT ( Z '23BFADEDA7E73B02' , KIND = I8B ), & INT ( Z '9C3B29620E29FC73' , KIND = I8B ), INT ( Z '8213F56A67F6B29B' , KIND = I8B ), & INT ( Z '45CAF4CBAD80AC6E' , KIND = I8B ), INT ( Z 'ECAF996911E109C3' , KIND = I8B ), & INT ( Z '8349F3BA91B47B8F' , KIND = I8B ), INT ( Z 'A298F2C501F45F42' , KIND = I8B ), & INT ( Z '173DB1FE98E0D789' , KIND = I8B ), INT ( Z 'E7DB7FC356594C34' , KIND = I8B ), & INT ( Z '241C70A936219A73' , KIND = I8B ), INT ( Z 'CB3F2F7642717713' , KIND = I8B ), & INT ( Z '1D0D1E7E3F190D6B' , KIND = I8B ), INT ( Z 'E1D25FB42BEF9F41' , KIND = I8B ), & INT ( Z 'ED238CD383AA0110' , KIND = I8B ), INT ( Z 'FE0EFB53D30DD4D7' , KIND = I8B ), & INT ( Z 'B228330EE76FA863' , KIND = I8B ), INT ( Z '8D237BD09B75C388' , KIND = I8B ), & INT ( Z 'F4363804324A40AA' , KIND = I8B ), INT ( Z '9EC95D1463E8A506' , KIND = I8B ), & INT ( Z 'DEB23FD2A14B927C' , KIND = I8B ), INT ( Z '306C5AC4C253346A' , KIND = I8B ), & INT ( Z 'B143C6053EDCD0D5' , KIND = I8B ), INT ( Z 'C67BB4597CE2CE48' , KIND = I8B ), & INT ( Z '965ECFC7499E771B' , KIND = I8B ), INT ( Z '7C877175F2E80185' , KIND = I8B ), & INT ( Z 'DD94B7868E94050A' , KIND = I8B ), INT ( Z 'F81AA16FDC1B81DA' , KIND = I8B ), & INT ( Z '7DFB41DC8E030A71' , KIND = I8B ), INT ( Z '8DD4A6E9B7D100F3' , KIND = I8B ), & INT ( Z 'CA7CF2B4191C8326' , KIND = I8B ), INT ( Z '9B10A4E5E9913128' , KIND = I8B ), & INT ( Z '5D7A1253B183CD0D' , KIND = I8B ), INT ( Z '3149D0A425C54130' , KIND = I8B ), & INT ( Z 'FD1C2F611F63A3F0' , KIND = I8B ), INT ( Z 'C1D4CE1F63F57D72' , KIND = I8B ), & INT ( Z '74D896E89DE4C050' , KIND = I8B ), INT ( Z '3D9C44CD2F36917C' , KIND = I8B ), & INT ( Z 'BC633B39673C8CEC' , KIND = I8B ), INT ( Z 'F24A01A73CF2DCCF' , KIND = I8B ), & INT ( Z 'C9075E5162AEF832' , KIND = I8B ), INT ( Z 'A681AB003D821AED' , KIND = I8B ), & INT ( Z 'D5BE0503E085D813' , KIND = I8B ), INT ( Z '976E41088617CA01' , KIND = I8B ), & INT ( Z '3B4935E5BB5AB63F' , KIND = I8B ), INT ( Z '902215C04CE2A1A9' , KIND = I8B ), & INT ( Z '4B2D8644D8A74E18' , KIND = I8B ), INT ( Z 'BD49D14AA79DBC82' , KIND = I8B ), & INT ( Z '8A1B835F2A3163CE' , KIND = I8B ), INT ( Z 'B42A9B30601B4A13' , KIND = I8B ), & INT ( Z 'DDF8E7D60ED1219E' , KIND = I8B ), INT ( Z 'EC9C459D51852BA2' , KIND = I8B ), & INT ( Z '3651321B7A5EDE61' , KIND = I8B ), INT ( Z '309AA0FE3C110E4C' , KIND = I8B ), & INT ( Z 'CABB90E5C942B503' , KIND = I8B ), INT ( Z '93E1AB8252F33B45' , KIND = I8B ), & INT ( Z '43E57EA258F695F9' , KIND = I8B ), INT ( Z 'FCC1493DCB1551DF' , KIND = I8B ), & INT ( Z '3D6A751F3B936243' , KIND = I8B ), INT ( Z 'B8DA1662E7B00A17' , KIND = I8B ), & INT ( Z '14DEDE4AEF343B77' , KIND = I8B ), INT ( Z 'FBF19B8D3DDAA657' , KIND = I8B ), & INT ( Z '0CC512670A783AD4' , KIND = I8B ), INT ( Z 'E7109BFBA19C0C9D' , KIND = I8B ), & INT ( Z '6D0B4AEED580A52A' , KIND = I8B ), INT ( Z '1D77013846A8A7F6' , KIND = I8B ), & INT ( Z '27FB2B80668B24C5' , KIND = I8B ), INT ( Z '906A617D450187E2' , KIND = I8B ), & INT ( Z '084E1DAA8AE0CE75' , KIND = I8B ), INT ( Z '64D4C1865852D1F4' , KIND = I8B ), & INT ( Z 'B1F9F660802DEDF6' , KIND = I8B ), INT ( Z 'B484F9DC9641E9DA' , KIND = I8B ), & INT ( Z '0A61A5152D990213' , KIND = I8B ), INT ( Z 'FE09F1E7EE678671' , KIND = I8B ), & INT ( Z '5E7873F8A0396973' , KIND = I8B ), INT ( Z 'E1A63853BBD26451' , KIND = I8B ), & INT ( Z 'A67D072D3C7FA14B' , KIND = I8B ), INT ( Z '7EC63730F500B406' , KIND = I8B ), & INT ( Z 'DB0B487B6423E1E8' , KIND = I8B ), INT ( Z '8D07E33455637EB2' , KIND = I8B ), & INT ( Z '501C48F88B9F899E' , KIND = I8B ), INT ( Z '9E77C4FD3240E108' , KIND = I8B ), & INT ( Z '91CE1A9A3D2CDA62' , KIND = I8B ), INT ( Z 'B049DC016ABC5E5F' , KIND = I8B ), & INT ( Z '64235B36AE876C06' , KIND = I8B ), INT ( Z '4615B63C7ED1194A' , KIND = I8B ), & INT ( Z '7641A140CC7810FB' , KIND = I8B ), INT ( Z 'DC5C5301C56B75F7' , KIND = I8B ), & INT ( Z '7E9619022D14A384' , KIND = I8B ), INT ( Z '0BCD91E5CF42AFCE' , KIND = I8B ), & INT ( Z 'A9E904C87FCB0A9D' , KIND = I8B ), INT ( Z '89B9B3E11B6329BA' , KIND = I8B ), & INT ( Z '1E3B9F42B859CC65' , KIND = I8B ), INT ( Z '4EC0F65F43135BC2' , KIND = I8B ), & INT ( Z '546345FA9FBDCD44' , KIND = I8B ), INT ( Z 'AC2820D9623BF429' , KIND = I8B ), & INT ( Z 'A5CA871366703F7E' , KIND = I8B ), INT ( Z '627133F713D832B2' , KIND = I8B ), & INT ( Z 'A97C177947AD4095' , KIND = I8B ), INT ( Z 'D732290FBACAF133' , KIND = I8B ), & INT ( Z 'A79E946C200627AF' , KIND = I8B ), INT ( Z '5D86C07A6C671FAF' , KIND = I8B ), & INT ( Z '49ED8EABCCCC485D' , KIND = I8B ), INT ( Z '867F59A9D4BED6C0' , KIND = I8B ), & INT ( Z '918639872807B19A' , KIND = I8B ), INT ( Z 'B4E870990780E79B' , KIND = I8B ), & INT ( Z '5C68F256BFFF5A74' , KIND = I8B ), INT ( Z 'A81F301449EE8C70' , KIND = I8B ), & INT ( Z '75E7C7E8F2099E01' , KIND = I8B ), INT ( Z 'E2228CBF49612182' , KIND = I8B ), & INT ( Z '73832EEC6FFF3111' , KIND = I8B ), INT ( Z 'D226FC195C6A2F8C' , KIND = I8B ), & INT ( Z '89B0DCF1974602C1' , KIND = I8B ), INT ( Z '2D5597F78DDCB4F1' , KIND = I8B ), & INT ( Z 'C831FD53C5FF7EAB' , KIND = I8B ), INT ( Z '83585D8FD9C25DB7' , KIND = I8B ), & INT ( Z 'EC1D142DFD178371' , KIND = I8B ), INT ( Z 'F8AAFDF57153E22D' , KIND = I8B ), & INT ( Z 'BA3E7CA8B77F5E55' , KIND = I8B ), INT ( Z 'A42E74F3D032F525' , KIND = I8B ), & INT ( Z '672459397C5D644D' , KIND = I8B ), INT ( Z '76D5BD72CDA8DAB9' , KIND = I8B ), & INT ( Z '28CE1BD2E55F35EB' , KIND = I8B ), INT ( Z 'CD3A1230C43FB26F' , KIND = I8B ), & INT ( Z 'E076B7C3EDBA5EB0' , KIND = I8B ), INT ( Z '2A459667C08988B3' , KIND = I8B ), & INT ( Z '7980D163CF5B81B3' , KIND = I8B ), INT ( Z '80444B5E7AA7CF85' , KIND = I8B ), & INT ( Z 'D89465B4E928F65C' , KIND = I8B ), INT ( Z 'F4D6FC01B0ABEAE0' , KIND = I8B ), & INT ( Z 'D7E105BCC332621F' , KIND = I8B ), INT ( Z 'A0555E361951C366' , KIND = I8B ), & INT ( Z '0EB97F22237333F3' , KIND = I8B ), INT ( Z 'F20CBB021CD6E599' , KIND = I8B ), & INT ( Z '8DD9472BF3FEFAA7' , KIND = I8B ), INT ( Z 'C86AB5C39FA63440' , KIND = I8B ), & INT ( Z '5267DEEAAC5000F0' , KIND = I8B ), INT ( Z 'EE8FE9C2A40C9EFF' , KIND = I8B ), & INT ( Z 'B14F98F6F0FEB951' , KIND = I8B ), INT ( Z 'FA856334878FC150' , KIND = I8B ), & INT ( Z '9380EB52ABB20096' , KIND = I8B ), INT ( Z '3519F219A687E35F' , KIND = I8B ), & INT ( Z '6ED1BF9A569F33D3' , KIND = I8B ), INT ( Z '9C935E00D4B9D8D2' , KIND = I8B ), & INT ( Z '78612627569E80BC' , KIND = I8B ), INT ( Z '02606EA01029DC37' , KIND = I8B ), & INT ( Z '0A862F80EC4700C8' , KIND = I8B ), INT ( Z 'C3B8358109E84F07' , KIND = I8B ), & INT ( Z '56796FB12C4620EB' , KIND = I8B ), INT ( Z '02F88A4814345345' , KIND = I8B ), & INT ( Z 'CD27BB612758C0FA' , KIND = I8B ), INT ( Z 'F4A642E14C6262C8' , KIND = I8B ), & INT ( Z '560BE5CEBBABD492' , KIND = I8B ), INT ( Z '41DB566D0CA0B40B' , KIND = I8B ), & INT ( Z '8038D51CB897789C' , KIND = I8B ), INT ( Z '98E7E9CCCFBD7DBD' , KIND = I8B ), & INT ( Z '2B8EDF426A96C9B7' , KIND = I8B ), INT ( Z '52522C084FC8E10E' , KIND = I8B ), & INT ( Z 'E0470A63E6BD56C3' , KIND = I8B ), INT ( Z 'BF21E44003ACDD2C' , KIND = I8B ), & INT ( Z 'B6729713053C7C25' , KIND = I8B ), INT ( Z '26E6B70A63BB1951' , KIND = I8B ), & INT ( Z '1858CCFCE06CAC74' , KIND = I8B ), INT ( Z 'EEEA5D5004981478' , KIND = I8B ), & INT ( Z '12079E6BE345CD97' , KIND = I8B ), INT ( Z '985032667E54EFD3' , KIND = I8B ), & INT ( Z '0F37801E0C43EBC8' , KIND = I8B ), INT ( Z '95527A5202DF0CCB' , KIND = I8B ), & INT ( Z 'D6898606DC1740FD' , KIND = I8B ), INT ( Z 'BE643F001DEA2BC7' , KIND = I8B ), & INT ( Z 'D30560258F54E6BA' , KIND = I8B ), INT ( Z 'BAA718E68396CFFD' , KIND = I8B ), & INT ( Z 'CC2BE788931D113C' , KIND = I8B ), INT ( Z '6DFD4EC02564B6B9' , KIND = I8B ), & INT ( Z '47C6B82EF32A2069' , KIND = I8B ), INT ( Z 'E950DF20247C83FD' , KIND = I8B ), & INT ( Z '1F9B70B55BF22AC5' , KIND = I8B ), INT ( Z 'E4BE5138175EF234' , KIND = I8B ), & INT ( Z '4CDC331D57FA5441' , KIND = I8B ), INT ( Z '91D28B7416CDD27E' , KIND = I8B ), & INT ( Z '27824CE2B2EEB577' , KIND = I8B ), INT ( Z '5DEDE5861D36AEC1' , KIND = I8B ), & INT ( Z 'E0133FE4ADF8E952' , KIND = I8B ), INT ( Z 'B6472E511C81471D' , KIND = I8B ), & INT ( Z '7162E01B5FAA62D5' , KIND = I8B ), INT ( Z 'F5695EE7A4845A71' , KIND = I8B ), & INT ( Z '58180FDDD97723A6' , KIND = I8B ), INT ( Z 'E3D8F9E563A198E5' , KIND = I8B ), & INT ( Z 'E6DDCC111BCA7DC5' , KIND = I8B ), INT ( Z '5961DB50C6D2B886' , KIND = I8B ), & INT ( Z '570F09EAA7EA7648' , KIND = I8B ), INT ( Z '8E679C2F5E44FF8F' , KIND = I8B ), & INT ( Z 'A0953F1562BD1D36' , KIND = I8B ), INT ( Z '6FBA5224F88766A8' , KIND = I8B ), & INT ( Z '2CD2CC6551E513DA' , KIND = I8B ), INT ( Z 'B201833B35D63F73' , KIND = I8B ), & INT ( Z 'C8BA8EDABB6C6484' , KIND = I8B ), INT ( Z '0BA8E6AE36A94052' , KIND = I8B ), & INT ( Z 'F8077F7EA65E58D1' , KIND = I8B ), INT ( Z 'DE81E40A034BCF4F' , KIND = I8B ), & INT ( Z 'BD749948B523BED2' , KIND = I8B ), INT ( Z 'A749902CE229C833' , KIND = I8B ), & INT ( Z 'FB04AFAF27FAF782' , KIND = I8B ), INT ( Z '8B112E86420F6191' , KIND = I8B ), & INT ( Z 'ACD1BF9AE26CAE87' , KIND = I8B ), INT ( Z '511BF4381AB43A40' , KIND = I8B ), & INT ( Z '79C5DB9AF1F9B563' , KIND = I8B ), INT ( Z 'ADD57A27D29339F6' , KIND = I8B ), & INT ( Z 'D8062F819B07DA29' , KIND = I8B ), INT ( Z '2562F146216148D0' , KIND = I8B ), & INT ( Z '18375281AE7822BC' , KIND = I8B ), INT ( Z 'D94AD8B1C7380874' , KIND = I8B ), & INT ( Z '8703DDB100E4E859' , KIND = I8B ), INT ( Z '975DD6CBD4DCCD82' , KIND = I8B ), & INT ( Z '8F2293910D0B15B5' , KIND = I8B ), INT ( Z '87CEC76F1C830548' , KIND = I8B ), & INT ( Z '28C4D51D411E2270' , KIND = I8B ), INT ( Z 'FD354C7ECA1400E3' , KIND = I8B ), & INT ( Z 'B2EB3875504DDB22' , KIND = I8B ), INT ( Z 'A9C2794AE3A3C69A' , KIND = I8B ), & INT ( Z 'F2F60A649165AB0C' , KIND = I8B ), INT ( Z 'BC829F9E7C99011B' , KIND = I8B ), & INT ( Z '5FA60692A46151EB' , KIND = I8B ), INT ( Z 'D433179D9C8CB841' , KIND = I8B ), & INT ( Z '77D9C67EDADF8AE7' , KIND = I8B ), INT ( Z '55D1A3C30DDFA0B1' , KIND = I8B ), & INT ( Z 'DBC7C41BA6BCD333' , KIND = I8B ), INT ( Z '849FEEC281D7F328' , KIND = I8B ), & INT ( Z 'D5D0381E91976DA1' , KIND = I8B ), INT ( Z '2B460CB3D15788DD' , KIND = I8B ), & INT ( Z '12B9B522906C0800' , KIND = I8B ), INT ( Z 'A5C7EA73224DEFF3' , KIND = I8B ), & INT ( Z '4B44462635FD4909' , KIND = I8B ), INT ( Z '36178FE0C5AD6B15' , KIND = I8B ), & INT ( Z 'D768226B34870A00' , KIND = I8B ), INT ( Z 'CF39E50FEAE16BEF' , KIND = I8B ), & INT ( Z '4F0AABD7E1BE4DA6' , KIND = I8B ), INT ( Z '21CEB9EC7B8C62ED' , KIND = I8B ), & INT ( Z 'E6A1158300D46640' , KIND = I8B ), INT ( Z '81842F29F2CCE375' , KIND = I8B ), & INT ( Z 'A2CD56CDDA2DE10F' , KIND = I8B ), INT ( Z '2A4268679A6F7BA8' , KIND = I8B ), & INT ( Z '60495AE3C1097FD0' , KIND = I8B ), INT ( Z 'A1E53AF46F801C53' , KIND = I8B ), & INT ( Z 'CB80AC8150B95953' , KIND = I8B ), INT ( Z '34D30281810B5A92' , KIND = I8B ), & INT ( Z '385BB19CB14BDFC4' , KIND = I8B ), INT ( Z 'CA5E89B18B602368' , KIND = I8B ), & INT ( Z '7E60D7A1A4E7AFA8' , KIND = I8B ), INT ( Z '4207C321E14E3137' , KIND = I8B ), & INT ( Z '46729E03DD9ED7B5' , KIND = I8B ), INT ( Z 'FCF62C1DEE382C42' , KIND = I8B ), & INT ( Z 'AEFC86C50710CDC9' , KIND = I8B ), INT ( Z '4944D9F52CD0DEC2' , KIND = I8B ), & INT ( Z '6C07A2C26A8346D1' , KIND = I8B ), INT ( Z '9E19DB92B4E31BA9' , KIND = I8B ), & INT ( Z '5ABBA87648D5013B' , KIND = I8B ), INT ( Z '9B96107278051673' , KIND = I8B ), & INT ( Z 'C7098B7305241885' , KIND = I8B ), INT ( Z 'C5A05277621BE293' , KIND = I8B ), & INT ( Z '316A9293DB0A418A' , KIND = I8B ), INT ( Z '027B948F16065C10' , KIND = I8B ), & INT ( Z 'B8CBEE4FC66D1EA7' , KIND = I8B ), INT ( Z 'F70867153AA2DB38' , KIND = I8B ), & INT ( Z '1EE29B9C68E668F6' , KIND = I8B ), INT ( Z '618D3CD96DC3F98A' , KIND = I8B ), & INT ( Z '737F74F1DC043328' , KIND = I8B ), INT ( Z '9A65406D44A5C903' , KIND = I8B ), & INT ( Z 'A69B428383200334' , KIND = I8B ), INT ( Z '79F08C0FC934F7EC' , KIND = I8B ), & INT ( Z '505F522E53053FF2' , KIND = I8B ), INT ( Z 'C0FE908895CF3B44' , KIND = I8B ), & INT ( Z 'D042132463E80401' , KIND = I8B ), INT ( Z '186CAF13BB8235E7' , KIND = I8B ), & INT ( Z '647726B9E7C68FEF' , KIND = I8B ), INT ( Z 'F13E34AABB430A15' , KIND = I8B ), & INT ( Z 'E2294BF6BE710280' , KIND = I8B ), INT ( Z '6F43ED6C553161B0' , KIND = I8B ), & INT ( Z '5ECA783430DC19F5' , KIND = I8B ), INT ( Z '96C6E0EAB509E64D' , KIND = I8B ), & INT ( Z '1AB39EF46E0D4321' , KIND = I8B ), INT ( Z 'CB14E8C76A7DBA1D' , KIND = I8B ), & INT ( Z 'B67D16413D132072' , KIND = I8B ), INT ( Z 'BC789925624C5FE0' , KIND = I8B ), & INT ( Z '616086B1899093E9' , KIND = I8B ), INT ( Z '7DDA22F9451D28A4' , KIND = I8B ), & INT ( Z 'E41C5BD18C57E88F' , KIND = I8B ), INT ( Z 'EB96BF6EBADF77D8' , KIND = I8B ), & INT ( Z 'BCDC542EF5FA5C71' , KIND = I8B ), INT ( Z 'AEA855DBCB323966' , KIND = I8B ), & INT ( Z '8E91B962F7B6F159' , KIND = I8B ), INT ( Z '933E37A534CBAAE7' , KIND = I8B ), & INT ( Z '6C13693AB378F38E' , KIND = I8B ), INT ( Z '1A526B52BDFEC7C0' , KIND = I8B ), & INT ( Z '723627BBB5A4ADB0' , KIND = I8B ), INT ( Z 'B80DC58E81FE95A1' , KIND = I8B ), & INT ( Z '8718438960573071' , KIND = I8B ), INT ( Z '20E706276D7E79B0' , KIND = I8B ), & INT ( Z 'CEC3B1AAA30DD91C' , KIND = I8B ), INT ( Z 'E61136F2227E3B09' , KIND = I8B ), & INT ( Z '546F2A35DC367E47' , KIND = I8B ), INT ( Z '949063D8A46F0C0E' , KIND = I8B ), & INT ( Z '213A4F0AA5E8A7B1' , KIND = I8B ), INT ( Z '8FCAC257558EE4E6' , KIND = I8B ), & INT ( Z 'E98AF4C353441DD8' , KIND = I8B ), INT ( Z 'F9B47CCECD8ACF11' , KIND = I8B ), & INT ( Z 'A988E2CD4F62D19D' , KIND = I8B ), INT ( Z 'B3BD72ED2AF29E1F' , KIND = I8B ), & INT ( Z '63EDB1F42815254F' , KIND = I8B ), INT ( Z '78219C0280ED82D6' , KIND = I8B ), & INT ( Z '93EB1B80A33B8605' , KIND = I8B ), INT ( Z 'E0ACCFA875AF45A7' , KIND = I8B ), & INT ( Z 'FE748F38990D3751' , KIND = I8B ), INT ( Z '6B150181909471C5' , KIND = I8B ), & INT ( Z 'BC72F130660533C3' , KIND = I8B ), INT ( Z '8C6C01C9498D8B88' , KIND = I8B ), & INT ( Z '7E11B306BF508525' , KIND = I8B ), INT ( Z '45DA41E1F4B98E37' , KIND = I8B ), & INT ( Z 'EB8FAD7C7F8680B4' , KIND = I8B ), INT ( Z 'AF87023B9BF0EE6A' , KIND = I8B ), & INT ( Z '5D961FC86F24A66F' , KIND = I8B ), INT ( Z '5750D25A71E7F1C5' , KIND = I8B ), & INT ( Z 'A67398DB9F6820E1' , KIND = I8B ), INT ( Z 'DB68C2CA82ED2A05' , KIND = I8B ), & INT ( Z '5A7DD3DD4576E805' , KIND = I8B ), INT ( Z 'D69283788730F71B' , KIND = I8B ), & INT ( Z '88083F8943A1148C' , KIND = I8B ), INT ( Z '892179BE91D43A43' , KIND = I8B ), & INT ( Z '311D48D496D4A206' , KIND = I8B ), INT ( Z '0C372456A8FD34E2' , KIND = I8B ), & INT ( Z '6A0A4F6B948959B0' , KIND = I8B ), INT ( Z 'AB69D82E364948D4' , KIND = I8B ), & INT ( Z 'BD649B09BC89CA88' , KIND = I8B ), INT ( Z '0F44ED6C533C821A' , KIND = I8B ), & INT ( Z '848CE34679ABB01C' , KIND = I8B ), INT ( Z 'D6444E39C3DB9B09' , KIND = I8B ), & INT ( Z 'B65EE0E615D61E95' , KIND = I8B ), INT ( Z '898B1463B405D150' , KIND = I8B ), & INT ( Z 'F2D80E0C0C0B4E11' , KIND = I8B ), INT ( Z '85EAB0E41A6940E5' , KIND = I8B ), & INT ( Z 'E3F6991F9B4BA63A' , KIND = I8B ), INT ( Z 'EBEDD97CA10745A4' , KIND = I8B ), & INT ( Z '6F8E118F0F0E2195' , KIND = I8B ), INT ( Z 'A7655D1D2103911F' , KIND = I8B ), & INT ( Z '1CF43F67821E8FC9' , KIND = I8B ), INT ( Z '66E94FDBC949170E' , KIND = I8B ), & INT ( Z '4B7195F2D2D1A9FB' , KIND = I8B ), INT ( Z 'D13EB46469447567' , KIND = I8B ), & INT ( Z 'D218A7A0B15319DD' , KIND = I8B ), INT ( Z '2051D1E95DCDAE68' , KIND = I8B ), & INT ( Z '8F26FDB7C3C30A3D' , KIND = I8B ), INT ( Z '82C730BEC1CAC960' , KIND = I8B ), & INT ( Z '069ED188DDA7E055' , KIND = I8B ), INT ( Z '68664663B5411A03' , KIND = I8B ), & INT ( Z 'B2F0BD25B4B3CCCC' , KIND = I8B ), INT ( Z 'A378FCEE723D7BB8' , KIND = I8B ), & INT ( Z 'C84685EB1511D86A' , KIND = I8B ), INT ( Z '827FD7FCA2916083' , KIND = I8B ), & INT ( Z 'DFACEC6F21E0BFFF' , KIND = I8B ), INT ( Z 'CC573C2A0ECCDAA6' , KIND = I8B )], [ 4 , 701 ]) !# size of the 'Pow5_128_Table' table INTEGER ( KIND = I4B ), PARAMETER :: Pow5_128_Size = 56 !> This table contains the 128-bit representations of powers of 5 from 0 to 55. ! The 128-bit representations are stored in each row of the array and they are stored ! in a little-endian order (i.e. the (first) element 0 of each row represents the ! least significant byte and the (second) element 1 is the most significand one). INTEGER ( KIND = I8B ), PARAMETER :: Pow5_128_Table ( 0 : 1 , 0 : Pow5_128_Size - 1 ) = & RESHAPE ([ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000005' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000019' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000000000007D' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000271' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000000C35' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000000003D09' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000000001312D' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000000005F5E1' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '00000000001DCD65' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '00000000009502F9' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000002E90EDD' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000000E8D4A51' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000000048C27395' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000016BCC41E9' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000071AFD498D' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0000002386F26FC1' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000000B1A2BC2EC5' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000003782DACE9D9' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '00001158E460913D' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000056BC75E2D631' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0001B1AE4D6E2EF5' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '000878678326EAC9' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '002A5A058FC295ED' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '00D3C21BCECCEDA1' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '0422CA8B0A00A425' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '14ADF4B7320334B9' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '6765C793FA10079D' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '04FCE5E3E2502611' , KIND = I8B ), INT ( Z '0000000000000002' , KIND = I8B ), & INT ( Z '18F07D736B90BE55' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B ), & INT ( Z '7CB2734119D3B7A9' , KIND = I8B ), INT ( Z '0000000000000032' , KIND = I8B ), & INT ( Z '6F7C40458122964D' , KIND = I8B ), INT ( Z '00000000000000FC' , KIND = I8B ), & INT ( Z '2D6D415B85ACEF81' , KIND = I8B ), INT ( Z '00000000000004EE' , KIND = I8B ), & INT ( Z 'E32246C99C60AD85' , KIND = I8B ), INT ( Z '00000000000018A6' , KIND = I8B ), & INT ( Z '6FAB61F00DE36399' , KIND = I8B ), INT ( Z '0000000000007B42' , KIND = I8B ), & INT ( Z '2E58E9B04570F1FD' , KIND = I8B ), INT ( Z '000000000002684C' , KIND = I8B ), & INT ( Z 'E7BC90715B34B9F1' , KIND = I8B ), INT ( Z '00000000000C097C' , KIND = I8B ), & INT ( Z '86AED236C807A1B5' , KIND = I8B ), INT ( Z '00000000003C2F70' , KIND = I8B ), & INT ( Z 'A16A1B11E8262889' , KIND = I8B ), INT ( Z '00000000012CED32' , KIND = I8B ), & INT ( Z '2712875988BECAAD' , KIND = I8B ), INT ( Z '0000000005E0A1FD' , KIND = I8B ), & INT ( Z 'C35CA4BFABB9F561' , KIND = I8B ), INT ( Z '000000001D6329F1' , KIND = I8B ), & INT ( Z 'D0CF37BE5AA1CAE5' , KIND = I8B ), INT ( Z '0000000092EFD1B8' , KIND = I8B ), & INT ( Z '140C16B7C528F679' , KIND = I8B ), INT ( Z '00000002DEAF189C' , KIND = I8B ), & INT ( Z '643C7196D9CCD05D' , KIND = I8B ), INT ( Z '0000000E596B7B0C' , KIND = I8B ), & INT ( Z 'F52E37F2410011D1' , KIND = I8B ), INT ( Z '00000047BF19673D' , KIND = I8B ), & INT ( Z 'C9E717BB45005915' , KIND = I8B ), INT ( Z '00000166BB7F0435' , KIND = I8B ), & INT ( Z 'F18376A85901BD69' , KIND = I8B ), INT ( Z '00000701A97B150C' , KIND = I8B ), & INT ( Z 'B7915149BD08B30D' , KIND = I8B ), INT ( Z '000023084F676940' , KIND = I8B ), & INT ( Z '95D69670B12B7F41' , KIND = I8B ), INT ( Z '0000AF298D050E43' , KIND = I8B ), & INT ( Z 'ED30F03375D97C45' , KIND = I8B ), INT ( Z '00036BCFC1194751' , KIND = I8B ), & INT ( Z 'A1F4B1014D3F6D59' , KIND = I8B ), INT ( Z '00111B0EC57E6499' , KIND = I8B ), & INT ( Z '29C77506823D22BD' , KIND = I8B ), INT ( Z '00558749DB77F700' , KIND = I8B ), & INT ( Z 'D0E549208B31ADB1' , KIND = I8B ), INT ( Z '01ABA4714957D300' , KIND = I8B ), & INT ( Z '147A6DA2B7F86475' , KIND = I8B ), INT ( Z '085A36366EB71F04' , KIND = I8B ), & INT ( Z '6664242D97D9F649' , KIND = I8B ), INT ( Z '29C30F1029939B14' , KIND = I8B ), & INT ( Z 'FFF4B4E3F741CF6D' , KIND = I8B ), INT ( Z 'D0CF4B50CFE20765' , KIND = I8B )], [ 2 , 56 ]) !# minimum exponent value of the 'Pow10_256_Compressed_Table' table INTEGER ( KIND = I4B ), PARAMETER :: Pow10_256_Compressed_MinExp = - 5005 !# maximum exponent value of the 'Pow10_256_Compressed_Table' table INTEGER ( KIND = I4B ), PARAMETER :: Pow10_256_Compressed_MaxExp = 5019 !> This table contains the 256-bit mantissa (or significand) approximations of the !   powers of 10 from -5005 to 5019 that can cover the entire exponent ranges of all !   three (quadruple-, double- and single-precision) floating point numbers. ! The 256-bit approximations are stored in each row of the array and they are stored !   in a little-endian order (i.e. the (first) element 0 of each row represents the !   least significant byte and the (fourth) element 3 is the most significand one). ! *Important Note*:  the 256-bit approximations are stored in a compressed form; ! therefore, this table must be used in conjunction with the 'Pow5_128_Table' ! listed above to compute the actual approximation for the required exponent. INTEGER ( KIND = I8B ), PARAMETER :: Pow10_256_Compressed_Table ( 0 : 3 , 0 : 179 ) = & RESHAPE ([ & INT ( Z '36551D5CAEBE5F19' , KIND = I8B ), INT ( Z 'B76974F01FD4D2A5' , KIND = I8B ), & INT ( Z '96C34F43A9FACED7' , KIND = I8B ), INT ( Z 'D740992314AD6BB8' , KIND = I8B ), & INT ( Z '280FF4BB6DE53C8C' , KIND = I8B ), INT ( Z '910DA112133C7D2F' , KIND = I8B ), & INT ( Z '8C1A9EFE537E7256' , KIND = I8B ), INT ( Z 'DB777B3B4103CD8E' , KIND = I8B ), & INT ( Z 'B51DD1A26B3E0AE4' , KIND = I8B ), INT ( Z 'DC75C0DE1DBD1518' , KIND = I8B ), & INT ( Z '986847E9FC8C0DA2' , KIND = I8B ), INT ( Z 'DFC37CE196FE24A6' , KIND = I8B ), & INT ( Z 'B1DFE4774EA27C85' , KIND = I8B ), INT ( Z '6D717A4AE66C471F' , KIND = I8B ), & INT ( Z 'FE02584657A5D4A3' , KIND = I8B ), INT ( Z 'E42507F5B8D7AB8A' , KIND = I8B ), & INT ( Z '62A78FB4471D9C41' , KIND = I8B ), INT ( Z 'D5BAC5A3031C0A3D' , KIND = I8B ), & INT ( Z 'C5AEC6423E968BB7' , KIND = I8B ), INT ( Z 'E89C8869F10D2F89' , KIND = I8B ), & INT ( Z 'CD0F383A196B7237' , KIND = I8B ), INT ( Z '3DA563D1BCF2E89C' , KIND = I8B ), & INT ( Z '4774A69ADDF3C50D' , KIND = I8B ), INT ( Z 'ED2A6C4D961CCDC9' , KIND = I8B ), & INT ( Z 'EE753F9DF785A420' , KIND = I8B ), INT ( Z '7D1DF2590CE8203E' , KIND = I8B ), & INT ( Z '5C3F923385BE6663' , KIND = I8B ), INT ( Z 'F1CF23D7A258D37E' , KIND = I8B ), & INT ( Z '0FFF2A51C95A3A72' , KIND = I8B ), INT ( Z '6856EB7268BB8873' , KIND = I8B ), & INT ( Z '0FB1034E07547FEB' , KIND = I8B ), INT ( Z 'F68B217180D2C34F' , KIND = I8B ), & INT ( Z '136B3DAF4BEF6FDF' , KIND = I8B ), INT ( Z 'FFAD1F695AC21476' , KIND = I8B ), & INT ( Z 'A1CB42ADD8C71A34' , KIND = I8B ), INT ( Z 'FB5ED9C210689E24' , KIND = I8B ), & INT ( Z '339C8F794803A95A' , KIND = I8B ), INT ( Z 'B60B57CE59A00FE3' , KIND = I8B ), & INT ( Z '537F3DB8E565B56B' , KIND = I8B ), INT ( Z '802561DC6F01E1C2' , KIND = I8B ), & INT ( Z '5C2E583532F7A896' , KIND = I8B ), INT ( Z 'EA135BA2A6E86A78' , KIND = I8B ), & INT ( Z 'BDC3551E0A26C72F' , KIND = I8B ), INT ( Z '82A7AC4CCB8F06BD' , KIND = I8B ), & INT ( Z '8386C87E9445033E' , KIND = I8B ), INT ( Z 'A2F677099BF2A66F' , KIND = I8B ), & INT ( Z '78B4BB2AA55193C3' , KIND = I8B ), INT ( Z '85368A03DAD39B5A' , KIND = I8B ), & INT ( Z '32F06577D7074E54' , KIND = I8B ), INT ( Z '173D9AA79942373E' , KIND = I8B ), & INT ( Z '499E81B4CD4AE3EA' , KIND = I8B ), INT ( Z '87D23A0933350F8C' , KIND = I8B ), & INT ( Z 'FE908EC116816F8B' , KIND = I8B ), INT ( Z '35CDFBC46A449E10' , KIND = I8B ), & INT ( Z '8D4D35B31A8D06C0' , KIND = I8B ), INT ( Z '8A7AFCA0558B9252' , KIND = I8B ), & INT ( Z 'A23AF279B441588B' , KIND = I8B ), INT ( Z '1493053A1C26C9FE' , KIND = I8B ), & INT ( Z 'C58E825E9EA5CAB3' , KIND = I8B ), INT ( Z '8D31134EDC8F41F2' , KIND = I8B ), & INT ( Z '1D664B9A0D81F3F8' , KIND = I8B ), INT ( Z 'F54956CD4A8BF8BB' , KIND = I8B ), & INT ( Z '9A68CB84CA90592C' , KIND = I8B ), INT ( Z '8FF4C0E2CB45C6DF' , KIND = I8B ), & INT ( Z 'C9CC2E96D0D7ECAD' , KIND = I8B ), INT ( Z '4C2B817AE934C413' , KIND = I8B ), & INT ( Z '7559CABB281AA312' , KIND = I8B ), INT ( Z '92C64978FB0BBC09' , KIND = I8B ), & INT ( Z 'D30D14DEDBA3C47A' , KIND = I8B ), INT ( Z '0B2130D22416CA03' , KIND = I8B ), & INT ( Z '02EBFFEFCE416A4F' , KIND = I8B ), INT ( Z '95A5F283A9D85228' , KIND = I8B ), & INT ( Z '6122213492C7EEBF' , KIND = I8B ), INT ( Z '8B8594477973B5CC' , KIND = I8B ), & INT ( Z 'A3DD3D019C378C32' , KIND = I8B ), INT ( Z '989402D1295CB59D' , KIND = I8B ), & INT ( Z 'F462491B6388FF85' , KIND = I8B ), INT ( Z 'AC8FC877DDA49C5B' , KIND = I8B ), & INT ( Z '9861BAF69ABF15B2' , KIND = I8B ), INT ( Z '9B90C292AFA3E833' , KIND = I8B ), & INT ( Z '9B80CC3A2F3F00D2' , KIND = I8B ), INT ( Z '09201621395EB23A' , KIND = I8B ), & INT ( Z '6255B4ACB3C54AAC' , KIND = I8B ), INT ( Z '9E9C7B6349DAF965' , KIND = I8B ), & INT ( Z 'C6A666357166B6F5' , KIND = I8B ), INT ( Z '34817EDA496E980D' , KIND = I8B ), & INT ( Z 'F18BE95ADFB35BD9' , KIND = I8B ), INT ( Z 'A1B7784EF1ECD192' , KIND = I8B ), & INT ( Z 'E582AC4E79ECB4E5' , KIND = I8B ), INT ( Z '5CC27DE46B2668BA' , KIND = I8B ), & INT ( Z 'A931725AD5869D0F' , KIND = I8B ), INT ( Z 'A4E205D9C7A01E8C' , KIND = I8B ), & INT ( Z 'E3BD8F843A7379A8' , KIND = I8B ), INT ( Z 'EF59CA4D33AEAACA' , KIND = I8B ), & INT ( Z 'C5D211C6689BB43B' , KIND = I8B ), INT ( Z 'A81C72076DE95AD4' , KIND = I8B ), & INT ( Z '2C17DBC2A25011F8' , KIND = I8B ), INT ( Z '427B47B78F679F36' , KIND = I8B ), & INT ( Z '5634DFC7A23269BC' , KIND = I8B ), INT ( Z 'AB670C628D2664FB' , KIND = I8B ), & INT ( Z '6941FA8C2552AD87' , KIND = I8B ), INT ( Z '8E2573250417E3EA' , KIND = I8B ), & INT ( Z 'B1727969F1308DA9' , KIND = I8B ), INT ( Z 'AEC226047AFCA9FA' , KIND = I8B ), & INT ( Z 'BFBF516B03E77A02' , KIND = I8B ), INT ( Z 'A0B5539D042A09B3' , KIND = I8B ), & INT ( Z 'A4029E36D6F23E59' , KIND = I8B ), INT ( Z 'B22E119D089684C9' , KIND = I8B ), & INT ( Z 'E34B0E471219629D' , KIND = I8B ), INT ( Z '6CFFE2FAFFDFB62F' , KIND = I8B ), & INT ( Z 'B488122830B22F41' , KIND = I8B ), INT ( Z 'B5AB237A780026CF' , KIND = I8B ), & INT ( Z 'C69DE78E00F92C06' , KIND = I8B ), INT ( Z 'F4D9A7F47802B282' , KIND = I8B ), & INT ( Z 'DFA7CE651C7C640E' , KIND = I8B ), INT ( Z 'B939B191996820E1' , KIND = I8B ), & INT ( Z 'D25AF8E4BDEF3D39' , KIND = I8B ), INT ( Z 'D1C451AA692CD802' , KIND = I8B ), & INT ( Z 'C828083CE66AB062' , KIND = I8B ), INT ( Z 'BCDA1386110B7B47' , KIND = I8B ), & INT ( Z '21631DF1A7CA30CF' , KIND = I8B ), INT ( Z 'C04A31CE10142B88' , KIND = I8B ), & INT ( Z '2EE136D2BD32E12E' , KIND = I8B ), INT ( Z 'C08CA2B2C6993561' , KIND = I8B ), & INT ( Z '9849C14804373AD0' , KIND = I8B ), INT ( Z 'F34EB109C4272065' , KIND = I8B ), & INT ( Z '07CF979EEA155507' , KIND = I8B ), INT ( Z 'C451BA327EDD033A' , KIND = I8B ), & INT ( Z 'F76F45D6A84E6C5C' , KIND = I8B ), INT ( Z '74C89E178C289C4E' , KIND = I8B ), & INT ( Z '05538296DEA43314' , KIND = I8B ), INT ( Z 'C829B6E8A0853113' , KIND = I8B ), & INT ( Z '94F9878998C91025' , KIND = I8B ), INT ( Z '869B308D8DFEDFB8' , KIND = I8B ), & INT ( Z '3BD21A71C2B71A8C' , KIND = I8B ), INT ( Z 'CC14F78A24DBBB01' , KIND = I8B ), & INT ( Z 'E2550DF7CD13845E' , KIND = I8B ), INT ( Z '901F6F7FC95EE63C' , KIND = I8B ), & INT ( Z 'C8601E6FA4BF8F4E' , KIND = I8B ), INT ( Z 'D013DCA6B54EE1AF' , KIND = I8B ), & INT ( Z '314838C31F12F799' , KIND = I8B ), INT ( Z '21A1837A56C0E7B9' , KIND = I8B ), & INT ( Z '673FDADCFB020F43' , KIND = I8B ), INT ( Z 'D426C8B1F6A9D56A' , KIND = I8B ), & INT ( Z 'F2260F65B1FEC8D2' , KIND = I8B ), INT ( Z 'BF8AC7AC3234497A' , KIND = I8B ), & INT ( Z 'E77BFCBF4C9E7ADA' , KIND = I8B ), INT ( Z 'D84E200D02E27651' , KIND = I8B ), & INT ( Z '65223F685FBB48C5' , KIND = I8B ), INT ( Z '5B005DBF596582AA' , KIND = I8B ), & INT ( Z 'C128EA94AAFF3332' , KIND = I8B ), INT ( Z 'DC8A49101265A45F' , KIND = I8B ), & INT ( Z 'A84C0547AD3E2669' , KIND = I8B ), INT ( Z '6F8C2E7D0CB97BDC' , KIND = I8B ), & INT ( Z '3C43609ED5462D14' , KIND = I8B ), INT ( Z 'E0DBAC1455D02C1B' , KIND = I8B ), & INT ( Z '9122E1565E556140' , KIND = I8B ), INT ( Z '26444729F361F768' , KIND = I8B ), & INT ( Z '30DE25C986024442' , KIND = I8B ), INT ( Z 'E542B37E01070609' , KIND = I8B ), & INT ( Z 'A694E67207B25770' , KIND = I8B ), INT ( Z '4012E15015C7BCB7' , KIND = I8B ), & INT ( Z '4D0447208F3D177F' , KIND = I8B ), INT ( Z 'E9BFCBC688A65F62' , KIND = I8B ), & INT ( Z '0C197AA9F4C79A7E' , KIND = I8B ), INT ( Z 'F285D262E981D766' , KIND = I8B ), & INT ( Z '0FA349B0CA4EBD47' , KIND = I8B ), INT ( Z 'EE53638712C3BAF0' , KIND = I8B ), & INT ( Z '30F39A05AE9FAEA9' , KIND = I8B ), INT ( Z '5EEEF1B71939A504' , KIND = I8B ), & INT ( Z 'AB176A1A25FD6C9C' , KIND = I8B ), INT ( Z 'F2FDEB831C04698D' , KIND = I8B ), & INT ( Z 'AD3A7B296573C53C' , KIND = I8B ), INT ( Z 'DBF9B06F93BFFDFB' , KIND = I8B ), & INT ( Z '7D0B53BA94B4643D' , KIND = I8B ), INT ( Z 'F7BFD6B3520EA329' , KIND = I8B ), & INT ( Z '4311E46BBEBF4F06' , KIND = I8B ), INT ( Z '1DFEF1B5137F779F' , KIND = I8B ), & INT ( Z 'D5CD9080862D2A51' , KIND = I8B ), INT ( Z 'FC999A50A460ABC1' , KIND = I8B ), & INT ( Z 'BD23DF9F8A82A8CB' , KIND = I8B ), INT ( Z 'E13695D3E1B9D384' , KIND = I8B ), & INT ( Z '7749DE9BF2446B6D' , KIND = I8B ), INT ( Z '80C5D6EFC64F5619' , KIND = I8B ), & INT ( Z '9BE5D4853787B437' , KIND = I8B ), INT ( Z 'B8E66B56D394147D' , KIND = I8B ), & INT ( Z '970CF8CCE40B1107' , KIND = I8B ), INT ( Z '834B459DC7B69EA2' , KIND = I8B ), & INT ( Z '2734238D9E3D2D3B' , KIND = I8B ), INT ( Z '6D24AE7C2611BDD5' , KIND = I8B ), & INT ( Z 'DEFD267424FBAC3F' , KIND = I8B ), INT ( Z '85DD57517B7A0A62' , KIND = I8B ), & INT ( Z '0ADCC666E173CF31' , KIND = I8B ), INT ( Z 'E17BB1A2FC03AC8C' , KIND = I8B ), & INT ( Z '0A4BC1B2A0F829A4' , KIND = I8B ), INT ( Z '887C4B616414E88B' , KIND = I8B ), & INT ( Z '42E3E243C3FA365B' , KIND = I8B ), INT ( Z 'E7E29AE280A43245' , KIND = I8B ), & INT ( Z '19A605AFAC1A9E5B' , KIND = I8B ), INT ( Z '8B2862617A07C409' , KIND = I8B ), & INT ( Z '6199216D3B08FCCE' , KIND = I8B ), INT ( Z 'ED25F5BD6E1C32A6' , KIND = I8B ), & INT ( Z '2BECDE00EDD89640' , KIND = I8B ), INT ( Z '8DE1DE296304417E' , KIND = I8B ), & INT ( Z 'DE6AC4A65AAA0DDC' , KIND = I8B ), INT ( Z '90CB3DA4EB4E9C54' , KIND = I8B ), & INT ( Z 'F3578F3AAC8C10D2' , KIND = I8B ), INT ( Z '90A901DAC840396A' , KIND = I8B ), & INT ( Z '8B134D8B53B24BDE' , KIND = I8B ), INT ( Z 'E8D208C2E554231E' , KIND = I8B ), & INT ( Z 'A6E54C31936ACD9D' , KIND = I8B ), INT ( Z '937E11E7CC8C33E0' , KIND = I8B ), & INT ( Z '3B8A457E418ED2FA' , KIND = I8B ), INT ( Z '9F63CE3B45CEE23D' , KIND = I8B ), & INT ( Z 'A83DBDBE6FF51F7F' , KIND = I8B ), INT ( Z '96615419A2CC79A5' , KIND = I8B ), & INT ( Z '7582AAAF505F7D2C' , KIND = I8B ), INT ( Z '071757FA70F8ECF6' , KIND = I8B ), & INT ( Z '1D21BAFBC6BDF274' , KIND = I8B ), INT ( Z '99530F9745770CB1' , KIND = I8B ), & INT ( Z '47086751D1BFC244' , KIND = I8B ), INT ( Z 'E7DB353A50105038' , KIND = I8B ), & INT ( Z '3E83BC53211CC27B' , KIND = I8B ), INT ( Z '9C538CEC4FBC0774' , KIND = I8B ), & INT ( Z 'AADF733514481AA9' , KIND = I8B ), INT ( Z '7124C52008BCB2F2' , KIND = I8B ), & INT ( Z '6C6C2458BB0BFABD' , KIND = I8B ), INT ( Z '9F63160FF9011FE9' , KIND = I8B ), & INT ( Z '54A3F155DED79252' , KIND = I8B ), INT ( Z 'E340200055D066FE' , KIND = I8B ), & INT ( Z '038C474A387E1BEF' , KIND = I8B ), INT ( Z 'A281F66C335C5920' , KIND = I8B ), & INT ( Z '66F82F83E78F45B2' , KIND = I8B ), INT ( Z '0CA71638CC66C30E' , KIND = I8B ), & INT ( Z 'E69A144C907D9363' , KIND = I8B ), INT ( Z 'A5B07AE4EDBD4C49' , KIND = I8B ), & INT ( Z '95F8384A5C10F4AF' , KIND = I8B ), INT ( Z 'FB057BAD1325F8A9' , KIND = I8B ), & INT ( Z 'A903015120C51B50' , KIND = I8B ), INT ( Z 'A8EEF1DF7A77E17F' , KIND = I8B ), & INT ( Z '899B412D19B80437' , KIND = I8B ), INT ( Z 'EE587B35EE0FF080' , KIND = I8B ), & INT ( Z 'E8F9910BF1580C20' , KIND = I8B ), INT ( Z 'AC3DAB4A1AE6D0D6' , KIND = I8B ), & INT ( Z 'C781090E748A2D6C' , KIND = I8B ), INT ( Z '1B44BA709B41FAC9' , KIND = I8B ), & INT ( Z 'F3394CF73C86F97A' , KIND = I8B ), INT ( Z 'AF9CF8A3B0DFD659' , KIND = I8B ), & INT ( Z '88F2DFB2D6849A1B' , KIND = I8B ), INT ( Z '177A0DE1B1C758D1' , KIND = I8B ), & INT ( Z '3A6C9FF074C91C03' , KIND = I8B ), INT ( Z 'B30D2D0396B72748' , KIND = I8B ), & INT ( Z 'CB03BBB49ACAE632' , KIND = I8B ), INT ( Z '0535B24D77660984' , KIND = I8B ), & INT ( Z '2F20C678A5594431' , KIND = I8B ), INT ( Z 'B68E9D219E936D1E' , KIND = I8B ), & INT ( Z 'ACC440B0C24C4B4A' , KIND = I8B ), INT ( Z 'F5FBC25C26DAA523' , KIND = I8B ), & INT ( Z '0D68F1075451173E' , KIND = I8B ), INT ( Z 'BA219F5E39D75394' , KIND = I8B ), & INT ( Z '8A43060F0FA775D5' , KIND = I8B ), INT ( Z '360ED84A5CE0FECD' , KIND = I8B ), & INT ( Z '7ED38C896B5E26BC' , KIND = I8B ), INT ( Z 'BDC68BCAC969926B' , KIND = I8B ), & INT ( Z 'A3764C9E7BFDD6FB' , KIND = I8B ), INT ( Z '6CD38FF92700788A' , KIND = I8B ), & INT ( Z '898B6959D41B8DCB' , KIND = I8B ), INT ( Z 'C17DBC3217A84AE2' , KIND = I8B ), & INT ( Z '155FF45CE16E1F8E' , KIND = I8B ), INT ( Z 'E4C545B373C08B0C' , KIND = I8B ), & INT ( Z '1C478DB63FD474C8' , KIND = I8B ), INT ( Z 'C5478C20FCD89358' , KIND = I8B ), & INT ( Z 'CE3638886093157F' , KIND = I8B ), INT ( Z '78897A81F9722117' , KIND = I8B ), & INT ( Z '6BAECA12558DFE94' , KIND = I8B ), INT ( Z 'C92458EF2EE7227E' , KIND = I8B ), & INT ( Z '96DE8F78F20CF4DD' , KIND = I8B ), INT ( Z '7F697E055C034630' , KIND = I8B ), & INT ( Z '0A02E2256B1ED9A5' , KIND = I8B ), INT ( Z 'CD1481C83D5336C6' , KIND = I8B ), & INT ( Z 'F84D26BA382A3B98' , KIND = I8B ), INT ( Z '6349D1696F488AB2' , KIND = I8B ), & INT ( Z 'DF346BD1FD310984' , KIND = I8B ), INT ( Z 'D11867B4BA2116E0' , KIND = I8B ), & INT ( Z '0ECD499A09D856E7' , KIND = I8B ), INT ( Z '00BAE25A886CC532' , KIND = I8B ), & INT ( Z 'AAC084D5DF2B9D7F' , KIND = I8B ), INT ( Z 'D5306DA390B5DDBE' , KIND = I8B ), & INT ( Z '1A4714F6BC521D16' , KIND = I8B ), INT ( Z '2DA8B27ADE6D68DA' , KIND = I8B ), & INT ( Z '4BB701B3132A032B' , KIND = I8B ), INT ( Z 'D95CF8738B82AFA0' , KIND = I8B ), & INT ( Z 'DB2EA6A7A8E49E3C' , KIND = I8B ), INT ( Z '151F22907EC8BCBD' , KIND = I8B ), & INT ( Z '8F0B721F9065BE13' , KIND = I8B ), INT ( Z 'DD9E6EFD0969F740' , KIND = I8B ), & INT ( Z '3A24849862F07EBF' , KIND = I8B ), INT ( Z 'B49E54F0256A1BE0' , KIND = I8B ), & INT ( Z 'BB9EA0FAD10358FE' , KIND = I8B ), INT ( Z 'E1F53A1BE3CDE207' , KIND = I8B ), & INT ( Z 'A1806409F8521533' , KIND = I8B ), INT ( Z '6F53FE5D3EA6702D' , KIND = I8B ), & INT ( Z 'AD6A4818B4F04B25' , KIND = I8B ), INT ( Z 'E661C4B9863C013B' , KIND = I8B ), & INT ( Z 'E76EE55162932FEB' , KIND = I8B ), INT ( Z '025409857EA88B50' , KIND = I8B ), & INT ( Z '745B736C0E0205A3' , KIND = I8B ), INT ( Z 'EAE47BD738AEBC94' , KIND = I8B ), & INT ( Z '2F5BEFDF9355F1DD' , KIND = I8B ), INT ( Z '0F89E3CD2D596A50' , KIND = I8B ), & INT ( Z 'C08F832678E89903' , KIND = I8B ), INT ( Z 'EF7DCE989D622102' , KIND = I8B ), & INT ( Z '9D0EFCD7B695D7A2' , KIND = I8B ), INT ( Z '5AC7C7E22FEBBF6B' , KIND = I8B ), & INT ( Z 'E36D0C8C2768EED3' , KIND = I8B ), INT ( Z 'F42E2E4E633E8D41' , KIND = I8B ), & INT ( Z '3FE72686E60A41A0' , KIND = I8B ), INT ( Z 'F296A8198AA40FB8' , KIND = I8B ), & INT ( Z '235532B08487FE6A' , KIND = I8B ), INT ( Z 'F8F60E812DE0CD7D' , KIND = I8B ), & INT ( Z '3416E09C76D3C065' , KIND = I8B ), INT ( Z 'F29262D9A2BCBE28' , KIND = I8B ), & INT ( Z '435857D1D2216CB0' , KIND = I8B ), INT ( Z 'FDD5E4FCB44C605C' , KIND = I8B ), & INT ( Z '292D213B72C4176E' , KIND = I8B ), INT ( Z 'A0B0E1D947665B46' , KIND = I8B ), & INT ( Z '4BB64866F22E6EC9' , KIND = I8B ), INT ( Z '816714ED8BACF15A' , KIND = I8B ), & INT ( Z 'FB1F407E06A544D4' , KIND = I8B ), INT ( Z '9EBD860F071DB94D' , KIND = I8B ), & INT ( Z '35B0D7E6CDFF33AF' , KIND = I8B ), INT ( Z '83EFABC8387C7E32' , KIND = I8B ), & INT ( Z '9FE0614A0AFB6D60' , KIND = I8B ), INT ( Z '324658E593E74E2E' , KIND = I8B ), & INT ( Z '0A1F981D74D2D6E5' , KIND = I8B ), INT ( Z '8684F57B4EB15085' , KIND = I8B ), & INT ( Z '85D73FFB60E28C47' , KIND = I8B ), INT ( Z '0A3A9F2C0ACF71A2' , KIND = I8B ), & INT ( Z 'BE311C083A225CD2' , KIND = I8B ), INT ( Z '892731AC9FAF056E' , KIND = I8B ), & INT ( Z '0051727975F71E76' , KIND = I8B ), INT ( Z '6853926E2EDA2D0C' , KIND = I8B ), & INT ( Z 'E0C8BB2C5C6D24E0' , KIND = I8B ), INT ( Z '8BD6A141006042BD' , KIND = I8B ), & INT ( Z 'D54D9E55435C2CF5' , KIND = I8B ), INT ( Z '41B0230E1421487D' , KIND = I8B ), & INT ( Z '547EB47B7282EE9C' , KIND = I8B ), INT ( Z '8E938662882AF53E' , KIND = I8B ), & INT ( Z 'FE80EA9C004B0589' , KIND = I8B ), INT ( Z 'F24512F07CC4EF84' , KIND = I8B ), & INT ( Z '0ACE1474DC1D122E' , KIND = I8B ), INT ( Z '915E2486EF32CD60' , KIND = I8B ), & INT ( Z '737477AEDBD3605F' , KIND = I8B ), INT ( Z '6610F6D247AB80DF' , KIND = I8B ), & INT ( Z 'F9A0B6720AAF6521' , KIND = I8B ), INT ( Z '9436C0760C86E30B' , KIND = I8B ), & INT ( Z 'A48737A51A997A94' , KIND = I8B ), INT ( Z '467EECD14C5EA8EE' , KIND = I8B ), & INT ( Z 'D3F6FC16EBCA5E03' , KIND = I8B ), INT ( Z '971DA05074DA7BEE' , KIND = I8B ), & INT ( Z '0000000000000000' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '3C7F400000000000' , KIND = I8B ), INT ( Z '9A130B963A6C115C' , KIND = I8B ), & INT ( Z 'E0A9D00000000000' , KIND = I8B ), INT ( Z '6FF006B0F858134F' , KIND = I8B ), & INT ( Z '62EB0D64283F9C76' , KIND = I8B ), INT ( Z '9D174B2DCEC0E47B' , KIND = I8B ), & INT ( Z '3D425AED07E6CE06' , KIND = I8B ), INT ( Z '54702DD23D2A72F9' , KIND = I8B ), & INT ( Z 'F2DB9BAA10B7BD6C' , KIND = I8B ), INT ( Z 'A02AA96B06DEB0FD' , KIND = I8B ), & INT ( Z 'A33B45B3F4DC0E48' , KIND = I8B ), INT ( Z '1D1D31810D054722' , KIND = I8B ), & INT ( Z '27F002D7F95D0190' , KIND = I8B ), INT ( Z 'A34D721642B06084' , KIND = I8B ), & INT ( Z '6E613C34EB02BCDB' , KIND = I8B ), INT ( Z '37FF96F2C26FA7B1' , KIND = I8B ), & INT ( Z '8A892ABAF368F137' , KIND = I8B ), INT ( Z 'A67FF273B8460356' , KIND = I8B ), & INT ( Z '28C4D51D411E2270' , KIND = I8B ), INT ( Z 'FD354C7ECA1400E3' , KIND = I8B ), & INT ( Z 'B2EB3875504DDB22' , KIND = I8B ), INT ( Z 'A9C2794AE3A3C69A' , KIND = I8B ), & INT ( Z '96E71C63FA8E0C8A' , KIND = I8B ), INT ( Z '89148BECA64785D5' , KIND = I8B ), & INT ( Z '7D3950E1849329B6' , KIND = I8B ), INT ( Z 'AD1556EE1BD724F1' , KIND = I8B ), & INT ( Z 'BFE07D41E3BFDE1F' , KIND = I8B ), INT ( Z 'FC0EB21CDCF588B1' , KIND = I8B ), & INT ( Z '0B4AB6F05722C440' , KIND = I8B ), INT ( Z 'B078DD424E0D24D9' , KIND = I8B ), & INT ( Z '8599DEC62AA45CF8' , KIND = I8B ), INT ( Z '8A035DC1859025A2' , KIND = I8B ), & INT ( Z '2F005235946EC71B' , KIND = I8B ), INT ( Z 'B3ED5FC6DF682094' , KIND = I8B ), & INT ( Z 'BF2F5AB5C6B1798A' , KIND = I8B ), INT ( Z 'BA6222B3BC8CA210' , KIND = I8B ), & INT ( Z '81172E3256403718' , KIND = I8B ), INT ( Z 'B773339DB6574E15' , KIND = I8B ), & INT ( Z '2DCB54067B49ABE5' , KIND = I8B ), INT ( Z 'A27D1FB9913E8C63' , KIND = I8B ), & INT ( Z '61BAD659DC1A29D3' , KIND = I8B ), INT ( Z 'BB0AAF936C360ADA' , KIND = I8B ), & INT ( Z 'CF82C283D2AE6243' , KIND = I8B ), INT ( Z 'E0D2875E2C6F8C2B' , KIND = I8B ), & INT ( Z '1A28B472837D513E' , KIND = I8B ), INT ( Z 'BEB42C27A7FCD01F' , KIND = I8B ), & INT ( Z 'EEDB8F15666F0AB2' , KIND = I8B ), INT ( Z 'EC54289350C6DDC0' , KIND = I8B ), & INT ( Z 'D7FB345A83BBDB9F' , KIND = I8B ), INT ( Z 'C2700395A2D1A7C0' , KIND = I8B ), & INT ( Z '1B58F1A7E9575563' , KIND = I8B ), INT ( Z '0A4791958ACF329D' , KIND = I8B ), & INT ( Z 'A869D6ED6B1F7250' , KIND = I8B ), INT ( Z 'C63E91DCD74A01DD' , KIND = I8B ), & INT ( Z '473C3C084839D2C5' , KIND = I8B ), INT ( Z '89B7E501E1B9B7A1' , KIND = I8B ), & INT ( Z '4155C21BA0854403' , KIND = I8B ), INT ( Z 'CA2034C9DC33E731' , KIND = I8B ), & INT ( Z '8506F998BB1EB395' , KIND = I8B ), INT ( Z '2BF7DBDF81EBC672' , KIND = I8B ), & INT ( Z '86747C247C393509' , KIND = I8B ), INT ( Z 'CE154BFF6BC0B4B4' , KIND = I8B ), & INT ( Z '74A8362631F48271' , KIND = I8B ), INT ( Z '4EC8888FE2907901' , KIND = I8B ), & INT ( Z '8CE74D4BBF82DD1E' , KIND = I8B ), INT ( Z 'D21E38FF97EFD28C' , KIND = I8B ), & INT ( Z '29E17220796141E6' , KIND = I8B ), INT ( Z 'C7303E79A90E62EC' , KIND = I8B ), & INT ( Z 'A706E68F2F6D3D6F' , KIND = I8B ), INT ( Z 'D63B5F352D1C3345' , KIND = I8B ), & INT ( Z 'DFC0B324CB257560' , KIND = I8B ), INT ( Z '62CFFDAF0A5A9271' , KIND = I8B ), & INT ( Z '0CA211F8F5C4287E' , KIND = I8B ), INT ( Z 'DA6D23FD4393D91B' , KIND = I8B ), & INT ( Z 'C23187222CEE0355' , KIND = I8B ), INT ( Z 'BD79F8EA904D59AF' , KIND = I8B ), & INT ( Z '6AC121136186B8C7' , KIND = I8B ), INT ( Z 'DEB3EEB101252611' , KIND = I8B ), & INT ( Z '39A7C75E6BAF4D71' , KIND = I8B ), INT ( Z '3BD6C04D190F6CCC' , KIND = I8B ), & INT ( Z '96F041C58BD75F4F' , KIND = I8B ), INT ( Z 'E31028AF8B925961' , KIND = I8B ), & INT ( Z '1A13F35115B27490' , KIND = I8B ), INT ( Z '96F5BBA516A81310' , KIND = I8B ), & INT ( Z '8A03282E68988712' , KIND = I8B ), INT ( Z 'E7823D682CE0518A' , KIND = I8B ), & INT ( Z 'FBA1D8FACB6A5D0E' , KIND = I8B ), INT ( Z 'D0493A8928D434E5' , KIND = I8B ), & INT ( Z '9C29EA61E8321EFB' , KIND = I8B ), INT ( Z 'EC0A9A64AA7A76D2' , KIND = I8B ), & INT ( Z '393C093F92D4EC25' , KIND = I8B ), INT ( Z 'D1AFD23AE4C0BFD3' , KIND = I8B ), & INT ( Z 'FC3B2DEF8A1294AA' , KIND = I8B ), INT ( Z 'F0A9AF53D02A967D' , KIND = I8B ), & INT ( Z '42973FDA4BED6825' , KIND = I8B ), INT ( Z '1BC70FEBA6B21D1E' , KIND = I8B ), & INT ( Z '131A24A373AC0A2D' , KIND = I8B ), INT ( Z 'F55FEE142FE87404' , KIND = I8B ), & INT ( Z '917E0B421F5DC9D4' , KIND = I8B ), INT ( Z 'E78D564BAC9ED016' , KIND = I8B ), & INT ( Z 'DB1E788C843F1A75' , KIND = I8B ), INT ( Z 'FA2DCABF1789EB91' , KIND = I8B ), & INT ( Z '98D69827B2CD2E4B' , KIND = I8B ), INT ( Z 'BE68BAD520283CE7' , KIND = I8B ), & INT ( Z '7B74B18337DAE16E' , KIND = I8B ), INT ( Z 'FF13BBB3BD61B0A9' , KIND = I8B ), & INT ( Z '72CDF11806D10874' , KIND = I8B ), INT ( Z '422D9DD5C498DF39' , KIND = I8B ), & INT ( Z 'BADF34926ADBC6D4' , KIND = I8B ), INT ( Z '82091CD1526FFE97' , KIND = I8B ), & INT ( Z '0B0A917F718555B1' , KIND = I8B ), INT ( Z '20CD5A8AF8F923C8' , KIND = I8B ), & INT ( Z 'D73157C19629C9CF' , KIND = I8B ), INT ( Z '8494DFCC9E26F49A' , KIND = I8B ), & INT ( Z 'E404064CED8D712A' , KIND = I8B ), INT ( Z '385560121DC226CA' , KIND = I8B ), & INT ( Z 'B04529F4C782E2A5' , KIND = I8B ), INT ( Z '872D6586DA60D16C' , KIND = I8B ), & INT ( Z 'B230972E25E77689' , KIND = I8B ), INT ( Z 'ECF3E4AC4EFF0A32' , KIND = I8B ), & INT ( Z '08FB1467A500014A' , KIND = I8B ), INT ( Z '89D2EDF58AB7AC0D' , KIND = I8B ), & INT ( Z '410060FD92FCB3CF' , KIND = I8B ), INT ( Z '004C30B113A8F305' , KIND = I8B ), & INT ( Z '75DF971F5AA72411' , KIND = I8B ), INT ( Z '8C85BA4EC5C02D9B' , KIND = I8B ), & INT ( Z '413353AE3A7B5BDD' , KIND = I8B ), INT ( Z 'A7F3672E7145AF76' , KIND = I8B ), & INT ( Z '215BEACF912AD3C4' , KIND = I8B ), INT ( Z '8F460D0F7BCFEEB5' , KIND = I8B ), & INT ( Z 'A4BF00F4785A889D' , KIND = I8B ), INT ( Z 'F557B93FB3F0A137' , KIND = I8B ), & INT ( Z '0EA153782222DC1D' , KIND = I8B ), INT ( Z '92142A01DD39462C' , KIND = I8B ), & INT ( Z '6D693C62A0526BC1' , KIND = I8B ), INT ( Z '7B5F0832AD97744D' , KIND = I8B ), & INT ( Z '3E905F5CA347E976' , KIND = I8B ), INT ( Z '94F05643E09A3663' , KIND = I8B ), & INT ( Z '64A2130914A11E5F' , KIND = I8B ), INT ( Z '9CC376D8ED0C9850' , KIND = I8B ), & INT ( Z '2BCAFF0DB53F45D1' , KIND = I8B ), INT ( Z '97DAD84DE9DF3CE9' , KIND = I8B ), & INT ( Z '9A4ACD156C4DBCCC' , KIND = I8B ), INT ( Z '7BB46E2D845BB13B' , KIND = I8B ), & INT ( Z '4B6159D95D6B2D7C' , KIND = I8B ), INT ( Z '9AD3F7F9929DEDB1' , KIND = I8B ), & INT ( Z 'D591674EB18C527B' , KIND = I8B ), INT ( Z 'DA23168537779930' , KIND = I8B ), & INT ( Z '2C1B00ACF3524228' , KIND = I8B ), INT ( Z '9DDBFE88946E78DB' , KIND = I8B ), & INT ( Z '6D3B2E1019201985' , KIND = I8B ), INT ( Z '2440AF6D98524E33' , KIND = I8B ), & INT ( Z '81F5EA317433BEF4' , KIND = I8B ), INT ( Z 'A0F336ABD5EE7F99' , KIND = I8B ), & INT ( Z '93A10F44A80F33C8' , KIND = I8B ), INT ( Z '337D80E31DB6AEF3' , KIND = I8B ), & INT ( Z '851BC9AD231A80BE' , KIND = I8B ), INT ( Z 'A419EC8A9B1AF2D5' , KIND = I8B ), & INT ( Z '19AF0317E895460A' , KIND = I8B ), INT ( Z 'AB0913F37BFD99DF' , KIND = I8B ), & INT ( Z 'BE64B501269FB5C4' , KIND = I8B ), INT ( Z 'A7506DC9D9B21CED' , KIND = I8B ), & INT ( Z 'C375DA4FC0194001' , KIND = I8B ), INT ( Z '3B265316E40B3772' , KIND = I8B ), & INT ( Z '76A3718B5911A726' , KIND = I8B ), INT ( Z 'AA970993B2526FBE' , KIND = I8B ), & INT ( Z 'C504151E575A9779' , KIND = I8B ), INT ( Z '8716A6AC9483E77D' , KIND = I8B ), & INT ( Z 'F49CD30202D41350' , KIND = I8B ), INT ( Z 'ADEE109F0F0E3952' , KIND = I8B ), & INT ( Z '3068E95C665AA02B' , KIND = I8B ), INT ( Z '87D5E085A65C15DB' , KIND = I8B ), & INT ( Z 'A72B6697C1695603' , KIND = I8B ), INT ( Z 'B155D537682FFC88' , KIND = I8B ), & INT ( Z '11213ACC4D36CF9A' , KIND = I8B ), INT ( Z '3B903AE48F4FC93B' , KIND = I8B ), & INT ( Z '19D343DF2EC654F8' , KIND = I8B ), INT ( Z 'B4CEAB44AFEED7E9' , KIND = I8B ), & INT ( Z 'DAA1581870D5B72C' , KIND = I8B ), INT ( Z 'CC83B1E48401CF12' , KIND = I8B ), & INT ( Z 'B3511A96BEC03C53' , KIND = I8B ), INT ( Z 'B858E85365D62467' , KIND = I8B ), & INT ( Z '91C8BC100512A9B9' , KIND = I8B ), INT ( Z '87802DD9987F5811' , KIND = I8B ), & INT ( Z '16CE86A4BA01377B' , KIND = I8B ), INT ( Z 'BBF4E39CD2A747E1' , KIND = I8B ), & INT ( Z '3AF95CBF0946009E' , KIND = I8B ), INT ( Z '9EA3266A1AAD74B9' , KIND = I8B ), & INT ( Z 'B783F4FCC19195F0' , KIND = I8B ), INT ( Z 'BFA2F60F6D809C91' , KIND = I8B ), & INT ( Z 'A010925E4C6122FF' , KIND = I8B ), INT ( Z '7AC8EB131770B5DA' , KIND = I8B ), & INT ( Z 'C1B9DE62331F1C84' , KIND = I8B ), INT ( Z 'C3637A576B184797' , KIND = I8B ), & INT ( Z '141471DAE08D526A' , KIND = I8B ), INT ( Z '60DC6A4185C03AE1' , KIND = I8B ), & INT ( Z 'CA7D3CCD0F578270' , KIND = I8B ), INT ( Z 'C736CCE777DDE55B' , KIND = I8B ), & INT ( Z 'BEB13E2E44A792AF' , KIND = I8B ), INT ( Z '8F9D3DE52E498711' , KIND = I8B ), & INT ( Z '8AB05967FF2004E2' , KIND = I8B ), INT ( Z 'CB1D4C019DDA13CF' , KIND = I8B ), & INT ( Z 'E4187B58FD28A94D' , KIND = I8B ), INT ( Z 'CEAFE789CDF47A1B' , KIND = I8B ), & INT ( Z '004B98F7D57FE9A3' , KIND = I8B ), INT ( Z 'CF1757C057271838' , KIND = I8B ), & INT ( Z '5D99BED0BF71C4FE' , KIND = I8B ), INT ( Z 'B74893236B751658' , KIND = I8B ), & INT ( Z '657697F11447157E' , KIND = I8B ), INT ( Z 'D325521FCDE22918' , KIND = I8B ), & INT ( Z '68D72BEC56D281BA' , KIND = I8B ), INT ( Z 'E389A8795D86FEF4' , KIND = I8B ), & INT ( Z '44641E2A07D9BD48' , KIND = I8B ), INT ( Z 'D7479F074A794537' , KIND = I8B ), & INT ( Z '18A8B9AC109F18C1' , KIND = I8B ), INT ( Z '36D950769B40F3FD' , KIND = I8B ), & INT ( Z '5E6B2C1F8B606532' , KIND = I8B ), INT ( Z 'DB7EA452D13DF70A' , KIND = I8B ), & INT ( Z 'A9B5D49B906C498A' , KIND = I8B ), INT ( Z '8ED3101419CB3227' , KIND = I8B ), & INT ( Z '17122D6F7054A794' , KIND = I8B ), INT ( Z 'DFCAC9DCF029F087' , KIND = I8B ), & INT ( Z 'EFB85F52D1C112FE' , KIND = I8B ), INT ( Z '98F8941008B79677' , KIND = I8B ), & INT ( Z 'B2175EE88BE4A8F9' , KIND = I8B ), INT ( Z 'E42C7988BDC70ED3' , KIND = I8B ), & INT ( Z '2E5A66D4570F98B0' , KIND = I8B ), INT ( Z '430B34D10EB0ECF4' , KIND = I8B ), & INT ( Z '413F8C185698DD07' , KIND = I8B ), INT ( Z 'E8A41F4C0A311014' , KIND = I8B ), & INT ( Z 'CC0F55EA864DD7F5' , KIND = I8B ), INT ( Z '456509D69D08D96C' , KIND = I8B ), & INT ( Z '240421CC6ACC3893' , KIND = I8B ), INT ( Z 'ED322939C32C1801' , KIND = I8B ), & INT ( Z '0ABFF31D3CEC5E4F' , KIND = I8B ), INT ( Z '1E0D12F1BBDE0514' , KIND = I8B ), & INT ( Z '48590390281493F6' , KIND = I8B ), INT ( Z 'F1D7078C8C500A93' , KIND = I8B ), & INT ( Z 'A3503F8C8AC1EB3A' , KIND = I8B ), INT ( Z 'A096E22CEC16E455' , KIND = I8B ), & INT ( Z '1473102F0414AD2C' , KIND = I8B ), INT ( Z 'F6932CB18C4DC755' , KIND = I8B ), & INT ( Z '5281D93D02664652' , KIND = I8B ), INT ( Z '85CE35CB6C04C918' , KIND = I8B ), & INT ( Z '88A7B9666E181071' , KIND = I8B ), INT ( Z 'FB670D5370586C49' , KIND = I8B ), & INT ( Z 'D541AC1F3C506316' , KIND = I8B ), INT ( Z '4F14396264F2916E' , KIND = I8B ), & INT ( Z 'D61515C3B3AAA229' , KIND = I8B ), INT ( Z '80299032D360FEAD' , KIND = I8B ), & INT ( Z '7946464C91702D77' , KIND = I8B ), INT ( Z '59012A5F505E728C' , KIND = I8B ), & INT ( Z '8E5FB9B92F0514A8' , KIND = I8B ), INT ( Z '82ABEF97E8F00EB3' , KIND = I8B ), & INT ( Z 'D5021D4C84E67979' , KIND = I8B ), INT ( Z '494EBE658276DB57' , KIND = I8B ), & INT ( Z '449B9FE2AC34E8BD' , KIND = I8B ), INT ( Z '853AE2ACBA297855' , KIND = I8B ), & INT ( Z '79A5E56484591846' , KIND = I8B ), INT ( Z '965C9079F7DC4B25' , KIND = I8B ), & INT ( Z 'B8B22E9DBD871702' , KIND = I8B ), INT ( Z '87D6A87AEBE6E32D' , KIND = I8B ), & INT ( Z 'E90E1D9A61AB958B' , KIND = I8B ), INT ( Z 'AB34E1EF0F78BCC8' , KIND = I8B ), & INT ( Z 'E926B14801CA9B38' , KIND = I8B ), INT ( Z '8A7F814817C36453' , KIND = I8B ), & INT ( Z '6B08E5E200510F62' , KIND = I8B ), INT ( Z '34279133827C7DC8' , KIND = I8B ), & INT ( Z '95238D2B41523B5D' , KIND = I8B ), INT ( Z '8D35AE9BFBBC5820' , KIND = I8B ), & INT ( Z '18D892A5C744F415' , KIND = I8B ), INT ( Z 'A40CAD1FA3FDA9C5' , KIND = I8B ), & INT ( Z 'FAFD9FEFC5B84A78' , KIND = I8B ), INT ( Z '8FF97346C8D3A990' , KIND = I8B ), & INT ( Z '85B5AD3AFA998F3A' , KIND = I8B ), INT ( Z 'B0E097EEB6CEA81E' , KIND = I8B ), & INT ( Z 'D4B88CB6422B9BE0' , KIND = I8B ), INT ( Z '92CB1367914EEF15' , KIND = I8B ), & INT ( Z '7AF50AE289EB0B9E' , KIND = I8B ), INT ( Z '3241430E3B081CB2' , KIND = I8B ), & INT ( Z '232E116F38AC1680' , KIND = I8B ), INT ( Z '95AAD472D731CF89' , KIND = I8B ), & INT ( Z '266A57B55352EA2A' , KIND = I8B ), INT ( Z '7E988AFB1F791E14' , KIND = I8B ), & INT ( Z 'FDD82EF0BEAEB5BC' , KIND = I8B ), INT ( Z '9898FD393B953C30' , KIND = I8B ), & INT ( Z '555464B4F76B344B' , KIND = I8B ), INT ( Z '3666AF1CB2F0356B' , KIND = I8B ), & INT ( Z 'C8DD55687A68BB70' , KIND = I8B ), INT ( Z '9B95D5EE4F80366D' , KIND = I8B ), & INT ( Z 'B19E3D897426AC0E' , KIND = I8B ), INT ( Z '3967066B4C3B300B' , KIND = I8B ), & INT ( Z 'D3F876B1CC8650E1' , KIND = I8B ), INT ( Z '9EA1A82F86EA1144' , KIND = I8B ), & INT ( Z '993C1ECD6C0A7050' , KIND = I8B ), INT ( Z '58EC01B8360275DC' , KIND = I8B ), & INT ( Z 'F0E4E5DDF50D5649' , KIND = I8B ), INT ( Z 'A1BCBF0B4E9168B4' , KIND = I8B ), & INT ( Z 'DC2AF1C2CA957B28' , KIND = I8B ), INT ( Z '7E79FE958F3081F2' , KIND = I8B ), & INT ( Z '0B13A89E71F04607' , KIND = I8B ), INT ( Z 'A4E76708455662FA' , KIND = I8B ), & INT ( Z 'F35E6D39041D980A' , KIND = I8B ), INT ( Z '1C3B4799BB16146C' , KIND = I8B ), & INT ( Z 'CEAA3A0DF738FF67' , KIND = I8B ), INT ( Z 'A821EE2C99CA3AE9' , KIND = I8B ), & INT ( Z 'EA17B9D4D87BC7A6' , KIND = I8B ), INT ( Z 'A6E6122F56F94A45' , KIND = I8B ), & INT ( Z '323264FA08A6A297' , KIND = I8B ), INT ( Z 'AB6CA4058CA98EBA' , KIND = I8B ), & INT ( Z 'C53D1851C3B12E0B' , KIND = I8B ), INT ( Z '009DEACABC65F455' , KIND = I8B ), & INT ( Z '1B276317CDEA9189' , KIND = I8B ), INT ( Z 'AEC7D9AF18FA7C21' , KIND = I8B ), & INT ( Z '02C9923A00FBF051' , KIND = I8B ), INT ( Z 'B64EB80E63EC3A6C' , KIND = I8B ), & INT ( Z 'E640102E40AF6BFC' , KIND = I8B ), INT ( Z 'B233E1DBC28B3229' , KIND = I8B ), & INT ( Z '323B2FE8DB975585' , KIND = I8B ), INT ( Z '547A6847BF6D2E85' , KIND = I8B ), & INT ( Z '9C5AC5E3502E3B09' , KIND = I8B ), INT ( Z 'B5B110DC8B9152B3' , KIND = I8B ), & INT ( Z 'A045490080841594' , KIND = I8B ), INT ( Z 'D5DC095935E521CF' , KIND = I8B ), & INT ( Z '0F0E9F521B9270FB' , KIND = I8B ), INT ( Z 'B93FBCA9122E41A4' , KIND = I8B ), & INT ( Z '8F55910806D59BAF' , KIND = I8B ), INT ( Z '6E5242257641D880' , KIND = I8B ), & INT ( Z 'C71261CB384C6321' , KIND = I8B ), INT ( Z 'BCE03CE7D6A056D5' , KIND = I8B ), & INT ( Z '763A723DF9686922' , KIND = I8B ), INT ( Z 'CC3C376FF5DEB4B3' , KIND = I8B ), & INT ( Z '36EE15C1030A006C' , KIND = I8B ), INT ( Z 'C092EAF6AAECD1FF' , KIND = I8B ), & INT ( Z '12CAD6DE3D40F431' , KIND = I8B ), INT ( Z 'B64F1457442E6578' , KIND = I8B ), & INT ( Z '7C07A28F8AD104CF' , KIND = I8B ), INT ( Z 'C45821F34CD26DA9' , KIND = I8B ), & INT ( Z 'C45BD180F52795FD' , KIND = I8B ), INT ( Z '4E1C7E58586D7EEB' , KIND = I8B ), & INT ( Z '78C6A18DA2580215' , KIND = I8B ), INT ( Z 'C8303EC42AD88026' , KIND = I8B ), & INT ( Z '077D5A3C610B9F25' , KIND = I8B ), INT ( Z '987D13FEC0991258' , KIND = I8B ), & INT ( Z '82F57D31A71C1D89' , KIND = I8B ), INT ( Z 'CC1BA0215552BFB5' , KIND = I8B ), & INT ( Z '28EB73FA309BAEFB' , KIND = I8B ), INT ( Z 'C619DB404F575681' , KIND = I8B ), & INT ( Z '7EF53A6634A89048' , KIND = I8B ), INT ( Z 'D01AA69D9C35FA11' , KIND = I8B ), & INT ( Z '218EFB2874B19ADF' , KIND = I8B ), INT ( Z 'C02D55F188327C0D' , KIND = I8B ), & INT ( Z '48868DA790C354D1' , KIND = I8B ), INT ( Z 'D42DB4AFDA9E5FE3' , KIND = I8B ), & INT ( Z 'F40AEB9752B3AA0B' , KIND = I8B ), INT ( Z 'B290C89B8CA89F01' , KIND = I8B ), & INT ( Z '050846AE4FECC8BB' , KIND = I8B ), INT ( Z 'D8552EBC70EC6A72' , KIND = I8B )], [ 4 , 180 ]) ! ------------------------------------------------------------------------- ! -----   tables of digit characters                                  ----- ! ------------------------------------------------------------------------- !# table of digit characters with 1-digit entries CHARACTER ( LEN = 1 ), PARAMETER :: Char1Digit ( 0 : 9 ) = [ & '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] !# table of digit characters with 2-digit entries CHARACTER ( LEN = 2 ), PARAMETER :: Char2Digits ( 0 : 99 ) = [ & '00' , '01' , '02' , '03' , '04' , '05' , '06' , '07' , '08' , '09' , & '10' , '11' , '12' , '13' , '14' , '15' , '16' , '17' , '18' , '19' , & '20' , '21' , '22' , '23' , '24' , '25' , '26' , '27' , '28' , '29' , & '30' , '31' , '32' , '33' , '34' , '35' , '36' , '37' , '38' , '39' , & '40' , '41' , '42' , '43' , '44' , '45' , '46' , '47' , '48' , '49' , & '50' , '51' , '52' , '53' , '54' , '55' , '56' , '57' , '58' , '59' , & '60' , '61' , '62' , '63' , '64' , '65' , '66' , '67' , '68' , '69' , & '70' , '71' , '72' , '73' , '74' , '75' , '76' , '77' , '78' , '79' , & '80' , '81' , '82' , '83' , '84' , '85' , '86' , '87' , '88' , '89' , & '90' , '91' , '92' , '93' , '94' , '95' , '96' , '97' , '98' , '99' ] !# table of digit characters with 4-digit entries CHARACTER ( LEN = 4 ), PARAMETER :: Char4Digits ( 0 : 9999 ) = [ & '0000' , '0001' , '0002' , '0003' , '0004' , '0005' , '0006' , '0007' , '0008' , '0009' , & '0010' , '0011' , '0012' , '0013' , '0014' , '0015' , '0016' , '0017' , '0018' , '0019' , & '0020' , '0021' , '0022' , '0023' , '0024' , '0025' , '0026' , '0027' , '0028' , '0029' , & '0030' , '0031' , '0032' , '0033' , '0034' , '0035' , '0036' , '0037' , '0038' , '0039' , & '0040' , '0041' , '0042' , '0043' , '0044' , '0045' , '0046' , '0047' , '0048' , '0049' , & '0050' , '0051' , '0052' , '0053' , '0054' , '0055' , '0056' , '0057' , '0058' , '0059' , & '0060' , '0061' , '0062' , '0063' , '0064' , '0065' , '0066' , '0067' , '0068' , '0069' , & '0070' , '0071' , '0072' , '0073' , '0074' , '0075' , '0076' , '0077' , '0078' , '0079' , & '0080' , '0081' , '0082' , '0083' , '0084' , '0085' , '0086' , '0087' , '0088' , '0089' , & '0090' , '0091' , '0092' , '0093' , '0094' , '0095' , '0096' , '0097' , '0098' , '0099' , & '0100' , '0101' , '0102' , '0103' , '0104' , '0105' , '0106' , '0107' , '0108' , '0109' , & '0110' , '0111' , '0112' , '0113' , '0114' , '0115' , '0116' , '0117' , '0118' , '0119' , & '0120' , '0121' , '0122' , '0123' , '0124' , '0125' , '0126' , '0127' , '0128' , '0129' , & '0130' , '0131' , '0132' , '0133' , '0134' , '0135' , '0136' , '0137' , '0138' , '0139' , & '0140' , '0141' , '0142' , '0143' , '0144' , '0145' , '0146' , '0147' , '0148' , '0149' , & '0150' , '0151' , '0152' , '0153' , '0154' , '0155' , '0156' , '0157' , '0158' , '0159' , & '0160' , '0161' , '0162' , '0163' , '0164' , '0165' , '0166' , '0167' , '0168' , '0169' , & '0170' , '0171' , '0172' , '0173' , '0174' , '0175' , '0176' , '0177' , '0178' , '0179' , & '0180' , '0181' , '0182' , '0183' , '0184' , '0185' , '0186' , '0187' , '0188' , '0189' , & '0190' , '0191' , '0192' , '0193' , '0194' , '0195' , '0196' , '0197' , '0198' , '0199' , & '0200' , '0201' , '0202' , '0203' , '0204' , '0205' , '0206' , '0207' , '0208' , '0209' , & '0210' , '0211' , '0212' , '0213' , '0214' , '0215' , '0216' , '0217' , '0218' , '0219' , & '0220' , '0221' , '0222' , '0223' , '0224' , '0225' , '0226' , '0227' , '0228' , '0229' , & '0230' , '0231' , '0232' , '0233' , '0234' , '0235' , '0236' , '0237' , '0238' , '0239' , & '0240' , '0241' , '0242' , '0243' , '0244' , '0245' , '0246' , '0247' , '0248' , '0249' , & '0250' , '0251' , '0252' , '0253' , '0254' , '0255' , '0256' , '0257' , '0258' , '0259' , & '0260' , '0261' , '0262' , '0263' , '0264' , '0265' , '0266' , '0267' , '0268' , '0269' , & '0270' , '0271' , '0272' , '0273' , '0274' , '0275' , '0276' , '0277' , '0278' , '0279' , & '0280' , '0281' , '0282' , '0283' , '0284' , '0285' , '0286' , '0287' , '0288' , '0289' , & '0290' , '0291' , '0292' , '0293' , '0294' , '0295' , '0296' , '0297' , '0298' , '0299' , & '0300' , '0301' , '0302' , '0303' , '0304' , '0305' , '0306' , '0307' , '0308' , '0309' , & '0310' , '0311' , '0312' , '0313' , '0314' , '0315' , '0316' , '0317' , '0318' , '0319' , & '0320' , '0321' , '0322' , '0323' , '0324' , '0325' , '0326' , '0327' , '0328' , '0329' , & '0330' , '0331' , '0332' , '0333' , '0334' , '0335' , '0336' , '0337' , '0338' , '0339' , & '0340' , '0341' , '0342' , '0343' , '0344' , '0345' , '0346' , '0347' , '0348' , '0349' , & '0350' , '0351' , '0352' , '0353' , '0354' , '0355' , '0356' , '0357' , '0358' , '0359' , & '0360' , '0361' , '0362' , '0363' , '0364' , '0365' , '0366' , '0367' , '0368' , '0369' , & '0370' , '0371' , '0372' , '0373' , '0374' , '0375' , '0376' , '0377' , '0378' , '0379' , & '0380' , '0381' , '0382' , '0383' , '0384' , '0385' , '0386' , '0387' , '0388' , '0389' , & '0390' , '0391' , '0392' , '0393' , '0394' , '0395' , '0396' , '0397' , '0398' , '0399' , & '0400' , '0401' , '0402' , '0403' , '0404' , '0405' , '0406' , '0407' , '0408' , '0409' , & '0410' , '0411' , '0412' , '0413' , '0414' , '0415' , '0416' , '0417' , '0418' , '0419' , & '0420' , '0421' , '0422' , '0423' , '0424' , '0425' , '0426' , '0427' , '0428' , '0429' , & '0430' , '0431' , '0432' , '0433' , '0434' , '0435' , '0436' , '0437' , '0438' , '0439' , & '0440' , '0441' , '0442' , '0443' , '0444' , '0445' , '0446' , '0447' , '0448' , '0449' , & '0450' , '0451' , '0452' , '0453' , '0454' , '0455' , '0456' , '0457' , '0458' , '0459' , & '0460' , '0461' , '0462' , '0463' , '0464' , '0465' , '0466' , '0467' , '0468' , '0469' , & '0470' , '0471' , '0472' , '0473' , '0474' , '0475' , '0476' , '0477' , '0478' , '0479' , & '0480' , '0481' , '0482' , '0483' , '0484' , '0485' , '0486' , '0487' , '0488' , '0489' , & '0490' , '0491' , '0492' , '0493' , '0494' , '0495' , '0496' , '0497' , '0498' , '0499' , & '0500' , '0501' , '0502' , '0503' , '0504' , '0505' , '0506' , '0507' , '0508' , '0509' , & '0510' , '0511' , '0512' , '0513' , '0514' , '0515' , '0516' , '0517' , '0518' , '0519' , & '0520' , '0521' , '0522' , '0523' , '0524' , '0525' , '0526' , '0527' , '0528' , '0529' , & '0530' , '0531' , '0532' , '0533' , '0534' , '0535' , '0536' , '0537' , '0538' , '0539' , & '0540' , '0541' , '0542' , '0543' , '0544' , '0545' , '0546' , '0547' , '0548' , '0549' , & '0550' , '0551' , '0552' , '0553' , '0554' , '0555' , '0556' , '0557' , '0558' , '0559' , & '0560' , '0561' , '0562' , '0563' , '0564' , '0565' , '0566' , '0567' , '0568' , '0569' , & '0570' , '0571' , '0572' , '0573' , '0574' , '0575' , '0576' , '0577' , '0578' , '0579' , & '0580' , '0581' , '0582' , '0583' , '0584' , '0585' , '0586' , '0587' , '0588' , '0589' , & '0590' , '0591' , '0592' , '0593' , '0594' , '0595' , '0596' , '0597' , '0598' , '0599' , & '0600' , '0601' , '0602' , '0603' , '0604' , '0605' , '0606' , '0607' , '0608' , '0609' , & '0610' , '0611' , '0612' , '0613' , '0614' , '0615' , '0616' , '0617' , '0618' , '0619' , & '0620' , '0621' , '0622' , '0623' , '0624' , '0625' , '0626' , '0627' , '0628' , '0629' , & '0630' , '0631' , '0632' , '0633' , '0634' , '0635' , '0636' , '0637' , '0638' , '0639' , & '0640' , '0641' , '0642' , '0643' , '0644' , '0645' , '0646' , '0647' , '0648' , '0649' , & '0650' , '0651' , '0652' , '0653' , '0654' , '0655' , '0656' , '0657' , '0658' , '0659' , & '0660' , '0661' , '0662' , '0663' , '0664' , '0665' , '0666' , '0667' , '0668' , '0669' , & '0670' , '0671' , '0672' , '0673' , '0674' , '0675' , '0676' , '0677' , '0678' , '0679' , & '0680' , '0681' , '0682' , '0683' , '0684' , '0685' , '0686' , '0687' , '0688' , '0689' , & '0690' , '0691' , '0692' , '0693' , '0694' , '0695' , '0696' , '0697' , '0698' , '0699' , & '0700' , '0701' , '0702' , '0703' , '0704' , '0705' , '0706' , '0707' , '0708' , '0709' , & '0710' , '0711' , '0712' , '0713' , '0714' , '0715' , '0716' , '0717' , '0718' , '0719' , & '0720' , '0721' , '0722' , '0723' , '0724' , '0725' , '0726' , '0727' , '0728' , '0729' , & '0730' , '0731' , '0732' , '0733' , '0734' , '0735' , '0736' , '0737' , '0738' , '0739' , & '0740' , '0741' , '0742' , '0743' , '0744' , '0745' , '0746' , '0747' , '0748' , '0749' , & '0750' , '0751' , '0752' , '0753' , '0754' , '0755' , '0756' , '0757' , '0758' , '0759' , & '0760' , '0761' , '0762' , '0763' , '0764' , '0765' , '0766' , '0767' , '0768' , '0769' , & '0770' , '0771' , '0772' , '0773' , '0774' , '0775' , '0776' , '0777' , '0778' , '0779' , & '0780' , '0781' , '0782' , '0783' , '0784' , '0785' , '0786' , '0787' , '0788' , '0789' , & '0790' , '0791' , '0792' , '0793' , '0794' , '0795' , '0796' , '0797' , '0798' , '0799' , & '0800' , '0801' , '0802' , '0803' , '0804' , '0805' , '0806' , '0807' , '0808' , '0809' , & '0810' , '0811' , '0812' , '0813' , '0814' , '0815' , '0816' , '0817' , '0818' , '0819' , & '0820' , '0821' , '0822' , '0823' , '0824' , '0825' , '0826' , '0827' , '0828' , '0829' , & '0830' , '0831' , '0832' , '0833' , '0834' , '0835' , '0836' , '0837' , '0838' , '0839' , & '0840' , '0841' , '0842' , '0843' , '0844' , '0845' , '0846' , '0847' , '0848' , '0849' , & '0850' , '0851' , '0852' , '0853' , '0854' , '0855' , '0856' , '0857' , '0858' , '0859' , & '0860' , '0861' , '0862' , '0863' , '0864' , '0865' , '0866' , '0867' , '0868' , '0869' , & '0870' , '0871' , '0872' , '0873' , '0874' , '0875' , '0876' , '0877' , '0878' , '0879' , & '0880' , '0881' , '0882' , '0883' , '0884' , '0885' , '0886' , '0887' , '0888' , '0889' , & '0890' , '0891' , '0892' , '0893' , '0894' , '0895' , '0896' , '0897' , '0898' , '0899' , & '0900' , '0901' , '0902' , '0903' , '0904' , '0905' , '0906' , '0907' , '0908' , '0909' , & '0910' , '0911' , '0912' , '0913' , '0914' , '0915' , '0916' , '0917' , '0918' , '0919' , & '0920' , '0921' , '0922' , '0923' , '0924' , '0925' , '0926' , '0927' , '0928' , '0929' , & '0930' , '0931' , '0932' , '0933' , '0934' , '0935' , '0936' , '0937' , '0938' , '0939' , & '0940' , '0941' , '0942' , '0943' , '0944' , '0945' , '0946' , '0947' , '0948' , '0949' , & '0950' , '0951' , '0952' , '0953' , '0954' , '0955' , '0956' , '0957' , '0958' , '0959' , & '0960' , '0961' , '0962' , '0963' , '0964' , '0965' , '0966' , '0967' , '0968' , '0969' , & '0970' , '0971' , '0972' , '0973' , '0974' , '0975' , '0976' , '0977' , '0978' , '0979' , & '0980' , '0981' , '0982' , '0983' , '0984' , '0985' , '0986' , '0987' , '0988' , '0989' , & '0990' , '0991' , '0992' , '0993' , '0994' , '0995' , '0996' , '0997' , '0998' , '0999' , & '1000' , '1001' , '1002' , '1003' , '1004' , '1005' , '1006' , '1007' , '1008' , '1009' , & '1010' , '1011' , '1012' , '1013' , '1014' , '1015' , '1016' , '1017' , '1018' , '1019' , & '1020' , '1021' , '1022' , '1023' , '1024' , '1025' , '1026' , '1027' , '1028' , '1029' , & '1030' , '1031' , '1032' , '1033' , '1034' , '1035' , '1036' , '1037' , '1038' , '1039' , & '1040' , '1041' , '1042' , '1043' , '1044' , '1045' , '1046' , '1047' , '1048' , '1049' , & '1050' , '1051' , '1052' , '1053' , '1054' , '1055' , '1056' , '1057' , '1058' , '1059' , & '1060' , '1061' , '1062' , '1063' , '1064' , '1065' , '1066' , '1067' , '1068' , '1069' , & '1070' , '1071' , '1072' , '1073' , '1074' , '1075' , '1076' , '1077' , '1078' , '1079' , & '1080' , '1081' , '1082' , '1083' , '1084' , '1085' , '1086' , '1087' , '1088' , '1089' , & '1090' , '1091' , '1092' , '1093' , '1094' , '1095' , '1096' , '1097' , '1098' , '1099' , & '1100' , '1101' , '1102' , '1103' , '1104' , '1105' , '1106' , '1107' , '1108' , '1109' , & '1110' , '1111' , '1112' , '1113' , '1114' , '1115' , '1116' , '1117' , '1118' , '1119' , & '1120' , '1121' , '1122' , '1123' , '1124' , '1125' , '1126' , '1127' , '1128' , '1129' , & '1130' , '1131' , '1132' , '1133' , '1134' , '1135' , '1136' , '1137' , '1138' , '1139' , & '1140' , '1141' , '1142' , '1143' , '1144' , '1145' , '1146' , '1147' , '1148' , '1149' , & '1150' , '1151' , '1152' , '1153' , '1154' , '1155' , '1156' , '1157' , '1158' , '1159' , & '1160' , '1161' , '1162' , '1163' , '1164' , '1165' , '1166' , '1167' , '1168' , '1169' , & '1170' , '1171' , '1172' , '1173' , '1174' , '1175' , '1176' , '1177' , '1178' , '1179' , & '1180' , '1181' , '1182' , '1183' , '1184' , '1185' , '1186' , '1187' , '1188' , '1189' , & '1190' , '1191' , '1192' , '1193' , '1194' , '1195' , '1196' , '1197' , '1198' , '1199' , & '1200' , '1201' , '1202' , '1203' , '1204' , '1205' , '1206' , '1207' , '1208' , '1209' , & '1210' , '1211' , '1212' , '1213' , '1214' , '1215' , '1216' , '1217' , '1218' , '1219' , & '1220' , '1221' , '1222' , '1223' , '1224' , '1225' , '1226' , '1227' , '1228' , '1229' , & '1230' , '1231' , '1232' , '1233' , '1234' , '1235' , '1236' , '1237' , '1238' , '1239' , & '1240' , '1241' , '1242' , '1243' , '1244' , '1245' , '1246' , '1247' , '1248' , '1249' , & '1250' , '1251' , '1252' , '1253' , '1254' , '1255' , '1256' , '1257' , '1258' , '1259' , & '1260' , '1261' , '1262' , '1263' , '1264' , '1265' , '1266' , '1267' , '1268' , '1269' , & '1270' , '1271' , '1272' , '1273' , '1274' , '1275' , '1276' , '1277' , '1278' , '1279' , & '1280' , '1281' , '1282' , '1283' , '1284' , '1285' , '1286' , '1287' , '1288' , '1289' , & '1290' , '1291' , '1292' , '1293' , '1294' , '1295' , '1296' , '1297' , '1298' , '1299' , & '1300' , '1301' , '1302' , '1303' , '1304' , '1305' , '1306' , '1307' , '1308' , '1309' , & '1310' , '1311' , '1312' , '1313' , '1314' , '1315' , '1316' , '1317' , '1318' , '1319' , & '1320' , '1321' , '1322' , '1323' , '1324' , '1325' , '1326' , '1327' , '1328' , '1329' , & '1330' , '1331' , '1332' , '1333' , '1334' , '1335' , '1336' , '1337' , '1338' , '1339' , & '1340' , '1341' , '1342' , '1343' , '1344' , '1345' , '1346' , '1347' , '1348' , '1349' , & '1350' , '1351' , '1352' , '1353' , '1354' , '1355' , '1356' , '1357' , '1358' , '1359' , & '1360' , '1361' , '1362' , '1363' , '1364' , '1365' , '1366' , '1367' , '1368' , '1369' , & '1370' , '1371' , '1372' , '1373' , '1374' , '1375' , '1376' , '1377' , '1378' , '1379' , & '1380' , '1381' , '1382' , '1383' , '1384' , '1385' , '1386' , '1387' , '1388' , '1389' , & '1390' , '1391' , '1392' , '1393' , '1394' , '1395' , '1396' , '1397' , '1398' , '1399' , & '1400' , '1401' , '1402' , '1403' , '1404' , '1405' , '1406' , '1407' , '1408' , '1409' , & '1410' , '1411' , '1412' , '1413' , '1414' , '1415' , '1416' , '1417' , '1418' , '1419' , & '1420' , '1421' , '1422' , '1423' , '1424' , '1425' , '1426' , '1427' , '1428' , '1429' , & '1430' , '1431' , '1432' , '1433' , '1434' , '1435' , '1436' , '1437' , '1438' , '1439' , & '1440' , '1441' , '1442' , '1443' , '1444' , '1445' , '1446' , '1447' , '1448' , '1449' , & '1450' , '1451' , '1452' , '1453' , '1454' , '1455' , '1456' , '1457' , '1458' , '1459' , & '1460' , '1461' , '1462' , '1463' , '1464' , '1465' , '1466' , '1467' , '1468' , '1469' , & '1470' , '1471' , '1472' , '1473' , '1474' , '1475' , '1476' , '1477' , '1478' , '1479' , & '1480' , '1481' , '1482' , '1483' , '1484' , '1485' , '1486' , '1487' , '1488' , '1489' , & '1490' , '1491' , '1492' , '1493' , '1494' , '1495' , '1496' , '1497' , '1498' , '1499' , & '1500' , '1501' , '1502' , '1503' , '1504' , '1505' , '1506' , '1507' , '1508' , '1509' , & '1510' , '1511' , '1512' , '1513' , '1514' , '1515' , '1516' , '1517' , '1518' , '1519' , & '1520' , '1521' , '1522' , '1523' , '1524' , '1525' , '1526' , '1527' , '1528' , '1529' , & '1530' , '1531' , '1532' , '1533' , '1534' , '1535' , '1536' , '1537' , '1538' , '1539' , & '1540' , '1541' , '1542' , '1543' , '1544' , '1545' , '1546' , '1547' , '1548' , '1549' , & '1550' , '1551' , '1552' , '1553' , '1554' , '1555' , '1556' , '1557' , '1558' , '1559' , & '1560' , '1561' , '1562' , '1563' , '1564' , '1565' , '1566' , '1567' , '1568' , '1569' , & '1570' , '1571' , '1572' , '1573' , '1574' , '1575' , '1576' , '1577' , '1578' , '1579' , & '1580' , '1581' , '1582' , '1583' , '1584' , '1585' , '1586' , '1587' , '1588' , '1589' , & '1590' , '1591' , '1592' , '1593' , '1594' , '1595' , '1596' , '1597' , '1598' , '1599' , & '1600' , '1601' , '1602' , '1603' , '1604' , '1605' , '1606' , '1607' , '1608' , '1609' , & '1610' , '1611' , '1612' , '1613' , '1614' , '1615' , '1616' , '1617' , '1618' , '1619' , & '1620' , '1621' , '1622' , '1623' , '1624' , '1625' , '1626' , '1627' , '1628' , '1629' , & '1630' , '1631' , '1632' , '1633' , '1634' , '1635' , '1636' , '1637' , '1638' , '1639' , & '1640' , '1641' , '1642' , '1643' , '1644' , '1645' , '1646' , '1647' , '1648' , '1649' , & '1650' , '1651' , '1652' , '1653' , '1654' , '1655' , '1656' , '1657' , '1658' , '1659' , & '1660' , '1661' , '1662' , '1663' , '1664' , '1665' , '1666' , '1667' , '1668' , '1669' , & '1670' , '1671' , '1672' , '1673' , '1674' , '1675' , '1676' , '1677' , '1678' , '1679' , & '1680' , '1681' , '1682' , '1683' , '1684' , '1685' , '1686' , '1687' , '1688' , '1689' , & '1690' , '1691' , '1692' , '1693' , '1694' , '1695' , '1696' , '1697' , '1698' , '1699' , & '1700' , '1701' , '1702' , '1703' , '1704' , '1705' , '1706' , '1707' , '1708' , '1709' , & '1710' , '1711' , '1712' , '1713' , '1714' , '1715' , '1716' , '1717' , '1718' , '1719' , & '1720' , '1721' , '1722' , '1723' , '1724' , '1725' , '1726' , '1727' , '1728' , '1729' , & '1730' , '1731' , '1732' , '1733' , '1734' , '1735' , '1736' , '1737' , '1738' , '1739' , & '1740' , '1741' , '1742' , '1743' , '1744' , '1745' , '1746' , '1747' , '1748' , '1749' , & '1750' , '1751' , '1752' , '1753' , '1754' , '1755' , '1756' , '1757' , '1758' , '1759' , & '1760' , '1761' , '1762' , '1763' , '1764' , '1765' , '1766' , '1767' , '1768' , '1769' , & '1770' , '1771' , '1772' , '1773' , '1774' , '1775' , '1776' , '1777' , '1778' , '1779' , & '1780' , '1781' , '1782' , '1783' , '1784' , '1785' , '1786' , '1787' , '1788' , '1789' , & '1790' , '1791' , '1792' , '1793' , '1794' , '1795' , '1796' , '1797' , '1798' , '1799' , & '1800' , '1801' , '1802' , '1803' , '1804' , '1805' , '1806' , '1807' , '1808' , '1809' , & '1810' , '1811' , '1812' , '1813' , '1814' , '1815' , '1816' , '1817' , '1818' , '1819' , & '1820' , '1821' , '1822' , '1823' , '1824' , '1825' , '1826' , '1827' , '1828' , '1829' , & '1830' , '1831' , '1832' , '1833' , '1834' , '1835' , '1836' , '1837' , '1838' , '1839' , & '1840' , '1841' , '1842' , '1843' , '1844' , '1845' , '1846' , '1847' , '1848' , '1849' , & '1850' , '1851' , '1852' , '1853' , '1854' , '1855' , '1856' , '1857' , '1858' , '1859' , & '1860' , '1861' , '1862' , '1863' , '1864' , '1865' , '1866' , '1867' , '1868' , '1869' , & '1870' , '1871' , '1872' , '1873' , '1874' , '1875' , '1876' , '1877' , '1878' , '1879' , & '1880' , '1881' , '1882' , '1883' , '1884' , '1885' , '1886' , '1887' , '1888' , '1889' , & '1890' , '1891' , '1892' , '1893' , '1894' , '1895' , '1896' , '1897' , '1898' , '1899' , & '1900' , '1901' , '1902' , '1903' , '1904' , '1905' , '1906' , '1907' , '1908' , '1909' , & '1910' , '1911' , '1912' , '1913' , '1914' , '1915' , '1916' , '1917' , '1918' , '1919' , & '1920' , '1921' , '1922' , '1923' , '1924' , '1925' , '1926' , '1927' , '1928' , '1929' , & '1930' , '1931' , '1932' , '1933' , '1934' , '1935' , '1936' , '1937' , '1938' , '1939' , & '1940' , '1941' , '1942' , '1943' , '1944' , '1945' , '1946' , '1947' , '1948' , '1949' , & '1950' , '1951' , '1952' , '1953' , '1954' , '1955' , '1956' , '1957' , '1958' , '1959' , & '1960' , '1961' , '1962' , '1963' , '1964' , '1965' , '1966' , '1967' , '1968' , '1969' , & '1970' , '1971' , '1972' , '1973' , '1974' , '1975' , '1976' , '1977' , '1978' , '1979' , & '1980' , '1981' , '1982' , '1983' , '1984' , '1985' , '1986' , '1987' , '1988' , '1989' , & '1990' , '1991' , '1992' , '1993' , '1994' , '1995' , '1996' , '1997' , '1998' , '1999' , & '2000' , '2001' , '2002' , '2003' , '2004' , '2005' , '2006' , '2007' , '2008' , '2009' , & '2010' , '2011' , '2012' , '2013' , '2014' , '2015' , '2016' , '2017' , '2018' , '2019' , & '2020' , '2021' , '2022' , '2023' , '2024' , '2025' , '2026' , '2027' , '2028' , '2029' , & '2030' , '2031' , '2032' , '2033' , '2034' , '2035' , '2036' , '2037' , '2038' , '2039' , & '2040' , '2041' , '2042' , '2043' , '2044' , '2045' , '2046' , '2047' , '2048' , '2049' , & '2050' , '2051' , '2052' , '2053' , '2054' , '2055' , '2056' , '2057' , '2058' , '2059' , & '2060' , '2061' , '2062' , '2063' , '2064' , '2065' , '2066' , '2067' , '2068' , '2069' , & '2070' , '2071' , '2072' , '2073' , '2074' , '2075' , '2076' , '2077' , '2078' , '2079' , & '2080' , '2081' , '2082' , '2083' , '2084' , '2085' , '2086' , '2087' , '2088' , '2089' , & '2090' , '2091' , '2092' , '2093' , '2094' , '2095' , '2096' , '2097' , '2098' , '2099' , & '2100' , '2101' , '2102' , '2103' , '2104' , '2105' , '2106' , '2107' , '2108' , '2109' , & '2110' , '2111' , '2112' , '2113' , '2114' , '2115' , '2116' , '2117' , '2118' , '2119' , & '2120' , '2121' , '2122' , '2123' , '2124' , '2125' , '2126' , '2127' , '2128' , '2129' , & '2130' , '2131' , '2132' , '2133' , '2134' , '2135' , '2136' , '2137' , '2138' , '2139' , & '2140' , '2141' , '2142' , '2143' , '2144' , '2145' , '2146' , '2147' , '2148' , '2149' , & '2150' , '2151' , '2152' , '2153' , '2154' , '2155' , '2156' , '2157' , '2158' , '2159' , & '2160' , '2161' , '2162' , '2163' , '2164' , '2165' , '2166' , '2167' , '2168' , '2169' , & '2170' , '2171' , '2172' , '2173' , '2174' , '2175' , '2176' , '2177' , '2178' , '2179' , & '2180' , '2181' , '2182' , '2183' , '2184' , '2185' , '2186' , '2187' , '2188' , '2189' , & '2190' , '2191' , '2192' , '2193' , '2194' , '2195' , '2196' , '2197' , '2198' , '2199' , & '2200' , '2201' , '2202' , '2203' , '2204' , '2205' , '2206' , '2207' , '2208' , '2209' , & '2210' , '2211' , '2212' , '2213' , '2214' , '2215' , '2216' , '2217' , '2218' , '2219' , & '2220' , '2221' , '2222' , '2223' , '2224' , '2225' , '2226' , '2227' , '2228' , '2229' , & '2230' , '2231' , '2232' , '2233' , '2234' , '2235' , '2236' , '2237' , '2238' , '2239' , & '2240' , '2241' , '2242' , '2243' , '2244' , '2245' , '2246' , '2247' , '2248' , '2249' , & '2250' , '2251' , '2252' , '2253' , '2254' , '2255' , '2256' , '2257' , '2258' , '2259' , & '2260' , '2261' , '2262' , '2263' , '2264' , '2265' , '2266' , '2267' , '2268' , '2269' , & '2270' , '2271' , '2272' , '2273' , '2274' , '2275' , '2276' , '2277' , '2278' , '2279' , & '2280' , '2281' , '2282' , '2283' , '2284' , '2285' , '2286' , '2287' , '2288' , '2289' , & '2290' , '2291' , '2292' , '2293' , '2294' , '2295' , '2296' , '2297' , '2298' , '2299' , & '2300' , '2301' , '2302' , '2303' , '2304' , '2305' , '2306' , '2307' , '2308' , '2309' , & '2310' , '2311' , '2312' , '2313' , '2314' , '2315' , '2316' , '2317' , '2318' , '2319' , & '2320' , '2321' , '2322' , '2323' , '2324' , '2325' , '2326' , '2327' , '2328' , '2329' , & '2330' , '2331' , '2332' , '2333' , '2334' , '2335' , '2336' , '2337' , '2338' , '2339' , & '2340' , '2341' , '2342' , '2343' , '2344' , '2345' , '2346' , '2347' , '2348' , '2349' , & '2350' , '2351' , '2352' , '2353' , '2354' , '2355' , '2356' , '2357' , '2358' , '2359' , & '2360' , '2361' , '2362' , '2363' , '2364' , '2365' , '2366' , '2367' , '2368' , '2369' , & '2370' , '2371' , '2372' , '2373' , '2374' , '2375' , '2376' , '2377' , '2378' , '2379' , & '2380' , '2381' , '2382' , '2383' , '2384' , '2385' , '2386' , '2387' , '2388' , '2389' , & '2390' , '2391' , '2392' , '2393' , '2394' , '2395' , '2396' , '2397' , '2398' , '2399' , & '2400' , '2401' , '2402' , '2403' , '2404' , '2405' , '2406' , '2407' , '2408' , '2409' , & '2410' , '2411' , '2412' , '2413' , '2414' , '2415' , '2416' , '2417' , '2418' , '2419' , & '2420' , '2421' , '2422' , '2423' , '2424' , '2425' , '2426' , '2427' , '2428' , '2429' , & '2430' , '2431' , '2432' , '2433' , '2434' , '2435' , '2436' , '2437' , '2438' , '2439' , & '2440' , '2441' , '2442' , '2443' , '2444' , '2445' , '2446' , '2447' , '2448' , '2449' , & '2450' , '2451' , '2452' , '2453' , '2454' , '2455' , '2456' , '2457' , '2458' , '2459' , & '2460' , '2461' , '2462' , '2463' , '2464' , '2465' , '2466' , '2467' , '2468' , '2469' , & '2470' , '2471' , '2472' , '2473' , '2474' , '2475' , '2476' , '2477' , '2478' , '2479' , & '2480' , '2481' , '2482' , '2483' , '2484' , '2485' , '2486' , '2487' , '2488' , '2489' , & '2490' , '2491' , '2492' , '2493' , '2494' , '2495' , '2496' , '2497' , '2498' , '2499' , & '2500' , '2501' , '2502' , '2503' , '2504' , '2505' , '2506' , '2507' , '2508' , '2509' , & '2510' , '2511' , '2512' , '2513' , '2514' , '2515' , '2516' , '2517' , '2518' , '2519' , & '2520' , '2521' , '2522' , '2523' , '2524' , '2525' , '2526' , '2527' , '2528' , '2529' , & '2530' , '2531' , '2532' , '2533' , '2534' , '2535' , '2536' , '2537' , '2538' , '2539' , & '2540' , '2541' , '2542' , '2543' , '2544' , '2545' , '2546' , '2547' , '2548' , '2549' , & '2550' , '2551' , '2552' , '2553' , '2554' , '2555' , '2556' , '2557' , '2558' , '2559' , & '2560' , '2561' , '2562' , '2563' , '2564' , '2565' , '2566' , '2567' , '2568' , '2569' , & '2570' , '2571' , '2572' , '2573' , '2574' , '2575' , '2576' , '2577' , '2578' , '2579' , & '2580' , '2581' , '2582' , '2583' , '2584' , '2585' , '2586' , '2587' , '2588' , '2589' , & '2590' , '2591' , '2592' , '2593' , '2594' , '2595' , '2596' , '2597' , '2598' , '2599' , & '2600' , '2601' , '2602' , '2603' , '2604' , '2605' , '2606' , '2607' , '2608' , '2609' , & '2610' , '2611' , '2612' , '2613' , '2614' , '2615' , '2616' , '2617' , '2618' , '2619' , & '2620' , '2621' , '2622' , '2623' , '2624' , '2625' , '2626' , '2627' , '2628' , '2629' , & '2630' , '2631' , '2632' , '2633' , '2634' , '2635' , '2636' , '2637' , '2638' , '2639' , & '2640' , '2641' , '2642' , '2643' , '2644' , '2645' , '2646' , '2647' , '2648' , '2649' , & '2650' , '2651' , '2652' , '2653' , '2654' , '2655' , '2656' , '2657' , '2658' , '2659' , & '2660' , '2661' , '2662' , '2663' , '2664' , '2665' , '2666' , '2667' , '2668' , '2669' , & '2670' , '2671' , '2672' , '2673' , '2674' , '2675' , '2676' , '2677' , '2678' , '2679' , & '2680' , '2681' , '2682' , '2683' , '2684' , '2685' , '2686' , '2687' , '2688' , '2689' , & '2690' , '2691' , '2692' , '2693' , '2694' , '2695' , '2696' , '2697' , '2698' , '2699' , & '2700' , '2701' , '2702' , '2703' , '2704' , '2705' , '2706' , '2707' , '2708' , '2709' , & '2710' , '2711' , '2712' , '2713' , '2714' , '2715' , '2716' , '2717' , '2718' , '2719' , & '2720' , '2721' , '2722' , '2723' , '2724' , '2725' , '2726' , '2727' , '2728' , '2729' , & '2730' , '2731' , '2732' , '2733' , '2734' , '2735' , '2736' , '2737' , '2738' , '2739' , & '2740' , '2741' , '2742' , '2743' , '2744' , '2745' , '2746' , '2747' , '2748' , '2749' , & '2750' , '2751' , '2752' , '2753' , '2754' , '2755' , '2756' , '2757' , '2758' , '2759' , & '2760' , '2761' , '2762' , '2763' , '2764' , '2765' , '2766' , '2767' , '2768' , '2769' , & '2770' , '2771' , '2772' , '2773' , '2774' , '2775' , '2776' , '2777' , '2778' , '2779' , & '2780' , '2781' , '2782' , '2783' , '2784' , '2785' , '2786' , '2787' , '2788' , '2789' , & '2790' , '2791' , '2792' , '2793' , '2794' , '2795' , '2796' , '2797' , '2798' , '2799' , & '2800' , '2801' , '2802' , '2803' , '2804' , '2805' , '2806' , '2807' , '2808' , '2809' , & '2810' , '2811' , '2812' , '2813' , '2814' , '2815' , '2816' , '2817' , '2818' , '2819' , & '2820' , '2821' , '2822' , '2823' , '2824' , '2825' , '2826' , '2827' , '2828' , '2829' , & '2830' , '2831' , '2832' , '2833' , '2834' , '2835' , '2836' , '2837' , '2838' , '2839' , & '2840' , '2841' , '2842' , '2843' , '2844' , '2845' , '2846' , '2847' , '2848' , '2849' , & '2850' , '2851' , '2852' , '2853' , '2854' , '2855' , '2856' , '2857' , '2858' , '2859' , & '2860' , '2861' , '2862' , '2863' , '2864' , '2865' , '2866' , '2867' , '2868' , '2869' , & '2870' , '2871' , '2872' , '2873' , '2874' , '2875' , '2876' , '2877' , '2878' , '2879' , & '2880' , '2881' , '2882' , '2883' , '2884' , '2885' , '2886' , '2887' , '2888' , '2889' , & '2890' , '2891' , '2892' , '2893' , '2894' , '2895' , '2896' , '2897' , '2898' , '2899' , & '2900' , '2901' , '2902' , '2903' , '2904' , '2905' , '2906' , '2907' , '2908' , '2909' , & '2910' , '2911' , '2912' , '2913' , '2914' , '2915' , '2916' , '2917' , '2918' , '2919' , & '2920' , '2921' , '2922' , '2923' , '2924' , '2925' , '2926' , '2927' , '2928' , '2929' , & '2930' , '2931' , '2932' , '2933' , '2934' , '2935' , '2936' , '2937' , '2938' , '2939' , & '2940' , '2941' , '2942' , '2943' , '2944' , '2945' , '2946' , '2947' , '2948' , '2949' , & '2950' , '2951' , '2952' , '2953' , '2954' , '2955' , '2956' , '2957' , '2958' , '2959' , & '2960' , '2961' , '2962' , '2963' , '2964' , '2965' , '2966' , '2967' , '2968' , '2969' , & '2970' , '2971' , '2972' , '2973' , '2974' , '2975' , '2976' , '2977' , '2978' , '2979' , & '2980' , '2981' , '2982' , '2983' , '2984' , '2985' , '2986' , '2987' , '2988' , '2989' , & '2990' , '2991' , '2992' , '2993' , '2994' , '2995' , '2996' , '2997' , '2998' , '2999' , & '3000' , '3001' , '3002' , '3003' , '3004' , '3005' , '3006' , '3007' , '3008' , '3009' , & '3010' , '3011' , '3012' , '3013' , '3014' , '3015' , '3016' , '3017' , '3018' , '3019' , & '3020' , '3021' , '3022' , '3023' , '3024' , '3025' , '3026' , '3027' , '3028' , '3029' , & '3030' , '3031' , '3032' , '3033' , '3034' , '3035' , '3036' , '3037' , '3038' , '3039' , & '3040' , '3041' , '3042' , '3043' , '3044' , '3045' , '3046' , '3047' , '3048' , '3049' , & '3050' , '3051' , '3052' , '3053' , '3054' , '3055' , '3056' , '3057' , '3058' , '3059' , & '3060' , '3061' , '3062' , '3063' , '3064' , '3065' , '3066' , '3067' , '3068' , '3069' , & '3070' , '3071' , '3072' , '3073' , '3074' , '3075' , '3076' , '3077' , '3078' , '3079' , & '3080' , '3081' , '3082' , '3083' , '3084' , '3085' , '3086' , '3087' , '3088' , '3089' , & '3090' , '3091' , '3092' , '3093' , '3094' , '3095' , '3096' , '3097' , '3098' , '3099' , & '3100' , '3101' , '3102' , '3103' , '3104' , '3105' , '3106' , '3107' , '3108' , '3109' , & '3110' , '3111' , '3112' , '3113' , '3114' , '3115' , '3116' , '3117' , '3118' , '3119' , & '3120' , '3121' , '3122' , '3123' , '3124' , '3125' , '3126' , '3127' , '3128' , '3129' , & '3130' , '3131' , '3132' , '3133' , '3134' , '3135' , '3136' , '3137' , '3138' , '3139' , & '3140' , '3141' , '3142' , '3143' , '3144' , '3145' , '3146' , '3147' , '3148' , '3149' , & '3150' , '3151' , '3152' , '3153' , '3154' , '3155' , '3156' , '3157' , '3158' , '3159' , & '3160' , '3161' , '3162' , '3163' , '3164' , '3165' , '3166' , '3167' , '3168' , '3169' , & '3170' , '3171' , '3172' , '3173' , '3174' , '3175' , '3176' , '3177' , '3178' , '3179' , & '3180' , '3181' , '3182' , '3183' , '3184' , '3185' , '3186' , '3187' , '3188' , '3189' , & '3190' , '3191' , '3192' , '3193' , '3194' , '3195' , '3196' , '3197' , '3198' , '3199' , & '3200' , '3201' , '3202' , '3203' , '3204' , '3205' , '3206' , '3207' , '3208' , '3209' , & '3210' , '3211' , '3212' , '3213' , '3214' , '3215' , '3216' , '3217' , '3218' , '3219' , & '3220' , '3221' , '3222' , '3223' , '3224' , '3225' , '3226' , '3227' , '3228' , '3229' , & '3230' , '3231' , '3232' , '3233' , '3234' , '3235' , '3236' , '3237' , '3238' , '3239' , & '3240' , '3241' , '3242' , '3243' , '3244' , '3245' , '3246' , '3247' , '3248' , '3249' , & '3250' , '3251' , '3252' , '3253' , '3254' , '3255' , '3256' , '3257' , '3258' , '3259' , & '3260' , '3261' , '3262' , '3263' , '3264' , '3265' , '3266' , '3267' , '3268' , '3269' , & '3270' , '3271' , '3272' , '3273' , '3274' , '3275' , '3276' , '3277' , '3278' , '3279' , & '3280' , '3281' , '3282' , '3283' , '3284' , '3285' , '3286' , '3287' , '3288' , '3289' , & '3290' , '3291' , '3292' , '3293' , '3294' , '3295' , '3296' , '3297' , '3298' , '3299' , & '3300' , '3301' , '3302' , '3303' , '3304' , '3305' , '3306' , '3307' , '3308' , '3309' , & '3310' , '3311' , '3312' , '3313' , '3314' , '3315' , '3316' , '3317' , '3318' , '3319' , & '3320' , '3321' , '3322' , '3323' , '3324' , '3325' , '3326' , '3327' , '3328' , '3329' , & '3330' , '3331' , '3332' , '3333' , '3334' , '3335' , '3336' , '3337' , '3338' , '3339' , & '3340' , '3341' , '3342' , '3343' , '3344' , '3345' , '3346' , '3347' , '3348' , '3349' , & '3350' , '3351' , '3352' , '3353' , '3354' , '3355' , '3356' , '3357' , '3358' , '3359' , & '3360' , '3361' , '3362' , '3363' , '3364' , '3365' , '3366' , '3367' , '3368' , '3369' , & '3370' , '3371' , '3372' , '3373' , '3374' , '3375' , '3376' , '3377' , '3378' , '3379' , & '3380' , '3381' , '3382' , '3383' , '3384' , '3385' , '3386' , '3387' , '3388' , '3389' , & '3390' , '3391' , '3392' , '3393' , '3394' , '3395' , '3396' , '3397' , '3398' , '3399' , & '3400' , '3401' , '3402' , '3403' , '3404' , '3405' , '3406' , '3407' , '3408' , '3409' , & '3410' , '3411' , '3412' , '3413' , '3414' , '3415' , '3416' , '3417' , '3418' , '3419' , & '3420' , '3421' , '3422' , '3423' , '3424' , '3425' , '3426' , '3427' , '3428' , '3429' , & '3430' , '3431' , '3432' , '3433' , '3434' , '3435' , '3436' , '3437' , '3438' , '3439' , & '3440' , '3441' , '3442' , '3443' , '3444' , '3445' , '3446' , '3447' , '3448' , '3449' , & '3450' , '3451' , '3452' , '3453' , '3454' , '3455' , '3456' , '3457' , '3458' , '3459' , & '3460' , '3461' , '3462' , '3463' , '3464' , '3465' , '3466' , '3467' , '3468' , '3469' , & '3470' , '3471' , '3472' , '3473' , '3474' , '3475' , '3476' , '3477' , '3478' , '3479' , & '3480' , '3481' , '3482' , '3483' , '3484' , '3485' , '3486' , '3487' , '3488' , '3489' , & '3490' , '3491' , '3492' , '3493' , '3494' , '3495' , '3496' , '3497' , '3498' , '3499' , & '3500' , '3501' , '3502' , '3503' , '3504' , '3505' , '3506' , '3507' , '3508' , '3509' , & '3510' , '3511' , '3512' , '3513' , '3514' , '3515' , '3516' , '3517' , '3518' , '3519' , & '3520' , '3521' , '3522' , '3523' , '3524' , '3525' , '3526' , '3527' , '3528' , '3529' , & '3530' , '3531' , '3532' , '3533' , '3534' , '3535' , '3536' , '3537' , '3538' , '3539' , & '3540' , '3541' , '3542' , '3543' , '3544' , '3545' , '3546' , '3547' , '3548' , '3549' , & '3550' , '3551' , '3552' , '3553' , '3554' , '3555' , '3556' , '3557' , '3558' , '3559' , & '3560' , '3561' , '3562' , '3563' , '3564' , '3565' , '3566' , '3567' , '3568' , '3569' , & '3570' , '3571' , '3572' , '3573' , '3574' , '3575' , '3576' , '3577' , '3578' , '3579' , & '3580' , '3581' , '3582' , '3583' , '3584' , '3585' , '3586' , '3587' , '3588' , '3589' , & '3590' , '3591' , '3592' , '3593' , '3594' , '3595' , '3596' , '3597' , '3598' , '3599' , & '3600' , '3601' , '3602' , '3603' , '3604' , '3605' , '3606' , '3607' , '3608' , '3609' , & '3610' , '3611' , '3612' , '3613' , '3614' , '3615' , '3616' , '3617' , '3618' , '3619' , & '3620' , '3621' , '3622' , '3623' , '3624' , '3625' , '3626' , '3627' , '3628' , '3629' , & '3630' , '3631' , '3632' , '3633' , '3634' , '3635' , '3636' , '3637' , '3638' , '3639' , & '3640' , '3641' , '3642' , '3643' , '3644' , '3645' , '3646' , '3647' , '3648' , '3649' , & '3650' , '3651' , '3652' , '3653' , '3654' , '3655' , '3656' , '3657' , '3658' , '3659' , & '3660' , '3661' , '3662' , '3663' , '3664' , '3665' , '3666' , '3667' , '3668' , '3669' , & '3670' , '3671' , '3672' , '3673' , '3674' , '3675' , '3676' , '3677' , '3678' , '3679' , & '3680' , '3681' , '3682' , '3683' , '3684' , '3685' , '3686' , '3687' , '3688' , '3689' , & '3690' , '3691' , '3692' , '3693' , '3694' , '3695' , '3696' , '3697' , '3698' , '3699' , & '3700' , '3701' , '3702' , '3703' , '3704' , '3705' , '3706' , '3707' , '3708' , '3709' , & '3710' , '3711' , '3712' , '3713' , '3714' , '3715' , '3716' , '3717' , '3718' , '3719' , & '3720' , '3721' , '3722' , '3723' , '3724' , '3725' , '3726' , '3727' , '3728' , '3729' , & '3730' , '3731' , '3732' , '3733' , '3734' , '3735' , '3736' , '3737' , '3738' , '3739' , & '3740' , '3741' , '3742' , '3743' , '3744' , '3745' , '3746' , '3747' , '3748' , '3749' , & '3750' , '3751' , '3752' , '3753' , '3754' , '3755' , '3756' , '3757' , '3758' , '3759' , & '3760' , '3761' , '3762' , '3763' , '3764' , '3765' , '3766' , '3767' , '3768' , '3769' , & '3770' , '3771' , '3772' , '3773' , '3774' , '3775' , '3776' , '3777' , '3778' , '3779' , & '3780' , '3781' , '3782' , '3783' , '3784' , '3785' , '3786' , '3787' , '3788' , '3789' , & '3790' , '3791' , '3792' , '3793' , '3794' , '3795' , '3796' , '3797' , '3798' , '3799' , & '3800' , '3801' , '3802' , '3803' , '3804' , '3805' , '3806' , '3807' , '3808' , '3809' , & '3810' , '3811' , '3812' , '3813' , '3814' , '3815' , '3816' , '3817' , '3818' , '3819' , & '3820' , '3821' , '3822' , '3823' , '3824' , '3825' , '3826' , '3827' , '3828' , '3829' , & '3830' , '3831' , '3832' , '3833' , '3834' , '3835' , '3836' , '3837' , '3838' , '3839' , & '3840' , '3841' , '3842' , '3843' , '3844' , '3845' , '3846' , '3847' , '3848' , '3849' , & '3850' , '3851' , '3852' , '3853' , '3854' , '3855' , '3856' , '3857' , '3858' , '3859' , & '3860' , '3861' , '3862' , '3863' , '3864' , '3865' , '3866' , '3867' , '3868' , '3869' , & '3870' , '3871' , '3872' , '3873' , '3874' , '3875' , '3876' , '3877' , '3878' , '3879' , & '3880' , '3881' , '3882' , '3883' , '3884' , '3885' , '3886' , '3887' , '3888' , '3889' , & '3890' , '3891' , '3892' , '3893' , '3894' , '3895' , '3896' , '3897' , '3898' , '3899' , & '3900' , '3901' , '3902' , '3903' , '3904' , '3905' , '3906' , '3907' , '3908' , '3909' , & '3910' , '3911' , '3912' , '3913' , '3914' , '3915' , '3916' , '3917' , '3918' , '3919' , & '3920' , '3921' , '3922' , '3923' , '3924' , '3925' , '3926' , '3927' , '3928' , '3929' , & '3930' , '3931' , '3932' , '3933' , '3934' , '3935' , '3936' , '3937' , '3938' , '3939' , & '3940' , '3941' , '3942' , '3943' , '3944' , '3945' , '3946' , '3947' , '3948' , '3949' , & '3950' , '3951' , '3952' , '3953' , '3954' , '3955' , '3956' , '3957' , '3958' , '3959' , & '3960' , '3961' , '3962' , '3963' , '3964' , '3965' , '3966' , '3967' , '3968' , '3969' , & '3970' , '3971' , '3972' , '3973' , '3974' , '3975' , '3976' , '3977' , '3978' , '3979' , & '3980' , '3981' , '3982' , '3983' , '3984' , '3985' , '3986' , '3987' , '3988' , '3989' , & '3990' , '3991' , '3992' , '3993' , '3994' , '3995' , '3996' , '3997' , '3998' , '3999' , & '4000' , '4001' , '4002' , '4003' , '4004' , '4005' , '4006' , '4007' , '4008' , '4009' , & '4010' , '4011' , '4012' , '4013' , '4014' , '4015' , '4016' , '4017' , '4018' , '4019' , & '4020' , '4021' , '4022' , '4023' , '4024' , '4025' , '4026' , '4027' , '4028' , '4029' , & '4030' , '4031' , '4032' , '4033' , '4034' , '4035' , '4036' , '4037' , '4038' , '4039' , & '4040' , '4041' , '4042' , '4043' , '4044' , '4045' , '4046' , '4047' , '4048' , '4049' , & '4050' , '4051' , '4052' , '4053' , '4054' , '4055' , '4056' , '4057' , '4058' , '4059' , & '4060' , '4061' , '4062' , '4063' , '4064' , '4065' , '4066' , '4067' , '4068' , '4069' , & '4070' , '4071' , '4072' , '4073' , '4074' , '4075' , '4076' , '4077' , '4078' , '4079' , & '4080' , '4081' , '4082' , '4083' , '4084' , '4085' , '4086' , '4087' , '4088' , '4089' , & '4090' , '4091' , '4092' , '4093' , '4094' , '4095' , '4096' , '4097' , '4098' , '4099' , & '4100' , '4101' , '4102' , '4103' , '4104' , '4105' , '4106' , '4107' , '4108' , '4109' , & '4110' , '4111' , '4112' , '4113' , '4114' , '4115' , '4116' , '4117' , '4118' , '4119' , & '4120' , '4121' , '4122' , '4123' , '4124' , '4125' , '4126' , '4127' , '4128' , '4129' , & '4130' , '4131' , '4132' , '4133' , '4134' , '4135' , '4136' , '4137' , '4138' , '4139' , & '4140' , '4141' , '4142' , '4143' , '4144' , '4145' , '4146' , '4147' , '4148' , '4149' , & '4150' , '4151' , '4152' , '4153' , '4154' , '4155' , '4156' , '4157' , '4158' , '4159' , & '4160' , '4161' , '4162' , '4163' , '4164' , '4165' , '4166' , '4167' , '4168' , '4169' , & '4170' , '4171' , '4172' , '4173' , '4174' , '4175' , '4176' , '4177' , '4178' , '4179' , & '4180' , '4181' , '4182' , '4183' , '4184' , '4185' , '4186' , '4187' , '4188' , '4189' , & '4190' , '4191' , '4192' , '4193' , '4194' , '4195' , '4196' , '4197' , '4198' , '4199' , & '4200' , '4201' , '4202' , '4203' , '4204' , '4205' , '4206' , '4207' , '4208' , '4209' , & '4210' , '4211' , '4212' , '4213' , '4214' , '4215' , '4216' , '4217' , '4218' , '4219' , & '4220' , '4221' , '4222' , '4223' , '4224' , '4225' , '4226' , '4227' , '4228' , '4229' , & '4230' , '4231' , '4232' , '4233' , '4234' , '4235' , '4236' , '4237' , '4238' , '4239' , & '4240' , '4241' , '4242' , '4243' , '4244' , '4245' , '4246' , '4247' , '4248' , '4249' , & '4250' , '4251' , '4252' , '4253' , '4254' , '4255' , '4256' , '4257' , '4258' , '4259' , & '4260' , '4261' , '4262' , '4263' , '4264' , '4265' , '4266' , '4267' , '4268' , '4269' , & '4270' , '4271' , '4272' , '4273' , '4274' , '4275' , '4276' , '4277' , '4278' , '4279' , & '4280' , '4281' , '4282' , '4283' , '4284' , '4285' , '4286' , '4287' , '4288' , '4289' , & '4290' , '4291' , '4292' , '4293' , '4294' , '4295' , '4296' , '4297' , '4298' , '4299' , & '4300' , '4301' , '4302' , '4303' , '4304' , '4305' , '4306' , '4307' , '4308' , '4309' , & '4310' , '4311' , '4312' , '4313' , '4314' , '4315' , '4316' , '4317' , '4318' , '4319' , & '4320' , '4321' , '4322' , '4323' , '4324' , '4325' , '4326' , '4327' , '4328' , '4329' , & '4330' , '4331' , '4332' , '4333' , '4334' , '4335' , '4336' , '4337' , '4338' , '4339' , & '4340' , '4341' , '4342' , '4343' , '4344' , '4345' , '4346' , '4347' , '4348' , '4349' , & '4350' , '4351' , '4352' , '4353' , '4354' , '4355' , '4356' , '4357' , '4358' , '4359' , & '4360' , '4361' , '4362' , '4363' , '4364' , '4365' , '4366' , '4367' , '4368' , '4369' , & '4370' , '4371' , '4372' , '4373' , '4374' , '4375' , '4376' , '4377' , '4378' , '4379' , & '4380' , '4381' , '4382' , '4383' , '4384' , '4385' , '4386' , '4387' , '4388' , '4389' , & '4390' , '4391' , '4392' , '4393' , '4394' , '4395' , '4396' , '4397' , '4398' , '4399' , & '4400' , '4401' , '4402' , '4403' , '4404' , '4405' , '4406' , '4407' , '4408' , '4409' , & '4410' , '4411' , '4412' , '4413' , '4414' , '4415' , '4416' , '4417' , '4418' , '4419' , & '4420' , '4421' , '4422' , '4423' , '4424' , '4425' , '4426' , '4427' , '4428' , '4429' , & '4430' , '4431' , '4432' , '4433' , '4434' , '4435' , '4436' , '4437' , '4438' , '4439' , & '4440' , '4441' , '4442' , '4443' , '4444' , '4445' , '4446' , '4447' , '4448' , '4449' , & '4450' , '4451' , '4452' , '4453' , '4454' , '4455' , '4456' , '4457' , '4458' , '4459' , & '4460' , '4461' , '4462' , '4463' , '4464' , '4465' , '4466' , '4467' , '4468' , '4469' , & '4470' , '4471' , '4472' , '4473' , '4474' , '4475' , '4476' , '4477' , '4478' , '4479' , & '4480' , '4481' , '4482' , '4483' , '4484' , '4485' , '4486' , '4487' , '4488' , '4489' , & '4490' , '4491' , '4492' , '4493' , '4494' , '4495' , '4496' , '4497' , '4498' , '4499' , & '4500' , '4501' , '4502' , '4503' , '4504' , '4505' , '4506' , '4507' , '4508' , '4509' , & '4510' , '4511' , '4512' , '4513' , '4514' , '4515' , '4516' , '4517' , '4518' , '4519' , & '4520' , '4521' , '4522' , '4523' , '4524' , '4525' , '4526' , '4527' , '4528' , '4529' , & '4530' , '4531' , '4532' , '4533' , '4534' , '4535' , '4536' , '4537' , '4538' , '4539' , & '4540' , '4541' , '4542' , '4543' , '4544' , '4545' , '4546' , '4547' , '4548' , '4549' , & '4550' , '4551' , '4552' , '4553' , '4554' , '4555' , '4556' , '4557' , '4558' , '4559' , & '4560' , '4561' , '4562' , '4563' , '4564' , '4565' , '4566' , '4567' , '4568' , '4569' , & '4570' , '4571' , '4572' , '4573' , '4574' , '4575' , '4576' , '4577' , '4578' , '4579' , & '4580' , '4581' , '4582' , '4583' , '4584' , '4585' , '4586' , '4587' , '4588' , '4589' , & '4590' , '4591' , '4592' , '4593' , '4594' , '4595' , '4596' , '4597' , '4598' , '4599' , & '4600' , '4601' , '4602' , '4603' , '4604' , '4605' , '4606' , '4607' , '4608' , '4609' , & '4610' , '4611' , '4612' , '4613' , '4614' , '4615' , '4616' , '4617' , '4618' , '4619' , & '4620' , '4621' , '4622' , '4623' , '4624' , '4625' , '4626' , '4627' , '4628' , '4629' , & '4630' , '4631' , '4632' , '4633' , '4634' , '4635' , '4636' , '4637' , '4638' , '4639' , & '4640' , '4641' , '4642' , '4643' , '4644' , '4645' , '4646' , '4647' , '4648' , '4649' , & '4650' , '4651' , '4652' , '4653' , '4654' , '4655' , '4656' , '4657' , '4658' , '4659' , & '4660' , '4661' , '4662' , '4663' , '4664' , '4665' , '4666' , '4667' , '4668' , '4669' , & '4670' , '4671' , '4672' , '4673' , '4674' , '4675' , '4676' , '4677' , '4678' , '4679' , & '4680' , '4681' , '4682' , '4683' , '4684' , '4685' , '4686' , '4687' , '4688' , '4689' , & '4690' , '4691' , '4692' , '4693' , '4694' , '4695' , '4696' , '4697' , '4698' , '4699' , & '4700' , '4701' , '4702' , '4703' , '4704' , '4705' , '4706' , '4707' , '4708' , '4709' , & '4710' , '4711' , '4712' , '4713' , '4714' , '4715' , '4716' , '4717' , '4718' , '4719' , & '4720' , '4721' , '4722' , '4723' , '4724' , '4725' , '4726' , '4727' , '4728' , '4729' , & '4730' , '4731' , '4732' , '4733' , '4734' , '4735' , '4736' , '4737' , '4738' , '4739' , & '4740' , '4741' , '4742' , '4743' , '4744' , '4745' , '4746' , '4747' , '4748' , '4749' , & '4750' , '4751' , '4752' , '4753' , '4754' , '4755' , '4756' , '4757' , '4758' , '4759' , & '4760' , '4761' , '4762' , '4763' , '4764' , '4765' , '4766' , '4767' , '4768' , '4769' , & '4770' , '4771' , '4772' , '4773' , '4774' , '4775' , '4776' , '4777' , '4778' , '4779' , & '4780' , '4781' , '4782' , '4783' , '4784' , '4785' , '4786' , '4787' , '4788' , '4789' , & '4790' , '4791' , '4792' , '4793' , '4794' , '4795' , '4796' , '4797' , '4798' , '4799' , & '4800' , '4801' , '4802' , '4803' , '4804' , '4805' , '4806' , '4807' , '4808' , '4809' , & '4810' , '4811' , '4812' , '4813' , '4814' , '4815' , '4816' , '4817' , '4818' , '4819' , & '4820' , '4821' , '4822' , '4823' , '4824' , '4825' , '4826' , '4827' , '4828' , '4829' , & '4830' , '4831' , '4832' , '4833' , '4834' , '4835' , '4836' , '4837' , '4838' , '4839' , & '4840' , '4841' , '4842' , '4843' , '4844' , '4845' , '4846' , '4847' , '4848' , '4849' , & '4850' , '4851' , '4852' , '4853' , '4854' , '4855' , '4856' , '4857' , '4858' , '4859' , & '4860' , '4861' , '4862' , '4863' , '4864' , '4865' , '4866' , '4867' , '4868' , '4869' , & '4870' , '4871' , '4872' , '4873' , '4874' , '4875' , '4876' , '4877' , '4878' , '4879' , & '4880' , '4881' , '4882' , '4883' , '4884' , '4885' , '4886' , '4887' , '4888' , '4889' , & '4890' , '4891' , '4892' , '4893' , '4894' , '4895' , '4896' , '4897' , '4898' , '4899' , & '4900' , '4901' , '4902' , '4903' , '4904' , '4905' , '4906' , '4907' , '4908' , '4909' , & '4910' , '4911' , '4912' , '4913' , '4914' , '4915' , '4916' , '4917' , '4918' , '4919' , & '4920' , '4921' , '4922' , '4923' , '4924' , '4925' , '4926' , '4927' , '4928' , '4929' , & '4930' , '4931' , '4932' , '4933' , '4934' , '4935' , '4936' , '4937' , '4938' , '4939' , & '4940' , '4941' , '4942' , '4943' , '4944' , '4945' , '4946' , '4947' , '4948' , '4949' , & '4950' , '4951' , '4952' , '4953' , '4954' , '4955' , '4956' , '4957' , '4958' , '4959' , & '4960' , '4961' , '4962' , '4963' , '4964' , '4965' , '4966' , '4967' , '4968' , '4969' , & '4970' , '4971' , '4972' , '4973' , '4974' , '4975' , '4976' , '4977' , '4978' , '4979' , & '4980' , '4981' , '4982' , '4983' , '4984' , '4985' , '4986' , '4987' , '4988' , '4989' , & '4990' , '4991' , '4992' , '4993' , '4994' , '4995' , '4996' , '4997' , '4998' , '4999' , & '5000' , '5001' , '5002' , '5003' , '5004' , '5005' , '5006' , '5007' , '5008' , '5009' , & '5010' , '5011' , '5012' , '5013' , '5014' , '5015' , '5016' , '5017' , '5018' , '5019' , & '5020' , '5021' , '5022' , '5023' , '5024' , '5025' , '5026' , '5027' , '5028' , '5029' , & '5030' , '5031' , '5032' , '5033' , '5034' , '5035' , '5036' , '5037' , '5038' , '5039' , & '5040' , '5041' , '5042' , '5043' , '5044' , '5045' , '5046' , '5047' , '5048' , '5049' , & '5050' , '5051' , '5052' , '5053' , '5054' , '5055' , '5056' , '5057' , '5058' , '5059' , & '5060' , '5061' , '5062' , '5063' , '5064' , '5065' , '5066' , '5067' , '5068' , '5069' , & '5070' , '5071' , '5072' , '5073' , '5074' , '5075' , '5076' , '5077' , '5078' , '5079' , & '5080' , '5081' , '5082' , '5083' , '5084' , '5085' , '5086' , '5087' , '5088' , '5089' , & '5090' , '5091' , '5092' , '5093' , '5094' , '5095' , '5096' , '5097' , '5098' , '5099' , & '5100' , '5101' , '5102' , '5103' , '5104' , '5105' , '5106' , '5107' , '5108' , '5109' , & '5110' , '5111' , '5112' , '5113' , '5114' , '5115' , '5116' , '5117' , '5118' , '5119' , & '5120' , '5121' , '5122' , '5123' , '5124' , '5125' , '5126' , '5127' , '5128' , '5129' , & '5130' , '5131' , '5132' , '5133' , '5134' , '5135' , '5136' , '5137' , '5138' , '5139' , & '5140' , '5141' , '5142' , '5143' , '5144' , '5145' , '5146' , '5147' , '5148' , '5149' , & '5150' , '5151' , '5152' , '5153' , '5154' , '5155' , '5156' , '5157' , '5158' , '5159' , & '5160' , '5161' , '5162' , '5163' , '5164' , '5165' , '5166' , '5167' , '5168' , '5169' , & '5170' , '5171' , '5172' , '5173' , '5174' , '5175' , '5176' , '5177' , '5178' , '5179' , & '5180' , '5181' , '5182' , '5183' , '5184' , '5185' , '5186' , '5187' , '5188' , '5189' , & '5190' , '5191' , '5192' , '5193' , '5194' , '5195' , '5196' , '5197' , '5198' , '5199' , & '5200' , '5201' , '5202' , '5203' , '5204' , '5205' , '5206' , '5207' , '5208' , '5209' , & '5210' , '5211' , '5212' , '5213' , '5214' , '5215' , '5216' , '5217' , '5218' , '5219' , & '5220' , '5221' , '5222' , '5223' , '5224' , '5225' , '5226' , '5227' , '5228' , '5229' , & '5230' , '5231' , '5232' , '5233' , '5234' , '5235' , '5236' , '5237' , '5238' , '5239' , & '5240' , '5241' , '5242' , '5243' , '5244' , '5245' , '5246' , '5247' , '5248' , '5249' , & '5250' , '5251' , '5252' , '5253' , '5254' , '5255' , '5256' , '5257' , '5258' , '5259' , & '5260' , '5261' , '5262' , '5263' , '5264' , '5265' , '5266' , '5267' , '5268' , '5269' , & '5270' , '5271' , '5272' , '5273' , '5274' , '5275' , '5276' , '5277' , '5278' , '5279' , & '5280' , '5281' , '5282' , '5283' , '5284' , '5285' , '5286' , '5287' , '5288' , '5289' , & '5290' , '5291' , '5292' , '5293' , '5294' , '5295' , '5296' , '5297' , '5298' , '5299' , & '5300' , '5301' , '5302' , '5303' , '5304' , '5305' , '5306' , '5307' , '5308' , '5309' , & '5310' , '5311' , '5312' , '5313' , '5314' , '5315' , '5316' , '5317' , '5318' , '5319' , & '5320' , '5321' , '5322' , '5323' , '5324' , '5325' , '5326' , '5327' , '5328' , '5329' , & '5330' , '5331' , '5332' , '5333' , '5334' , '5335' , '5336' , '5337' , '5338' , '5339' , & '5340' , '5341' , '5342' , '5343' , '5344' , '5345' , '5346' , '5347' , '5348' , '5349' , & '5350' , '5351' , '5352' , '5353' , '5354' , '5355' , '5356' , '5357' , '5358' , '5359' , & '5360' , '5361' , '5362' , '5363' , '5364' , '5365' , '5366' , '5367' , '5368' , '5369' , & '5370' , '5371' , '5372' , '5373' , '5374' , '5375' , '5376' , '5377' , '5378' , '5379' , & '5380' , '5381' , '5382' , '5383' , '5384' , '5385' , '5386' , '5387' , '5388' , '5389' , & '5390' , '5391' , '5392' , '5393' , '5394' , '5395' , '5396' , '5397' , '5398' , '5399' , & '5400' , '5401' , '5402' , '5403' , '5404' , '5405' , '5406' , '5407' , '5408' , '5409' , & '5410' , '5411' , '5412' , '5413' , '5414' , '5415' , '5416' , '5417' , '5418' , '5419' , & '5420' , '5421' , '5422' , '5423' , '5424' , '5425' , '5426' , '5427' , '5428' , '5429' , & '5430' , '5431' , '5432' , '5433' , '5434' , '5435' , '5436' , '5437' , '5438' , '5439' , & '5440' , '5441' , '5442' , '5443' , '5444' , '5445' , '5446' , '5447' , '5448' , '5449' , & '5450' , '5451' , '5452' , '5453' , '5454' , '5455' , '5456' , '5457' , '5458' , '5459' , & '5460' , '5461' , '5462' , '5463' , '5464' , '5465' , '5466' , '5467' , '5468' , '5469' , & '5470' , '5471' , '5472' , '5473' , '5474' , '5475' , '5476' , '5477' , '5478' , '5479' , & '5480' , '5481' , '5482' , '5483' , '5484' , '5485' , '5486' , '5487' , '5488' , '5489' , & '5490' , '5491' , '5492' , '5493' , '5494' , '5495' , '5496' , '5497' , '5498' , '5499' , & '5500' , '5501' , '5502' , '5503' , '5504' , '5505' , '5506' , '5507' , '5508' , '5509' , & '5510' , '5511' , '5512' , '5513' , '5514' , '5515' , '5516' , '5517' , '5518' , '5519' , & '5520' , '5521' , '5522' , '5523' , '5524' , '5525' , '5526' , '5527' , '5528' , '5529' , & '5530' , '5531' , '5532' , '5533' , '5534' , '5535' , '5536' , '5537' , '5538' , '5539' , & '5540' , '5541' , '5542' , '5543' , '5544' , '5545' , '5546' , '5547' , '5548' , '5549' , & '5550' , '5551' , '5552' , '5553' , '5554' , '5555' , '5556' , '5557' , '5558' , '5559' , & '5560' , '5561' , '5562' , '5563' , '5564' , '5565' , '5566' , '5567' , '5568' , '5569' , & '5570' , '5571' , '5572' , '5573' , '5574' , '5575' , '5576' , '5577' , '5578' , '5579' , & '5580' , '5581' , '5582' , '5583' , '5584' , '5585' , '5586' , '5587' , '5588' , '5589' , & '5590' , '5591' , '5592' , '5593' , '5594' , '5595' , '5596' , '5597' , '5598' , '5599' , & '5600' , '5601' , '5602' , '5603' , '5604' , '5605' , '5606' , '5607' , '5608' , '5609' , & '5610' , '5611' , '5612' , '5613' , '5614' , '5615' , '5616' , '5617' , '5618' , '5619' , & '5620' , '5621' , '5622' , '5623' , '5624' , '5625' , '5626' , '5627' , '5628' , '5629' , & '5630' , '5631' , '5632' , '5633' , '5634' , '5635' , '5636' , '5637' , '5638' , '5639' , & '5640' , '5641' , '5642' , '5643' , '5644' , '5645' , '5646' , '5647' , '5648' , '5649' , & '5650' , '5651' , '5652' , '5653' , '5654' , '5655' , '5656' , '5657' , '5658' , '5659' , & '5660' , '5661' , '5662' , '5663' , '5664' , '5665' , '5666' , '5667' , '5668' , '5669' , & '5670' , '5671' , '5672' , '5673' , '5674' , '5675' , '5676' , '5677' , '5678' , '5679' , & '5680' , '5681' , '5682' , '5683' , '5684' , '5685' , '5686' , '5687' , '5688' , '5689' , & '5690' , '5691' , '5692' , '5693' , '5694' , '5695' , '5696' , '5697' , '5698' , '5699' , & '5700' , '5701' , '5702' , '5703' , '5704' , '5705' , '5706' , '5707' , '5708' , '5709' , & '5710' , '5711' , '5712' , '5713' , '5714' , '5715' , '5716' , '5717' , '5718' , '5719' , & '5720' , '5721' , '5722' , '5723' , '5724' , '5725' , '5726' , '5727' , '5728' , '5729' , & '5730' , '5731' , '5732' , '5733' , '5734' , '5735' , '5736' , '5737' , '5738' , '5739' , & '5740' , '5741' , '5742' , '5743' , '5744' , '5745' , '5746' , '5747' , '5748' , '5749' , & '5750' , '5751' , '5752' , '5753' , '5754' , '5755' , '5756' , '5757' , '5758' , '5759' , & '5760' , '5761' , '5762' , '5763' , '5764' , '5765' , '5766' , '5767' , '5768' , '5769' , & '5770' , '5771' , '5772' , '5773' , '5774' , '5775' , '5776' , '5777' , '5778' , '5779' , & '5780' , '5781' , '5782' , '5783' , '5784' , '5785' , '5786' , '5787' , '5788' , '5789' , & '5790' , '5791' , '5792' , '5793' , '5794' , '5795' , '5796' , '5797' , '5798' , '5799' , & '5800' , '5801' , '5802' , '5803' , '5804' , '5805' , '5806' , '5807' , '5808' , '5809' , & '5810' , '5811' , '5812' , '5813' , '5814' , '5815' , '5816' , '5817' , '5818' , '5819' , & '5820' , '5821' , '5822' , '5823' , '5824' , '5825' , '5826' , '5827' , '5828' , '5829' , & '5830' , '5831' , '5832' , '5833' , '5834' , '5835' , '5836' , '5837' , '5838' , '5839' , & '5840' , '5841' , '5842' , '5843' , '5844' , '5845' , '5846' , '5847' , '5848' , '5849' , & '5850' , '5851' , '5852' , '5853' , '5854' , '5855' , '5856' , '5857' , '5858' , '5859' , & '5860' , '5861' , '5862' , '5863' , '5864' , '5865' , '5866' , '5867' , '5868' , '5869' , & '5870' , '5871' , '5872' , '5873' , '5874' , '5875' , '5876' , '5877' , '5878' , '5879' , & '5880' , '5881' , '5882' , '5883' , '5884' , '5885' , '5886' , '5887' , '5888' , '5889' , & '5890' , '5891' , '5892' , '5893' , '5894' , '5895' , '5896' , '5897' , '5898' , '5899' , & '5900' , '5901' , '5902' , '5903' , '5904' , '5905' , '5906' , '5907' , '5908' , '5909' , & '5910' , '5911' , '5912' , '5913' , '5914' , '5915' , '5916' , '5917' , '5918' , '5919' , & '5920' , '5921' , '5922' , '5923' , '5924' , '5925' , '5926' , '5927' , '5928' , '5929' , & '5930' , '5931' , '5932' , '5933' , '5934' , '5935' , '5936' , '5937' , '5938' , '5939' , & '5940' , '5941' , '5942' , '5943' , '5944' , '5945' , '5946' , '5947' , '5948' , '5949' , & '5950' , '5951' , '5952' , '5953' , '5954' , '5955' , '5956' , '5957' , '5958' , '5959' , & '5960' , '5961' , '5962' , '5963' , '5964' , '5965' , '5966' , '5967' , '5968' , '5969' , & '5970' , '5971' , '5972' , '5973' , '5974' , '5975' , '5976' , '5977' , '5978' , '5979' , & '5980' , '5981' , '5982' , '5983' , '5984' , '5985' , '5986' , '5987' , '5988' , '5989' , & '5990' , '5991' , '5992' , '5993' , '5994' , '5995' , '5996' , '5997' , '5998' , '5999' , & '6000' , '6001' , '6002' , '6003' , '6004' , '6005' , '6006' , '6007' , '6008' , '6009' , & '6010' , '6011' , '6012' , '6013' , '6014' , '6015' , '6016' , '6017' , '6018' , '6019' , & '6020' , '6021' , '6022' , '6023' , '6024' , '6025' , '6026' , '6027' , '6028' , '6029' , & '6030' , '6031' , '6032' , '6033' , '6034' , '6035' , '6036' , '6037' , '6038' , '6039' , & '6040' , '6041' , '6042' , '6043' , '6044' , '6045' , '6046' , '6047' , '6048' , '6049' , & '6050' , '6051' , '6052' , '6053' , '6054' , '6055' , '6056' , '6057' , '6058' , '6059' , & '6060' , '6061' , '6062' , '6063' , '6064' , '6065' , '6066' , '6067' , '6068' , '6069' , & '6070' , '6071' , '6072' , '6073' , '6074' , '6075' , '6076' , '6077' , '6078' , '6079' , & '6080' , '6081' , '6082' , '6083' , '6084' , '6085' , '6086' , '6087' , '6088' , '6089' , & '6090' , '6091' , '6092' , '6093' , '6094' , '6095' , '6096' , '6097' , '6098' , '6099' , & '6100' , '6101' , '6102' , '6103' , '6104' , '6105' , '6106' , '6107' , '6108' , '6109' , & '6110' , '6111' , '6112' , '6113' , '6114' , '6115' , '6116' , '6117' , '6118' , '6119' , & '6120' , '6121' , '6122' , '6123' , '6124' , '6125' , '6126' , '6127' , '6128' , '6129' , & '6130' , '6131' , '6132' , '6133' , '6134' , '6135' , '6136' , '6137' , '6138' , '6139' , & '6140' , '6141' , '6142' , '6143' , '6144' , '6145' , '6146' , '6147' , '6148' , '6149' , & '6150' , '6151' , '6152' , '6153' , '6154' , '6155' , '6156' , '6157' , '6158' , '6159' , & '6160' , '6161' , '6162' , '6163' , '6164' , '6165' , '6166' , '6167' , '6168' , '6169' , & '6170' , '6171' , '6172' , '6173' , '6174' , '6175' , '6176' , '6177' , '6178' , '6179' , & '6180' , '6181' , '6182' , '6183' , '6184' , '6185' , '6186' , '6187' , '6188' , '6189' , & '6190' , '6191' , '6192' , '6193' , '6194' , '6195' , '6196' , '6197' , '6198' , '6199' , & '6200' , '6201' , '6202' , '6203' , '6204' , '6205' , '6206' , '6207' , '6208' , '6209' , & '6210' , '6211' , '6212' , '6213' , '6214' , '6215' , '6216' , '6217' , '6218' , '6219' , & '6220' , '6221' , '6222' , '6223' , '6224' , '6225' , '6226' , '6227' , '6228' , '6229' , & '6230' , '6231' , '6232' , '6233' , '6234' , '6235' , '6236' , '6237' , '6238' , '6239' , & '6240' , '6241' , '6242' , '6243' , '6244' , '6245' , '6246' , '6247' , '6248' , '6249' , & '6250' , '6251' , '6252' , '6253' , '6254' , '6255' , '6256' , '6257' , '6258' , '6259' , & '6260' , '6261' , '6262' , '6263' , '6264' , '6265' , '6266' , '6267' , '6268' , '6269' , & '6270' , '6271' , '6272' , '6273' , '6274' , '6275' , '6276' , '6277' , '6278' , '6279' , & '6280' , '6281' , '6282' , '6283' , '6284' , '6285' , '6286' , '6287' , '6288' , '6289' , & '6290' , '6291' , '6292' , '6293' , '6294' , '6295' , '6296' , '6297' , '6298' , '6299' , & '6300' , '6301' , '6302' , '6303' , '6304' , '6305' , '6306' , '6307' , '6308' , '6309' , & '6310' , '6311' , '6312' , '6313' , '6314' , '6315' , '6316' , '6317' , '6318' , '6319' , & '6320' , '6321' , '6322' , '6323' , '6324' , '6325' , '6326' , '6327' , '6328' , '6329' , & '6330' , '6331' , '6332' , '6333' , '6334' , '6335' , '6336' , '6337' , '6338' , '6339' , & '6340' , '6341' , '6342' , '6343' , '6344' , '6345' , '6346' , '6347' , '6348' , '6349' , & '6350' , '6351' , '6352' , '6353' , '6354' , '6355' , '6356' , '6357' , '6358' , '6359' , & '6360' , '6361' , '6362' , '6363' , '6364' , '6365' , '6366' , '6367' , '6368' , '6369' , & '6370' , '6371' , '6372' , '6373' , '6374' , '6375' , '6376' , '6377' , '6378' , '6379' , & '6380' , '6381' , '6382' , '6383' , '6384' , '6385' , '6386' , '6387' , '6388' , '6389' , & '6390' , '6391' , '6392' , '6393' , '6394' , '6395' , '6396' , '6397' , '6398' , '6399' , & '6400' , '6401' , '6402' , '6403' , '6404' , '6405' , '6406' , '6407' , '6408' , '6409' , & '6410' , '6411' , '6412' , '6413' , '6414' , '6415' , '6416' , '6417' , '6418' , '6419' , & '6420' , '6421' , '6422' , '6423' , '6424' , '6425' , '6426' , '6427' , '6428' , '6429' , & '6430' , '6431' , '6432' , '6433' , '6434' , '6435' , '6436' , '6437' , '6438' , '6439' , & '6440' , '6441' , '6442' , '6443' , '6444' , '6445' , '6446' , '6447' , '6448' , '6449' , & '6450' , '6451' , '6452' , '6453' , '6454' , '6455' , '6456' , '6457' , '6458' , '6459' , & '6460' , '6461' , '6462' , '6463' , '6464' , '6465' , '6466' , '6467' , '6468' , '6469' , & '6470' , '6471' , '6472' , '6473' , '6474' , '6475' , '6476' , '6477' , '6478' , '6479' , & '6480' , '6481' , '6482' , '6483' , '6484' , '6485' , '6486' , '6487' , '6488' , '6489' , & '6490' , '6491' , '6492' , '6493' , '6494' , '6495' , '6496' , '6497' , '6498' , '6499' , & '6500' , '6501' , '6502' , '6503' , '6504' , '6505' , '6506' , '6507' , '6508' , '6509' , & '6510' , '6511' , '6512' , '6513' , '6514' , '6515' , '6516' , '6517' , '6518' , '6519' , & '6520' , '6521' , '6522' , '6523' , '6524' , '6525' , '6526' , '6527' , '6528' , '6529' , & '6530' , '6531' , '6532' , '6533' , '6534' , '6535' , '6536' , '6537' , '6538' , '6539' , & '6540' , '6541' , '6542' , '6543' , '6544' , '6545' , '6546' , '6547' , '6548' , '6549' , & '6550' , '6551' , '6552' , '6553' , '6554' , '6555' , '6556' , '6557' , '6558' , '6559' , & '6560' , '6561' , '6562' , '6563' , '6564' , '6565' , '6566' , '6567' , '6568' , '6569' , & '6570' , '6571' , '6572' , '6573' , '6574' , '6575' , '6576' , '6577' , '6578' , '6579' , & '6580' , '6581' , '6582' , '6583' , '6584' , '6585' , '6586' , '6587' , '6588' , '6589' , & '6590' , '6591' , '6592' , '6593' , '6594' , '6595' , '6596' , '6597' , '6598' , '6599' , & '6600' , '6601' , '6602' , '6603' , '6604' , '6605' , '6606' , '6607' , '6608' , '6609' , & '6610' , '6611' , '6612' , '6613' , '6614' , '6615' , '6616' , '6617' , '6618' , '6619' , & '6620' , '6621' , '6622' , '6623' , '6624' , '6625' , '6626' , '6627' , '6628' , '6629' , & '6630' , '6631' , '6632' , '6633' , '6634' , '6635' , '6636' , '6637' , '6638' , '6639' , & '6640' , '6641' , '6642' , '6643' , '6644' , '6645' , '6646' , '6647' , '6648' , '6649' , & '6650' , '6651' , '6652' , '6653' , '6654' , '6655' , '6656' , '6657' , '6658' , '6659' , & '6660' , '6661' , '6662' , '6663' , '6664' , '6665' , '6666' , '6667' , '6668' , '6669' , & '6670' , '6671' , '6672' , '6673' , '6674' , '6675' , '6676' , '6677' , '6678' , '6679' , & '6680' , '6681' , '6682' , '6683' , '6684' , '6685' , '6686' , '6687' , '6688' , '6689' , & '6690' , '6691' , '6692' , '6693' , '6694' , '6695' , '6696' , '6697' , '6698' , '6699' , & '6700' , '6701' , '6702' , '6703' , '6704' , '6705' , '6706' , '6707' , '6708' , '6709' , & '6710' , '6711' , '6712' , '6713' , '6714' , '6715' , '6716' , '6717' , '6718' , '6719' , & '6720' , '6721' , '6722' , '6723' , '6724' , '6725' , '6726' , '6727' , '6728' , '6729' , & '6730' , '6731' , '6732' , '6733' , '6734' , '6735' , '6736' , '6737' , '6738' , '6739' , & '6740' , '6741' , '6742' , '6743' , '6744' , '6745' , '6746' , '6747' , '6748' , '6749' , & '6750' , '6751' , '6752' , '6753' , '6754' , '6755' , '6756' , '6757' , '6758' , '6759' , & '6760' , '6761' , '6762' , '6763' , '6764' , '6765' , '6766' , '6767' , '6768' , '6769' , & '6770' , '6771' , '6772' , '6773' , '6774' , '6775' , '6776' , '6777' , '6778' , '6779' , & '6780' , '6781' , '6782' , '6783' , '6784' , '6785' , '6786' , '6787' , '6788' , '6789' , & '6790' , '6791' , '6792' , '6793' , '6794' , '6795' , '6796' , '6797' , '6798' , '6799' , & '6800' , '6801' , '6802' , '6803' , '6804' , '6805' , '6806' , '6807' , '6808' , '6809' , & '6810' , '6811' , '6812' , '6813' , '6814' , '6815' , '6816' , '6817' , '6818' , '6819' , & '6820' , '6821' , '6822' , '6823' , '6824' , '6825' , '6826' , '6827' , '6828' , '6829' , & '6830' , '6831' , '6832' , '6833' , '6834' , '6835' , '6836' , '6837' , '6838' , '6839' , & '6840' , '6841' , '6842' , '6843' , '6844' , '6845' , '6846' , '6847' , '6848' , '6849' , & '6850' , '6851' , '6852' , '6853' , '6854' , '6855' , '6856' , '6857' , '6858' , '6859' , & '6860' , '6861' , '6862' , '6863' , '6864' , '6865' , '6866' , '6867' , '6868' , '6869' , & '6870' , '6871' , '6872' , '6873' , '6874' , '6875' , '6876' , '6877' , '6878' , '6879' , & '6880' , '6881' , '6882' , '6883' , '6884' , '6885' , '6886' , '6887' , '6888' , '6889' , & '6890' , '6891' , '6892' , '6893' , '6894' , '6895' , '6896' , '6897' , '6898' , '6899' , & '6900' , '6901' , '6902' , '6903' , '6904' , '6905' , '6906' , '6907' , '6908' , '6909' , & '6910' , '6911' , '6912' , '6913' , '6914' , '6915' , '6916' , '6917' , '6918' , '6919' , & '6920' , '6921' , '6922' , '6923' , '6924' , '6925' , '6926' , '6927' , '6928' , '6929' , & '6930' , '6931' , '6932' , '6933' , '6934' , '6935' , '6936' , '6937' , '6938' , '6939' , & '6940' , '6941' , '6942' , '6943' , '6944' , '6945' , '6946' , '6947' , '6948' , '6949' , & '6950' , '6951' , '6952' , '6953' , '6954' , '6955' , '6956' , '6957' , '6958' , '6959' , & '6960' , '6961' , '6962' , '6963' , '6964' , '6965' , '6966' , '6967' , '6968' , '6969' , & '6970' , '6971' , '6972' , '6973' , '6974' , '6975' , '6976' , '6977' , '6978' , '6979' , & '6980' , '6981' , '6982' , '6983' , '6984' , '6985' , '6986' , '6987' , '6988' , '6989' , & '6990' , '6991' , '6992' , '6993' , '6994' , '6995' , '6996' , '6997' , '6998' , '6999' , & '7000' , '7001' , '7002' , '7003' , '7004' , '7005' , '7006' , '7007' , '7008' , '7009' , & '7010' , '7011' , '7012' , '7013' , '7014' , '7015' , '7016' , '7017' , '7018' , '7019' , & '7020' , '7021' , '7022' , '7023' , '7024' , '7025' , '7026' , '7027' , '7028' , '7029' , & '7030' , '7031' , '7032' , '7033' , '7034' , '7035' , '7036' , '7037' , '7038' , '7039' , & '7040' , '7041' , '7042' , '7043' , '7044' , '7045' , '7046' , '7047' , '7048' , '7049' , & '7050' , '7051' , '7052' , '7053' , '7054' , '7055' , '7056' , '7057' , '7058' , '7059' , & '7060' , '7061' , '7062' , '7063' , '7064' , '7065' , '7066' , '7067' , '7068' , '7069' , & '7070' , '7071' , '7072' , '7073' , '7074' , '7075' , '7076' , '7077' , '7078' , '7079' , & '7080' , '7081' , '7082' , '7083' , '7084' , '7085' , '7086' , '7087' , '7088' , '7089' , & '7090' , '7091' , '7092' , '7093' , '7094' , '7095' , '7096' , '7097' , '7098' , '7099' , & '7100' , '7101' , '7102' , '7103' , '7104' , '7105' , '7106' , '7107' , '7108' , '7109' , & '7110' , '7111' , '7112' , '7113' , '7114' , '7115' , '7116' , '7117' , '7118' , '7119' , & '7120' , '7121' , '7122' , '7123' , '7124' , '7125' , '7126' , '7127' , '7128' , '7129' , & '7130' , '7131' , '7132' , '7133' , '7134' , '7135' , '7136' , '7137' , '7138' , '7139' , & '7140' , '7141' , '7142' , '7143' , '7144' , '7145' , '7146' , '7147' , '7148' , '7149' , & '7150' , '7151' , '7152' , '7153' , '7154' , '7155' , '7156' , '7157' , '7158' , '7159' , & '7160' , '7161' , '7162' , '7163' , '7164' , '7165' , '7166' , '7167' , '7168' , '7169' , & '7170' , '7171' , '7172' , '7173' , '7174' , '7175' , '7176' , '7177' , '7178' , '7179' , & '7180' , '7181' , '7182' , '7183' , '7184' , '7185' , '7186' , '7187' , '7188' , '7189' , & '7190' , '7191' , '7192' , '7193' , '7194' , '7195' , '7196' , '7197' , '7198' , '7199' , & '7200' , '7201' , '7202' , '7203' , '7204' , '7205' , '7206' , '7207' , '7208' , '7209' , & '7210' , '7211' , '7212' , '7213' , '7214' , '7215' , '7216' , '7217' , '7218' , '7219' , & '7220' , '7221' , '7222' , '7223' , '7224' , '7225' , '7226' , '7227' , '7228' , '7229' , & '7230' , '7231' , '7232' , '7233' , '7234' , '7235' , '7236' , '7237' , '7238' , '7239' , & '7240' , '7241' , '7242' , '7243' , '7244' , '7245' , '7246' , '7247' , '7248' , '7249' , & '7250' , '7251' , '7252' , '7253' , '7254' , '7255' , '7256' , '7257' , '7258' , '7259' , & '7260' , '7261' , '7262' , '7263' , '7264' , '7265' , '7266' , '7267' , '7268' , '7269' , & '7270' , '7271' , '7272' , '7273' , '7274' , '7275' , '7276' , '7277' , '7278' , '7279' , & '7280' , '7281' , '7282' , '7283' , '7284' , '7285' , '7286' , '7287' , '7288' , '7289' , & '7290' , '7291' , '7292' , '7293' , '7294' , '7295' , '7296' , '7297' , '7298' , '7299' , & '7300' , '7301' , '7302' , '7303' , '7304' , '7305' , '7306' , '7307' , '7308' , '7309' , & '7310' , '7311' , '7312' , '7313' , '7314' , '7315' , '7316' , '7317' , '7318' , '7319' , & '7320' , '7321' , '7322' , '7323' , '7324' , '7325' , '7326' , '7327' , '7328' , '7329' , & '7330' , '7331' , '7332' , '7333' , '7334' , '7335' , '7336' , '7337' , '7338' , '7339' , & '7340' , '7341' , '7342' , '7343' , '7344' , '7345' , '7346' , '7347' , '7348' , '7349' , & '7350' , '7351' , '7352' , '7353' , '7354' , '7355' , '7356' , '7357' , '7358' , '7359' , & '7360' , '7361' , '7362' , '7363' , '7364' , '7365' , '7366' , '7367' , '7368' , '7369' , & '7370' , '7371' , '7372' , '7373' , '7374' , '7375' , '7376' , '7377' , '7378' , '7379' , & '7380' , '7381' , '7382' , '7383' , '7384' , '7385' , '7386' , '7387' , '7388' , '7389' , & '7390' , '7391' , '7392' , '7393' , '7394' , '7395' , '7396' , '7397' , '7398' , '7399' , & '7400' , '7401' , '7402' , '7403' , '7404' , '7405' , '7406' , '7407' , '7408' , '7409' , & '7410' , '7411' , '7412' , '7413' , '7414' , '7415' , '7416' , '7417' , '7418' , '7419' , & '7420' , '7421' , '7422' , '7423' , '7424' , '7425' , '7426' , '7427' , '7428' , '7429' , & '7430' , '7431' , '7432' , '7433' , '7434' , '7435' , '7436' , '7437' , '7438' , '7439' , & '7440' , '7441' , '7442' , '7443' , '7444' , '7445' , '7446' , '7447' , '7448' , '7449' , & '7450' , '7451' , '7452' , '7453' , '7454' , '7455' , '7456' , '7457' , '7458' , '7459' , & '7460' , '7461' , '7462' , '7463' , '7464' , '7465' , '7466' , '7467' , '7468' , '7469' , & '7470' , '7471' , '7472' , '7473' , '7474' , '7475' , '7476' , '7477' , '7478' , '7479' , & '7480' , '7481' , '7482' , '7483' , '7484' , '7485' , '7486' , '7487' , '7488' , '7489' , & '7490' , '7491' , '7492' , '7493' , '7494' , '7495' , '7496' , '7497' , '7498' , '7499' , & '7500' , '7501' , '7502' , '7503' , '7504' , '7505' , '7506' , '7507' , '7508' , '7509' , & '7510' , '7511' , '7512' , '7513' , '7514' , '7515' , '7516' , '7517' , '7518' , '7519' , & '7520' , '7521' , '7522' , '7523' , '7524' , '7525' , '7526' , '7527' , '7528' , '7529' , & '7530' , '7531' , '7532' , '7533' , '7534' , '7535' , '7536' , '7537' , '7538' , '7539' , & '7540' , '7541' , '7542' , '7543' , '7544' , '7545' , '7546' , '7547' , '7548' , '7549' , & '7550' , '7551' , '7552' , '7553' , '7554' , '7555' , '7556' , '7557' , '7558' , '7559' , & '7560' , '7561' , '7562' , '7563' , '7564' , '7565' , '7566' , '7567' , '7568' , '7569' , & '7570' , '7571' , '7572' , '7573' , '7574' , '7575' , '7576' , '7577' , '7578' , '7579' , & '7580' , '7581' , '7582' , '7583' , '7584' , '7585' , '7586' , '7587' , '7588' , '7589' , & '7590' , '7591' , '7592' , '7593' , '7594' , '7595' , '7596' , '7597' , '7598' , '7599' , & '7600' , '7601' , '7602' , '7603' , '7604' , '7605' , '7606' , '7607' , '7608' , '7609' , & '7610' , '7611' , '7612' , '7613' , '7614' , '7615' , '7616' , '7617' , '7618' , '7619' , & '7620' , '7621' , '7622' , '7623' , '7624' , '7625' , '7626' , '7627' , '7628' , '7629' , & '7630' , '7631' , '7632' , '7633' , '7634' , '7635' , '7636' , '7637' , '7638' , '7639' , & '7640' , '7641' , '7642' , '7643' , '7644' , '7645' , '7646' , '7647' , '7648' , '7649' , & '7650' , '7651' , '7652' , '7653' , '7654' , '7655' , '7656' , '7657' , '7658' , '7659' , & '7660' , '7661' , '7662' , '7663' , '7664' , '7665' , '7666' , '7667' , '7668' , '7669' , & '7670' , '7671' , '7672' , '7673' , '7674' , '7675' , '7676' , '7677' , '7678' , '7679' , & '7680' , '7681' , '7682' , '7683' , '7684' , '7685' , '7686' , '7687' , '7688' , '7689' , & '7690' , '7691' , '7692' , '7693' , '7694' , '7695' , '7696' , '7697' , '7698' , '7699' , & '7700' , '7701' , '7702' , '7703' , '7704' , '7705' , '7706' , '7707' , '7708' , '7709' , & '7710' , '7711' , '7712' , '7713' , '7714' , '7715' , '7716' , '7717' , '7718' , '7719' , & '7720' , '7721' , '7722' , '7723' , '7724' , '7725' , '7726' , '7727' , '7728' , '7729' , & '7730' , '7731' , '7732' , '7733' , '7734' , '7735' , '7736' , '7737' , '7738' , '7739' , & '7740' , '7741' , '7742' , '7743' , '7744' , '7745' , '7746' , '7747' , '7748' , '7749' , & '7750' , '7751' , '7752' , '7753' , '7754' , '7755' , '7756' , '7757' , '7758' , '7759' , & '7760' , '7761' , '7762' , '7763' , '7764' , '7765' , '7766' , '7767' , '7768' , '7769' , & '7770' , '7771' , '7772' , '7773' , '7774' , '7775' , '7776' , '7777' , '7778' , '7779' , & '7780' , '7781' , '7782' , '7783' , '7784' , '7785' , '7786' , '7787' , '7788' , '7789' , & '7790' , '7791' , '7792' , '7793' , '7794' , '7795' , '7796' , '7797' , '7798' , '7799' , & '7800' , '7801' , '7802' , '7803' , '7804' , '7805' , '7806' , '7807' , '7808' , '7809' , & '7810' , '7811' , '7812' , '7813' , '7814' , '7815' , '7816' , '7817' , '7818' , '7819' , & '7820' , '7821' , '7822' , '7823' , '7824' , '7825' , '7826' , '7827' , '7828' , '7829' , & '7830' , '7831' , '7832' , '7833' , '7834' , '7835' , '7836' , '7837' , '7838' , '7839' , & '7840' , '7841' , '7842' , '7843' , '7844' , '7845' , '7846' , '7847' , '7848' , '7849' , & '7850' , '7851' , '7852' , '7853' , '7854' , '7855' , '7856' , '7857' , '7858' , '7859' , & '7860' , '7861' , '7862' , '7863' , '7864' , '7865' , '7866' , '7867' , '7868' , '7869' , & '7870' , '7871' , '7872' , '7873' , '7874' , '7875' , '7876' , '7877' , '7878' , '7879' , & '7880' , '7881' , '7882' , '7883' , '7884' , '7885' , '7886' , '7887' , '7888' , '7889' , & '7890' , '7891' , '7892' , '7893' , '7894' , '7895' , '7896' , '7897' , '7898' , '7899' , & '7900' , '7901' , '7902' , '7903' , '7904' , '7905' , '7906' , '7907' , '7908' , '7909' , & '7910' , '7911' , '7912' , '7913' , '7914' , '7915' , '7916' , '7917' , '7918' , '7919' , & '7920' , '7921' , '7922' , '7923' , '7924' , '7925' , '7926' , '7927' , '7928' , '7929' , & '7930' , '7931' , '7932' , '7933' , '7934' , '7935' , '7936' , '7937' , '7938' , '7939' , & '7940' , '7941' , '7942' , '7943' , '7944' , '7945' , '7946' , '7947' , '7948' , '7949' , & '7950' , '7951' , '7952' , '7953' , '7954' , '7955' , '7956' , '7957' , '7958' , '7959' , & '7960' , '7961' , '7962' , '7963' , '7964' , '7965' , '7966' , '7967' , '7968' , '7969' , & '7970' , '7971' , '7972' , '7973' , '7974' , '7975' , '7976' , '7977' , '7978' , '7979' , & '7980' , '7981' , '7982' , '7983' , '7984' , '7985' , '7986' , '7987' , '7988' , '7989' , & '7990' , '7991' , '7992' , '7993' , '7994' , '7995' , '7996' , '7997' , '7998' , '7999' , & '8000' , '8001' , '8002' , '8003' , '8004' , '8005' , '8006' , '8007' , '8008' , '8009' , & '8010' , '8011' , '8012' , '8013' , '8014' , '8015' , '8016' , '8017' , '8018' , '8019' , & '8020' , '8021' , '8022' , '8023' , '8024' , '8025' , '8026' , '8027' , '8028' , '8029' , & '8030' , '8031' , '8032' , '8033' , '8034' , '8035' , '8036' , '8037' , '8038' , '8039' , & '8040' , '8041' , '8042' , '8043' , '8044' , '8045' , '8046' , '8047' , '8048' , '8049' , & '8050' , '8051' , '8052' , '8053' , '8054' , '8055' , '8056' , '8057' , '8058' , '8059' , & '8060' , '8061' , '8062' , '8063' , '8064' , '8065' , '8066' , '8067' , '8068' , '8069' , & '8070' , '8071' , '8072' , '8073' , '8074' , '8075' , '8076' , '8077' , '8078' , '8079' , & '8080' , '8081' , '8082' , '8083' , '8084' , '8085' , '8086' , '8087' , '8088' , '8089' , & '8090' , '8091' , '8092' , '8093' , '8094' , '8095' , '8096' , '8097' , '8098' , '8099' , & '8100' , '8101' , '8102' , '8103' , '8104' , '8105' , '8106' , '8107' , '8108' , '8109' , & '8110' , '8111' , '8112' , '8113' , '8114' , '8115' , '8116' , '8117' , '8118' , '8119' , & '8120' , '8121' , '8122' , '8123' , '8124' , '8125' , '8126' , '8127' , '8128' , '8129' , & '8130' , '8131' , '8132' , '8133' , '8134' , '8135' , '8136' , '8137' , '8138' , '8139' , & '8140' , '8141' , '8142' , '8143' , '8144' , '8145' , '8146' , '8147' , '8148' , '8149' , & '8150' , '8151' , '8152' , '8153' , '8154' , '8155' , '8156' , '8157' , '8158' , '8159' , & '8160' , '8161' , '8162' , '8163' , '8164' , '8165' , '8166' , '8167' , '8168' , '8169' , & '8170' , '8171' , '8172' , '8173' , '8174' , '8175' , '8176' , '8177' , '8178' , '8179' , & '8180' , '8181' , '8182' , '8183' , '8184' , '8185' , '8186' , '8187' , '8188' , '8189' , & '8190' , '8191' , '8192' , '8193' , '8194' , '8195' , '8196' , '8197' , '8198' , '8199' , & '8200' , '8201' , '8202' , '8203' , '8204' , '8205' , '8206' , '8207' , '8208' , '8209' , & '8210' , '8211' , '8212' , '8213' , '8214' , '8215' , '8216' , '8217' , '8218' , '8219' , & '8220' , '8221' , '8222' , '8223' , '8224' , '8225' , '8226' , '8227' , '8228' , '8229' , & '8230' , '8231' , '8232' , '8233' , '8234' , '8235' , '8236' , '8237' , '8238' , '8239' , & '8240' , '8241' , '8242' , '8243' , '8244' , '8245' , '8246' , '8247' , '8248' , '8249' , & '8250' , '8251' , '8252' , '8253' , '8254' , '8255' , '8256' , '8257' , '8258' , '8259' , & '8260' , '8261' , '8262' , '8263' , '8264' , '8265' , '8266' , '8267' , '8268' , '8269' , & '8270' , '8271' , '8272' , '8273' , '8274' , '8275' , '8276' , '8277' , '8278' , '8279' , & '8280' , '8281' , '8282' , '8283' , '8284' , '8285' , '8286' , '8287' , '8288' , '8289' , & '8290' , '8291' , '8292' , '8293' , '8294' , '8295' , '8296' , '8297' , '8298' , '8299' , & '8300' , '8301' , '8302' , '8303' , '8304' , '8305' , '8306' , '8307' , '8308' , '8309' , & '8310' , '8311' , '8312' , '8313' , '8314' , '8315' , '8316' , '8317' , '8318' , '8319' , & '8320' , '8321' , '8322' , '8323' , '8324' , '8325' , '8326' , '8327' , '8328' , '8329' , & '8330' , '8331' , '8332' , '8333' , '8334' , '8335' , '8336' , '8337' , '8338' , '8339' , & '8340' , '8341' , '8342' , '8343' , '8344' , '8345' , '8346' , '8347' , '8348' , '8349' , & '8350' , '8351' , '8352' , '8353' , '8354' , '8355' , '8356' , '8357' , '8358' , '8359' , & '8360' , '8361' , '8362' , '8363' , '8364' , '8365' , '8366' , '8367' , '8368' , '8369' , & '8370' , '8371' , '8372' , '8373' , '8374' , '8375' , '8376' , '8377' , '8378' , '8379' , & '8380' , '8381' , '8382' , '8383' , '8384' , '8385' , '8386' , '8387' , '8388' , '8389' , & '8390' , '8391' , '8392' , '8393' , '8394' , '8395' , '8396' , '8397' , '8398' , '8399' , & '8400' , '8401' , '8402' , '8403' , '8404' , '8405' , '8406' , '8407' , '8408' , '8409' , & '8410' , '8411' , '8412' , '8413' , '8414' , '8415' , '8416' , '8417' , '8418' , '8419' , & '8420' , '8421' , '8422' , '8423' , '8424' , '8425' , '8426' , '8427' , '8428' , '8429' , & '8430' , '8431' , '8432' , '8433' , '8434' , '8435' , '8436' , '8437' , '8438' , '8439' , & '8440' , '8441' , '8442' , '8443' , '8444' , '8445' , '8446' , '8447' , '8448' , '8449' , & '8450' , '8451' , '8452' , '8453' , '8454' , '8455' , '8456' , '8457' , '8458' , '8459' , & '8460' , '8461' , '8462' , '8463' , '8464' , '8465' , '8466' , '8467' , '8468' , '8469' , & '8470' , '8471' , '8472' , '8473' , '8474' , '8475' , '8476' , '8477' , '8478' , '8479' , & '8480' , '8481' , '8482' , '8483' , '8484' , '8485' , '8486' , '8487' , '8488' , '8489' , & '8490' , '8491' , '8492' , '8493' , '8494' , '8495' , '8496' , '8497' , '8498' , '8499' , & '8500' , '8501' , '8502' , '8503' , '8504' , '8505' , '8506' , '8507' , '8508' , '8509' , & '8510' , '8511' , '8512' , '8513' , '8514' , '8515' , '8516' , '8517' , '8518' , '8519' , & '8520' , '8521' , '8522' , '8523' , '8524' , '8525' , '8526' , '8527' , '8528' , '8529' , & '8530' , '8531' , '8532' , '8533' , '8534' , '8535' , '8536' , '8537' , '8538' , '8539' , & '8540' , '8541' , '8542' , '8543' , '8544' , '8545' , '8546' , '8547' , '8548' , '8549' , & '8550' , '8551' , '8552' , '8553' , '8554' , '8555' , '8556' , '8557' , '8558' , '8559' , & '8560' , '8561' , '8562' , '8563' , '8564' , '8565' , '8566' , '8567' , '8568' , '8569' , & '8570' , '8571' , '8572' , '8573' , '8574' , '8575' , '8576' , '8577' , '8578' , '8579' , & '8580' , '8581' , '8582' , '8583' , '8584' , '8585' , '8586' , '8587' , '8588' , '8589' , & '8590' , '8591' , '8592' , '8593' , '8594' , '8595' , '8596' , '8597' , '8598' , '8599' , & '8600' , '8601' , '8602' , '8603' , '8604' , '8605' , '8606' , '8607' , '8608' , '8609' , & '8610' , '8611' , '8612' , '8613' , '8614' , '8615' , '8616' , '8617' , '8618' , '8619' , & '8620' , '8621' , '8622' , '8623' , '8624' , '8625' , '8626' , '8627' , '8628' , '8629' , & '8630' , '8631' , '8632' , '8633' , '8634' , '8635' , '8636' , '8637' , '8638' , '8639' , & '8640' , '8641' , '8642' , '8643' , '8644' , '8645' , '8646' , '8647' , '8648' , '8649' , & '8650' , '8651' , '8652' , '8653' , '8654' , '8655' , '8656' , '8657' , '8658' , '8659' , & '8660' , '8661' , '8662' , '8663' , '8664' , '8665' , '8666' , '8667' , '8668' , '8669' , & '8670' , '8671' , '8672' , '8673' , '8674' , '8675' , '8676' , '8677' , '8678' , '8679' , & '8680' , '8681' , '8682' , '8683' , '8684' , '8685' , '8686' , '8687' , '8688' , '8689' , & '8690' , '8691' , '8692' , '8693' , '8694' , '8695' , '8696' , '8697' , '8698' , '8699' , & '8700' , '8701' , '8702' , '8703' , '8704' , '8705' , '8706' , '8707' , '8708' , '8709' , & '8710' , '8711' , '8712' , '8713' , '8714' , '8715' , '8716' , '8717' , '8718' , '8719' , & '8720' , '8721' , '8722' , '8723' , '8724' , '8725' , '8726' , '8727' , '8728' , '8729' , & '8730' , '8731' , '8732' , '8733' , '8734' , '8735' , '8736' , '8737' , '8738' , '8739' , & '8740' , '8741' , '8742' , '8743' , '8744' , '8745' , '8746' , '8747' , '8748' , '8749' , & '8750' , '8751' , '8752' , '8753' , '8754' , '8755' , '8756' , '8757' , '8758' , '8759' , & '8760' , '8761' , '8762' , '8763' , '8764' , '8765' , '8766' , '8767' , '8768' , '8769' , & '8770' , '8771' , '8772' , '8773' , '8774' , '8775' , '8776' , '8777' , '8778' , '8779' , & '8780' , '8781' , '8782' , '8783' , '8784' , '8785' , '8786' , '8787' , '8788' , '8789' , & '8790' , '8791' , '8792' , '8793' , '8794' , '8795' , '8796' , '8797' , '8798' , '8799' , & '8800' , '8801' , '8802' , '8803' , '8804' , '8805' , '8806' , '8807' , '8808' , '8809' , & '8810' , '8811' , '8812' , '8813' , '8814' , '8815' , '8816' , '8817' , '8818' , '8819' , & '8820' , '8821' , '8822' , '8823' , '8824' , '8825' , '8826' , '8827' , '8828' , '8829' , & '8830' , '8831' , '8832' , '8833' , '8834' , '8835' , '8836' , '8837' , '8838' , '8839' , & '8840' , '8841' , '8842' , '8843' , '8844' , '8845' , '8846' , '8847' , '8848' , '8849' , & '8850' , '8851' , '8852' , '8853' , '8854' , '8855' , '8856' , '8857' , '8858' , '8859' , & '8860' , '8861' , '8862' , '8863' , '8864' , '8865' , '8866' , '8867' , '8868' , '8869' , & '8870' , '8871' , '8872' , '8873' , '8874' , '8875' , '8876' , '8877' , '8878' , '8879' , & '8880' , '8881' , '8882' , '8883' , '8884' , '8885' , '8886' , '8887' , '8888' , '8889' , & '8890' , '8891' , '8892' , '8893' , '8894' , '8895' , '8896' , '8897' , '8898' , '8899' , & '8900' , '8901' , '8902' , '8903' , '8904' , '8905' , '8906' , '8907' , '8908' , '8909' , & '8910' , '8911' , '8912' , '8913' , '8914' , '8915' , '8916' , '8917' , '8918' , '8919' , & '8920' , '8921' , '8922' , '8923' , '8924' , '8925' , '8926' , '8927' , '8928' , '8929' , & '8930' , '8931' , '8932' , '8933' , '8934' , '8935' , '8936' , '8937' , '8938' , '8939' , & '8940' , '8941' , '8942' , '8943' , '8944' , '8945' , '8946' , '8947' , '8948' , '8949' , & '8950' , '8951' , '8952' , '8953' , '8954' , '8955' , '8956' , '8957' , '8958' , '8959' , & '8960' , '8961' , '8962' , '8963' , '8964' , '8965' , '8966' , '8967' , '8968' , '8969' , & '8970' , '8971' , '8972' , '8973' , '8974' , '8975' , '8976' , '8977' , '8978' , '8979' , & '8980' , '8981' , '8982' , '8983' , '8984' , '8985' , '8986' , '8987' , '8988' , '8989' , & '8990' , '8991' , '8992' , '8993' , '8994' , '8995' , '8996' , '8997' , '8998' , '8999' , & '9000' , '9001' , '9002' , '9003' , '9004' , '9005' , '9006' , '9007' , '9008' , '9009' , & '9010' , '9011' , '9012' , '9013' , '9014' , '9015' , '9016' , '9017' , '9018' , '9019' , & '9020' , '9021' , '9022' , '9023' , '9024' , '9025' , '9026' , '9027' , '9028' , '9029' , & '9030' , '9031' , '9032' , '9033' , '9034' , '9035' , '9036' , '9037' , '9038' , '9039' , & '9040' , '9041' , '9042' , '9043' , '9044' , '9045' , '9046' , '9047' , '9048' , '9049' , & '9050' , '9051' , '9052' , '9053' , '9054' , '9055' , '9056' , '9057' , '9058' , '9059' , & '9060' , '9061' , '9062' , '9063' , '9064' , '9065' , '9066' , '9067' , '9068' , '9069' , & '9070' , '9071' , '9072' , '9073' , '9074' , '9075' , '9076' , '9077' , '9078' , '9079' , & '9080' , '9081' , '9082' , '9083' , '9084' , '9085' , '9086' , '9087' , '9088' , '9089' , & '9090' , '9091' , '9092' , '9093' , '9094' , '9095' , '9096' , '9097' , '9098' , '9099' , & '9100' , '9101' , '9102' , '9103' , '9104' , '9105' , '9106' , '9107' , '9108' , '9109' , & '9110' , '9111' , '9112' , '9113' , '9114' , '9115' , '9116' , '9117' , '9118' , '9119' , & '9120' , '9121' , '9122' , '9123' , '9124' , '9125' , '9126' , '9127' , '9128' , '9129' , & '9130' , '9131' , '9132' , '9133' , '9134' , '9135' , '9136' , '9137' , '9138' , '9139' , & '9140' , '9141' , '9142' , '9143' , '9144' , '9145' , '9146' , '9147' , '9148' , '9149' , & '9150' , '9151' , '9152' , '9153' , '9154' , '9155' , '9156' , '9157' , '9158' , '9159' , & '9160' , '9161' , '9162' , '9163' , '9164' , '9165' , '9166' , '9167' , '9168' , '9169' , & '9170' , '9171' , '9172' , '9173' , '9174' , '9175' , '9176' , '9177' , '9178' , '9179' , & '9180' , '9181' , '9182' , '9183' , '9184' , '9185' , '9186' , '9187' , '9188' , '9189' , & '9190' , '9191' , '9192' , '9193' , '9194' , '9195' , '9196' , '9197' , '9198' , '9199' , & '9200' , '9201' , '9202' , '9203' , '9204' , '9205' , '9206' , '9207' , '9208' , '9209' , & '9210' , '9211' , '9212' , '9213' , '9214' , '9215' , '9216' , '9217' , '9218' , '9219' , & '9220' , '9221' , '9222' , '9223' , '9224' , '9225' , '9226' , '9227' , '9228' , '9229' , & '9230' , '9231' , '9232' , '9233' , '9234' , '9235' , '9236' , '9237' , '9238' , '9239' , & '9240' , '9241' , '9242' , '9243' , '9244' , '9245' , '9246' , '9247' , '9248' , '9249' , & '9250' , '9251' , '9252' , '9253' , '9254' , '9255' , '9256' , '9257' , '9258' , '9259' , & '9260' , '9261' , '9262' , '9263' , '9264' , '9265' , '9266' , '9267' , '9268' , '9269' , & '9270' , '9271' , '9272' , '9273' , '9274' , '9275' , '9276' , '9277' , '9278' , '9279' , & '9280' , '9281' , '9282' , '9283' , '9284' , '9285' , '9286' , '9287' , '9288' , '9289' , & '9290' , '9291' , '9292' , '9293' , '9294' , '9295' , '9296' , '9297' , '9298' , '9299' , & '9300' , '9301' , '9302' , '9303' , '9304' , '9305' , '9306' , '9307' , '9308' , '9309' , & '9310' , '9311' , '9312' , '9313' , '9314' , '9315' , '9316' , '9317' , '9318' , '9319' , & '9320' , '9321' , '9322' , '9323' , '9324' , '9325' , '9326' , '9327' , '9328' , '9329' , & '9330' , '9331' , '9332' , '9333' , '9334' , '9335' , '9336' , '9337' , '9338' , '9339' , & '9340' , '9341' , '9342' , '9343' , '9344' , '9345' , '9346' , '9347' , '9348' , '9349' , & '9350' , '9351' , '9352' , '9353' , '9354' , '9355' , '9356' , '9357' , '9358' , '9359' , & '9360' , '9361' , '9362' , '9363' , '9364' , '9365' , '9366' , '9367' , '9368' , '9369' , & '9370' , '9371' , '9372' , '9373' , '9374' , '9375' , '9376' , '9377' , '9378' , '9379' , & '9380' , '9381' , '9382' , '9383' , '9384' , '9385' , '9386' , '9387' , '9388' , '9389' , & '9390' , '9391' , '9392' , '9393' , '9394' , '9395' , '9396' , '9397' , '9398' , '9399' , & '9400' , '9401' , '9402' , '9403' , '9404' , '9405' , '9406' , '9407' , '9408' , '9409' , & '9410' , '9411' , '9412' , '9413' , '9414' , '9415' , '9416' , '9417' , '9418' , '9419' , & '9420' , '9421' , '9422' , '9423' , '9424' , '9425' , '9426' , '9427' , '9428' , '9429' , & '9430' , '9431' , '9432' , '9433' , '9434' , '9435' , '9436' , '9437' , '9438' , '9439' , & '9440' , '9441' , '9442' , '9443' , '9444' , '9445' , '9446' , '9447' , '9448' , '9449' , & '9450' , '9451' , '9452' , '9453' , '9454' , '9455' , '9456' , '9457' , '9458' , '9459' , & '9460' , '9461' , '9462' , '9463' , '9464' , '9465' , '9466' , '9467' , '9468' , '9469' , & '9470' , '9471' , '9472' , '9473' , '9474' , '9475' , '9476' , '9477' , '9478' , '9479' , & '9480' , '9481' , '9482' , '9483' , '9484' , '9485' , '9486' , '9487' , '9488' , '9489' , & '9490' , '9491' , '9492' , '9493' , '9494' , '9495' , '9496' , '9497' , '9498' , '9499' , & '9500' , '9501' , '9502' , '9503' , '9504' , '9505' , '9506' , '9507' , '9508' , '9509' , & '9510' , '9511' , '9512' , '9513' , '9514' , '9515' , '9516' , '9517' , '9518' , '9519' , & '9520' , '9521' , '9522' , '9523' , '9524' , '9525' , '9526' , '9527' , '9528' , '9529' , & '9530' , '9531' , '9532' , '9533' , '9534' , '9535' , '9536' , '9537' , '9538' , '9539' , & '9540' , '9541' , '9542' , '9543' , '9544' , '9545' , '9546' , '9547' , '9548' , '9549' , & '9550' , '9551' , '9552' , '9553' , '9554' , '9555' , '9556' , '9557' , '9558' , '9559' , & '9560' , '9561' , '9562' , '9563' , '9564' , '9565' , '9566' , '9567' , '9568' , '9569' , & '9570' , '9571' , '9572' , '9573' , '9574' , '9575' , '9576' , '9577' , '9578' , '9579' , & '9580' , '9581' , '9582' , '9583' , '9584' , '9585' , '9586' , '9587' , '9588' , '9589' , & '9590' , '9591' , '9592' , '9593' , '9594' , '9595' , '9596' , '9597' , '9598' , '9599' , & '9600' , '9601' , '9602' , '9603' , '9604' , '9605' , '9606' , '9607' , '9608' , '9609' , & '9610' , '9611' , '9612' , '9613' , '9614' , '9615' , '9616' , '9617' , '9618' , '9619' , & '9620' , '9621' , '9622' , '9623' , '9624' , '9625' , '9626' , '9627' , '9628' , '9629' , & '9630' , '9631' , '9632' , '9633' , '9634' , '9635' , '9636' , '9637' , '9638' , '9639' , & '9640' , '9641' , '9642' , '9643' , '9644' , '9645' , '9646' , '9647' , '9648' , '9649' , & '9650' , '9651' , '9652' , '9653' , '9654' , '9655' , '9656' , '9657' , '9658' , '9659' , & '9660' , '9661' , '9662' , '9663' , '9664' , '9665' , '9666' , '9667' , '9668' , '9669' , & '9670' , '9671' , '9672' , '9673' , '9674' , '9675' , '9676' , '9677' , '9678' , '9679' , & '9680' , '9681' , '9682' , '9683' , '9684' , '9685' , '9686' , '9687' , '9688' , '9689' , & '9690' , '9691' , '9692' , '9693' , '9694' , '9695' , '9696' , '9697' , '9698' , '9699' , & '9700' , '9701' , '9702' , '9703' , '9704' , '9705' , '9706' , '9707' , '9708' , '9709' , & '9710' , '9711' , '9712' , '9713' , '9714' , '9715' , '9716' , '9717' , '9718' , '9719' , & '9720' , '9721' , '9722' , '9723' , '9724' , '9725' , '9726' , '9727' , '9728' , '9729' , & '9730' , '9731' , '9732' , '9733' , '9734' , '9735' , '9736' , '9737' , '9738' , '9739' , & '9740' , '9741' , '9742' , '9743' , '9744' , '9745' , '9746' , '9747' , '9748' , '9749' , & '9750' , '9751' , '9752' , '9753' , '9754' , '9755' , '9756' , '9757' , '9758' , '9759' , & '9760' , '9761' , '9762' , '9763' , '9764' , '9765' , '9766' , '9767' , '9768' , '9769' , & '9770' , '9771' , '9772' , '9773' , '9774' , '9775' , '9776' , '9777' , '9778' , '9779' , & '9780' , '9781' , '9782' , '9783' , '9784' , '9785' , '9786' , '9787' , '9788' , '9789' , & '9790' , '9791' , '9792' , '9793' , '9794' , '9795' , '9796' , '9797' , '9798' , '9799' , & '9800' , '9801' , '9802' , '9803' , '9804' , '9805' , '9806' , '9807' , '9808' , '9809' , & '9810' , '9811' , '9812' , '9813' , '9814' , '9815' , '9816' , '9817' , '9818' , '9819' , & '9820' , '9821' , '9822' , '9823' , '9824' , '9825' , '9826' , '9827' , '9828' , '9829' , & '9830' , '9831' , '9832' , '9833' , '9834' , '9835' , '9836' , '9837' , '9838' , '9839' , & '9840' , '9841' , '9842' , '9843' , '9844' , '9845' , '9846' , '9847' , '9848' , '9849' , & '9850' , '9851' , '9852' , '9853' , '9854' , '9855' , '9856' , '9857' , '9858' , '9859' , & '9860' , '9861' , '9862' , '9863' , '9864' , '9865' , '9866' , '9867' , '9868' , '9869' , & '9870' , '9871' , '9872' , '9873' , '9874' , '9875' , '9876' , '9877' , '9878' , '9879' , & '9880' , '9881' , '9882' , '9883' , '9884' , '9885' , '9886' , '9887' , '9888' , '9889' , & '9890' , '9891' , '9892' , '9893' , '9894' , '9895' , '9896' , '9897' , '9898' , '9899' , & '9900' , '9901' , '9902' , '9903' , '9904' , '9905' , '9906' , '9907' , '9908' , '9909' , & '9910' , '9911' , '9912' , '9913' , '9914' , '9915' , '9916' , '9917' , '9918' , '9919' , & '9920' , '9921' , '9922' , '9923' , '9924' , '9925' , '9926' , '9927' , '9928' , '9929' , & '9930' , '9931' , '9932' , '9933' , '9934' , '9935' , '9936' , '9937' , '9938' , '9939' , & '9940' , '9941' , '9942' , '9943' , '9944' , '9945' , '9946' , '9947' , '9948' , '9949' , & '9950' , '9951' , '9952' , '9953' , '9954' , '9955' , '9956' , '9957' , '9958' , '9959' , & '9960' , '9961' , '9962' , '9963' , '9964' , '9965' , '9966' , '9967' , '9968' , '9969' , & '9970' , '9971' , '9972' , '9973' , '9974' , '9975' , '9976' , '9977' , '9978' , '9979' , & '9980' , '9981' , '9982' , '9983' , '9984' , '9985' , '9986' , '9987' , '9988' , '9989' , & '9990' , '9991' , '9992' , '9993' , '9994' , '9995' , '9996' , '9997' , '9998' , '9999' ] ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------------------------------- ! -----   parameters for high-precision decmial conversion algorithm  ----- ! ------------------------------------------------------------------------- !> The following three precomputed parameters speed up left shifts by having the number !   of new digits that will be added by multiplying 5&#94;i by 2&#94;i. If the number is less !   than 5&#94;i then it will add one fewer digit. There are only 60 entries since !   that's the max shift amount. INTEGER ( KIND = I4B ), PARAMETER :: LShift_Digits ( 0 : 60 ) = [ & 0 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , & 4 , 4 , 4 , 4 , 5 , 5 , 5 , 6 , 6 , 6 , & 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , & 10 , 10 , 10 , 10 , 11 , 11 , 11 , 12 , 12 , 12 , & 13 , 13 , 13 , 13 , 14 , 14 , 14 , 15 , 15 , 15 , & 16 , 16 , 16 , 16 , 17 , 17 , 17 , 18 , 18 , 18 , 19 ] INTEGER ( KIND = I4B ), PARAMETER :: LShift_Length ( 0 : 60 ) = [ & 0 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 7 , & 7 , 8 , 9 , 10 , 10 , 11 , 12 , 12 , 13 , 14 , & 14 , 15 , 16 , 17 , 17 , 18 , 19 , 19 , 20 , 21 , & 21 , 22 , 23 , 24 , 24 , 25 , 26 , 26 , 27 , 28 , & 28 , 29 , 30 , 31 , 31 , 32 , 33 , 33 , 34 , 35 , & 35 , 36 , 37 , 38 , 38 , 39 , 40 , 40 , 41 , 42 , 42 ] CHARACTER ( LEN = 42 ), PARAMETER :: LShift_PowFive ( 0 : 60 ) = [ & '                                          ' , & '5                                         ' , & '25                                        ' , & '125                                       ' , & '625                                       ' , & '3125                                      ' , & '15625                                     ' , & '78125                                     ' , & '390625                                    ' , & '1953125                                   ' , & '9765625                                   ' , & '48828125                                  ' , & '244140625                                 ' , & '1220703125                                ' , & '6103515625                                ' , & '30517578125                               ' , & '152587890625                              ' , & '762939453125                              ' , & '3814697265625                             ' , & '19073486328125                            ' , & '95367431640625                            ' , & '476837158203125                           ' , & '2384185791015625                          ' , & '11920928955078125                         ' , & '59604644775390625                         ' , & '298023223876953125                        ' , & '1490116119384765625                       ' , & '7450580596923828125                       ' , & '37252902984619140625                      ' , & '186264514923095703125                     ' , & '931322574615478515625                     ' , & '4656612873077392578125                    ' , & '23283064365386962890625                   ' , & '116415321826934814453125                  ' , & '582076609134674072265625                  ' , & '2910383045673370361328125                 ' , & '14551915228366851806640625                ' , & '72759576141834259033203125                ' , & '363797880709171295166015625               ' , & '1818989403545856475830078125              ' , & '9094947017729282379150390625              ' , & '45474735088646411895751953125             ' , & '227373675443232059478759765625            ' , & '1136868377216160297393798828125           ' , & '5684341886080801486968994140625           ' , & '28421709430404007434844970703125          ' , & '142108547152020037174224853515625         ' , & '710542735760100185871124267578125         ' , & '3552713678800500929355621337890625        ' , & '17763568394002504646778106689453125       ' , & '88817841970012523233890533447265625       ' , & '444089209850062616169452667236328125      ' , & '2220446049250313080847263336181640625     ' , & '11102230246251565404236316680908203125    ' , & '55511151231257827021181583404541015625    ' , & '277555756156289135105907917022705078125   ' , & '1387778780781445675529539585113525390625  ' , & '6938893903907228377647697925567626953125  ' , & '34694469519536141888238489627838134765625 ' , & '173472347597680709441192448139190673828125' , & '867361737988403547205962240695953369140625' ] !** DERIVED TYPE DEFINITIONS ! na !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE/GENERIC DEFINITIONS: ! na END MODULE ModBase_Tables_CharConv !******************************************************************************","tags":"","loc":"sourcefile\\modbase - tables - charconv.f90.html"},{"title":"ModBase - Integer - FromChar.f90 – FortCharConv","text":"Source Code MODULE ModBase_Integer_FromChar !&#94; **PURPOSE OF THIS MODULE**: ! This module contains routines that convert a decimal string into an integer value. ! !&#94; **REFERENCES**: ! [1] [Number Conversion Benchmark in C](https://github.com/ibireme/c_numconv_benchmark) ! !&#94; **TECHNICAL NOTES**: ! 1. A Fortran number (FortNum) that has the form as: [S]N[N...] where !       S is a sign indicator (required if negative '-', optional if positive '+'). !       N is a decimal digit (0 through 9). Any leading zeros, leading and trailing !           spaces are ignored. !    Unlike Fortran constants, the optional kind parameter (_k) is not allowed here. ! 2. A FortPlus number (FortPlus) has a slightly more relaxed rule than that of a Fortran !    number such that any invalid characters after characters that are valid are ignored. !    For example, -3567e23 is treated as a valid number with a value of -3567. ! 3. A JSON number (JsonNum) has a slightly stricter rule than that of a Fortran number !    such that a plus sign and leading zoroes are not allowed. !** USE STATEMENTS: USE ModBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! 32-bit integer PUBLIC :: I32_FromChar_CC_FortNum , I32_FromChar_CC_FortPlus PUBLIC :: I32_FromChar_CC_JsonNum , I32_FromChar_Lemire_FortPlus PUBLIC :: I32_FromChar_YY_JsonNum ! 64-bit integer PUBLIC :: I64_FromChar_CC_FortNum , I64_FromChar_CC_FortPlus PUBLIC :: I64_FromChar_CC_JsonNum , I64_FromChar_Lemire_FortPlus PUBLIC :: I64_FromChar_YY_JsonNum PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: INTEGER ( KIND = I4B ), PARAMETER :: MinI32 = INT ( Z '80000000' , KIND = I4B ) ! -2,147,483,648 INTEGER ( KIND = I4B ), PARAMETER :: MaxI32 = INT ( Z '7FFFFFFF' , KIND = I4B ) !  2,147,483,647 INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! -9,223,372,036,854,775,808 INTEGER ( KIND = I8B ), PARAMETER :: MaxI64 = INT ( Z '7FFFFFFFFFFFFFFF' , KIND = I8B ) !  9,223,372,036,854,775,807 INTEGER ( KIND = I4B ), PARAMETER :: MaxI32Div10 = MaxI32 / 10 ! = 214,748,364 INTEGER ( KIND = I4B ), PARAMETER :: MaxI32Mod10 = MOD ( MaxI32 , 10 ) ! = 7 INTEGER ( KIND = I8B ), PARAMETER :: MaxI64Div10 = MaxI64 / 10_I8B ! = 922,337,203,685,477,580 INTEGER ( KIND = I8B ), PARAMETER :: MaxI64Mod10 = MOD ( MaxI64 , 10_I8B ) ! = 7 INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI32 = 10 INTEGER ( KIND = I4B ), PARAMETER :: MaxDigitI64 = 19 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: A4 = IACHAR ( '4' ) INTEGER ( KIND = I4B ), PARAMETER :: A9 = IACHAR ( '9' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I8B ), PARAMETER :: LBase = 10_I8B !** DERIVED TYPE DEFINITIONS ! na !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE DEFINITIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                           32-BIT INTEGER ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I32_FromChar_CC_FortNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a Fortran number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for leading zero(s) Number = 0 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_CC_FortNum !****************************************************************************** FUNCTION I32_FromChar_CC_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for leading zero(s) Number = 0 IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_CC_FortPlus !****************************************************************************** FUNCTION I32_FromChar_CC_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN IF ( Indx == StrLen ) THEN Number = 0 ELSE CurChr => cStr ( Indx + 1 : Indx + 1 ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 ELSE Number = 0 END IF END IF RETURN END IF ! compute value of the input string Number = 0 IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_CC_JsonNum !****************************************************************************** FUNCTION I32_FromChar_Lemire_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IndxP7 INTEGER ( KIND = I4B ) :: Sign , StrLen INTEGER ( KIND = I4B ) :: IStart , NumDigit CHARACTER ( LEN = 1 ), POINTER :: CurChr CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0 RETURN END IF END IF ! initialize Number = 0 IStart = 0 NumDigit = 0 ! process 8 digits immediately if possible IndxP7 = Indx + 7 IF ( IndxP7 <= StrLen ) THEN wStr = cStr ( Indx : IndxP7 ) IF ( Is_Made_Of_Eight_Digits ( WVal )) THEN ! process 8 digits at once Number = INT ( Parse_Eight_Digits_Unrolled ( wVal ), KIND = I4B ) IStart = Indx NumDigit = 8 Indx = Indx + 8 END IF END IF ! process the remaining digits IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( IStart == 0 ) IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI32 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI32 ) THEN ! value might be in the applicable range IF ( Number < 0 ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1 ). AND .( Number == MinI32 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1 END IF ELSE IF ( IACHAR ( cStr ( IStart : IStart )) < A4 ) THEN ! no overflow Overflow = FalseVal ELSE ! overflow Overflow = TrueVal END IF END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I32_FromChar_Lemire_FortPlus !****************************************************************************** FUNCTION I32_FromChar_YY_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 32-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I4B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: ! Digit: '0' INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_ZERO = SHIFTL ( 1 , 0 ) ! 1 = Z'01' ! Digit: [1-9] INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_NONZERO = SHIFTL ( 1 , 1 ) ! 2 = Z'02' ! Digit type table (generate with misc/make_tables.c) INTEGER ( KIND = I1B ), PARAMETER :: DigitTable ( 0 : 127 ) = [ & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '04' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '08' , KIND = I1B ), INT ( Z '10' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '01' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IVal , Add INTEGER ( KIND = I4B ) :: Indx , StrLen , I INTEGER ( KIND = I4B ) :: Sign , SignBit INTEGER ( KIND = I4B ) :: CurCode ! ASCII code of current character LOGICAL ( KIND = 4 ) :: Digit_End , Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF END IF ! check for sign Sign = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 RETURN END IF ! check whether first digit is zero ! < for JSON number, the first digit being zero is not allowed. > CurCode = IACHAR ( cStr ( Indx : Indx )) IF (. NOT .( IAND ( DigitTable ( CurCode ), DIGI_TYPE_NONZERO ) /= 0 )) THEN IF ( CurCode == A0 ) THEN IF ( Indx + 1 > StrLen ) THEN Number = 0 ELSE IF (. NOT .( IAND ( DigitTable ( IACHAR ( cStr ( Indx + 1 : Indx + 1 ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Number = 0 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 END IF END IF ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI32 END IF RETURN END IF ! compute IVal for the next 8 characters (digits) IVal = CurCode - A0 I = 1 !DIR$ UNROLL = 8 DO IF ( Indx + I <= StrLen ) THEN CurCode = IACHAR ( cStr ( Indx + I : Indx + I )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN IVal = IVal * LBase + ( CurCode - A0 ) ELSE Digit_End = TrueVal EXIT END IF ELSE Digit_End = TrueVal EXIT END IF I = I + 1 IF ( I > 8 ) THEN Digit_End = FalseVal EXIT END IF END DO IF (( Digit_End ). OR .( Indx + I > StrLen )) THEN Number = INT ( IVal * Sign , KIND = I4B ) RETURN END IF ! deal with more digit(s) Indx = Indx + I CurCode = IACHAR ( cStr ( Indx : Indx )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN ! must check overflow Add = CurCode - A0 ! check overflow IF ( IVal < MaxI32Div10 ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN IF (( IAND ( DigitTable ( IACHAR ( cStr ( Indx : Indx ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF ELSE Overflow = FalseVal END IF ELSEIF ( IVal > MaxI32Div10 ) THEN Overflow = TrueVal ELSE ! IVal is equal to MaxI32Div10 SignBit = 0 IF ( Sign == - 1 ) SignBit = 1 IF ( Add > MaxI32Mod10 + SignBit ) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF END IF IF ( Overflow ) THEN ! overflow IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI32 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI32 END IF ELSE ! not overflow IVal = IVal * LBase + Add Number = INT ( IVal * Sign , KIND = I4B ) END IF ELSE ! not overflow Number = INT ( IVal * Sign , KIND = I4B ) END IF RETURN END FUNCTION I32_FromChar_YY_JsonNum !------------------------------------------------------------------------------ ! !                           64-BIT INTEGER ROUTINES ! !------------------------------------------------------------------------------ FUNCTION I64_FromChar_CC_FortNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a Fortran number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a non-digit character encountered.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_CC_FortNum !****************************************************************************** FUNCTION I64_FromChar_CC_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for leading zero(s) Number = 0_I8B IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! compute value of the input string IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_CC_FortPlus !****************************************************************************** FUNCTION I64_FromChar_CC_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: NumDigit INTEGER ( KIND = I4B ) :: IStart CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN IF ( Indx == StrLen ) THEN Number = 0_I8B ELSE CurChr => cStr ( Indx + 1 : Indx + 1 ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 ELSE Number = 0_I8B END IF END IF RETURN END IF ! compute value of the input string Number = 0_I8B IStart = 0 NumDigit = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * IBase + ( IACHAR ( CurChr ) - A0 ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_CC_JsonNum !****************************************************************************** FUNCTION I64_FromChar_Lemire_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a FortPlus number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IndxP7 , StrLen INTEGER ( KIND = I8B ) :: Sign INTEGER ( KIND = I4B ) :: IStart , NumDigit CHARACTER ( LEN = 1 ), POINTER :: CurChr CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) LOGICAL ( KIND = 4 ) :: Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the first digit is zero so loop through the following ! characters until a non-zero character is found Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Number = 0_I8B RETURN END IF END IF ! initialize Number = 0_I8B IStart = 0 NumDigit = 0 ! process 8 digits immediately if possible IndxP7 = Indx + 7 IF ( IndxP7 <= StrLen ) THEN wStr = cStr ( Indx : IndxP7 ) IF ( Is_Made_Of_Eight_Digits ( WVal )) THEN ! process 8 digits at once Number = Parse_Eight_Digits_Unrolled ( wVal ) IStart = Indx NumDigit = 8 Indx = Indx + 8 ! process another 8 digits immediately if possible IndxP7 = Indx + 7 IF ( IndxP7 <= StrLen ) THEN wStr = cStr ( Indx : IndxP7 ) IF ( Is_Made_Of_Eight_Digits ( WVal )) THEN ! process 8 digits at once Number = Number * 100000000_I8B + Parse_Eight_Digits_Unrolled ( wVal ) NumDigit = 16 Indx = Indx + 8 END IF END IF END IF END IF ! process the remaining digits IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN IF ( IStart == 0 ) IStart = Indx DO ! compute the value without checking if it will overflow ! we will check it after we process all the characters if valid Number = Number * LBase + INT ( IACHAR ( CurChr ) - A0 , KIND = I8B ) Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT END DO NumDigit = Indx - IStart END IF END IF ! now, we have a valid string so check if the value is in the applicable range IF ( NumDigit < MaxDigitI64 ) THEN ! value is in the applicable range Overflow = FalseVal ELSEIF ( NumDigit == MaxDigitI64 ) THEN ! value might be in the applicable range IF ( Number < 0_I8B ) THEN ! overflow occurs Overflow = TrueVal IF (( Sign /= 1_I8B ). AND .( Number == MinI64 )) THEN ! actually not overflow Overflow = FalseVal Sign = 1_I8B END IF ELSE ! no overflow Overflow = FalseVal END IF ELSE ! value is out of the applicable range Overflow = TrueVal END IF IF ( Overflow ) THEN IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE Number = Number * Sign END IF RETURN END FUNCTION I64_FromChar_Lemire_FortPlus !****************************************************************************** FUNCTION I64_FromChar_YY_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: !! To convert a decimal string to a 64-bit integer by interpreting the string as a JSON number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr !! character string LOGICAL ( KIND = 4 ), OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid INTEGER ( KIND = I8B ) :: Number !! number !** SUBROUTINE PARAMETER DECLARATIONS: ! Digit: '0' INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_ZERO = SHIFTL ( 1 , 0 ) ! 1 = Z'01' ! Digit: [1-9] INTEGER ( KIND = I1B ), PARAMETER :: DIGI_TYPE_NONZERO = SHIFTL ( 1 , 1 ) ! 2 = Z'02' ! Digit type table (generate with misc/make_tables.c) INTEGER ( KIND = I1B ), PARAMETER :: DigitTable ( 0 : 127 ) = [ & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '04' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '08' , KIND = I1B ), INT ( Z '10' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '01' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), & INT ( Z '02' , KIND = I1B ), INT ( Z '02' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), & INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B ), INT ( Z '00' , KIND = I1B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IVal , Add INTEGER ( KIND = I4B ) :: Indx , StrLen , I INTEGER ( KIND = I8B ) :: Sign , SignBit INTEGER ( KIND = I4B ) :: CurCode ! ASCII code of current character LOGICAL :: Digit_End , Overflow !** FLOW ! get valid string length by removing the trailing space(s) StrLen = LEN_TRIM ( cStr ) IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF END IF ! check for sign Sign = 1_I8B IF ( cStr ( Indx : Indx ) == '-' ) THEN Sign = - 1_I8B Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ELSEIF ( cStr ( Indx : Indx ) == '+' ) THEN ! < for JSON number, a plus sign is not allowed. > IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a plus sign is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 RETURN END IF ! check whether first digit is zero ! < for JSON number, the first digit being zero is not allowed. > CurCode = IACHAR ( cStr ( Indx : Indx )) IF (. NOT .( IAND ( DigitTable ( CurCode ), DIGI_TYPE_NONZERO ) /= 0 )) THEN IF ( CurCode == A0 ) THEN IF ( Indx + 1 > StrLen ) THEN Number = 0_I8B ELSE IF (. NOT .( IAND ( DigitTable ( IACHAR ( cStr ( Indx + 1 : Indx + 1 ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Number = 0_I8B ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is not allowed.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 END IF END IF ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: the first character is not a digit.' IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal Number = MinI64 END IF RETURN END IF ! compute IVal for the next 17 characters (digits) IVal = INT ( CurCode - A0 , KIND = I8B ) I = 1 !DIR$ UNROLL = 17 DO IF ( Indx + I <= StrLen ) THEN CurCode = IACHAR ( cStr ( Indx + I : Indx + I )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN IVal = IVal * LBase + INT ( CurCode - A0 , KIND = I8B ) ELSE Digit_End = TrueVal EXIT END IF ELSE Digit_End = TrueVal EXIT END IF I = I + 1 IF ( I > 17 ) THEN Digit_End = FalseVal EXIT END IF END DO IF (( Digit_End ). OR .( Indx + I > StrLen )) THEN Number = IVal * Sign RETURN END IF ! deal with more digit(s) Indx = Indx + I CurCode = IACHAR ( cStr ( Indx : Indx )) IF (( IAND ( DigitTable ( CurCode ), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN ! must check overflow Add = INT ( CurCode - A0 , KIND = I8B ) ! check overflow IF ( IVal < MaxI64Div10 ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN IF (( IAND ( DigitTable ( IACHAR ( cStr ( Indx : Indx ))), IOR ( DIGI_TYPE_ZERO , DIGI_TYPE_NONZERO )) /= 0 )) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF ELSE Overflow = FalseVal END IF ELSEIF ( IVal > MaxI64Div10 ) THEN Overflow = TrueVal ELSE ! IVal is equal to MaxI64Div10 SignBit = 0_I8B IF ( Sign == - 1_I8B ) SignBit = 1_I8B IF ( Add > MaxI64Mod10 + SignBit ) THEN Overflow = TrueVal ELSE Overflow = FalseVal END IF END IF IF ( Overflow ) THEN ! overflow IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal IF ( Sign == 1_I8B ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is positively too large.' Number = MaxI64 ELSE IF ( PRESENT ( ErrMsg )) ErrMsg = 'The input number is negatively too large.' Number = MinI64 END IF ELSE ! not overflow IVal = IVal * LBase + Add Number = IVal * Sign END IF ELSE ! no overflow Number = IVal * Sign END IF RETURN END FUNCTION I64_FromChar_YY_JsonNum !------------------------------------------------------------------------------ ! !                           AUXILIARY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Eight_Digits_Unrolled ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits_Unrolled !** PURPOSE OF THIS SUBROUTINE: ! To parse eight digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: K1 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K2 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K3 = INT ( Z '0000FFFF0000FFFF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M1 = 2561_I8B INTEGER ( KIND = I8B ), PARAMETER :: M2 = 6553601_I8B INTEGER ( KIND = I8B ), PARAMETER :: M3 = 42949672960001_I8B ! parameters for alternative implementation !    INTEGER(KIND=I8B), PARAMETER  :: Mask = INT(Z'000000FF000000FF', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: Mul1 = INT(Z'000F424000000064', KIND=I8B)   ! 100 + (1000000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Mul2 = INT(Z'0000271000000001', KIND=I8B)   ! 1 + (10000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Sub  = INT(Z'3030303030303030', KIND=I8B) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = SHIFTR ( IAND ( SHIFTR ( IAND ( SHIFTR ( IAND ( InVal , K1 ) * M1 , 8 ), K2 ) * M2 , 16 ), K3 ) * M3 , 32 ) ! alternative implementation !    OutVal = InVal - Sub !    OutVal = (OutVal*10) + SHIFTR(OutVal, 8)    ! OutVal = (OutVal * 2561) >> 8 !    OutVal = SHIFTR(((IAND(OutVal, Mask)*Mul1) + (IAND(SHIFTR(OutVal, 16), Mask)*Mul2)), 32) RETURN END FUNCTION Parse_Eight_Digits_Unrolled !****************************************************************************** FUNCTION Is_Made_Of_Eight_Digits ( InVal ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Made_Of_Eight_Digits !** PURPOSE OF THIS SUBROUTINE: ! To check whether we can process eight digits immediately IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal LOGICAL ( KIND = 4 ) :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: C1 = INT ( Z 'F0F0F0F0F0F0F0F0' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C2 = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: C3 = INT ( Z '0606060606060606' , KIND = I8B ) !    INTEGER(KIND=I8B), PARAMETER  :: K1 = INT(Z'4646464646464646', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: K2 = INT(Z'3030303030303030', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: K3 = INT(Z'8080808080808080', KIND=I8B) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IOR ( IAND ( InVal , C1 ), SHIFTR ( IAND (( InVal + C3 ), C1 ), 4 )) == C2 ! alternative implementations !    Flag = (IAND(InVal, C1) == K2).AND.(IAND(InVal + C3, C1) ==  K2) !    Flag = (IAND(IOR((InVal + K1), (InVal - K2)), K3) == 0_I8B) !    Flag = IAND(IAND(InVal, InVal + C3), C1) == C2 RETURN END FUNCTION Is_Made_Of_Eight_Digits !****************************************************************************** END MODULE ModBase_Integer_FromChar !******************************************************************************","tags":"","loc":"sourcefile\\modbase - integer - fromchar.f90.html"},{"title":"ModBase - RealQP - CharConv.f90 – FortCharConv","text":"Source Code MODULE ModBase_RealQP_CharConv !&#94; **PURPOSE OF THIS MODULE**: ! This module contains routines that perform a conversion between a 128-bit !   floating point number and a string. ! !&#94; **REFERENCE TECHNICAL ARTICLES**: ! [1]  Junekey Jeon.  [Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm](https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf) ! [2]  Ulf Adams.  [Ryu: Fast Float-to-String Conversion](https://dl.acm.org/doi/10.1145/3192366.3192369) ! [3]  Raffaello Giulietti.  [The Schubfach way to render doubles](https://drive.google.com/open?id=1luHhyQF9zKlM8yJ1nebU0OgVYhfC6CBN) ! [4]  Clinger WD. [How to Read Floating Point Numbers Accurately](https://doi.org/10.1145/989393.989430), !   SIGPLAN Not 2004 Apr;39(4):360–371. ! [5]  Daniel Lemire.  [Number Parsing at a Gigabyte per Second](https://arxiv.org/abs/2101.11408), !   Software: Practice and Experience 51 (8), 2021. ! [6]  Noble Mushtak and Daniel Lemire.  [Fast Number Parsing Without Fallback](https://arxiv.org/abs/2212.06644), !   Software: Practice and Experience 53 (7), 2023. ! [7]  Bouvier & Zimmermann.  [Division-Free Binary-to-Decimal Conversion](https://hal.inria.fr/hal-00864293v1/document) ! [8]  Hacker's Delight, 2nd Edition. ! [9]  Nigel Tao.  [The Eisel-Lemire ParseNumberF64 Algorithm](https://nigeltao.github.io/blog/2020/eisel-lemire.html) ! [10] Nigel Tao.  [ParseNumberF64 by Simple Decimal Conversion](https://nigeltao.github.io/blog/2020/parse-number-f64-simple.html) ! !&#94; **REFERENCE CODE IMPLEMENTATION**: ! [11] [DragonBox: C++ reference implementation](https://github.com/jk-jeon/dragonbox) ! [12] [Ryu: C reference implementation](https://github.com/ulfjack/ryu) ! [13] [Schubfach: Java reference implementation](https://github.com/c4f7fcce9cb06515/Schubfach) ! [14] [Drachennest: Different algorithms for converting binary to decimal floating-point numbers](https://github.com/abolz/Drachennest) ! [15] [Number Conversion Benchmark in C](https://github.com/ibireme/c_numconv_benchmark) ! [16] [fast_float number parsing library: 4x faster than strtod](https://github.com/fastfloat/fast_float) ! [17] [fast_double_parser: 4x faster than strtod](https://github.com/lemire/fast_double_parser) ! [18] [The LLVM Project: LibC Support](https://github.com/llvm/llvm-project/tree/main/libc/src/__support) ! [19] [Double Conversion: Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles](https://github.com/google/double-conversion) ! [20] [fmt: A modern formatting library](https://github.com/fmtlib/fmt) ! !&#94; **TECHNICAL AND IMPLEMENTATION NOTES**: ! ***On the output to string***: ! 1) Three routines are available to convert a real (floating-point) number into a string. !    - \"RealToString_DragonBox\" is based on the Dragonbox binary-to-decimal conversion algorithm [1] !      and the reference implementation [11, 14, 20] !    - \"RealToString_Ryu\" is based on the Ryu binary-to-decimal conversion algorithm [2] !      and the reference implementation [12, 14] !    - \"RealToString_Schubfach\" is based on the Schubfach binary-to-decimal conversion algorithm [3] !      and the reference implementation [13, 14, 15] ! 2) All three binary-to-decimal conversion algorithms employed here produce the so-called shortest !    output representation that provide an error-free write-read cycle.  This means that any correct !    parsers (e.g. RealFromString routines) will read in the output string and return the original !    real (floating-poing) number. ! 3) Although the DragonBox reference implementation provides several modes of rounding, only the !    round-to-nearest mode is implemented here (the other two algorithms also use this mode). ! 4) Although the Ryu reference implementation provides several conversion output formats (Shortest, !    Scientific, Fixed), only the shortest representation (as mentioned above) is implemented. !    Therefore, all three routines will produces the output string in a format similar to \"G0\" format !    specification in Fortran. ! 5) Actually, the RealToString routines have an optional \"format\" argument that we can use to specify !    whether to output the string in \"General (G)\" or \"Scientific (ES)\" format.  However, because they !    always produce the shortest output, no input argument to the routines is provided to specify !    the desired number of significant digits as typically done in Fortran format specifications. ! ***On the input from string***: ! 1) Four routines are available to convert a string into a real (floating-point) number.  All four !    routines utilize the so-call Clinger's fast-path algorithm [4].  Three of them (except \"YY\") employ !    the so-call Eisel-Lemire decimal-to-binary conversion algorithm [5, 9] but are based on different !    reference implementation.  When the Eisel-Lemire (or YY's fast-path) algorithm is NOT valid, three !    of the routines (except \"LibC\") use multi-precision (unsigned) integer arithmetic (i.e. BigUInt) !    whereas \"LibC\" employs the so-call Simple Decimal Conversion algorithm [10]. !    - \"RealFromString_FastFloat\" is based on the reference implementation [16] !    - \"RealFromString_LibC\" is based on the reference implementation [18] !    - \"RealFromString_YY\" is based on the reference implementation [15, 19] !    - \"RealFromString_Lemire\" is based on the reference implementation [17, 19] ! 2) The RealFromString routines have an optional \"parsing\" argument that we can use to specify how !    the routines interpret the input string. ! 3) The \"Parse_Fortran_String\" routine is called when the optional \"parsing\" argument is not specified !    (i.e. the default option) or \"FortNum (or 1)\" value is supplied as the parsing argument.  The routine !    will interpret the input string as a valid Fortran real (floating point) number if it has one of !    the two following forms: !    <1> A number without exponent part -> [S]N[N...] !    <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] !       where !       [ ] indicates an optional field !       S is a sign indicator (required if negative '-', optional if positive '+'). !       N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere !           after the sign (but before the exponent). !       E is an exponent indicator (either 'e' or 'E') !    The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. !    - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. !    - The optional kind parameter (e.g. 10.0_QP) is not allowed here. !    Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered !    valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\" !    is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement !    where spaces inside the valid number are allowed. However, this can easily be done by adding an !    optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or 'ignored'. !    Then, the input will be pre-processed according to the flag.  Nonetheless, this routine neglects !    this optional input because it will make the routine much less efficient due to the fact that !    we will need to scan the whole string twice and we will also need to copy the input string into !    a buffer string and working with the buffer instead of directly handling the input string. ! 4) The \"Parse_FPlus_String\" routine is called when \"FPlusNum (or 2)\" value is supplied as the parsing !    argument.  The routine will parse a valid Fortran real (floating point) number with more relaxed !    rules than those used in \"Parse_Fortran_Number\" routine. The relaxed rules consider the following !    numbers as valid: !    - a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' !      in place of 'e' or 'E'. !    - a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to !      be expressed in a valid number expressed in the scientific format. !    - digits before any invalid character encountered are treated as a valid number !      and any characters after the first encounter (including the first invalid one) !      are neglected.  therefore, for example, a '12.56ax-300' is considered to be !      a valid number with a value of 12.56. ! 5) The \"Parse_JSON_String\" routine is called when \"JsonNum (or 3)\" value is supplied as the parsing !    argument.  The routine will parse a valid JSON floating point number where its differences from !    from Fortran number are as follows: !    - leading and trailing spaces are not allowed. !    - a plus sign as the first character is not allowed. !    - leading zero(s) is not allowed (if 0 is the first character, the second one !      must either be a period or an exponent indicator.) !    - a period must be followed by at least one digit. ! !&#94; **USAGE**: ! ***On the output to string***: ! => cStr = RealXP_ToString_DragonBox(Number, IsScientific) ! => cStr = RealXP_ToString_Ryu(Number, IsScientific) ! => cStr = RealXP_ToString_Schubfach(Number, IsScientific) !   where !   \"cStr\" is an \"allocatable\" character string representing the output string !   \"Number\" is a real number representing the floating point value !   \"IsScientific\" is a logical flag (optional argument) indicating whether !       the output string is in \"General\" or \"Scientific\" format. !       If present and true, the output string is in \"Scientific\" format. !       Otherwise, the output string is in \"General\" format. ! ***On the input from string***: ! => Number = RealXP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) ! => Number = RealXP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) !   where !   \"Number\" is a real number representing the floating point value if the input string is valid !   \"cStr\" is a character string representing the floating-point number string !   \"ParseOpt\" is an integer input flag (optional) indicating how to interpret the input string. !       The valid value is FortNum (1), FPlusNum (2) or JsonNum (3). !       If not specified and invalid, the routines will interpret the input string as a Fortran number. !   \"ErrFlag\" is a logical output flag (optional) indicating whether there is an error in parsing !       the input string.  True if the string represents a valid number.  False, otherwise. !   \"ErrMsg\" is an allocatable output character string (optional) that returns a message that describe !       the result of parsing the input string. ! **NOTE**: \"XP\" in the routine names shown above indicate the precision of the real number. !   The actual name will either be \"RealSP_...\", \"RealQP_...\" or \"RealQP_...\" for single-precision, !   double-precision and quadruple-precision number, respectively. !** USE STATEMENTS: USE ModBase_Common USE ModBase_SIntUtil USE ModBase_UIntUtil USE ModBase_UInt128 USE ModBase_Tables_CharConv USE , INTRINSIC :: IEEE_ARITHMETIC IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! Real-To-String PUBLIC :: RealQP_ToString_DragonBox PUBLIC :: RealQP_ToString_Ryu PUBLIC :: RealQP_ToString_Schubfach ! Real-From-String PUBLIC :: RealQP_FromString_FastFloat PUBLIC :: RealQP_FromString_LibC PUBLIC :: RealQP_FromString_YY PUBLIC :: RealQP_FromString_Lemire PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! options for type of number to be parsed INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: FortNum = 1 ! strict fortran number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: FPlusNum = 2 ! relaxed fortran number INTEGER ( KIND = I4B ), PARAMETER , PUBLIC :: JsonNum = 3 ! json number ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ parameters used to convert bit widths to whole decimal digits +++ INTEGER ( KIND = I8B ), PARAMETER :: LB2To10_M1 = 301029995664_I8B ! LogBaseTenOfTwoTimesTenToThe12th INTEGER ( KIND = I8B ), PARAMETER :: LB2To10_M2 = 1000000000000_I8B ! TenToThe12th ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ Characteristics of IEEE-754 & related binary floating-point numbers +++ INTEGER ( KIND = I4B ), PARAMETER :: RealKind = 16 INTEGER ( KIND = I4B ), PARAMETER :: BinaryPrecision = 113 INTEGER ( KIND = I4B ), PARAMETER :: TotalBits = 128 INTEGER ( KIND = I4B ), PARAMETER :: SignBits = TotalBits - 1 ! 127 INTEGER ( KIND = I4B ), PARAMETER :: SignificandBits = BinaryPrecision - 1 ! 112 INTEGER ( KIND = I4B ), PARAMETER :: ExponentBits = TotalBits - BinaryPrecision ! 15 INTEGER ( KIND = I4B ), PARAMETER :: MaxExponent = SHIFTL ( 1 , ExponentBits ) - 1 ! 32767 INTEGER ( KIND = I4B ), PARAMETER :: ExponentBias = SHIFTL ( 1 , ExponentBits - 1 ) - 1 ! 16383 INTEGER ( KIND = I4B ), PARAMETER :: DecimalPrecision = INT (( SignificandBits * LB2To10_M1 ) / LB2To10_M2 , KIND = I4B ) ! 33 INTEGER ( KIND = I4B ), PARAMETER :: DecimalRange = INT ((( ExponentBias - 1 ) * LB2To10_M1 ) / LB2To10_M2 , KIND = I4B ) ! 4931 INTEGER ( KIND = I4B ), PARAMETER :: MaxDecimalConversionDigits = 11563 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ common masking parameters +++ ! SigHidBitMask = SHIFTL(1, SignificandBits) = UInt128(281474976710656_I8B, 0_I8B) TYPE ( UInt128 ), PARAMETER :: SigHidBitMask = UInt128 ( SHIFTL ( 1_I8B , SignificandBits - 64 ), 0_I8B ) ! SignificandMask = SigHidBitMask - 1 = UInt128(281474976710655_I8B, -1_I8B) TYPE ( UInt128 ), PARAMETER :: SignificandMask = UInt128 ( SHIFTL ( 1_I8B , SignificandBits - 64 ) - 1_I8B , - 1_I8B ) ! SignMask = SHIFTL(1, SignBits) = UInt128(-9223372036854775808_I8B, 0_I8B) TYPE ( UInt128 ), PARAMETER :: SignMask = UInt128 ( SHIFTL ( 1_I8B , SignBits - 64 ), 0_I8B ) ! ExponentMask = NOT(IOR(SignMask, SignificandMask)) = UInt128(9223090561878065152_I8B, 0_I8B) TYPE ( UInt128 ), PARAMETER :: ExponentMask = UInt128 ( NOT ( IOR ( SignMask % High , SignificandMask % High )), & NOT ( IOR ( SignMask % Low , SignificandMask % Low ))) ! ExpMantMask = SignificandMask + ExponentMask = NOT(SignMask) = UInt128(9223372036854775807_I8B, -1_I8B) !    TYPE(UInt128), PARAMETER :: ExpMantMask      = UInt128(NOT(SignMask%High), NOT(SignMask%Low)) ! QuietNaNMask = SHIFTL(1, SignificandBits - 1) = UInt128(140737488355328_I8B, 0_I8B) !    TYPE(UInt128), PARAMETER :: QuietNaNMask     = UInt128(SHIFTL(1_I8B, SignificandBits-64-1), 0_I8B) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Exceptional exponent value for NaN or Infinity INTEGER ( KIND = I4B ), PARAMETER :: ExceptionalExponent = INT ( Z '7FFFFFFF' , KIND = I4B ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ maximum and minimum (positive) parameters +++ ! MinSubnormal = 1 TYPE ( UInt128 ), PARAMETER , PUBLIC :: MinSubnormal = UInt128 ( 0_I8B , 1_I8B ) ! MaxSubnormal = SHIFTL(1, SignificandBits) - 1 !              = UInt128(281474976710655_I8B, -1_I8B) TYPE ( UInt128 ), PARAMETER , PUBLIC :: MaxSubnormal = UInt128 ( SHIFTL ( 1_I8B , SignificandBits - 64 ) - 1_I8B , - 1_I8B ) ! MinNormal = SHIFTL(1, SignificandBits) = MaxSubnormal + 1 !           = UInt128(281474976710656_I8B, 0_I8B) TYPE ( UInt128 ), PARAMETER , PUBLIC :: MinNormal = UInt128 ( SHIFTL ( 1_I8B , SignificandBits - 64 ), 0_I8B ) ! MaxNormal = IOR(SHIFTL((MaxExponent - 1), SignificandBits), MaxSubnormal) !           = UInt128(9223090561878065151_I8B, -1_I8B) TYPE ( UInt128 ), PARAMETER , PUBLIC :: MaxNormal = UInt128 ( IOR ( SHIFTL ( MaxExponent - 1_I8B , SignificandBits - 64 ), & MaxSubnormal % High ), IOR ( 0_I8B , MaxSubnormal % Low )) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------------------------------- ! -----   parameters for high-precision decmial conversion algorithm  ----- ! ------------------------------------------------------------------------- ! 1600 is an arbitrary number of digits, but should be large enough for any practical number. ! Important note: a number of digits large enough to represent the smallest subnormal ! for quadruple-precision number is about 16564 (= 5001 + 11563). INTEGER ( KIND = I4B ), PARAMETER :: MAX_NUM_DIGITS = 1600 ! The maximum amount we can shift is the number of bits used in the Accumulator, ! minus the number of bits needed to represent the base (in this case 4). INTEGER ( KIND = I4B ), PARAMETER :: MAX_SHIFT_AMOUNT = 4 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------------------ ! -----   parameters for BigUInt of FastFloat algorithm  ----- ! ------------------------------------------------------------ ! the number of bits of 'Digit' of BigUInt. INTEGER ( KIND = I4B ), PARAMETER :: DigitBits = 64 ! the total number of bits of a BigUInt that needs to be at least the number of bits ! required to store the largest BigUInt, which is Log2(10**(MaxDigits + MaxExp10)), or ! Log2(10**(11563 + 5005))`, or ~55037 bits, so we round to 55040. INTEGER ( KIND = I4B ), PARAMETER :: BigUIntBits = 55040 ! the (fixed) capacity of a BigUInt INTEGER ( KIND = I4B ), PARAMETER :: BigCapacity = BigUIntBits / DigitBits ! = 860 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ parameters used by parsing routines +++ !    TYPE(UInt128), PARAMETER :: DivBase      = UInt128(0_I8B, 10_I8B) TYPE ( UInt128 ), PARAMETER :: MaxDivbyBase = UInt128 ( INT ( Z '1999999999999999' , KIND = I8B ), & INT ( Z '9999999999999999' , KIND = I8B )) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ number parameters +++ TYPE ( UInt128 ), PARAMETER :: TwoUInt = UInt128 ( 0_I8B , 2_I8B ) TYPE ( UInt128 ), PARAMETER :: ThreeUInt = UInt128 ( 0_I8B , 3_I8B ) TYPE ( UInt128 ), PARAMETER :: FourUInt = UInt128 ( 0_I8B , 4_I8B ) TYPE ( UInt128 ), PARAMETER :: FiveUInt = UInt128 ( 0_I8B , 5_I8B ) TYPE ( UInt128 ), PARAMETER :: TenUInt = UInt128 ( 0_I8B , 10_I8B ) TYPE ( UInt128 ), PARAMETER :: FortyUInt = UInt128 ( 0_I8B , 40_I8B ) TYPE ( UInt128 ), PARAMETER :: HundredUInt = UInt128 ( 0_I8B , 100_I8B ) TYPE ( UInt128 ), PARAMETER :: TenThousandUInt = UInt128 ( 0_I8B , 10000_I8B ) !    TYPE(UInt128), PARAMETER :: Largest_Pow10   = UInt128(5421010862427522170_I8B, 687399551400673280_I8B) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ---------------------------------------------------- ! -----   Simple-Decimal-Algorithm' parameters   ----- ! ---------------------------------------------------- ! The nth item in Powers_Of_Two represents the greatest power of two less than ! 10&#94;n. This tells us how much we can safely shift without overshooting. INTEGER ( KIND = I1B ), PARAMETER :: Powers_Of_Two ( 0 : 18 ) = [ & 0 , 3 , 6 , 9 , 13 , 16 , 19 , 23 , 26 , 29 , 33 , 36 , 39 , 43 , 46 , 49 , 53 , 56 , 59 ] INTEGER ( KIND = I4B ), PARAMETER :: Num_Powers_Of_Two = SIZE ( Powers_Of_Two ) ! = 19 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! -------------------------------------------------- ! -----   Eisel-Lemire-Algorithm' parameters   ----- ! -------------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: LowBits = TotalBits - SignificandBits - 3 ! = 13 ! The halfway constant is used to check if the bits that will be shifted away intially are all 1. TYPE ( UInt128 ), PARAMETER :: HalfWay = UInt128 ( 0_I8B , SHIFTL ( 1_I8B , LowBits ) - 1_I8B ) ! = 8191 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! --------------------------------------------- ! -----   Clinger-Algorithm' parameters   ----- ! --------------------------------------------- INTEGER ( KIND = I4B ) :: Idx REAL ( KIND = QP ), PARAMETER :: Powers_Of_Ten ( 0 : 48 ) = [( 1 0.0E0_QP ** Idx , Idx = 0 , 48 )] INTEGER ( KIND = I4B ), PARAMETER :: Num_Exact_Pow10 = 48 INTEGER ( KIND = I4B ), PARAMETER :: Num_Mantissa_Digits = 33 REAL ( KIND = QP ), PARAMETER :: Max_Exact_Integer = 1038459371706965525706099265844019 1.0_QP ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INTEGER ( KIND = I4B ), PARAMETER :: Exponent_UppBound = 4933 ! = 4932 + 1 INTEGER ( KIND = I4B ), PARAMETER :: Exponent_LowBound = - 5005 ! = (-4966) - 39 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Dragonbox-Algorithm' parameters   ----- ! ----------------------------------------------- ! parameters for main routine INTEGER ( KIND = I4B ), PARAMETER :: Kappa = 3 INTEGER ( KIND = I4B ), PARAMETER :: Big_Divisor = 10 ** ( Kappa + 1 ) ! 10000 INTEGER ( KIND = I4B ), PARAMETER :: Small_Divisor = Big_Divisor / 10 ! 1000 INTEGER ( KIND = I4B ), PARAMETER :: Half_Small_Divisor = Small_Divisor / 2 ! 500 INTEGER ( KIND = I4B ), PARAMETER :: Divisibility_Check_By_5_Threshold = 176 INTEGER ( KIND = I4B ), PARAMETER :: Case_Fc_Pm_Half_Lower_Threshold = - 4 ! parameters for short interval case INTEGER ( KIND = I4B ), PARAMETER :: Case_Shorter_Interval_Left_Endpoint_Lower_Threshold = 2 INTEGER ( KIND = I4B ), PARAMETER :: Case_Shorter_Interval_Left_Endpoint_Upper_Threshold = 3 INTEGER ( KIND = I4B ), PARAMETER :: Shorter_Interval_Tie_Lower_Threshold = - 163 INTEGER ( KIND = I4B ), PARAMETER :: Shorter_Interval_Tie_Upper_Threshold = - 162 ! parameters for Is_Divisible_By_Pow10 routine INTEGER ( KIND = I4B ), PARAMETER :: Info_Shift_Amount = 26 INTEGER ( KIND = I4B ), PARAMETER :: OneShiftL = SHIFTL ( 1 , Info_Shift_Amount ) INTEGER ( KIND = I4B ), PARAMETER :: Comparison_Mask = OneShiftL - 1 INTEGER ( KIND = I4B ), PARAMETER :: Magic_Number = OneShiftL / Small_Divisor + 1 ! parameters for Divide_By_10_To_Kappa_Plus_1 TYPE ( UInt128 ), PARAMETER :: DivM = UInt128 ( INT ( Z '68DB8BAC710CB295' , KIND = I8B ), & INT ( Z 'E9E1B089A0275255' , KIND = I8B )) INTEGER ( KIND = I4B ), PARAMETER :: DivS = 12 ! 140 - 128 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------- ! -----   Ryu-Algorithm's parameters        ----- ! ----------------------------------------------- INTEGER ( KIND = I4B ), PARAMETER :: BitsPerPow5 = 256 INTEGER ( KIND = I4B ), PARAMETER :: MaxExp_ModInv5 = 55 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------ ! -----   Schubfach-Algorithm's parameters   ----- ! ------------------------------------------------ INTEGER ( KIND = I4B ), PARAMETER :: Pow10_Min_Exact_Exp = 0 INTEGER ( KIND = I4B ), PARAMETER :: Pow10_Max_Exact_Exp = 110 ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------ ! -----   FastFloat-Algorithm's parameters   ----- ! ------------------------------------------------ ! Bias so we can get the real exponent with an invalid adjusted_mantissa INTEGER ( KIND = I4B ), PARAMETER :: Invalid_AM_Bias = - INT ( Z '00008000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: Mantissa_Explicit_Bits = SignificandBits INTEGER ( KIND = I4B ), PARAMETER :: Minimum_Exponent = - ExponentBias INTEGER ( KIND = I4B ), PARAMETER :: Infinite_Power = MaxExponent INTEGER ( KIND = I4B ), PARAMETER :: Sign_Index = SignBits INTEGER ( KIND = I4B ), PARAMETER :: MantTotalBits = 128 ! see section 6 in 'Number Parsing at a Gigabyte per Second' paper for ! how the following two numbers can be obtained INTEGER ( KIND = I4B ), PARAMETER :: Max_Exponent_Round_To_Even = 49 INTEGER ( KIND = I4B ), PARAMETER :: Min_Exponent_Round_To_Even = - 6 INTEGER ( KIND = I4B ), PARAMETER :: Largest_Power_of_Ten = Exponent_UppBound - 1 INTEGER ( KIND = I4B ), PARAMETER :: Smallest_Power_of_Ten = Exponent_LowBound + 1 INTEGER ( KIND = I4B ), PARAMETER :: Max_Digits = MaxDecimalConversionDigits + 2 TYPE ( UInt128 ), PARAMETER :: OneMant = UInt128 ( 0_I8B , 1_I8B ) ! Max_Mantissa_Fast_Path = SHIFTL(2, Mantissa_Explicit_Bits) TYPE ( UInt128 ), PARAMETER :: Max_Mantissa_Fast_Path = UInt128 ( 562949953421312_I8B , 0_I8B ) ! Exponent_Mask   = ExponentMask    = UInt128(9223090561878065152_I8B, 0_I8B) TYPE ( UInt128 ), PARAMETER :: Exponent_Mask = UInt128 ( ExponentMask % High , ExponentMask % Low ) ! Mantissa_Mask   = SignificandMask = UInt128(281474976710655_I8B, -1_I8B) TYPE ( UInt128 ), PARAMETER :: Mantissa_Mask = UInt128 ( SignificandMask % High , SignificandMask % Low ) ! Hidden_Bit_Mask = SigHidBitMask   = UInt128(281474976710656_I8B, 0_I8B) TYPE ( UInt128 ), PARAMETER :: Hidden_Bit_Mask = UInt128 ( SigHidBitMask % High , SigHidBitMask % Low ) ! MaxMant = UInt128(INT(Z'FFFFFFFFFFFFFFFF', KIND=I8B), INT(Z'FFFFFFFFFFFFFFFF', KIND=I8B)) TYPE ( UInt128 ), PARAMETER :: MaxMant = MaxU128 ! NotOneMant = NOT(1) = UInt128(INT(Z'FFFFFFFFFFFFFFFF', KIND=I8B), INT(Z'FFFFFFFFFFFFFFFE', KIND=I8B)) TYPE ( UInt128 ), PARAMETER :: NotOneMant = UInt128 ( NOT ( 0_I8B ), NOT ( 1_I8B )) ! NotSigHidBitMask = NOT(SHIFTL(1, SignificandBits)) !                  = UInt128(INT(Z'FFFEFFFFFFFFFFFF', KIND=I8B), INT(Z'FFFFFFFFFFFFFFFF', KIND=I8B)) TYPE ( UInt128 ), PARAMETER :: NotSigHidBitMask = UInt128 ( NOT ( SHIFTL ( 1_I8B , SignificandBits - 64 )), & NOT ( 0_I8B )) INTEGER ( KIND = I8B ), PARAMETER :: Powers_of_Ten_Uint64 ( 0 : 19 ) = & [ 0_I8B , & 10_I8B , & 100_I8B , & 1000_I8B , & 10000_I8B , & 100000_I8B , & 1000000_I8B , & 10000000_I8B , & 100000000_I8B , & 1000000000_I8B , & 10000000000_I8B , & 100000000000_I8B , & 1000000000000_I8B , & 10000000000000_I8B , & 100000000000000_I8B , & 1000000000000000_I8B , & 10000000000000000_I8B , & 100000000000000000_I8B , & 1000000000000000000_I8B , & - 8446744073709551616_I8B ] ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ------------------------------------------------ ! -----   YY/Lemire-Algorithm's parameters   ----- ! ------------------------------------------------ INTEGER ( KIND = I8B ), PARAMETER :: MaxU64 = MAX_U64 TYPE ( UInt128 ), PARAMETER :: BitMask = UInt128 ( 0_I8B , SHIFTL ( 1_I8B , LowBits ) - 1_I8B ) ! Halfway !    TYPE(UInt128),      PARAMETER :: BitMaskMinus1  = UInt128(0_I8B, SHIFTL(1_I8B, LowBits) - 2_I8B)        ! BitMask - 1 TYPE ( UInt128 ), PARAMETER :: AddRound = UInt128 ( 0_I8B , SHIFTL ( 1_I8B , ExponentBits - 1 )) ! 16384 TYPE ( UInt128 ), PARAMETER :: MaxUInt = UInt128 ( MaxU64 , MaxU64 ) TYPE ( UInt128 ), PARAMETER :: FpRawInf = UInt128 ( INT ( Z '7FFF000000000000' , KIND = I8B ), 0_I8B ) ! = ExponentMask INTEGER ( KIND = I4B ), PARAMETER :: MaxExpBin = 16384 INTEGER ( KIND = I4B ), PARAMETER :: MinExpBin = - 16381 INTEGER ( KIND = I4B ), PARAMETER :: UIntSafeDigits = 39 INTEGER ( KIND = I4B ), PARAMETER :: MaxDecDigits = MaxDecimalConversionDigits + 1 ! MaxMantissa = SHIFTL(1, BinaryPrecision) = UInt128(INT(Z'0002000000000000', KIND=I8B), 0_I8B) TYPE ( UInt128 ), PARAMETER :: MaxMantissa = UInt128 ( SHIFTL ( 1_I8B , BinaryPrecision - 64 ), 0_I8B ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ----------------------------------------------------- ! -----   parameters for Write_FPN128 function    ----- ! ----------------------------------------------------- ! maximum number of significant digits (i.e. the maximum decimal precision !   that guarantees an error-free write-read cycle.) INTEGER ( KIND = I4B ), PARAMETER :: H = 36 ! The first powers of 10. The last entry here is 10**(H-1). TYPE ( UInt128 ), PARAMETER :: PowTen ( 0 : H - 1 ) = [ & UInt128 ( 0_I8B , 1_I8B ), UInt128 ( 0_I8B , 10_I8B ), & UInt128 ( 0_I8B , 10_I8B ** 2 ), UInt128 ( 0_I8B , 10_I8B ** 3 ), & UInt128 ( 0_I8B , 10_I8B ** 4 ), UInt128 ( 0_I8B , 10_I8B ** 5 ), & UInt128 ( 0_I8B , 10_I8B ** 6 ), UInt128 ( 0_I8B , 10_I8B ** 7 ), & UInt128 ( 0_I8B , 10_I8B ** 8 ), UInt128 ( 0_I8B , 10_I8B ** 9 ), & UInt128 ( 0_I8B , 10_I8B ** 10 ), UInt128 ( 0_I8B , 10_I8B ** 11 ), & UInt128 ( 0_I8B , 10_I8B ** 12 ), UInt128 ( 0_I8B , 10_I8B ** 13 ), & UInt128 ( 0_I8B , 10_I8B ** 14 ), UInt128 ( 0_I8B , 10_I8B ** 15 ), & UInt128 ( 0_I8B , 10_I8B ** 16 ), UInt128 ( 0_I8B , 10_I8B ** 17 ), & UInt128 ( 0_I8B , 10_I8B ** 18 ), & UInt128 ( 0_I8B , - 8446744073709551616_I8B ), & UInt128 ( 5_I8B , 7766279631452241920_I8B ), & UInt128 ( 54_I8B , 3875820019684212736_I8B ), & UInt128 ( 542_I8B , 1864712049423024128_I8B ), & UInt128 ( 5421_I8B , 200376420520689664_I8B ), & UInt128 ( 54210_I8B , 2003764205206896640_I8B ), & UInt128 ( 542101_I8B , 1590897978359414784_I8B ), & UInt128 ( 5421010_I8B , - 2537764290115403776_I8B ), & UInt128 ( 54210108_I8B , - 6930898827444486144_I8B ), & UInt128 ( 542101086_I8B , 4477988020393345024_I8B ), & UInt128 ( 5421010862_I8B , 7886392056514347008_I8B ), & UInt128 ( 54210108624_I8B , 5076944270305263616_I8B ), & UInt128 ( 542101086242_I8B , - 4570789518076018688_I8B ), & UInt128 ( 5421010862427_I8B , - 8814407033341083648_I8B ), & UInt128 ( 54210108624275_I8B , 4089650035136921600_I8B ), & UInt128 ( 542101086242752_I8B , 4003012203950112768_I8B ), & UInt128 ( 5421010862427522_I8B , 3136633892082024448_I8B )] TYPE ( UInt128 ), PARAMETER :: PowTen36 = UInt128 ( 54210108624275221_I8B , - 5527149226598858752_I8B ) ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !** DERIVED TYPE DEFINITIONS ! ---------------------------------------------------------------------------- ! auxiliary string information ! ---------------------------------------------------------------------------- TYPE StringAux INTEGER ( KIND = I4B ) :: Start ! starting position that exclude the leading spaces INTEGER ( KIND = I4B ) :: SigCut ! position after the string is truncated ! = zero if Truncated = False; non-zero if Truncated = True INTEGER ( KIND = I4B ) :: Indices ( 4 ) ! positions of characters representing the ! significand in the string LOGICAL :: Truncated ! flag indicating whether the computed decimal ! significand is based on a truncated string END TYPE StringAux ! ---------------------------------------------------------------------------- ! -----   derived types for high-precision decmial conversion algorithm  ----- ! ---------------------------------------------------------------------------- TYPE HPDecimal INTEGER ( KIND = I4B ) :: NumDigits = 0 INTEGER ( KIND = I4B ) :: DecimalPoint = 0 LOGICAL :: Truncated = FalseVal INTEGER ( KIND = I1B ) :: Digits ( 0 : MAX_NUM_DIGITS - 1 ) CONTAINS PROCEDURE :: ShouldRoundUp => HPDec_Should_Round_Up PROCEDURE :: GetNumNewDigits => HPDec_Get_Num_New_Digits PROCEDURE :: TrimTrailingZeroes => HPDec_Trim_Trailing_Zeroes PROCEDURE :: RightShift => HPDec_Right_Shift PROCEDURE :: LeftShift => HPDec_Left_Shift PROCEDURE :: Construct => HPDec_Construct PROCEDURE :: Shift => HPDec_Shift PROCEDURE :: RoundToUIntType => HPDec_Round_To_UInt END TYPE HPDecimal ! ---------------------------------------------------------------------------- ! -----   derived types for FastFloat algorithm                          ----- ! ---------------------------------------------------------------------------- ! a multiprecision (fixed capacity) unsigned integer where its representation are: ! - Base is 2**64. ! - Magnitude as array in little endian order. ! - The 'Length' first 'Digit' count as the number. ! ---------------------------------------------------------------------------- TYPE BigUInt INTEGER ( KIND = I8B ) :: Digit ( 0 : BigCapacity - 1 ) INTEGER ( KIND = I4B ) :: Length = 0 ! number of digit currently stored CONTAINS PROCEDURE :: IsEmpty => BigUInt_IsEmpty PROCEDURE :: IsNonZero => BigUInt_IsNonZero PROCEDURE :: Push => BigUInt_Push PROCEDURE :: Extend => BigUInt_Extend PROCEDURE :: Normalize => BigUInt_Normalize PROCEDURE :: FromU128 => BigUInt_From_U128 PROCEDURE :: Hi128 => BigUInt_Get_Hi128 PROCEDURE :: FromU64 => BigUInt_From_U64 PROCEDURE :: Hi64 => BigUInt_Get_Hi64 PROCEDURE :: Compare => BigUInt_Compare PROCEDURE :: ShiftL => BigUInt_ShiftL PROCEDURE :: LeadZ => BigUInt_LeadZ PROCEDURE :: BitLen => BigUInt_BitLen PROCEDURE :: SmallMul => BigUInt_SmallMul PROCEDURE :: LongMul => BigUInt_LongMul PROCEDURE :: Add => BigUInt_Add PROCEDURE :: Pow2 => BigUInt_Pow2 PROCEDURE :: Pow5 => BigUInt_Pow5 PROCEDURE :: Pow10 => BigUInt_Pow10 END TYPE BigUInt ! parsed number information TYPE Parsed_Number_Info INTEGER ( KIND = I4B ) :: Exp ! base-10 exponent TYPE ( UInt128 ) :: Sig ! base-10 significand INTEGER ( KIND = I4B ) :: IntegralStart ! starting index of integral part of the significand INTEGER ( KIND = I4B ) :: IntegralEnd ! ending index of integral part of the significand INTEGER ( KIND = I4B ) :: FractionStart ! starting index of fractional part of the significand INTEGER ( KIND = I4B ) :: FractionEnd ! ending index of fractional part of the significand END TYPE ! ---------------------------------------------------------------------------- ! binary floating-point representation in base 2 ! --> ((-1)**S) * M * (2**E) ! ---------------------------------------------------------------------------- TYPE BinRep TYPE ( UInt128 ) :: Significand ! significand/mantissa (M) INTEGER ( KIND = I4B ) :: Exponent ! exponent (E); negative value is invalid LOGICAL :: Negative ! negative sign flag; true if the value is negative END TYPE BinRep ! ---------------------------------------------------------------------------- !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE/GENERIC DEFINITIONS: ! interfaces to routines used by FastFloat algorithm ABSTRACT INTERFACE SUBROUTINE CB_Round ( E , M , Min ) IMPORT INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E TYPE ( UInt128 ), INTENT ( INOUT ) :: M INTEGER ( KIND = I4B ), INTENT ( IN ) :: Min END SUBROUTINE FUNCTION CB_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) IMPORT LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag END FUNCTION END INTERFACE CONTAINS !** MODULE SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                       REAL128-TO-STRING MAIN ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RealQP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a quadruple-precision floating-point value to a character (decimal) string ! using the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Number ! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawBin ! raw IEEE binary floating point representation TYPE ( UInt128 ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) INTEGER ( KIND = I8B ) :: IntVal ( 2 ) ! working integers (for conversion to binary representation) REAL ( KIND = QP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( IntVal , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 60 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number RawBin = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= ZeroU128 SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = ToI32 ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits )) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == ZeroU128 )) THEN ! zero SigDec = ZeroU128 ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealQP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealQP_ToString_DragonBox !****************************************************************************** FUNCTION RealQP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a quadruple-precision floating-point value to a character (decimal) string ! using the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Number ! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawBin ! raw IEEE binary floating point representation TYPE ( UInt128 ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) INTEGER ( KIND = I8B ) :: IntVal ( 2 ) ! working integers (for conversion to binary representation) REAL ( KIND = QP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( IntVal , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 60 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number RawBin = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= ZeroU128 SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = ToI32 ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits )) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == ZeroU128 )) THEN ! zero SigDec = ZeroU128 ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealQP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealQP_ToString_Ryu !****************************************************************************** FUNCTION RealQP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a quadruple-precision floating-point value to a character (decimal) string ! using the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Number ! number LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false CHARACTER ( LEN = :), ALLOCATABLE :: cStr ! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawBin ! raw IEEE binary floating point representation TYPE ( UInt128 ) :: SigRaw ! raw (biased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpRaw ! raw (biased) exponent in base 2 TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: ConvFlag ! conversion flag (true if bin2dec conversion is needed) INTEGER ( KIND = I8B ) :: IntVal ( 2 ) ! working integers (for conversion to binary representation) REAL ( KIND = QP ) :: FloatVal ! working real (for conversion to binary representation) EQUIVALENCE ( IntVal , FloatVal ) INTEGER ( KIND = I4B ) :: wPos CHARACTER ( LEN = 60 ) :: wStr ! working string INTEGER ( KIND = I4B ) :: wLen ! length of string !** FLOW ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion of real value to its binary representation  +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! get raw IEEE binary floating point representation (little-endian order) FloatVal = Number RawBin = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! decompose the representation into its parts Negative = IAND ( RawBin , SignMask ) /= ZeroU128 SigRaw = IAND ( RawBin , SignificandMask ) ExpRaw = ToI32 ( SHIFTR ( IAND ( RawBin , ExponentMask ), SignificandBits )) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from binary to decimal representation +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ConvFlag = TrueVal ! check for special cases IF (( ExpRaw == 0 ). AND .( SigRaw == ZeroU128 )) THEN ! zero SigDec = ZeroU128 ExpDec = 0 ConvFlag = FalseVal ELSEIF ( ExpRaw == MaxExponent ) THEN ! NaN or Infinity SigDec = SigRaw ExpDec = ExceptionalExponent ConvFlag = FalseVal END IF ! get exponent and mantissa IF ( ExpRaw /= 0 ) THEN ! normal number SigBin = IOR ( SigRaw , SigHidBitMask ) ExpBin = ExpRaw - ExponentBias - SignificandBits IF (( - SignificandBits <= ExpBin ). AND .( ExpBin <= 0 )) THEN IF ( TRAILZ ( SigBin ) >= - ExpBin ) THEN ! fast path for small integer number (without fraction?) SigDec = SHIFTR ( SigBin , - ExpBin ) ExpDec = 0 ConvFlag = FalseVal END IF END IF ELSE ! subnormal number SigBin = SigRaw ExpBin = 1 - ExponentBias - SignificandBits END IF IF ( ConvFlag ) THEN ! perform binary-to-decimal conversion CALL Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) END IF ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ conversion from decimal represetnation to decimal string  +++++ ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! write output IF ( Negative ) THEN wStr ( 1 : 1 ) = '-' wPos = 2 ELSE wPos = 1 END IF wLen = ( wPos - 1 ) + Write_RealQP ( SigDec , ExpDec , wStr ( wPos :), IsScientific ) ! set output cStr = wStr ( 1 : wLen ) RETURN END FUNCTION RealQP_ToString_Schubfach !------------------------------------------------------------------------------ ! !                       REAL128-FROM-STRING MAIN ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RealQP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the FastFloat algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using FastFloat algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , Aux % Truncated , Aux % Indices , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_FastFloat !****************************************************************************** FUNCTION RealQP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the LibC algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF ! perform decimal to binary conversion using LibC algorithm if SlowPath is true IF ( SlowPath ) CALL Dec2Bin_LibC ( SigDec , ExpDec , cStr , Aux % Start , Aux % Truncated , SigBin , ExpBin ) ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! +++ convert binary representation into real number +++ ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! construct raw binary representation of floating point number ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_LibC !****************************************************************************** FUNCTION RealQP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the YY algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using YY's algorithm +++ RawVal = Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_YY !****************************************************************************** FUNCTION RealQP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a character (decimal) string to a quadruple-precision floating-point value ! using the Lemire algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), OPTIONAL , INTENT ( IN ) :: ParseOpt LOGICAL , OPTIONAL , INTENT ( OUT ) :: ErrFlag CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg REAL ( KIND = QP ) :: Number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ) :: ExpDec ! exponent in base 10 LOGICAL :: Negative ! sign flag (true if real value is negative) TYPE ( UInt128 ) :: SigBin ! (unbiased) significand in base 2 INTEGER ( KIND = I4B ) :: ExpBin ! (unbiased) exponent in base 2 TYPE ( StringAux ) :: Aux TYPE ( UInt128 ) :: RawVal LOGICAL :: Valid LOGICAL :: SlowPath INTEGER ( KIND = I4B ) :: ParseFormat INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW ! check and set optional input (parsing format) ParseFormat = FortNum IF ( PRESENT ( ParseOpt )) THEN IF (( ParseOpt >= 1 ). AND .( ParseOpt <= 3 )) ParseFormat = ParseOpt END IF ! parse floating-point-number string SELECT CASE ( ParseFormat ) CASE ( FortNum ) Valid = Parse_Fortran_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( FPlusNum ) Valid = Parse_FPlus_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) CASE ( JsonNum ) Valid = Parse_JSON_String ( cStr , SigDec , ExpDec , Negative , Aux , ErrMsg ) END SELECT IF ( PRESENT ( ErrFlag )) ErrFlag = . NOT . Valid IF ( Valid ) THEN ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! +++++ perform decimal to binary conversion +++++ ! ++++++++++++++++++++++++++++++++++++++++++++++++ ! set flag SlowPath = TrueVal ! If the exponent is too large and can't be represented in this size of ! float, return inf. These bounds are relatively loose, but are mostly ! serving as a first pass. Some close numbers getting through is okay. IF ( ExpDec > Exponent_UppBound ) THEN ! infinity SigBin = ZeroU128 ExpBin = MaxExponent SlowPath = FalseVal ! If the exponent is too small even for a subnormal, return 0. ELSEIF ( ExpDec < Exponent_LowBound ) THEN ! zero SigBin = ZeroU128 ExpBin = 0 SlowPath = FalseVal ELSEIF (. NOT . Aux % Truncated ) THEN IF ( Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! clinger's fast path is valid SlowPath = FalseVal END IF END IF IF ( SlowPath ) THEN ! +++ perform decimal to binary conversion using Lemire's algorithm +++ RawVal = Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) ELSE ! +++ construct raw binary representation of floating point number +++ ! set sign bit IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( SigBin , SignificandMask )) END IF ! convert raw binary representation to floating point number (little-endian order) IntVal ( 1 ) = RawVal % Low IntVal ( 2 ) = RawVal % High Number = FloatVal ELSE ! handle special cases (infinity or NaN) Number = Handle_Invalid_String ( cStr , Aux % Start , Negative ) END IF RETURN END FUNCTION RealQP_FromString_Lemire !------------------------------------------------------------------------------ ! !                           COMMON AND GENERIC ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Eight_Digits_Unrolled ( InVal ) RESULT ( OutVal ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits_Unrolled !** PURPOSE OF THIS SUBROUTINE: ! To parse eight digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: InVal INTEGER ( KIND = I8B ) :: OutVal !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: K1 = INT ( Z '0F0F0F0F0F0F0F0F' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K2 = INT ( Z '00FF00FF00FF00FF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: K3 = INT ( Z '0000FFFF0000FFFF' , KIND = I8B ) INTEGER ( KIND = I8B ), PARAMETER :: M1 = 2561_I8B INTEGER ( KIND = I8B ), PARAMETER :: M2 = 6553601_I8B INTEGER ( KIND = I8B ), PARAMETER :: M3 = 42949672960001_I8B ! parameters for alternative implementation !    INTEGER(KIND=I8B), PARAMETER  :: Mask = INT(Z'000000FF000000FF', KIND=I8B) !    INTEGER(KIND=I8B), PARAMETER  :: Mul1 = INT(Z'000F424000000064', KIND=I8B)   ! 100 + (1000000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Mul2 = INT(Z'0000271000000001', KIND=I8B)   ! 1 + (10000ULL << 32) !    INTEGER(KIND=I8B), PARAMETER  :: Sub  = INT(Z'3030303030303030', KIND=I8B) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW OutVal = SHIFTR ( IAND ( SHIFTR ( IAND ( SHIFTR ( IAND ( InVal , K1 ) * M1 , 8 ), K2 ) * M2 , 16 ), K3 ) * M3 , 32 ) ! alternative implementation !    OutVal = InVal - Sub !    OutVal = (OutVal*10) + SHIFTR(OutVal, 8)    ! OutVal = (OutVal * 2561) >> 8 !    OutVal = SHIFTR(((IAND(OutVal, Mask)*Mul1) + (IAND(SHIFTR(OutVal, 16), Mask)*Mul2)), 32) RETURN END FUNCTION Parse_Eight_Digits_Unrolled !****************************************************************************** FUNCTION Floor_Log10_ThreeQuartersPow2 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_ThreeQuartersPow2 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = FLOOR(LOG10((3/4)*(2**E))) where -2956395 <= E <= 2500325 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! base-2 exponent INTEGER ( KIND = I4B ) :: K ! base-10 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG10(2) * 2**Shift) ! Addend     = FLOOR(LOG10(3/4) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 41 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 661971961083_I8B INTEGER ( KIND = I8B ), PARAMETER :: Addend = - 274743187321_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW K = INT ( SHIFTA ( INT ( E , KIND = I8B ) * Multiplier + Addend , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_ThreeQuartersPow2 !****************************************************************************** FUNCTION Floor_Log10_Pow2 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_Pow2 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = FLOOR(LOG10(2**E)) where -5456721 <= E <= 5456721 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! base-2 exponent INTEGER ( KIND = I4B ) :: K ! base-10 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG10(2) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 41 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 661971961083_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW K = INT ( SHIFTA ( INT ( E , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_Pow2 !****************************************************************************** FUNCTION Floor_Log2_Pow10 ( K ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log2_Pow10 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = FLOOR(LOG2(10**K)) where -1838394 <= K <= 1838394 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! base-10 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG2(10) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 38 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 913124641741_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = INT ( SHIFTA ( INT ( K , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log2_Pow10 !****************************************************************************** FUNCTION Floor_Log2_Pow5 ( P ) RESULT ( E ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log2_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute E = FLOOR(LOG2(5**P)) where -32768 <= Exp <= 32768 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! base-5 exponent INTEGER ( KIND = I4B ) :: E ! base-2 exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! Multiplier = FLOOR(LOG2(5) * 2**Shift) INTEGER ( KIND = I4B ), PARAMETER :: Shift = 46 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 163391164108059_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = INT ( SHIFTA ( INT ( P , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log2_Pow5 !****************************************************************************** FUNCTION Floor_Log10_Pow5 ( E ) RESULT ( K ) !DIR$ ATTRIBUTES FORCEINLINE :: Floor_Log10_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To compute K = Floor(Log10(5**E)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! ! 0 <= Exp <= 2**15 INTEGER ( KIND = I4B ) :: K !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Shift = 48 INTEGER ( KIND = I8B ), PARAMETER :: Multiplier = 196742565691928_I8B !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The first value this approximation fails for is 5&#94;2621 which is just greater than 10&#94;1832. K = INT ( SHIFTR ( INT ( E , KIND = I8B ) * Multiplier , Shift ), KIND = I4B ) RETURN END FUNCTION Floor_Log10_Pow5 !****************************************************************************** SUBROUTINE MultiplyBasic ( X , XLen , Y , YLen , Z ) !DIR$ ATTRIBUTES INLINE :: MultiplyBasic !** PURPOSE OF THIS SUBROUTINE: ! To multiply two magnitude arrays and return the result using grade-school algorithm IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: XLen ! The length of the first array INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ( 0 : XLen - 1 ) ! The first magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: YLen ! The length of the second array INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ( 0 : YLen - 1 ) ! The second magnitude array INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Z ( 0 : XLen + YLen - 1 ) ! The result array !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MinI64 = INT ( Z '8000000000000000' , KIND = I8B ) ! min signed 64-bit !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Carry64 , ProductHi , ProductLo , Sum INTEGER ( KIND = I4B ) :: I , J !** FLOW Carry64 = 0_I8B DO J = 0 , YLen - 1 CALL UMul128 ( X ( 0 ), Y ( J ), ProductHi , ProductLo ) Z ( J ) = ProductLo + Carry64 IF ( IEOR ( Z ( J ), MinI64 ) < IEOR ( ProductLo , MinI64 )) THEN Carry64 = ProductHi + 1_I8B ELSE Carry64 = ProductHi END IF END DO Z ( YLen ) = Carry64 DO I = 1 , XLen - 1 Carry64 = 0_I8B DO J = 0 , YLen - 1 CALL UMul128 ( X ( I ), Y ( J ), ProductHi , ProductLo ) Sum = ProductLo + Z ( I + J ) IF ( IEOR ( Sum , MinI64 ) < IEOR ( ProductLo , MinI64 )) ProductHi = ProductHi + 1_I8B Z ( I + J ) = Sum + Carry64 IF ( IEOR ( Z ( I + J ), MinI64 ) < IEOR ( Sum , MinI64 )) THEN Carry64 = ProductHi + 1_I8B ELSE Carry64 = ProductHi END IF END DO Z ( I + YLen ) = Carry64 END DO RETURN END SUBROUTINE MultiplyBasic !****************************************************************************** SUBROUTINE ShiftRight ( X , ShiftPos ) !DIR$ ATTRIBUTES INLINE :: ShiftRight !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by the specified amount IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftPos !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LargeShift , SmallShift !** FLOW IF ( ShiftPos == 0 ) RETURN LargeShift = SHIFTR ( ShiftPos , 6 ) IF ( LargeShift >= SIZE ( X )) THEN X = 0_I8B ELSE SmallShift = IAND ( ShiftPos , 63 ) IF ( LargeShift > 0 ) CALL ShiftLarge ( X , LargeShift ) IF ( SmallShift > 0 ) CALL ShiftSmall ( X , SmallShift ) END IF RETURN CONTAINS SUBROUTINE ShiftSmall ( X , Shift ) !DIR$ ATTRIBUTES FORCEINLINE :: ShiftSmall !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by the given amount (less than 64). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: I , XLen INTEGER ( KIND = I8B ) :: Nxt !** FLOW XLen = SIZE ( X ) Nxt = X ( 0 ) DO I = 0 , XLen - 2 X ( I ) = IOR ( SHIFTR ( Nxt , Shift ), SHIFTL ( X ( I + 1 ), 64 - Shift )) Nxt = X ( I + 1 ) END DO X ( XLen - 1 ) = SHIFTR ( X ( XLen - 1 ), Shift ) RETURN END SUBROUTINE ShiftSmall !****************************************************************************** SUBROUTINE ShiftLarge ( X , Shift ) !DIR$ ATTRIBUTES FORCEINLINE :: ShiftLarge !** PURPOSE OF THIS SUBROUTINE: ! To shift the input right by 64*shift, i.e. moves each ! element of the array shift positions to the right. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index , XLen !** FLOW XLen = SIZE ( X ) DO Index = 0 , XLen - Shift - 1 X ( Index ) = X ( Shift + Index ) END DO X ( XLen - Shift :) = 0_I8B RETURN END SUBROUTINE ShiftLarge !****************************************************************************** END SUBROUTINE ShiftRight !****************************************************************************** SUBROUTINE Multiply_N_ShiftRight ( X , XLen , Y , YLen , Shift , Z ) !DIR$ ATTRIBUTES INLINE :: Multiply_N_ShiftRight !** PURPOSE OF THIS SUBROUTINE: ! To perform multiplication and then rigth shift IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: XLen ! The length of the first array INTEGER ( KIND = I8B ), INTENT ( IN ) :: X ( 0 : XLen - 1 ) ! The first magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: YLen ! The length of the second array INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ( 0 : YLen - 1 ) ! The second magnitude array INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! shift position of bits in the result array INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Z ( 0 : XLen + YLen - 1 ) ! The result array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL MultiplyBasic ( X , XLen , Y , YLen , Z ) CALL ShiftRight ( Z , Shift ) RETURN END SUBROUTINE Multiply_N_ShiftRight !****************************************************************************** SUBROUTINE Increment_Value ( X ) !DIR$ ATTRIBUTES INLINE :: Increment_Value !** PURPOSE OF THIS SUBROUTINE: ! To increase value of the input by 1 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: XLen , I INTEGER ( KIND = I8B ) :: Sum , Carry !** FLOW XLen = SIZE ( X ) Sum = X ( 0 ) + 1_I8B Carry = SHIFTR ( IOR ( IAND ( X ( 0 ), 1_I8B ), IAND ( IOR ( X ( 0 ), 1_I8B ), NOT ( Sum ))), 63 ) X ( 0 ) = Sum IF ( Carry /= 0_I8B ) THEN I = 1_I4B DO X ( I ) = X ( I ) + 1_I8B IF (. NOT .(( I < XLen ). AND .( X ( I ) == 0 ))) EXIT I = I + 1_I4B END DO END IF RETURN END SUBROUTINE Increment_Value !****************************************************************************** FUNCTION Get_Pow10_256Bits ( K ) RESULT ( Pow10 ) !DIR$ ATTRIBUTES FORCEINLINE :: Get_Pow10_256Bits !** PURPOSE OF THIS SUBROUTINE: ! To get the 256-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! the power of ten in little-endian order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( K >= Pow10_256_Small_MinExp ). AND .( K <= Pow10_256_Small_MaxExp )) THEN Pow10 = Pow10_256_Small_Table (:, K ) ELSE CALL Compute_Pow10_256Bits ( K , Pow10 ) END IF RETURN END FUNCTION Get_Pow10_256Bits !****************************************************************************** SUBROUTINE Compute_Pow10_256Bits ( K , Pow10 ) !DIR$ ATTRIBUTES INLINE :: Compute_Pow10_256Bits !** PURPOSE OF THIS SUBROUTINE: ! To compute the 256-bit approximation of power of ten ! -> Pow10 = 10**K IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: K ! the power INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Pow10 ( 0 : 3 ) ! the power of ten in little-endian order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pow10_Index , KBase , Offset , Alpha INTEGER ( KIND = I8B ) :: Pow10_Cache ( 0 : 3 ), Pow5 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Pow10_384 ( 0 : 5 ) !** FLOW ! compute essential indices Pow10_Index = ( K - Pow10_256_Compressed_MinExp ) / Pow5_128_Size KBase = Pow10_Index * Pow5_128_Size + Pow10_256_Compressed_MinExp Offset = K - KBase ! get base cache Pow10_Cache = Pow10_256_Compressed_Table (:, Pow10_Index ) IF ( Offset == 0 ) THEN Pow10 = Pow10_Cache RETURN END IF ! compute the required amount of bit-shift Alpha should be in the range (0, 256) Alpha = Floor_Log2_Pow10 ( KBase + Offset ) - Floor_Log2_Pow10 ( KBase ) - Offset ! compute the approximation for the specified power K Pow5 = Pow5_128_Table (:, Offset ) CALL Multiply_N_ShiftRight ( Pow10_Cache , 4 , Pow5 , 2 , Alpha , Pow10_384 ) Pow10 ( 0 : 3 ) = Pow10_384 ( 0 : 3 ) CALL Increment_Value ( Pow10 ) RETURN END SUBROUTINE Compute_Pow10_256Bits !****************************************************************************** FUNCTION Handle_Invalid_String ( cStr , Start , Negative ) RESULT ( RealNum ) !** PURPOSE OF THIS SUBROUTINE: ! To handle invalid input string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start LOGICAL , INTENT ( IN ) :: Negative REAL ( KIND = QP ) :: RealNum !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Finish INTEGER ( KIND = I4B ) :: Ptr , Q !** FLOW ! Could not parse a decimal floating-point number.  Start has been ! advanced over any leading spaces. Ptr = Start Finish = LEN_TRIM ( cStr ) IF ( Start > Finish ) THEN ! empty string RealNum = IEEE_VALUE ( 0.0_QP , IEEE_QUIET_NAN ) ELSEIF ( Finish == Ptr + 2 ) THEN IF (( ToUpper ( cStr ( Ptr : Ptr )) == 'N' ). AND .( ToUpper ( cStr ( Ptr + 1 : Ptr + 1 )) == 'A' ). AND . & ( ToUpper ( cStr ( Ptr + 2 : Ptr + 2 )) == 'N' )) THEN ! Exact NAN RealNum = IEEE_VALUE ( 0.0_QP , IEEE_QUIET_NAN ) ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_QP , IEEE_SIGNALING_NAN ) END IF ELSE ! Try to parse Inf, maybe with a sign Q = Ptr IF ( Q <= Finish ) THEN IF ( Is_Character_Sign ( cStr ( Q : Q ))) Q = Q + 1 END IF IF ( Finish == Q + 2 ) THEN IF (( ToUpper ( cStr ( Q : Q )) == 'I' ). AND .( ToUpper ( cStr ( Q + 1 : Q + 1 )) == 'N' ). AND . & ( ToUpper ( cStr ( Q + 2 : Q + 2 )) == 'F' )) THEN IF ( Negative ) THEN RealNum = IEEE_VALUE ( 1.0_QP , IEEE_NEGATIVE_INF ) ELSE RealNum = IEEE_VALUE ( 1.0_QP , IEEE_POSITIVE_INF ) END IF ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_QP , IEEE_SIGNALING_NAN ) END IF ELSEIF ( Finish == Q + 7 ) THEN IF (( ToUpper ( cStr ( Q : Q )) == 'I' ). AND .( ToUpper ( cStr ( Q + 1 : Q + 1 )) == 'N' ). AND . & ( ToUpper ( cStr ( Q + 2 : Q + 2 )) == 'F' ). AND .( ToUpper ( cStr ( Q + 3 : Q + 3 )) == 'I' ). AND . & ( ToUpper ( cStr ( Q + 4 : Q + 4 )) == 'N' ). AND .( ToUpper ( cStr ( Q + 5 : Q + 5 )) == 'I' ). AND . & ( ToUpper ( cStr ( Q + 6 : Q + 6 )) == 'T' ). AND .( ToUpper ( cStr ( Q + 7 : Q + 7 )) == 'Y' )) THEN IF ( Negative ) THEN RealNum = IEEE_VALUE ( 1.0_QP , IEEE_NEGATIVE_INF ) ELSE RealNum = IEEE_VALUE ( 1.0_QP , IEEE_POSITIVE_INF ) END IF ELSE ! Invalid NAN RealNum = IEEE_VALUE ( 0.0_QP , IEEE_SIGNALING_NAN ) END IF ELSE ! Invalid input RealNum = IEEE_VALUE ( 0.0_QP , IEEE_SIGNALING_NAN ) END IF END IF RETURN CONTAINS FUNCTION Is_Character_Sign ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is a 'sign' character IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN =* ), PARAMETER :: SET_SIGNS = '+-' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_SIGNS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Sign !************************************************************************** FUNCTION ToUpper ( ChrIn ) RESULT ( ChrOut ) !** PURPOSE OF THIS SUBROUTINE: ! To change case of the input character to upper case if applicable IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: ChrIn CHARACTER ( LEN = 1 ) :: ChrOut !** SUBROUTINE PARAMETER DECLARATIONS: CHARACTER ( LEN =* ), PARAMETER :: SET_ALPHABETS_LOWER = 'abcdefghijklmnopqrstuvwxyz' CHARACTER ( LEN =* ), PARAMETER :: SET_ALPHABETS_UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ID !** FLOW: ID = INDEX ( SET_ALPHABETS_LOWER , ChrIn ) IF ( ID > 0 ) THEN ChrOut = SET_ALPHABETS_UPPER ( ID : ID ) ELSE ChrOut = ChrIn END IF RETURN END FUNCTION ToUpper !************************************************************************** END FUNCTION Handle_Invalid_String !****************************************************************************** !------------------------------------------------------------------------------ ! !           (RAW) FLOATING-POINT BINARY REPRESENTATION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION RawFP_BiasedExponent ( RawVal ) RESULT ( BiasedExponent ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_BiasedExponent !** PURPOSE OF THIS SUBROUTINE: ! To determine the biased exponent of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: RawVal INTEGER ( KIND = I4B ) :: BiasedExponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BiasedExponent = ToI32 ( SHIFTR ( IAND ( RawVal , ExponentMask ), SignificandBits )) RETURN END FUNCTION RawFP_BiasedExponent !****************************************************************************** FUNCTION RawFP_Significand ( RawVal ) RESULT ( Significand ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Significand !** PURPOSE OF THIS SUBROUTINE: ! To determine the significand of the floating point value IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: RawVal TYPE ( UInt128 ) :: Significand !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Significand = IAND ( RawVal , SignificandMask ) RETURN END FUNCTION RawFP_Significand !****************************************************************************** FUNCTION RawFP_Construct ( FpBin ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_Construct !** PURPOSE OF THIS SUBROUTINE: ! To construct a raw binary floating point number based on ! its three parts IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BinRep ), INTENT ( IN ) :: FpBin TYPE ( UInt128 ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! set sign bit IF ( FpBin % Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF ! add exponent bits RawVal = IOR ( RawVal , SHIFTL ( UInt128 ( FpBin % Exponent ), SignificandBits )) ! add (both implicit and explicit) significand bits RawVal = IOR ( RawVal , IAND ( FpBin % Significand , SignificandMask )) RETURN END FUNCTION RawFP_Construct !****************************************************************************** FUNCTION RawFP_FromFloat ( RealVal ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_FromFloat !** PURPOSE OF THIS SUBROUTINE: ! To construct a raw binary floating point number based on ! the specified real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: RealVal TYPE ( UInt128 ) :: RawVal !** SUBROUTINE PARAMETER DECLARATIONS: LOGICAL , PARAMETER :: Little_Endian = ( TRANSFER ([ 1_I1B , 0_I1B , 0_I1B , 0_I1B ], & 0_I4B ) == 1_I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW IF ( Little_Endian ) THEN ! little-endian order FloatVal = RealVal RawVal = UInt128 ( IntVal ( 2 ), IntVal ( 1 )) ! UInt128(HiVal, LowVal) ELSE ! big-endian order FloatVal = RealVal RawVal = UInt128 ( IntVal ( 1 ), IntVal ( 2 )) END IF RETURN END FUNCTION RawFP_FromFloat !****************************************************************************** FUNCTION RawFP_ToFloat ( RawVal ) RESULT ( RealVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_ToFloat !** PURPOSE OF THIS SUBROUTINE: ! To convert a raw binary floating point number into ! its equivalent real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: RawVal REAL ( KIND = QP ) :: RealVal !** SUBROUTINE PARAMETER DECLARATIONS: LOGICAL , PARAMETER :: Little_Endian = ( TRANSFER ([ 1_I1B , 0_I1B , 0_I1B , 0_I1B ], & 0_I4B ) == 1_I4B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: IntVal ( 2 ) REAL ( KIND = QP ) :: FloatVal EQUIVALENCE ( IntVal , FloatVal ) !** FLOW IF ( Little_Endian ) THEN ! little-endian order IntVal ( 2 ) = RawVal % High IntVal ( 1 ) = RawVal % Low RealVal = FloatVal ELSE ! big-endian order IntVal ( 1 ) = RawVal % High IntVal ( 2 ) = RawVal % Low RealVal = FloatVal END IF RETURN END FUNCTION RawFP_ToFloat !****************************************************************************** FUNCTION RawFP_SetZero ( Negative ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetZero !** PURPOSE OF THIS SUBROUTINE: ! To set value to zero IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative TYPE ( UInt128 ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Negative ) THEN RawVal = SignMask ELSE RawVal = ZeroU128 END IF RETURN END FUNCTION RawFP_SetZero !****************************************************************************** FUNCTION RawFP_SetInfinity ( Negative ) RESULT ( RawVal ) !DIR$ ATTRIBUTES FORCEINLINE :: RawFP_SetInfinity !** PURPOSE OF THIS SUBROUTINE: ! To set value to infinity IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative TYPE ( UInt128 ) :: RawVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Exponent !** FLOW ! set sign of infinity RawVal = RawFP_SetZero ( Negative ) ! set infinity biased exponent Exponent = IAND ( SHIFTL ( UInt128 ( MaxExponent ), SignificandBits ), ExponentMask ) RawVal = IAND ( RawVal , NOT ( ExponentMask )) RawVal = IOR ( RawVal , Exponent ) RETURN END FUNCTION RawFP_SetInfinity !****************************************************************************** !------------------------------------------------------------------------------ ! !               HIGH-PRECISION DECIMAL (HPDECIMAL) ROUTINES ! !------------------------------------------------------------------------------ FUNCTION HPDec_Should_Round_Up ( HP , RoundToDigit ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To return a flag indicating whether to round a number up !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: RoundToDigit LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( RoundToDigit < 0 ). OR .( RoundToDigit >= HP % NumDigits )) THEN Flag = FalseVal RETURN END IF ! If we're right in the middle and there are no extra digits IF (( HP % Digits ( RoundToDigit ) == 5 ) . AND .( RoundToDigit + 1 == HP % NumDigits )) THEN ! Round up if we've truncated (since that means the result is slightly ! higher than what's represented.) IF ( HP % Truncated ) THEN Flag = TrueVal RETURN END IF ! If this exactly halfway, round to even. IF ( RoundToDigit == 0 ) THEN ! When the input is \".5\". Flag = FalseVal RETURN END IF Flag = MOD ( HP % Digits ( RoundToDigit - 1 ), 2 ) /= 0 RETURN END IF ! If there are digits after roundToDigit, they must be non-zero since we ! trim trailing zeroes after all operations that change digits. Flag = HP % Digits ( RoundToDigit ) >= 5 RETURN END FUNCTION HPDec_Should_Round_Up !****************************************************************************** FUNCTION HPDec_Get_Num_New_Digits ( HP , LShiftAmount ) RESULT ( NewDigits ) !** PURPOSE OF THIS SUBROUTINE: ! Takes an amount to left shift and returns the number of new digits needed ! to store the result based on LEFT_SHIFT_DIGIT_TABLE. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: LShiftAmount INTEGER ( KIND = I4B ) :: NewDigits !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = :), ALLOCATABLE :: PowerOfFive INTEGER ( KIND = I1B ) :: CurDigit , P5Digit INTEGER ( KIND = I4B ) :: Indx INTEGER ( KIND = I4B ) :: Length !** FLOW Length = LShift_Length ( LShiftAmount ) PowerOfFive = LShift_PowFive ( LShiftAmount )( 1 : Length ) NewDigits = LShift_Digits ( LShiftAmount ) Indx = 1 DO WHILE ( Indx <= Length ) IF ( Indx > HP % NumDigits ) THEN NewDigits = NewDigits - 1 RETURN END IF P5Digit = INT ( IACHAR ( PowerOfFive ( Indx : Indx )) - A0 , KIND = I1B ) CurDigit = HP % Digits ( Indx - 1 ) IF ( CurDigit /= P5Digit ) THEN IF ( CurDigit < P5Digit ) NewDigits = NewDigits - 1 RETURN END IF Indx = Indx + 1 END DO RETURN END FUNCTION HPDec_Get_Num_New_Digits !****************************************************************************** SUBROUTINE HPDec_Trim_Trailing_Zeroes ( HP ) !** PURPOSE OF THIS SUBROUTINE: ! Trim all trailing 0s !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW DO WHILE (( HP % NumDigits > 0 ). AND .( HP % Digits ( HP % NumDigits - 1 ) == 0 )) HP % NumDigits = HP % NumDigits - 1 END DO IF ( HP % NumDigits == 0 ) THEN HP % DecimalPoint = 0 END IF RETURN END SUBROUTINE HPDec_Trim_Trailing_Zeroes !****************************************************************************** SUBROUTINE HPDec_Right_Shift ( HP , ShiftAmount ) !** PURPOSE OF THIS SUBROUTINE: ! Perform a digitwise binary non-rounding right shift on this value by ShiftAmount. ! The ShiftAmount can't be more than MAX_SHIFT_AMOUNT to prevent overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftAmount !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ReadIndx INTEGER ( KIND = I4B ) :: WriteIndx INTEGER ( KIND = I8B ) :: Accumulator INTEGER ( KIND = I8B ) :: ShiftMask INTEGER ( KIND = I8B ) :: ReadDigit INTEGER ( KIND = I8B ) :: WriteDigit !** FLOW ! initialize ReadIndx = 0 WriteIndx = 0 Accumulator = 0_I8B ShiftMask = SHIFTL ( 1_I8B , ShiftAmount ) - 1_I8B ! Warm Up phase: we don't have enough digits to start writing, so just ! read them into the Accumulator. DO WHILE ( SHIFTR ( Accumulator , ShiftAmount ) == 0_I8B ) ReadDigit = 0_I8B ! If there are still digits to read, read the next one, else the digit is ! assumed to be 0. IF ( ReadIndx < HP % NumDigits ) ReadDigit = HP % Digits ( ReadIndx ) Accumulator = Accumulator * 10_I8B + ReadDigit ReadIndx = ReadIndx + 1 END DO ! Shift the decimal point by the number of digits it took to fill the ! Accumulator. HP % DecimalPoint = HP % DecimalPoint - ( ReadIndx - 1 ) ! Middle phase: we have enough digits to write, as well as more digits to ! read. Keep reading until we run out of digits. DO WHILE ( ReadIndx < HP % NumDigits ) ReadDigit = HP % Digits ( ReadIndx ) WriteDigit = SHIFTR ( Accumulator , ShiftAmount ) Accumulator = IAND ( Accumulator , ShiftMask ) HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) Accumulator = Accumulator * 10_I8B + ReadDigit ReadIndx = ReadIndx + 1 WriteIndx = WriteIndx + 1 END DO ! Cool Down phase: All of the readable digits have been read, so just write ! the remainder, DO WHILE treating any more digits as 0. ! DO WHILE (Accumulator > 0_I8B) DO WHILE ( Accumulator /= 0_I8B ) ! +++ unsigned comparison +++ WriteDigit = SHIFTR ( Accumulator , ShiftAmount ) Accumulator = IAND ( Accumulator , ShiftMask ) IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) WriteIndx = WriteIndx + 1 ELSEIF ( WriteDigit /= 0_I8B ) THEN ! +++ unsigned comparison +++ HP % Truncated = TrueVal END IF Accumulator = Accumulator * 10_I8B END DO HP % NumDigits = WriteIndx CALL HP % TrimTrailingZeroes () RETURN END SUBROUTINE HPDec_Right_Shift !****************************************************************************** SUBROUTINE HPDec_Left_Shift ( HP , ShiftAmount ) !** PURPOSE OF THIS SUBROUTINE: ! Perform a digitwise binary non-rounding left shift on this value by ShiftAmount. ! The ShiftAmount can't be more than MAX_SHIFT_AMOUNT to prevent overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: ShiftAmount !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: NewDigits INTEGER ( KIND = I4B ) :: ReadIndx INTEGER ( KIND = I4B ) :: WriteIndx INTEGER ( KIND = I8B ) :: Accumulator INTEGER ( KIND = I8B ) :: NextAccumulator INTEGER ( KIND = I8B ) :: WriteDigit !** FLOW ! initialize NewDigits = HP % GetNumNewDigits ( ShiftAmount ) ReadIndx = HP % NumDigits - 1 WriteIndx = HP % NumDigits + NewDigits Accumulator = 0_I8B ! No Warm Up phase. Since we're putting digits in at the top and taking ! digits from the bottom we don't have to wait for the Accumulator to fill. ! Middle phase: while we have more digits to read, keep reading as well as ! writing. DO WHILE ( ReadIndx >= 0 ) Accumulator = Accumulator + SHIFTL ( INT ( HP % Digits ( ReadIndx ), KIND = I8B ), ShiftAmount ) ! +++ unsigned division and modulation +++ ! NextAccumulator = Accumulator / 10_I8B ! WriteDigit = Accumulator - (10_I8B * NextAccumulator) CALL UDivMod ( Accumulator , 10_I8B , NextAccumulator , WriteDigit ) WriteIndx = WriteIndx - 1 IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) ELSEIF ( WriteDigit /= 0_I8B ) THEN HP % Truncated = TrueVal END IF Accumulator = NextAccumulator ReadIndx = ReadIndx - 1 END DO ! Cool Down phase: there are no more digits to read, so just write the ! remaining digits in the Accumulator. ! DO WHILE (Accumulator > 0_I8B) DO WHILE ( Accumulator /= 0_I8B ) ! +++ unsigned comparison +++ ! +++ unsigned division and modulation +++ ! NextAccumulator = Accumulator / 10_I8B ! WriteDigit = Accumulator - (10_I8B * NextAccumulator) CALL UDivMod ( Accumulator , 10_I8B , NextAccumulator , WriteDigit ) WriteIndx = WriteIndx - 1 IF ( WriteIndx < MAX_NUM_DIGITS ) THEN HP % Digits ( WriteIndx ) = INT ( WriteDigit , KIND = I1B ) ELSEIF ( WriteDigit /= 0_I8B ) THEN HP % Truncated = TrueVal END IF Accumulator = NextAccumulator END DO HP % NumDigits = HP % NumDigits + NewDigits IF ( HP % NumDigits > MAX_NUM_DIGITS ) THEN HP % NumDigits = MAX_NUM_DIGITS END IF HP % DecimalPoint = HP % DecimalPoint + NewDigits CALL HP % TrimTrailingZeroes () RETURN END SUBROUTINE HPDec_Left_Shift !****************************************************************************** SUBROUTINE HPDec_Construct ( HP , cStr , Start , Finish ) !** PURPOSE OF THIS SUBROUTINE: ! To construct 'HPDecimal' based on input string (cStr) where !   - Start is the index of the first valid numeric character, and !   - Finish is the index of the last valid character (== length of the input !     string excluding trailing space(s)) ! The routine assumes that cStr is a 'VALID' floating point string and ! Start is less than Finish. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start INTEGER ( KIND = I4B ), INTENT ( IN ) :: Finish !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) CHARACTER ( LEN =* ), PARAMETER :: SET_DIGITS = '0123456789' CHARACTER ( LEN =* ), PARAMETER :: SET_EXPONENTS = 'EeDdQq' CHARACTER ( LEN =* ), PARAMETER :: SET_SIGNS = '+-' CHARACTER ( LEN =* ), PARAMETER :: SET_INTEGERS = SET_DIGITS // SET_SIGNS !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Ptr INTEGER ( KIND = I4B ) :: Add2Exp LOGICAL :: SawDot INTEGER ( KIND = I4B ) :: TotalDigits ! This counts the digits in the number, even if ! there isn't space to store them all. !** FLOW ! initialize Ptr = Start SawDot = FalseVal TotalDigits = 0 DO WHILE (( Is_Character_Digit ( cStr ( Ptr : Ptr ))). OR .( cStr ( Ptr : Ptr ) == '.' )) IF ( cStr ( Ptr : Ptr ) == '.' ) THEN IF ( SawDot ) EXIT HP % DecimalPoint = TotalDigits SawDot = TrueVal ELSE IF (( cStr ( Ptr : Ptr ) == '0' ). AND .( HP % NumDigits == 0 )) THEN HP % DecimalPoint = HP % DecimalPoint - 1 Ptr = Ptr + 1 IF ( Ptr <= Finish ) THEN CYCLE ELSE EXIT END IF END IF TotalDigits = TotalDigits + 1 IF ( HP % NumDigits < MAX_NUM_DIGITS ) THEN HP % Digits ( HP % NumDigits ) = INT ( IACHAR ( cStr ( Ptr : Ptr )) - A0 , KIND = I1B ) HP % NumDigits = HP % NumDigits + 1 ELSEIF ( cStr ( Ptr : Ptr ) /= '0' ) THEN HP % Truncated = TrueVal END IF END IF Ptr = Ptr + 1 IF ( Ptr > Finish ) EXIT END DO IF (. NOT . SawDot ) HP % DecimalPoint = TotalDigits IF ( Ptr <= Finish ) THEN IF ( Is_Character_Exponent ( cStr ( Ptr : Ptr ))) THEN Ptr = Ptr + 1 IF ( Ptr <= Finish ) THEN IF ( Is_Character_Integer ( cStr ( Ptr : Ptr ))) THEN Add2Exp = I32_FromChar ( cStr ( Ptr :)) IF ( Add2Exp > 100000 ) THEN Add2Exp = 100000 ELSEIF ( Add2Exp < - 100000 ) THEN Add2Exp = - 100000 END IF HP % DecimalPoint = HP % DecimalPoint + Add2Exp END IF END IF ELSEIF ( Is_Character_Sign ( cStr ( Ptr : Ptr ))) THEN Add2Exp = I32_FromChar ( cStr ( Ptr :)) IF ( Add2Exp > 100000 ) THEN Add2Exp = 100000 ELSEIF ( Add2Exp < - 100000 ) THEN Add2Exp = - 100000 END IF HP % DecimalPoint = HP % DecimalPoint + Add2Exp END IF END IF CALL HP % TrimTrailingZeroes () RETURN CONTAINS FUNCTION Is_Character_Digit ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'DIGIT' set !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_DIGITS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Digit !************************************************************************** FUNCTION Is_Character_Exponent ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is an 'exponent' character !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_EXPONENTS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Exponent !************************************************************************** FUNCTION Is_Character_Integer ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'INTEGER' set !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_INTEGERS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Integer !************************************************************************** FUNCTION Is_Character_Sign ( Chr ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given character is in the 'SIGN' set !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Chr ! character LOGICAL :: Flag ! true if the character is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Flag = ( INDEX ( SET_SIGNS , Chr ) /= 0 ) RETURN END FUNCTION Is_Character_Sign !************************************************************************** END SUBROUTINE HPDec_Construct !****************************************************************************** SUBROUTINE HPDec_Shift ( HP , Shift ) !** PURPOSE OF THIS SUBROUTINE: ! Binary shift left (ShiftAmount > 0) or right (ShiftAmount < 0) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( INOUT ) :: HP INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftAmount !** FLOW ShiftAmount = Shift IF ( ShiftAmount > 0 ) THEN ! Left shift DO WHILE ( ShiftAmount > MAX_SHIFT_AMOUNT ) CALL HP % LeftShift ( MAX_SHIFT_AMOUNT ) ShiftAmount = ShiftAmount - MAX_SHIFT_AMOUNT END DO CALL HP % LeftShift ( ShiftAmount ) ELSEIF ( ShiftAmount < 0 ) THEN ! Right shift DO WHILE ( ShiftAmount < - MAX_SHIFT_AMOUNT ) CALL HP % RightShift ( MAX_SHIFT_AMOUNT ) ShiftAmount = ShiftAmount + MAX_SHIFT_AMOUNT END DO CALL HP % RightShift ( - ShiftAmount ) END IF RETURN END SUBROUTINE HPDec_Shift !****************************************************************************** SUBROUTINE HPDec_Round_To_UInt ( HP , ResVal ) !** PURPOSE OF THIS SUBROUTINE: ! Round the number represented to the closest value of UIntType. ! This is done ignoring overflow. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HPDecimal ), INTENT ( IN ) :: HP TYPE ( UInt128 ), INTENT ( OUT ) :: ResVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: CurDigit !** FLOW ResVal = ZeroU128 CurDigit = 0 DO WHILE (( CurDigit < HP % DecimalPoint ). AND .( CurDigit < HP % NumDigits )) CALL Multiply ( ResVal , 10 ) CALL Add ( ResVal , INT ( HP % Digits ( CurDigit ), KIND = I4B )) CurDigit = CurDigit + 1 END DO ! If there are implicit 0s at the end of the number, include those. DO WHILE ( CurDigit < HP % DecimalPoint ) CALL Multiply ( ResVal , 10 ) CurDigit = CurDigit + 1 END DO IF ( HP % ShouldRoundUp ( HP % DecimalPoint )) THEN CALL Increment ( ResVal ) END IF RETURN END SUBROUTINE HPDec_Round_To_UInt !****************************************************************************** !------------------------------------------------------------------------------ ! !            MULTI-PRECISION UNSIGNED INTEGER (BIGUINT) ROUTINES ! !------------------------------------------------------------------------------ ! ----------------------------------------------------------------------------- ! -----   BigUInt Routines for FastFloat Algorithms                       ----- ! ----------------------------------------------------------------------------- FUNCTION Empty_Hi64 ( Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: Empty_Hi64 !** PURPOSE OF THIS SUBROUTINE: ! To return empty value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Truncated = FalseVal Val = 0_I8B RETURN END FUNCTION Empty_Hi64 !****************************************************************************** FUNCTION UInt64_Hi64_I ( R0 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Hi64_I !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW Truncated = FalseVal ShiftPos = LEADZ ( R0 ) Val = SHIFTL ( R0 , ShiftPos ) RETURN END FUNCTION UInt64_Hi64_I !****************************************************************************** FUNCTION UInt64_Hi64_II ( R0 , R1 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt64_Hi64_II !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 values. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 , R1 LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW ShiftPos = LEADZ ( R0 ) IF ( ShiftPos == 0 ) THEN Truncated = R1 /= 0_I8B Val = R0 ELSE Truncated = SHIFTL ( R1 , ShiftPos ) /= 0_I8B Val = IOR ( SHIFTL ( R0 , ShiftPos ), SHIFTR ( R1 , 64 - ShiftPos )) END IF RETURN END FUNCTION UInt64_Hi64_II !****************************************************************************** FUNCTION UInt128_Hi128_I ( R0 , R1 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt128_Hi128_I !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 values. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 , R1 LOGICAL , INTENT ( OUT ) :: Truncated TYPE ( UInt128 ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW Truncated = FalseVal ShiftPos = LEADZ ( R0 ) IF ( ShiftPos == 0 ) THEN Val = UInt128 ( R0 , R1 ) ELSE Val % High = IOR ( SHIFTL ( R0 , ShiftPos ), SHIFTR ( R1 , 64 - ShiftPos )) Val % Low = SHIFTL ( R1 , ShiftPos ) END IF RETURN END FUNCTION UInt128_Hi128_I !****************************************************************************** FUNCTION UInt128_Hi128_II ( R0 , R1 , R2 , Truncated ) RESULT ( Val ) !DIR$ ATTRIBUTES FORCEINLINE :: UInt128_Hi128_II !** PURPOSE OF THIS SUBROUTINE: ! To return high bit of uint64 values. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: R0 , R1 , R2 LOGICAL , INTENT ( OUT ) :: Truncated TYPE ( UInt128 ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ShiftPos !** FLOW ShiftPos = LEADZ ( R0 ) IF ( ShiftPos == 0 ) THEN Truncated = R2 /= 0_I8B Val = UInt128 ( R0 , R1 ) ELSE Truncated = SHIFTL ( R2 , ShiftPos ) /= 0_I8B Val % High = IOR ( SHIFTL ( R0 , ShiftPos ), SHIFTR ( R1 , 64 - ShiftPos )) Val % Low = IOR ( SHIFTL ( R1 , ShiftPos ), SHIFTR ( R2 , 64 - ShiftPos )) END IF RETURN END FUNCTION UInt128_Hi128_II !****************************************************************************** FUNCTION BigUInt_IsEmpty ( Big ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether BigUInt is empty or not. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL :: Flag ! true if empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = Big % Length == 0 RETURN END FUNCTION BigUInt_IsEmpty !****************************************************************************** FUNCTION BigUInt_IsNonZero ( Big , Index ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check if any limbs are non-zero after the given index. ! this needs to be done in reverse order, since the index ! is relative to the most significant limbs. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big ! BigUInt object INTEGER ( KIND = I4B ), INTENT ( IN ) :: Index ! the specified index LOGICAL :: Flag ! true if the stack is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: I , RIndex !** FLOW I = Index DO WHILE ( I < Big % Length ) RIndex = Big % Length - I - 1 IF ( Big % Digit ( RIndex ) /= 0_I8B ) THEN Flag = TrueVal RETURN END IF I = I + 1 END DO Flag = FalseVal RETURN END FUNCTION BigUInt_IsNonZero !****************************************************************************** SUBROUTINE BigUInt_Push ( Big , Value ) !** PURPOSE OF THIS SUBROUTINE: ! To append the item to the BigUInt IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Value ! item to be appended !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Big % Digit ( Big % Length ) = Value Big % Length = Big % Length + 1 RETURN END SUBROUTINE BigUInt_Push !****************************************************************************** SUBROUTINE BigUInt_Extend ( Big , Span ) !** PURPOSE OF THIS SUBROUTINE: ! To append a span of items to the stack IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Span ( 0 :) ! span of items to be appended !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SpanLen ! FLOW SpanLen = SIZE ( Span ) Big % Digit ( Big % Length : Big % Length + SpanLen - 1 ) = Span ( 0 : SpanLen - 1 ) Big % Length = Big % Length + SpanLen RETURN END SUBROUTINE BigUInt_Extend !****************************************************************************** SUBROUTINE BigUInt_Normalize ( Big ) !** PURPOSE OF THIS SUBROUTINE: ! To normalize the BigUInt, so most-significant zero digits are removed. IMPLICIT NONE !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex ! FLOW RIndex = Big % Length - 1 IF ( RIndex >= 0 ) THEN DO WHILE ( Big % Digit ( RIndex ) == 0_I8B ) Big % Length = Big % Length - 1 RIndex = Big % Length - 1 IF ( RIndex < 0 ) EXIT END DO END IF RETURN END SUBROUTINE BigUInt_Normalize !****************************************************************************** FUNCTION ScalarAdd ( X , Y , Overflow ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To add two small integers, checking for overflow. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y LOGICAL , INTENT ( OUT ) :: Overflow INTEGER ( KIND = I8B ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! add value Z = X + Y ! check overflow Overflow = Z . ULT . X RETURN END FUNCTION ScalarAdd !****************************************************************************** FUNCTION ScalarMul ( X , Y , Carry ) RESULT ( Z_Low ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply two small integers, getting both the high and low bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: X , Y INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Carry INTEGER ( KIND = I8B ) :: Z_Low !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Z_Hi LOGICAL :: Overflow !** FLOW CALL UMul128 ( X , Y , Z_Hi , Z_Low ) Z_Low = ScalarAdd ( Z_Low , Carry , Overflow ) IF ( Overflow ) Z_Hi = Z_Hi + 1_I8B ! cannot overflow Carry = Z_Hi RETURN END FUNCTION ScalarMul !****************************************************************************** SUBROUTINE BigUInt_SmallMul ( Big , Y ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply BigUInt by scalar value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y ! value to be added !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index INTEGER ( KIND = I8B ) :: Carry !** FLOW Carry = 0_I8B DO Index = 0 , Big % Length - 1 Big % Digit ( Index ) = ScalarMul ( Big % Digit ( Index ), Y , Carry ) END DO IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_SmallMul !****************************************************************************** SUBROUTINE BigUInt_LongMul ( Big , Span ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply BigUInt and BigUInt using grade-school multiplication algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big ! BigUInt object INTEGER ( KIND = I8B ), INTENT ( IN ) :: Span ( 0 :) ! span of values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: SpanLen INTEGER ( KIND = I8B ) :: Z ( 0 : Big % Length + SIZE ( Span ) - 1 ) !** FLOW SpanLen = SIZE ( Span ) IF ( SpanLen /= 0 ) THEN ! perform multiplication CALL MultiplyBasic ( Big % Digit , Big % Length , Span , SpanLen , Z ) ! transfer output from the buffer back to the stack Big % Length = Big % Length + SpanLen Big % Digit ( 0 : Big % Length - 1 ) = Z ( 0 : Big % Length - 1 ) END IF CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_LongMul !****************************************************************************** SUBROUTINE BigUInt_From_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To create BigUInt from a unsigned 64-bit integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Push ( Val ) CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_From_U64 !****************************************************************************** FUNCTION BigUInt_Get_Hi64 ( Big , Truncated ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To get the high 64 bits from the vector, and if bits were truncated. ! this is to get the significant digits for the float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL , INTENT ( OUT ) :: Truncated INTEGER ( KIND = I8B ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex !** FLOW IF ( Big % Length == 0 ) THEN Val = Empty_Hi64 ( Truncated ) ELSEIF ( Big % Length == 1 ) THEN RIndex = Big % Length - 1 Val = Uint64_Hi64_I ( Big % Digit ( RIndex ), Truncated ) ELSE RIndex = Big % Length - 1 Val = Uint64_Hi64_II ( Big % Digit ( RIndex ), Big % Digit ( RIndex - 1 ), Truncated ) Truncated = Truncated . OR . Big % IsNonZero ( 2 ) END IF RETURN END FUNCTION BigUInt_Get_Hi64 !****************************************************************************** SUBROUTINE BigUInt_From_U128 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To create BigUInt from a 128-bit integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big TYPE ( UInt128 ), INTENT ( IN ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Push ( Val % Low ) CALL Big % Push ( Val % High ) CALL Big % Normalize () RETURN END SUBROUTINE BigUInt_From_U128 !****************************************************************************** FUNCTION BigUInt_Get_Hi128 ( Big , Truncated ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To get the high 128 bits from the vector, and if bits were truncated. ! this is to get the significant digits for the float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big LOGICAL , INTENT ( OUT ) :: Truncated TYPE ( UInt128 ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RIndex !** FLOW IF ( Big % Length == 0 ) THEN Val = UInt128 ( 0_I8B , Empty_Hi64 ( Truncated )) ELSEIF ( Big % Length == 1 ) THEN RIndex = Big % Length - 1 Val = UInt128 ( Uint64_Hi64_I ( Big % Digit ( RIndex ), Truncated ), 0_I8B ) ELSEIF ( Big % Length == 2 ) THEN RIndex = Big % Length - 1 Val = Uint128_Hi128_I ( Big % Digit ( RIndex ), Big % Digit ( RIndex - 1 ), Truncated ) ELSE RIndex = Big % Length - 1 Val = Uint128_Hi128_II ( Big % Digit ( RIndex ), Big % Digit ( RIndex - 1 ), & Big % Digit ( RIndex - 2 ), Truncated ) Truncated = Truncated . OR . Big % IsNonZero ( 3 ) END IF RETURN END FUNCTION BigUInt_Get_Hi128 !****************************************************************************** FUNCTION BigUInt_Compare ( Big , Other ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare two big integers, returning the large value. ! assumes both are normalized. if the return value is ! negative, other is larger, if the return value is ! positive, this is larger, otherwise they are equal. ! the limbs are stored in little-endian order, so we ! must compare the limbs in ever order. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big , Other INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index !** FLOW IF ( Big % Length > Other % Length ) THEN Flag = 1 ELSEIF ( Big % Length < Other % Length ) THEN Flag = - 1 ELSE DO Index = Big % Length - 1 , 0 , - 1 ASSOCIATE ( XI => Big % Digit ( Index ), YI => Other % Digit ( Index )) IF ( XI . UGT . YI ) THEN Flag = 1 RETURN ELSEIF ( XI . ULT . YI ) THEN Flag = - 1 RETURN END IF END ASSOCIATE END DO Flag = 0 END IF RETURN END FUNCTION BigUInt_Compare !****************************************************************************** SUBROUTINE BigUInt_ShiftL ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To move the limbs left by `n` bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE PARAMETER DECLARATIONS: ! these parameters are for DigitBits = 64 INTEGER ( KIND = I4B ), PARAMETER :: LargePos = 6 INTEGER ( KIND = I4B ), PARAMETER :: SmallMask = 63 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LargeShift , SmallShift !** FLOW LargeShift = SHIFTR ( N , LargePos ) SmallShift = IAND ( N , SmallMask ) IF ( LargeShift > 0 ) CALL BigUInt_ShiftL_Limbs ( Big , LargeShift ) ! shift array elements IF ( SmallShift > 0 ) CALL BigUInt_ShiftL_Bits ( Big , SmallShift ) ! shift bits of array elements RETURN CONTAINS SUBROUTINE BigUInt_ShiftL_Bits ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To shift left each limb n bits, carrying over to the new limb ! returns true if we were able to shift all the digits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index , Shl , Shr INTEGER ( KIND = I8B ) :: XI , Carry , Prev !** FLOW ! Internally, for each item, we shift left by n, and add the previous ! right shifted limb-bits. ! For example, we transform (for u8) shifted left 2, to: !      b10100100 b01000010 !      b10 b10010001 b00001000 ! ASSERT(n /= 0) ! ASSERT(n < sizeof(limb) * 8) Shl = N Shr = DigitBits - Shl Prev = 0_I8B DO Index = 0 , Big % Length - 1 XI = Big % Digit ( Index ) Big % Digit ( Index ) = IOR ( SHIFTL ( XI , Shl ), SHIFTR ( Prev , Shr )) Prev = XI END DO Carry = SHIFTR ( Prev , Shr ) IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_ShiftL_Bits !************************************************************************** SUBROUTINE BigUInt_ShiftL_Limbs ( Big , N ) !** PURPOSE OF THIS SUBROUTINE: ! To move the limbs left by `n` limbs. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Buffer ( 0 : Big % Length - 1 ) !** FLOW IF (. NOT . Big % IsEmpty ()) THEN ! move limbs by first copy source to buffer Buffer ( 0 : Big % Length - 1 ) = Big % Digit ( 0 : Big % Length - 1 ) ! then copy from the buffer to the destination Big % Digit ( N : Big % Length + N - 1 ) = Buffer ( 0 : Big % Length - 1 ) ! fill in empty limbs Big % Digit ( 0 : N - 1 ) = 0_I8B ! set length Big % Length = Big % Length + N END IF RETURN END SUBROUTINE BigUInt_ShiftL_Limbs !************************************************************************** END SUBROUTINE BigUInt_ShiftL !****************************************************************************** FUNCTION BigUInt_LeadZ ( Big ) RESULT ( N ) !** PURPOSE OF THIS SUBROUTINE: ! To get the number of leading zeros in the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big INTEGER ( KIND = I4B ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Big % IsEmpty ()) THEN N = 0 ELSE N = LEADZ ( Big % Digit ( Big % Length - 1 )) END IF RETURN END FUNCTION BigUInt_LeadZ !****************************************************************************** FUNCTION BigUInt_BitLen ( Big ) RESULT ( N ) !** PURPOSE OF THIS SUBROUTINE: ! To get the number of bits in the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( IN ) :: Big INTEGER ( KIND = I4B ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ !** FLOW LZ = Big % LeadZ () N = DigitBits * Big % Length - LZ RETURN END FUNCTION BigUInt_BitLen !****************************************************************************** SUBROUTINE BigUInt_Add ( Big , Y ) !** PURPOSE OF THIS SUBROUTINE: ! To add a long number (unsigned 64-bit integer) to the BigUInt. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Index INTEGER ( KIND = I8B ) :: Carry LOGICAL :: Overflow !** FLOW Index = 0 Carry = Y DO WHILE (( Carry /= 0_I8B ). AND .( Index < Big % Length )) Big % Digit ( Index ) = ScalarAdd ( Big % Digit ( Index ), Carry , Overflow ) IF ( Overflow ) THEN Carry = 1_I8B ELSE Carry = 0_I8B END IF Index = Index + 1 END DO IF ( Carry /= 0_I8B ) CALL Big % Push ( Carry ) RETURN END SUBROUTINE BigUInt_Add !****************************************************************************** SUBROUTINE BigUInt_Pow2 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 2 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % ShiftL ( Exp ) RETURN END SUBROUTINE BigUInt_Pow2 !****************************************************************************** SUBROUTINE BigUInt_Pow5 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 5 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE PARAMETER DECLARATIONS: ! multiply by a power of 5 INTEGER ( KIND = I4B ), PARAMETER :: Large_Step = 135 INTEGER ( KIND = I4B ), PARAMETER :: Small_Step = 27 INTEGER ( KIND = I4B ), PARAMETER :: Large_Length = 5 INTEGER ( KIND = I8B ), PARAMETER :: Small_Power_of_5 ( 0 : Small_Step ) = [ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '0000000000000005' , KIND = I8B ), & INT ( Z '0000000000000019' , KIND = I8B ), INT ( Z '000000000000007D' , KIND = I8B ), & INT ( Z '0000000000000271' , KIND = I8B ), INT ( Z '0000000000000C35' , KIND = I8B ), & INT ( Z '0000000000003D09' , KIND = I8B ), INT ( Z '000000000001312D' , KIND = I8B ), & INT ( Z '000000000005F5E1' , KIND = I8B ), INT ( Z '00000000001DCD65' , KIND = I8B ), & INT ( Z '00000000009502F9' , KIND = I8B ), INT ( Z '0000000002E90EDD' , KIND = I8B ), & INT ( Z '000000000E8D4A51' , KIND = I8B ), INT ( Z '0000000048C27395' , KIND = I8B ), & INT ( Z '000000016BCC41E9' , KIND = I8B ), INT ( Z '000000071AFD498D' , KIND = I8B ), & INT ( Z '0000002386F26FC1' , KIND = I8B ), INT ( Z '000000B1A2BC2EC5' , KIND = I8B ), & INT ( Z '000003782DACE9D9' , KIND = I8B ), INT ( Z '00001158E460913D' , KIND = I8B ), & INT ( Z '000056BC75E2D631' , KIND = I8B ), INT ( Z '0001B1AE4D6E2EF5' , KIND = I8B ), & INT ( Z '000878678326EAC9' , KIND = I8B ), INT ( Z '002A5A058FC295ED' , KIND = I8B ), & INT ( Z '00D3C21BCECCEDA1' , KIND = I8B ), INT ( Z '0422CA8B0A00A425' , KIND = I8B ), & INT ( Z '14ADF4B7320334B9' , KIND = I8B ), INT ( Z '6765C793FA10079D' , KIND = I8B )] INTEGER ( KIND = I8B ), PARAMETER :: Max_Native = Small_Power_of_5 ( Small_Step ) ! 7450580596923828125_I8B INTEGER ( KIND = I8B ), PARAMETER :: Large_Power_of_5 ( 0 : Large_Length - 1 ) = [ & INT ( Z '13A1D71CFF1B172D' , KIND = I8B ), INT ( Z '7F682D3DEFA07617' , KIND = I8B ), & INT ( Z '3F0131E7FF8C90C0' , KIND = I8B ), INT ( Z '917B01773FDCB9FE' , KIND = I8B ), & INT ( Z '2C06B9D16C407A7' , KIND = I8B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: IExp !** FLOW IExp = Exp ! multiply Big by 5**Large_Step DO WHILE ( IExp >= Large_Step ) CALL Big % LongMul ( Large_Power_of_5 ) IExp = IExp - Large_Step END DO ! multiply Big by 5**Small_Step DO WHILE ( IExp >= Small_Step ) CALL Big % SmallMul ( Max_Native ) IExp = IExp - Small_Step END DO ! multiply Big by 5**IExp IF ( IExp /= 0 ) CALL Big % SmallMul ( Small_Power_of_5 ( IExp )) RETURN END SUBROUTINE BigUInt_Pow5 !****************************************************************************** SUBROUTINE BigUInt_Pow10 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply as if by 10 raised to a power. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % Pow5 ( Exp ) CALL Big % Pow2 ( Exp ) RETURN END SUBROUTINE BigUInt_Pow10 ! ----------------------------------------------------------------------------- ! -----   BigUInt Routines for YY Algorithms                              ----- ! ----------------------------------------------------------------------------- SUBROUTINE BigInt_Add_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big + Val'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx , Max INTEGER ( KIND = I8B ) :: Num , Add !** FLOW Num = Big % Digit ( 0 ) Add = Num + Val Big % Digit ( 0 ) = Add IF (( Add . UGE . Num ). OR .( Add . UGE . Val )) RETURN ! add digit Max = Big % Length DO Idx = 1 , Max - 1 IF ( Big % Digit ( Idx ) /= MaxU64 ) THEN Big % Digit ( Idx ) = Big % Digit ( Idx ) + 1_I8B RETURN END IF Big % Digit ( Idx ) = 0_I8B END DO Big % Digit ( Big % Length ) = 1_I8B Big % Length = Big % Length + 1 RETURN END SUBROUTINE BigInt_Add_U64 !****************************************************************************** SUBROUTINE BigInt_Mul_U64 ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * Val'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I8B ), INTENT ( IN ) :: Val ! an unsigned integer (cannot be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx , Max INTEGER ( KIND = I8B ) :: Hi , Lo , Carry !** FLOW ! initialize Idx = 0 Max = Big % Length Carry = 0_I8B DO WHILE ( Idx < Max ) IF ( Big % Digit ( Idx ) /= 0_I8B ) EXIT Idx = Idx + 1 END DO DO WHILE ( Idx < Max ) CALL UMul128_N_Add ( Big % Digit ( Idx ), Val , Carry , Hi , Lo ) Big % Digit ( Idx ) = Lo Carry = Hi Idx = Idx + 1 END DO IF ( Carry /= 0_I8B ) THEN Big % Digit ( Big % Length ) = Carry Big % Length = Big % Length + 1 END IF RETURN END SUBROUTINE BigInt_Mul_U64 !****************************************************************************** SUBROUTINE BigInt_Mul_Pow2 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * (2**Exp)'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! an exponent integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift , Move , Idx INTEGER ( KIND = I8B ) :: Num !** FLOW ! initialize Shift = IAND ( Exp , 63 ) ! small shift == MOD(Exp, 64) Move = SHIFTR ( Exp , 6 ) ! large shift == Exp / 64 Idx = Big % Length IF ( Shift == 0 ) THEN DO WHILE ( Idx > 0 ) Big % Digit ( Idx + Move - 1 ) = Big % Digit ( Idx - 1 ) Idx = Idx - 1 END DO Big % Length = Big % Length + Move DO WHILE ( Move /= 0 ) Move = Move - 1 Big % Digit ( Move ) = 0_I8B END DO ELSE Big % Digit ( Idx ) = 0_I8B DO WHILE ( Idx > 0 ) Num = SHIFTL ( Big % Digit ( Idx ), Shift ) Num = IOR ( Num , SHIFTR ( Big % Digit ( Idx - 1 ), ( 64 - Shift ))) Big % Digit ( Idx + Move ) = Num Idx = Idx - 1 END DO Big % Digit ( Move ) = SHIFTL ( Big % Digit ( 0 ), Shift ) IF ( Big % Digit ( Big % Length + Move ) /= 0_I8B ) THEN Big % Length = Big % Length + ( Move + 1 ) ELSE Big % Length = Big % Length + Move END IF DO WHILE ( Move /= 0 ) Move = Move - 1 Big % Digit ( Move ) = 0_I8B END DO END IF RETURN END SUBROUTINE BigInt_Mul_Pow2 !****************************************************************************** SUBROUTINE BigInt_Mul_Pow10 ( Big , Exp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'Big = Big * (10**Exp)'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! an exponent integer (cannot be 0) !** SUBROUTINE PARAMETER DECLARATIONS: ! Maximum exponent of exact pow10 INTEGER ( KIND = I4B ), PARAMETER :: U64_POW10_MAX_EXP = 19 ! Table: [ 10&#94;0, ..., 10&#94;19 ] INTEGER ( KIND = I8B ), PARAMETER :: U64_Pow10_Table ( 0 : U64_POW10_MAX_EXP ) = [ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '000000000000000A' , KIND = I8B ), & INT ( Z '0000000000000064' , KIND = I8B ), INT ( Z '00000000000003E8' , KIND = I8B ), & INT ( Z '0000000000002710' , KIND = I8B ), INT ( Z '00000000000186A0' , KIND = I8B ), & INT ( Z '00000000000F4240' , KIND = I8B ), INT ( Z '0000000000989680' , KIND = I8B ), & INT ( Z '0000000005F5E100' , KIND = I8B ), INT ( Z '000000003B9ACA00' , KIND = I8B ), & INT ( Z '00000002540BE400' , KIND = I8B ), INT ( Z '000000174876E800' , KIND = I8B ), & INT ( Z '000000E8D4A51000' , KIND = I8B ), INT ( Z '000009184E72A000' , KIND = I8B ), & INT ( Z '00005AF3107A4000' , KIND = I8B ), INT ( Z '00038D7EA4C68000' , KIND = I8B ), & INT ( Z '002386F26FC10000' , KIND = I8B ), INT ( Z '016345785D8A0000' , KIND = I8B ), & INT ( Z '0DE0B6B3A7640000' , KIND = I8B ), INT ( Z '8AC7230489E80000' , KIND = I8B )] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Xpn !** FLOW ! initialize Xpn = Exp DO WHILE ( Xpn >= U64_POW10_MAX_EXP ) CALL BigInt_Mul_U64 ( Big , U64_Pow10_Table ( U64_POW10_MAX_EXP )) Xpn = Xpn - U64_POW10_MAX_EXP END DO IF ( Xpn /= 0 ) CALL BigInt_Mul_U64 ( Big , U64_Pow10_Table ( Xpn )) RETURN END SUBROUTINE BigInt_Mul_Pow10 !****************************************************************************** FUNCTION BigInt_Compare ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare two BigUInt. ! return -1 if 'a < b', +1 if 'a > b', 0 if 'a == b'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( IN ) :: A TYPE ( BigUInt ), INTENT ( IN ) :: B INTEGER ( KIND = I4B ) :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Idx !** FLOW ! first check Length components IF ( A % Length < B % Length ) THEN Flag = - 1 RETURN END IF IF ( A % Length > B % Length ) THEN Flag = + 1 RETURN END IF ! next check Digit components Idx = A % Length DO WHILE ( Idx > 0 ) Idx = Idx - 1 ASSOCIATE ( Av => A % Digit ( Idx ), Bv => B % Digit ( Idx )) IF ( Av . ULT . Bv ) THEN Flag = - 1 RETURN END IF IF ( Av . UGT . Bv ) THEN Flag = + 1 RETURN END IF END ASSOCIATE END DO Flag = 0 RETURN END FUNCTION BigInt_Compare !****************************************************************************** SUBROUTINE BigInt_Set_UIntType ( Big , Val ) !** PURPOSE OF THIS SUBROUTINE: ! To set 'Big' with the specified unsigned integer value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) TYPE ( UInt128 ), INTENT ( IN ) :: Val ! an unsigned integer (can be 0) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Big % Length = 2 Big % Digit ( 0 ) = Val % Low Big % Digit ( 1 ) = Val % High RETURN END SUBROUTINE BigInt_Set_UIntType !****************************************************************************** SUBROUTINE BigInt_Set_String ( Big , SigDec , ExpDec , cStr , Aux ) !** PURPOSE OF THIS SUBROUTINE: ! To set 'Big' with the specified floating point number string and its related information. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big ! a big number (can be 0) TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: ExpDec ! exponent in base 10 CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (. NOT . Aux % Truncated ) THEN ! no digit cut, set significant part only CALL BigInt_Set_UIntType ( Big , SigDec ) RETURN END IF ! some digits were cut, read them from 'SigCut' to 'SigEnd' BLOCK ! +++ local variables +++ INTEGER ( KIND = I4B ) :: Header , SigEnd , CurIdx , Length , DigitTotLen , DotPos INTEGER ( KIND = I8B ) :: CurVal LOGICAL :: DigitCut , HasDot ! +++ execution +++ ! initialize and process auxiliary string information needed Header = Aux % SigCut SigEnd = Aux % Indices ( 4 ) CurIdx = Header Length = 0 CurVal = 0_I8B DigitCut = FalseVal HasDot = TrueVal DotPos = Aux % Indices ( 3 ) - 1 IF ( SigEnd == 0 ) THEN SigEnd = Aux % Indices ( 2 ) HasDot = FalseVal DotPos = 0 END IF DigitTotLen = UIntSafeDigits + ( SigEnd - Header ) IF ( HasDot ) DigitTotLen = DigitTotLen + 1 IF ( DigitTotLen > MaxDecDigits ) THEN DigitCut = TrueVal SigEnd = SigEnd - ( DigitTotLen - ( MaxDecDigits + 1 )) IF ( Aux % Indices ( 3 ) == Aux % Indices ( 4 )) SigEnd = SigEnd - 1 DigitTotLen = ( MaxDecDigits + 1 ) END IF ExpDec = ExpDec - ( DigitTotLen - UIntSafeDigits ) ! set the truncated significand CALL BigInt_Set_UIntType ( Big , SigDec ) IF ( HasDot ) THEN ! SigCut occurred before encountering the period so we must check ! whether the current position is at the period DO WHILE ( CurIdx <= SigEnd ) IF ( CurIdx /= DotPos ) THEN CurVal = CurVal * IBase + ( IACHAR ( cStr ( CurIdx : CurIdx )) - A0 ) CurIdx = CurIdx + 1 Length = Length + 1 IF (( CurIdx > SigEnd ). AND .( DigitCut )) THEN ! The last digit must be non-zero, set it to '1' for correct rounding. CurVal = CurVal - UMOD ( CurVal , 10_I8B ) + 1_I8B END IF IF (( Length == UIntSafeDigits ). OR .( CurIdx > SigEnd )) THEN CALL Bigint_Mul_Pow10 ( Big , Length ) CALL Bigint_Add_U64 ( Big , CurVal ) CurVal = 0_I8B Length = 0 END IF ELSE CurIdx = CurIdx + 1 END IF END DO ELSE ! SigCut occurred after encountering the period so we do not need to check ! whether the current position is at the period DO WHILE ( CurIdx <= SigEnd ) CurVal = CurVal * IBase + ( IACHAR ( cStr ( CurIdx : CurIdx )) - A0 ) CurIdx = CurIdx + 1 Length = Length + 1 IF (( CurIdx > SigEnd ). AND .( DigitCut )) THEN ! The last digit must be non-zero, set it to '1' for correct rounding. CurVal = CurVal - UMOD ( CurVal , 10_I8B ) + 1_I8B END IF IF (( Length == UIntSafeDigits ). OR .( CurIdx > SigEnd )) THEN CALL Bigint_Mul_Pow10 ( Big , Length ) CALL Bigint_Add_U64 ( Big , CurVal ) CurVal = 0_I8B Length = 0 END IF END DO END IF END BLOCK RETURN END SUBROUTINE BigInt_Set_String !****************************************************************************** !------------------------------------------------------------------------------ ! !            PARSING FLOATING-POINT-NUMBER STRING ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Parse_Fortran_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid Fortran real (floating point) number that has one of the two following forms: ! 1. A number without exponent part -> [S]N[N...] ! 2. A number with exponent part    -> [S]N[N...]E[S]N[N...] !   Where !   [ ] indicates an optional field !   S is a sign indicator (required if negative '-', optional if positive '+'). !   N is a decimal digit (0 through 9). A decimal point may appear anywhere !       after the sign (but before the exponent). !   E is an exponent indicator (either 'e' or 'E') ! The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. ! 1. A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. ! 2. The optional kind parameter (_k) is not allowed here. ! ! Note: Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" !   and \"1.23   \" are considered valid.  However, no space is allowed inside !   the supposedly valid number.  For instance, \"1 .2 3\" is considered NOT valid. !   Therefore, this routine is not totally compatible with Fortran READ statement !   where spaces inside the valid number are allowed. !   However, this can easily be done by adding an optional 'Inside Space' flag that !   provide an interpretation of the spaces as 'zero' or 'ignored'.  Then, the input !   will be pre-processed according to the flag.  Nonetheless, this routine neglects !   this optional input because it will make the routine much less efficient due to !   the fact that we will need to scan the whole string twice and we will also need !   to copy the input string into a buffer string and working with the buffer instead !   of directly handling the input string. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: I64SafeDigits = 18 INTEGER ( KIND = I8B ), PARAMETER :: TenPow18 = 10_I8B ** I64SafeDigits INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 39 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigLimit INTEGER ( KIND = I8B ) :: CurVal INTEGER ( KIND = I4B ) :: CurLen , AddCount INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: AtLeastOneDigit , Truncated !** FLOW ! initialize SigDec = ZeroU128 ExpDec = 0 Valid = FalseVal AtLeastOneDigit = FalseVal Truncated = FalseVal StrLen = LEN_TRIM ( cStr ) ! get valid string length by removing the trailing space(s) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF END IF ! check for sign of the significand NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or a dot CurChr => cStr ( Indx : Indx ) IF ((( CurChr < '0' ). OR .( CurChr > '9' )). AND .( CurChr /= '.' )) THEN ! current character is neither a digit nor a dot Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit or the dot.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN AtLeastOneDigit = TrueVal ! the current digit is zero so loop through the following ! characters until a non-zero character is found DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF ! compute for the significand in the integral part CurVal = 0_I8B CurLen = 0 AddCount = 0 IntegralStart = 0 IntegralEnd = 0 SigCount = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal IntegralStart = Indx DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * TenPow18 + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 IF ( CurLen /= 0 ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * ( 10_I8B ** CurLen ) + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount > 0 ) THEN SigDec = SigDec * TenPow18 + CurVal ELSE SigDec % Low = CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * TenPow18 + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF IF ( CurLen /= 0 ) THEN IF ( AddCount > 0 ) THEN SigDec = SigDec * ( 10_I8B ** CurLen ) + CurVal ELSE SigDec % Low = CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN IF ( AtLeastOneDigit ) THEN Valid = TrueVal ELSE ! this happens when not a number is encountered (i.e. the first non-blank character ! is not a sign, a digit or a period) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid input: the first non-blank character is not a sign, a digit or a period.' END IF RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (. NOT .(( CurChr == 'e' ). OR .( CurChr == 'E' ))) THEN ! the current character is NOT an exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: invalid character after a digit.' RETURN END IF Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr == '+' ). OR .( CurChr == '-' )) THEN IF ( CurChr == '-' ) ESign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ! check whether the following character is a digit CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ELSE IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent indicator.' RETURN END IF END IF ! here the current character is a digit so this is likely a valid number ExpDec = ( IACHAR ( CurChr ) - A0 ) DO Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! there is a non-integer character after the exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: not a digit after the exponent(+sign) indicator(s).' RETURN END IF ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT END DO END IF END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = ZeroU128 SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_Fortran_String !****************************************************************************** FUNCTION Parse_JSON_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid JSON real (floating point) number where its differences ! from Fortran number are as follows: !   1. leading and trailing spaces are not allowed. !   2. a plus sign as the first character is not allowed. !   3. leading zero(s) is not allowed (if 0 is the first character, the second one !      must either be a period or an exponent indicator.) !   4. a period must be followed by at least one digit. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: I64SafeDigits = 18 INTEGER ( KIND = I8B ), PARAMETER :: TenPow18 = 10_I8B ** I64SafeDigits INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 39 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigLimit INTEGER ( KIND = I8B ) :: CurVal INTEGER ( KIND = I4B ) :: CurLen , AddCount INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: Truncated !** FLOW ! initialize SigDec = ZeroU128 ExpDec = 0 Valid = FalseVal Truncated = FalseVal StrLen = LEN ( cStr ) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check for sign of the significand NegSign = FalseVal Indx = 1 IF ( cStr ( Indx : Indx ) == '-' ) THEN NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit.' RETURN END IF END IF Aux % Start = Indx CurVal = 0_I8B CurLen = 0 AddCount = 0 ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN ! the current (leading) digit is zero Indx = Indx + 1 IF ( Indx > StrLen ) THEN ! only a zero digit encountered Valid = TrueVal RETURN END IF ! check whether the following character is a digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN ! leading zero cannot be followed by an integer (i.e. no leading zeros) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: leading zero(s) is/are not allowed.' RETURN END IF IntegralStart = 0 IntegralEnd = 0 SigCount = 0 ELSE ! check whether the current character is a non-zero digit or not CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! must start with an integer IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a leading character is not a digit.' RETURN END IF ! compute for the significand in the integral part IntegralStart = Indx CurVal = IACHAR ( cStr ( Indx : Indx )) - A0 CurLen = 1 Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * TenPow18 + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 IF ( CurLen /= 0 ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * ( 10_I8B ** CurLen ) + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount > 0 ) THEN SigDec = SigDec * TenPow18 + CurVal ELSE SigDec % Low = CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * TenPow18 + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF IF ( CurLen /= 0 ) THEN IF ( AddCount > 0 ) THEN SigDec = SigDec * ( 10_I8B ** CurLen ) + CurVal ELSE SigDec % Low = CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN ! this should not happen here since the algorithm implemented above should take care of this already? IF ( PRESENT ( ErrMsg )) ErrMsg = 'There must be something wrong with the implementation.' RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (. NOT .(( CurChr == 'e' ). OR .( CurChr == 'E' ))) THEN ! the current character is NOT an exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: invalid character after a digit.' RETURN END IF Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr == '+' ). OR .( CurChr == '-' )) THEN IF ( CurChr == '-' ) ESign = - 1 Indx = Indx + 1 IF ( Indx > StrLen ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ! check whether the following character is a digit CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent+sign indicators.' RETURN END IF ELSE IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! current character is not a digit IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: no digit after the exponent indicator.' RETURN END IF END IF ! here the current character is a digit so this is likely a valid number ExpDec = ( IACHAR ( CurChr ) - A0 ) DO Indx = Indx + 1 IF ( Indx > StrLen ) EXIT CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) THEN ! there is a non-integer character after the exponent indicator IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: not a digit after the exponent(+sign) indicator(s).' RETURN END IF ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT END DO END IF END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = ZeroU128 SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_JSON_String !****************************************************************************** FUNCTION Parse_FPlus_String ( cStr , SigDec , ExpDec , NegSign , Aux , ErrMsg ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: ! To parse a valid Fortran real (floating point) number with more relaxed rules than ! those used in \"Parse_Fortran_Number\" routine. ! The relaxed rules consider the following numbers as valid: !   1. a number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' !      in place of 'e' or 'E'. !   2. a number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to !      be expressed in a valid number expressed in the scientific format !   3. digits before any invalid character encountered are treated as a valid number !      and any characters after the first encounter (including the first invalid one) !      are neglected.  therefore, for example, a '12.56ax-300' is considered to be !      a valid number with value of 12.56. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), TARGET , INTENT ( IN ) :: cStr TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! exponent in base 10 LOGICAL , INTENT ( OUT ) :: NegSign TYPE ( StringAux ), INTENT ( OUT ) :: Aux CHARACTER ( LEN = :), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid LOGICAL :: Valid !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) INTEGER ( KIND = I4B ), PARAMETER :: IBase = 10 INTEGER ( KIND = I4B ), PARAMETER :: ExpLimit = INT ( Z '10000000' , KIND = I4B ) INTEGER ( KIND = I4B ), PARAMETER :: I64SafeDigits = 18 INTEGER ( KIND = I8B ), PARAMETER :: TenPow18 = 10_I8B ** I64SafeDigits INTEGER ( KIND = I4B ), PARAMETER :: FP_Max_Digits = 39 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigLimit INTEGER ( KIND = I8B ) :: CurVal INTEGER ( KIND = I4B ) :: CurLen , AddCount INTEGER ( KIND = I4B ) :: Indx , StrLen INTEGER ( KIND = I4B ) :: NFrac INTEGER ( KIND = I4B ) :: ESign INTEGER ( KIND = I4B ) :: SigCount INTEGER ( KIND = I4B ) :: IntegralStart , IntegralEnd INTEGER ( KIND = I4B ) :: FractionStart , FractionEnd CHARACTER ( LEN = 1 ), POINTER :: CurChr LOGICAL :: AtLeastOneDigit , Truncated !** FLOW ! initialize SigDec = ZeroU128 ExpDec = 0 Valid = FalseVal AtLeastOneDigit = FalseVal Truncated = FalseVal StrLen = LEN_TRIM ( cStr ) ! get valid string length by removing the trailing space(s) Aux % Truncated = Truncated Aux % Indices = 0 Aux % Start = 0 Aux % SigCut = 0 IF ( StrLen == 0 ) THEN IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF ! check whether there are spaces in front of the number ! (only allow space(s) in front of the number but no spaces inside it) Indx = 1 IF ( cStr ( Indx : Indx ) == ' ' ) THEN Indx = Indx + 1 DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= ' ' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this is an empty string.' RETURN END IF END IF ! check for sign of the significand NegSign = FalseVal CurChr => cStr ( Indx : Indx ) IF (( CurChr == '-' ). OR .( CurChr == '+' )) THEN IF ( CurChr == '-' ) NegSign = TrueVal Indx = Indx + 1 IF ( Indx > StrLen ) THEN Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: this string only contains a sign without a digit.' RETURN END IF ! check whether the following character is a digit or a dot CurChr => cStr ( Indx : Indx ) IF ((( CurChr < '0' ). OR .( CurChr > '9' )). AND .( CurChr /= '.' )) THEN ! current character is neither a digit nor a dot Aux % Start = Indx IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid Input: a sign must be followed by a digit or the dot.' RETURN END IF END IF Aux % Start = Indx ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN AtLeastOneDigit = TrueVal ! the current digit is zero so loop through the following ! characters until a non-zero character is found DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF ! compute for the significand in the integral part CurVal = 0_I8B CurLen = 0 AddCount = 0 IntegralStart = 0 IntegralEnd = 0 SigCount = 0 CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal IntegralStart = Indx DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * TenPow18 + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 END DO SigCount = Indx - IntegralStart IntegralEnd = Indx - 1 IF ( CurLen /= 0 ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * ( 10_I8B ** CurLen ) + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF END IF ! check whether the current character is a dot FractionStart = 0 FractionEnd = 0 NFrac = 0 IF ( Indx <= StrLen ) THEN IF ( cStr ( Indx : Indx ) == '.' ) THEN Indx = Indx + 1 IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF (( CurChr >= '0' ). AND .( CurChr <= '9' )) THEN AtLeastOneDigit = TrueVal NFrac = Indx IF ( SigCount > 0 ) THEN FractionStart = Indx ! continue computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount > 0 ) THEN SigDec = SigDec * TenPow18 + CurVal ELSE SigDec % Low = CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 END DO NFrac = Indx - NFrac SigCount = SigCount + NFrac FractionEnd = Indx - 1 ELSE ! check for leading zero(s) IF ( cStr ( Indx : Indx ) == '0' ) THEN DO WHILE ( Indx <= StrLen ) IF ( cStr ( Indx : Indx ) /= '0' ) EXIT Indx = Indx + 1 END DO IF ( Indx > StrLen ) THEN ! only zero digits encountered Valid = TrueVal RETURN END IF END IF CurChr => cStr ( Indx : Indx ) IF (( CurChr > '0' ). AND .( CurChr <= '9' )) THEN FractionStart = Indx ! start computing for the significand DO WHILE ( Indx <= StrLen ) CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT CurVal = CurVal * IBase + ( IACHAR ( CurChr ) - A0 ) CurLen = CurLen + 1 IF ( CurLen == I64SafeDigits ) THEN IF ( AddCount == 0 ) THEN SigDec % Low = CurVal ELSE SigDec = SigDec * TenPow18 + CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF Indx = Indx + 1 SigCount = SigCount + 1 END DO NFrac = Indx - NFrac FractionEnd = Indx - 1 END IF END IF IF ( CurLen /= 0 ) THEN IF ( AddCount > 0 ) THEN SigDec = SigDec * ( 10_I8B ** CurLen ) + CurVal ELSE SigDec % Low = CurVal END IF CurVal = 0_I8B CurLen = 0 AddCount = AddCount + 1 END IF END IF END IF END IF END IF ! done for the significand part so check the number of significant digits ! (there must be at least one significant digit) IF ( SigCount == 0 ) THEN IF ( AtLeastOneDigit ) THEN Valid = TrueVal ELSE ! this happens when not a number is encountered (i.e. the first non-blank character ! is not a sign, a digit or a period) IF ( PRESENT ( ErrMsg )) ErrMsg = 'Invalid input: the first non-blank character is not a sign, a digit or a period.' END IF RETURN END IF ESign = 1 ! check whether the current character is an exponent indicator IF ( Indx <= StrLen ) THEN DO SELECT CASE ( cStr ( Indx : Indx )) CASE ( 'e' , 'E' , 'd' , 'D' , 'q' , 'Q' ) Indx = Indx + 1 ! check for a sign of the exponent IF ( Indx <= StrLen ) THEN CurChr => cStr ( Indx : Indx ) IF ( CurChr == '-' ) THEN ESign = - 1 Indx = Indx + 1 ELSEIF ( CurChr == '+' ) THEN Indx = Indx + 1 END IF ELSE EXIT END IF CASE ( '-' ) ESign = - 1 Indx = Indx + 1 CASE ( '+' ) Indx = Indx + 1 CASE DEFAULT EXIT END SELECT IF ( Indx <= StrLen ) THEN DO CurChr => cStr ( Indx : Indx ) IF (( CurChr < '0' ). OR .( CurChr > '9' )) EXIT ExpDec = ExpDec * IBase + ( IACHAR ( CurChr ) - A0 ) IF ( ExpDec > ExpLimit ) EXIT Indx = Indx + 1 IF ( Indx > StrLen ) EXIT END DO END IF EXIT END DO END IF ! check number of significant digits IF ( SigCount > FP_Max_Digits ) THEN ! the input string have more digits than 'SigDec' can normally handle so ! start again this time and avoid overflow SigDec = ZeroU128 SigLimit = MaxDivbyBase - 10 IF ( IntegralStart > 0 ) THEN Indx = IntegralStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= IntegralEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF IF ( SigDec . UGE . SigLimit ) THEN ! We have a big integer (but we can handle it) so determine exponent ExpDec = IntegralEnd + 1 - Indx + ESign * ExpDec ELSE ! We may have a value with a fractional component. IF ( FractionStart > 0 ) THEN Indx = FractionStart DO WHILE (( SigDec . ULT . SigLimit ). AND .( Indx <= FractionEnd )) SigDec = SigDec * IBase + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 END DO END IF ! determine exponent ExpDec = FractionStart - Indx + ESign * ExpDec END IF ! We have now corrected both exponent and significand, to a truncated value Truncated = TrueVal Aux % SigCut = Indx ELSE ! determine exponent ExpDec = ESign * ExpDec - NFrac END IF ! set output Valid = TrueVal Aux % Truncated = Truncated Aux % Indices ( 1 ) = IntegralStart Aux % Indices ( 2 ) = IntegralEnd Aux % Indices ( 3 ) = FractionStart Aux % Indices ( 4 ) = FractionEnd IF ( PRESENT ( ErrMsg )) ErrMsg = 'Valid Input: no error encountered.' RETURN END FUNCTION Parse_FPlus_String !****************************************************************************** !------------------------------------------------------------------------------ ! !                       BINARY-TO-DECIMAL CONVERSION ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE Bin2Dec_DragonBox ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the DragonBox algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format TYPE ( UInt128 ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 LOGICAL :: Include_Left_Endpoint , Include_Right_Endpoint INTEGER ( KIND = I4B ) :: Minus_K , Beta INTEGER ( KIND = I4B ) :: DeltaI , R , Dist TYPE ( UInt128 ) :: Two_Fl , Two_Fc TYPE ( UInt128 ) :: ZMul_Val LOGICAL :: ZMul_IsInteger LOGICAL :: XMul_IsInteger , XMul_Parity LOGICAL :: YMul_IsInteger , Approx_Y_Parity LOGICAL :: Divisible_By_Small_Divisor !** FLOW: ! Step 1: integer promotion & Schubfach multiplier calculation. ! Check if normal. IF (( ExpRaw /= 0 ). AND .( SigRaw == ZeroU128 )) THEN CALL Shorter_Interval_Case ( ExpBin , SigDec , ExpDec ) RETURN END IF Include_Left_Endpoint = ( IAND ( SigBin , OneU128 ) == ZeroU128 ) Include_Right_Endpoint = Include_Left_Endpoint ! Compute K and Beta as well as get cached data Minus_K = Floor_Log10_Pow2 ( ExpBin ) - Kappa Beta = ExpBin + Floor_Log2_Pow10 ( - Minus_K ) Pow10 = Get_Pow10_256Bits ( - Minus_K ) IF ( Minus_K > 0 ) Pow10 ( 0 ) = Pow10 ( 0 ) + 1_I8B ! Compute Zi and Deltai. ! 10**Kappa <= Deltai < 10**(Kappa + 1) DeltaI = Compute_Delta ( Pow10 , Beta ) Two_Fc = SHIFTL ( SigBin , 1 ) ! For the case of binary32, the result of integer check is not correct for ! 29711844 * 2&#94;-82 ! = 6.1442653300000000008655037797566933477355632930994033813476... * 10&#94;-18 ! and 29711844 * 2&#94;-81 ! = 1.2288530660000000001731007559513386695471126586198806762695... * 10&#94;-17, ! and they are the unique counterexamples. However, since 29711844 is even, ! this does not cause any problem for the endpoints calculations; it can only ! cause a problem when we need to perform integer check for the center. ! Fortunately, with these inputs, that branch is never executed, so we are ! fine. CALL Compute_Mul ( SHIFTL ( IOR ( Two_Fc , OneU128 ), Beta ), Pow10 , ZMul_Val , ZMul_IsInteger ) ! Step 2: Try larger divisor; remove trailing zeros if necessary. ! Using an upper bound on zi, we might be able to optimize the division ! better than the compiler; we are computing zi / big_divisor here. SigDec = Divide_By_10_To_Kappa_Plus_1 ( ZMul_Val ) R = ZMul_Val - Big_Divisor * SigDec ! implicit conversion if necessary IF ( R . ULT . DeltaI ) THEN ! Exclude the right endpoint if necessary. IF (( R == 0 ). AND . ZMul_IsInteger . AND .(. NOT . Include_Right_Endpoint )) THEN SigDec = SigDec - OneU128 R = Big_Divisor ! must perform Step 3 ELSE ExpDec = Minus_K + Kappa + 1 RETURN END IF ELSEIF ( R == DeltaI ) THEN ! r == deltai; compare fractional parts. Two_Fl = Two_Fc - OneU128 XMul_Parity = Compute_Mul_Parity ( Two_Fl , Pow10 , Beta , XMul_IsInteger ) IF ((. NOT . Include_Left_Endpoint ). OR .( ExpBin < Case_Fc_Pm_Half_Lower_Threshold ). OR . & ( ExpBin > Divisibility_Check_By_5_Threshold )) THEN ! If the left endpoint is not included, the condition for ! success is z&#94;(f) < delta&#94;(f) (odd parity). ! Otherwise, the inequalities on exponent ensure that ! x is not an integer, so if z&#94;(f) >= delta&#94;(f) (even parity), we in fact ! have strict inequality. IF ( XMul_Parity ) THEN ExpDec = Minus_K + Kappa + 1 RETURN END IF ! must perform Step 3 ELSE IF ( XMul_Parity . OR . XMul_IsInteger ) THEN ExpDec = Minus_K + Kappa + 1 RETURN END IF ! must perform Step 3 END IF ELSE ! must perform Step 3 END IF ! Step 3: Find the significand with the smaller divisor SigDec = SigDec * TenUInt ExpDec = Minus_K + Kappa Dist = R - SHIFTR ( DeltaI , 1 ) + Half_Small_Divisor Approx_Y_Parity = IAND ( IEOR ( Dist , Half_Small_Divisor ), 1 ) /= 0 Divisible_By_Small_Divisor = Is_Divisible_By_Pow10 ( Dist ) ! Add dist / 10&#94;kappa to the significand. SigDec = SigDec + Dist ! Is dist divisible by 10&#94;kappa? IF ( Divisible_By_Small_Divisor ) THEN ! Check z&#94;(f) >= epsilon&#94;(f). ! We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1, ! where yi == zi - epsiloni if and only if z&#94;(f) >= epsilon&#94;(f) ! Since there are only 2 possibilities, we only need to care about the ! parity. Also, zi and r should have the same parity since the divisor ! is an even number. IF ( Compute_Mul_Parity ( Two_Fc , Pow10 , Beta , YMul_IsInteger ) . NEQV . Approx_Y_Parity ) THEN SigDec = SigDec - OneU128 ELSE ! If z&#94;(f) >= epsilon&#94;(f), we might have a tie ! when z&#94;(f) == epsilon&#94;(f), or equivalently, when y is an integer IF ( YMul_IsInteger ) THEN IF ( IAND ( SigDec , OneU128 ) /= ZeroU128 ) SigDec = SigDec - OneU128 END IF END IF END IF RETURN CONTAINS SUBROUTINE Compute_Mul ( U , Pow10 , ResHi , IsInteger ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the multiplication of U and Pow10 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 TYPE ( UInt128 ), INTENT ( OUT ) :: ResHi LOGICAL , INTENT ( OUT ) :: IsInteger !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: ResLo !** FLOW CALL UMul384_Upper256 ( U , Pow10 , ResHi , ResLo ) IsInteger = ResLo == ZeroU128 RETURN END SUBROUTINE Compute_Mul !************************************************************************** FUNCTION Compute_Mul_Parity ( Two_F , Pow10 , Beta , IsInteger ) RESULT ( Parity ) !** PURPOSE OF THIS SUBROUTINE: ! To check multiplication parity IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Two_F INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta LOGICAL , INTENT ( OUT ) :: IsInteger LOGICAL :: Parity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: U256Hi , U256Lo !** FLOW CALL UMul384_Lower256 ( Two_F , Pow10 , U256Hi , U256Lo ) Parity = IAND ( SHIFTR ( U256Hi , ( 128 - Beta )), OneU128 ) /= ZeroU128 IsInteger = IOR ( SHIFTL ( U256Hi , Beta ), SHIFTR ( U256Lo , ( 128 - Beta ))) == ZeroU128 RETURN END FUNCTION Compute_Mul_Parity !************************************************************************** FUNCTION Is_Divisible_By_Pow10 ( N ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To replace N by Floor(N / Pow(10, M)) returning true if and only if N is ! divisible by pow(10, M). ! Precondition: N <= Pow(10, M + 1). ! Note: M = Kappa IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: N LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The numbers below are chosen such that: !   1. floor(n/d) = floor(nm / 2&#94;k) where d=10 or d=100, !   2. nm mod 2&#94;k < m if and only if n is divisible by d, ! where m is magic_number, k is shift_amount ! and d is divisor. ! ! Item 1 is a common technique of replacing division by a constant with ! multiplication, see e.g. \"Division by Invariant Integers Using ! Multiplication\" by Granlund and Montgomery (1994). magic_number (m) is set ! to ceil(2&#94;k/d) for large enough k. ! The idea for item 2 originates from Schubfach. N = N * Magic_Number Flag = IAND ( N , Comparison_Mask ) . ULT . Magic_Number N = SHIFTR ( N , Info_Shift_Amount ) RETURN END FUNCTION Is_Divisible_By_Pow10 !************************************************************************** FUNCTION Divide_By_10_To_Kappa_Plus_1 ( N ) RESULT ( M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute M = Floor(N / 10**(Kappa + 1)) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: N TYPE ( UInt128 ) :: M !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW M = SHIFTR ( UMul256_Upper128 ( N , DivM ), DivS ) RETURN END FUNCTION Divide_By_10_To_Kappa_Plus_1 !************************************************************************** FUNCTION Compute_Delta ( Pow10 , Beta ) RESULT ( Delta ) !** PURPOSE OF THIS SUBROUTINE: ! To compute Delta IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta INTEGER ( KIND = I4B ) :: Delta !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Delta = INT ( IAND ( SHIFTR ( Pow10 ( 3 ), ( 64 - 1 - Beta )), INT ( Z '00000000FFFFFFFF' , KIND = I8B )), KIND = I4B ) RETURN END FUNCTION Compute_Delta !************************************************************************** SUBROUTINE Shorter_Interval_Case ( Exponent , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the decimal representation ! for shorter interval case. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exponent ! The decoded value of exponent in binary TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Minus_K , Beta TYPE ( UInt128 ) :: Xi , Zi INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 !** FLOW: ! Compute k and beta Minus_K = Floor_Log10_ThreeQuartersPow2 ( Exponent ) Beta = Exponent + Floor_Log2_Pow10 ( - Minus_K ) ! Compute Xi and Zi Pow10 = Get_Pow10_256Bits ( - Minus_K ) IF ( Minus_K > 0 ) Pow10 ( 0 ) = Pow10 ( 0 ) + 1_I8B Xi = Compute_Left_Endpoint ( Pow10 , Beta ) Zi = Compute_Right_Endpoint ( Pow10 , Beta ) ! If the left endpoint is not an integer, increase it IF (. NOT . Is_Left_Endpoint_Integer ( Exponent )) Xi = Xi + OneU128 ! Try bigger divisor SigDec = Zi . UDIV . TenUInt ! If succeed, remove trailing zeros if necessary and return IF ( SigDec * TenUInt . UGE . Xi ) THEN ExpDec = Minus_K + 1 ExpDec = ExpDec RETURN END IF ! Otherwise, compute the round-up of y SigDec = Compute_Round_Up ( Pow10 , Beta ) ExpDec = Minus_K ! When tie occurs, choose one of them according to the rule IF ( Exponent >= Shorter_Interval_Tie_Lower_Threshold . AND . & Exponent <= Shorter_Interval_Tie_Upper_Threshold ) THEN IF ( IAND ( SigDec , OneU128 ) /= ZeroU128 ) SigDec = SigDec - OneU128 ! Round to even. ELSEIF ( SigDec . ULT . Xi ) THEN SigDec = SigDec + OneU128 END IF RETURN END SUBROUTINE Shorter_Interval_Case !************************************************************************** FUNCTION Compute_Left_Endpoint ( Pow10 , Beta ) RESULT ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the left end point (Xi) for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta TYPE ( UInt128 ) :: X !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10Hi !** FLOW Pow10Hi = UInt128 ( Pow10 ( 3 ), Pow10 ( 2 )) X = SHIFTR (( Pow10Hi - SHIFTR ( Pow10Hi , ( SignificandBits + 2 ))), & ( TotalBits - SignificandBits - 1 - Beta )) RETURN END FUNCTION Compute_Left_Endpoint !************************************************************************** FUNCTION Compute_Right_Endpoint ( Pow10 , Beta ) RESULT ( Z ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the right end point (Zi) for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta TYPE ( UInt128 ) :: Z !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10Hi !** FLOW Pow10Hi = UInt128 ( Pow10 ( 3 ), Pow10 ( 2 )) Z = SHIFTR (( Pow10Hi + SHIFTR ( Pow10Hi , ( SignificandBits + 1 ))), & ( TotalBits - SignificandBits - 1 - Beta )) RETURN END FUNCTION Compute_Right_Endpoint !************************************************************************** FUNCTION Compute_Round_Up ( Pow10 , Beta ) RESULT ( Y ) !** PURPOSE OF THIS SUBROUTINE: ! To compute the rounded-up value of Yi for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Beta TYPE ( UInt128 ) :: Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Pow10Hi !** FLOW Pow10Hi = UInt128 ( Pow10 ( 3 ), Pow10 ( 2 )) Y = SHIFTR ( SHIFTR ( Pow10Hi , ( TotalBits - SignificandBits - 2 - Beta )) + OneU128 , 1 ) RETURN END FUNCTION Compute_Round_Up !************************************************************************** FUNCTION Is_Left_Endpoint_Integer ( E ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To chaeck whether the left end point (Xi) is an integer for the shorter interval case IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: E LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = (( E >= Case_Shorter_Interval_Left_Endpoint_Lower_Threshold ) . AND . & ( E <= Case_Shorter_Interval_Left_Endpoint_Upper_Threshold )) RETURN END FUNCTION Is_Left_Endpoint_Integer !************************************************************************** SUBROUTINE UMul384_Upper256 ( X128 , Y64 , U256Hi , U256Lo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute upper 256 bits of multiplication of a 128-bit unsigned integer and ! a 256-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X128 ! a 128-bit unsigned integer INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y64 ( 0 : 3 ) ! a 256-bit unsigned integer in little-endian order TYPE ( UInt128 ), INTENT ( OUT ) :: U256Hi , U256Lo ! upper and lower parts of the upper 256 bits of the result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X64 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Z64 ( 0 : 5 ) !** FLOW ! get input X64 ( 0 ) = X128 % Low X64 ( 1 ) = X128 % High ! perform multiplication CALL MultiplyBasic ( X64 , 2 , Y64 , 4 , Z64 ) ! set output U256Hi = UInt128 ( Z64 ( 5 ), Z64 ( 4 )) U256Lo = UInt128 ( Z64 ( 3 ), Z64 ( 2 )) RETURN END SUBROUTINE UMul384_Upper256 !************************************************************************** SUBROUTINE UMul384_Lower256 ( X128 , Y64 , U256Hi , U256Lo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute lower 256 bits of multiplication of a 128-bit unsigned integer and ! a 256-bit unsigned integer. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X128 ! a 128-bit unsigned integer INTEGER ( KIND = I8B ), INTENT ( IN ) :: Y64 ( 0 : 3 ) ! a 256-bit unsigned integer in little-endian order TYPE ( UInt128 ), INTENT ( OUT ) :: U256Hi , U256Lo ! upper and lower parts of the lower 256 bits of the result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X64 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Z64 ( 0 : 5 ) !** FLOW ! get input X64 ( 0 ) = X128 % Low X64 ( 1 ) = X128 % High ! perform multiplication CALL MultiplyBasic ( X64 , 2 , Y64 , 4 , Z64 ) ! set output U256Hi = UInt128 ( Z64 ( 3 ), Z64 ( 2 )) U256Lo = UInt128 ( Z64 ( 1 ), Z64 ( 0 )) RETURN END SUBROUTINE UMul384_Lower256 !************************************************************************** END SUBROUTINE Bin2Dec_DragonBox !****************************************************************************** SUBROUTINE Bin2Dec_Ryu ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the Ryu algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format TYPE ( UInt128 ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: REAL ( KIND = DP ), PARAMETER :: Log2Base5 = LOG ( 2.0_DP ) / LOG ( 5.0_DP ) INTEGER ( KIND = I4B ), PARAMETER :: QLimit = FLOOR ( Log2Base5 * BinaryPrecision ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: E2 TYPE ( UInt128 ) :: M2 LOGICAL :: Even , AcceptBounds TYPE ( UInt128 ) :: MV , MP , MM TYPE ( UInt128 ) :: Vr , Vp , Vm TYPE ( UInt128 ) :: VrDiv10 , VpDiv10 , VmDiv10 TYPE ( UInt128 ) :: VrMod10 , VmMod10 INTEGER ( KIND = I4B ) :: E10 , Q LOGICAL :: VmIsTrailingZeros , VrIsTrailingZeros , DecrementVp INTEGER ( KIND = I4B ) :: Removed , LastRemovedDigit !** FLOW ! We subtract 2 in all cases so that the bounds computation has 2 additional bits. E2 = ExpBin - 2 M2 = SigBin Even = IAND ( M2 , OneU128 ) == ZeroU128 AcceptBounds = Even ! Step 2: Determine the interval of legal decimal representations. ! Implicit bool -> int conversion. True is 1, false is 0. MV = M2 * FourUInt MP = MV + TwoUInt ! check whether Cb is closer to the lower bound IF (( SigRaw == ZeroU128 ). AND .( ExpRaw > 1 )) THEN ! closer to the lower bound; irregular spacing MM = MV - OneU128 ELSE ! not closer to the lower bound; regular spacing MM = MV - TwoUInt END IF ! Step 3: Convert to a decimal power base using 128-bit arithmetic. VmIsTrailingZeros = FalseVal VrIsTrailingZeros = FalseVal DecrementVp = FalseVal IF ( E2 >= 0 ) THEN ! We need (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 ! and we need to remove at least Q' = LOG10(2**E2) digits from the ! scaled values Vm, Vr, Vp, i.e. we want to compute !  (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**Q' !               = (MM, MV, MP) * 2**E2 / 10**(E10) !               = (MM, MV, MP) * 5**(-E10) / 2**(E10 - E2) ! However, to correctly round the result we need to know the value of ! the last removed digit.  We therefore remove only Q = Q' - 1 digits in ! the first step and make sure that we execute the loop below at least ! once and determine the correct value of the last removed digit. Q = Floor_Log10_Pow2 ( E2 ) IF ( E2 > 3 ) Q = Q - 1 ! == MAX(0, Q' - 1) E10 = Q ! Determine whether all the removed digits are 0. ! ! Z(X, E2, Q) = MOD((X * 2**E2), 10**Q) == 0 !             = P10(X * 2**E2) >= Q !             = MIN(P2(X) + P2(E2), P5(X)) >= Q !             = P2(X) + E2 >= Q and P5(x) >= Q !             = P5(X) >= Q !             = MOD(X, 5**Q) == 0 ! QLimit = FLOOR(LOG5(2**BinaryPrecision)) IF ( Q <= QLimit ) THEN ! Only one of MP, MV, and MM can be a multiple of 5, if any. IF ( UMOD ( MV , FiveUInt ) == ZeroU128 ) THEN VrIsTrailingZeros = Is_Multiple_Of_Pow5 ( MV , Q - 1 ) ELSEIF ( AcceptBounds ) THEN ! Same as min(E2 + (~MM & 1), Pow5Factor(MM)) >= Q ! <=> E2 + (~MM & 1) >= Q && Pow5Factor(MM) >= Q ! <=> true && Pow5Factor(MM) >= Q, since E2 >= Q. VmIsTrailingZeros = Is_Multiple_Of_Pow5 ( MM , Q ) ELSE ! Same as min(E2 + 1, Pow5Factor(MP)) >= Q. ! Vp -= Is_Multiple_Of_Pow5(MP, Q) DecrementVp = Is_Multiple_Of_Pow5 ( MP , Q ) END IF END IF ELSE ! We need (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**E2 ! and we need to remove at least Q' = LOG10(5**-E2) digits from the ! scaled values Vm, Vr, Vp, i.e. we want to compute !  (Vm, Vr, Vp) = (MM, MV, MP) * 2**E2 / 10**(E2 + Q') !               = (MM, MV, MP) * 2**E2 / 10**(E10), !               = (MM, MV, MP) * 5**(-E10) / 2**(E10 - E2) Q = Floor_Log10_Pow5 ( - E2 ) IF ( - E2 > 1 ) Q = Q - 1 ! == MAX(0, Q' - 1) E10 = Q + E2 ! Determine whether all the removed digits are 0. ! ! Z(X, E2, Q) = MOD((X * 5**-E2), 10**Q) == 0 !             = MIN(P2(X), P5(X) - E2) >= Q !             = P2(X) >= Q and P5(X) - E2 >= Q !             = P2(X) >= Q !             = MOD(X, 2**Q) == 0 IF ( Q <= 1 ) THEN ! {Vr,Vp,Vm} is trailing zeros if {MV,MP,MM} has at least Q trailing 0 bits. ! MV = 4 M2, so it always has at least two trailing 0 bits. VrIsTrailingZeros = TrueVal IF ( AcceptBounds ) THEN ! MM = MV - 1 - MMShift, so it has 1 trailing 0 bit iff MMShift == 1. VmIsTrailingZeros = ( MM == ( MV - TwoUInt )) ELSE ! MP = MV + 2, so it always has at least one trailing 0 bit. DecrementVp = TrueVal END IF ELSEIF ( Q < ( TotalBits - 1 )) THEN ! TODO(ulfjack): Use a tighter bound here. ! We need to compute min(ntz(MV), Pow5Factor(MV) - E2) >= Q-1 ! <=> ntz(MV) >= Q-1  &&  Pow5Factor(MV) - E2 >= Q-1 ! <=> ntz(MV) >= Q-1    (E2 is negative and -E2 >= Q) ! <=> (MV & ((1 << (Q-1)) - 1)) == 0 ! We also need to make sure that the left shift does not overflow. VrIsTrailingZeros = Is_Multiple_Of_Pow2 ( MV , Q - 1 ) END IF END IF CALL MulPow5DivPow2 ( MM , MV , MP , - E10 , E10 - E2 , Vm , Vr , Vp ) IF ( DecrementVp ) Vp = Vp - OneU128 ! Step 4: Find the shortest decimal representation in the interval of legal representations. Removed = 0 LastRemovedDigit = 0 VpDiv10 = Divide_By_Pow10Factor ( Vp , 10 ) CALL DivMod_By_Pow10Factor ( Vm , 10 , VmDiv10 , VmMod10 ) DO WHILE ( VpDiv10 . UGT . VmDiv10 ) VmIsTrailingZeros = VmIsTrailingZeros . AND . ( VmMod10 == ZeroU128 ) VrIsTrailingZeros = VrIsTrailingZeros . AND . ( LastRemovedDigit == 0 ) CALL DivMod_By_Pow10Factor ( Vr , 10 , VrDiv10 , VrMod10 ) LastRemovedDigit = VrMod10 Vr = VrDiv10 Vp = VpDiv10 VpDiv10 = Divide_By_Pow10Factor ( Vp , 10 ) Vm = VmDiv10 CALL DivMod_By_Pow10Factor ( Vm , 10 , VmDiv10 , VmMod10 ) Removed = Removed + 1 END DO IF ( VmIsTrailingZeros ) THEN DO WHILE ( Mod_By_Pow10Factor ( Vm , 10 ) == ZeroU128 ) VrIsTrailingZeros = VrIsTrailingZeros . AND . ( LastRemovedDigit == 0 ) CALL DivMod_By_Pow10Factor ( Vr , 10 , VrDiv10 , VrMod10 ) LastRemovedDigit = VrMod10 Vr = VrDiv10 Vp = Divide_By_Pow10Factor ( Vp , 10 ) Vm = Divide_By_Pow10Factor ( Vm , 10 ) Removed = Removed + 1 END DO END IF IF ( VrIsTrailingZeros . AND .( LastRemovedDigit == 5 ). AND .( Mod_By_Pow10Factor ( Vr , 2 ) == ZeroU128 )) THEN ! Round even if the exact numbers is .....50..0. LastRemovedDigit = 4 END IF ! We need to take Vr+1 if Vr is outside bounds or we need to round up. SigDec = Vr IF ((( Vr == Vm ). AND .((. NOT . AcceptBounds ). OR .(. NOT . VmIsTrailingZeros ))) & . OR .( LastRemovedDigit >= 5 )) THEN SigDec = SigDec + OneU128 END IF ExpDec = E10 + Removed RETURN CONTAINS SUBROUTINE MulPow5DivPow2 ( U , V , W , E5 , E2 , A , B , C ) !** PURPOSE OF THIS SUBROUTINE: ! To perform multipy by power of 5 and divide by power of 2 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: U , V , W INTEGER ( KIND = I4B ), INTENT ( IN ) :: E5 , E2 TYPE ( UInt128 ), INTENT ( OUT ) :: A , B , C !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Shift INTEGER ( KIND = I8B ) :: U64 ( 0 : 1 ), V64 ( 0 : 1 ), W64 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Pow5 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I8B ) :: A64 ( 0 : 5 ), B64 ( 0 : 5 ), C64 ( 0 : 5 ) !** FLOW Shift = E2 - ( Floor_Log2_Pow5 ( E5 ) + 1 - BitsPerPow5 ) Pow5 = Get_Pow10_256Bits ( E5 ) IF (( E5 < Pow10_Min_Exact_Exp ). OR .( E5 > Pow10_Max_Exact_Exp )) Pow5 ( 0 ) = Pow5 ( 0 ) + 1_I8B U64 ( 0 ) = U % Low U64 ( 1 ) = U % High CALL Multiply_N_ShiftRight ( U64 , 2 , Pow5 , 4 , Shift , A64 ) A = UInt128 ( A64 ( 1 ), A64 ( 0 )) V64 ( 0 ) = V % Low V64 ( 1 ) = V % High CALL Multiply_N_ShiftRight ( V64 , 2 , Pow5 , 4 , Shift , B64 ) B = UInt128 ( B64 ( 1 ), B64 ( 0 )) W64 ( 0 ) = W % Low W64 ( 1 ) = W % High CALL Multiply_N_ShiftRight ( W64 , 2 , Pow5 , 4 , Shift , C64 ) C = UInt128 ( C64 ( 1 ), C64 ( 0 )) RETURN END SUBROUTINE MulPow5DivPow2 !************************************************************************** FUNCTION Is_Multiple_Of_Pow5 ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Multiple_Of_Pow5 !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 5**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Exp <= MaxExp_ModInv5 ) THEN Flag = IsMultipleOfPow5_128Bits ( Value , Exp ) ELSE Flag = Pow5Factor_128Bits ( Value ) . UGE . Exp END IF RETURN END FUNCTION Is_Multiple_Of_Pow5 !************************************************************************** FUNCTION Is_Multiple_Of_Pow2 ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Multiple_Of_Pow2 !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 2**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = IAND ( Value , SHIFTL ( OneU128 , Exp ) - OneU128 ) == ZeroU128 RETURN END FUNCTION Is_Multiple_Of_Pow2 !************************************************************************** SUBROUTINE DivMod_By_Pow10Factor ( X , Y , Q , R ) !DIR$ ATTRIBUTES FORCEINLINE :: DivMod_By_Pow10Factor !** PURPOSE OF THIS SUBROUTINE: ! To perform division (X .UDIV. Y) by 5 or 10, and modulus (UMOD(X, Y)) of 5 or 10 (i.e. Y is 5 or 10). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X ! dividend INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! divisor; must be 5 or 10 TYPE ( UInt128 ), INTENT ( OUT ) :: Q ! quotient TYPE ( UInt128 ), INTENT ( OUT ) :: R ! remainder !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: CST = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: LookUp1 = INT ( B '111100000' , KIND = I4B ) ! 480 INTEGER ( KIND = I8B ), PARAMETER :: LookUp2 = INT ( O '321043210' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AddendQ INTEGER ( KIND = I8B ) :: QHi , QLo INTEGER ( KIND = I8B ) :: R64 , RHi , RLo , AddendR !** FLOW ! Ryu performs 128-bit division only by 5 and 10, so that's what we ! implement.  The strategy here is to relate division of x with that of ! x.hi and x.lo separately. ! assert(y == 5 || y == 10); ! The following implements division by 5 and 10.  In either case, we ! first compute division by 5: !   x/5 = (x.hi*2&#94;64 + x.lo)/5 !       = (x.hi*(2&#94;64-1) + x.hi + x.lo)/5 !       = x.hi*((2&#94;64-1)/5) + (x.hi + x.lo)/5 since CST=(2&#94;64-1)/5 is exact !       = x.hi*CST + x.hi/5 + x.lo/5 + ((x.lo%5) + (x.hi%5) >= 5) ! We go a step further and replace the last adjustment term with a ! lookup table, which we encode as a binary literal.  This seems to ! yield smaller code on x86 at least. CALL UMul128 ( X % High , CST , Q % High , Q % Low ) CALL UDivMod ( X % High , 5_I8B , QHi , RHi ) CALL UDivMod ( X % Low , 5_I8B , QLo , RLo ) CALL Add ( Q , QHi + QLo ) AddendQ = IAND ( SHIFTR ( LookUp1 , RHi + RLo ), 1 ) CALL Add ( Q , AddendQ ) ! The following implements modulus by 5 and 10.  In either case, ! we first compute modulus by 5: !   x (mod 5) = x.hi*2&#94;64 + x.lo (mod 5) !             = x.hi + x.lo (mod 5) since 2&#94;64 == 1 (mod 5) ! So the straightforward implementation would be !   ((x.hi % 5) + (x.lo % 5)) % 5 ! But we go a step further and replace the outermost % with a ! lookup table: !             = {0,1,2,3,4,0,1,2,3}[(x.hi % 5) + (x.lo % 5)] (mod 5) ! which we encode as an octal literal. R64 = IAND ( SHIFTR ( Lookup2 , 3_I8B * ( RHi + RLo )), 7_I8B ) R = UInt128 ( 0_I8B , R64 ) IF ( Y == 10 ) THEN ! x % 10 = (x % 5)      if x / 5 is even !          (x % 5) + 5  if x / 5 is odd ! The compiler should be able to CSE the below computation of x/5 and ! the above modulus operations with a nearby inlined computation of x/10. AddendR = 5_I8B * IAND ( Q % Low , 1_I8B ) CALL Add ( R , AddendR ) Q = ShiftROnce ( Q ) END IF RETURN END SUBROUTINE DivMod_By_Pow10Factor !************************************************************************** FUNCTION Divide_By_Pow10Factor ( X , Y ) RESULT ( Q ) !DIR$ ATTRIBUTES FORCEINLINE :: Divide_By_Pow10Factor !** PURPOSE OF THIS SUBROUTINE: ! To perform division (X .UDIV. Y) by 5 or 10 (i.e. Y is 5 or 10). IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 5 or 10 TYPE ( UInt128 ) :: Q !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: CST = INT ( Z '3333333333333333' , KIND = I8B ) ! = MaxU64 .UDIV. 5_I8B INTEGER ( KIND = I4B ), PARAMETER :: LookUp = INT ( B '111100000' , KIND = I4B ) ! = 480 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Addend INTEGER ( KIND = I8B ) :: QHi , QLo , RHi , RLo !** FLOW ! compute division by 5: !   x/5 = (x.hi*2&#94;64 + x.lo)/5 !       = (x.hi*(2&#94;64-1) + x.hi + x.lo)/5 !       = x.hi*((2&#94;64-1)/5) + (x.hi + x.lo)/5 since CST=(2&#94;64-1)/5 is exact !       = x.hi*CST + x.hi/5 + x.lo/5 + ((x.lo%5) + (x.hi%5) >= 5) ! We go a step further and replace the last adjustment term with a ! lookup table, which we encode as a binary literal. CALL UMul128 ( X % High , CST , Q % High , Q % Low ) CALL UDivMod ( X % High , 5_I8B , QHi , RHi ) CALL UDivMod ( X % Low , 5_I8B , QLo , RLo ) CALL Add ( Q , QHi + QLo ) Addend = IAND ( SHIFTR ( LookUp , RHi + RLo ), 1 ) CALL Add ( Q , Addend ) IF ( Y == 10 ) Q = ShiftROnce ( Q ) RETURN END FUNCTION Divide_By_Pow10Factor !************************************************************************** FUNCTION Mod_By_Pow10Factor ( X , Y ) RESULT ( R ) !DIR$ ATTRIBUTES FORCEINLINE :: Mod_By_Pow10Factor !** PURPOSE OF THIS SUBROUTINE: ! To perform modulus (UMOD(X, Y)) of 2, 5 or 10 (i.e. Y is 2 or 5 or 10. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X INTEGER ( KIND = I4B ), INTENT ( IN ) :: Y ! must be 2, 5 or 10 TYPE ( UInt128 ) :: R !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: CST = INT ( Z '3333333333333333' , KIND = I8B ) INTEGER ( KIND = I4B ), PARAMETER :: LookUp1 = INT ( B '111100000' , KIND = I4B ) ! 480 INTEGER ( KIND = I8B ), PARAMETER :: LookUp2 = INT ( O '321043210' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AddendQ INTEGER ( KIND = I8B ) :: QHi , QLo INTEGER ( KIND = I8B ) :: R64 , RHi , RLo , AddendR TYPE ( UInt128 ) :: Q !** FLOW ! Ryu performs 128-bit modulus only by 2, 5 and 10, so that's what we ! implement.  The strategy here is to relate modulus of x with that of ! x.hi and x.lo separately. IF ( Y == 2 ) THEN R = IAND ( X , OneU128 ) RETURN END IF ! assert(y == 5 || y == 10); ! The following implements modulus by 5 and 10.  In either case, ! we first compute modulus by 5: !   x (mod 5) = x.hi*2&#94;64 + x.lo (mod 5) !             = x.hi + x.lo (mod 5) since 2&#94;64 == 1 (mod 5) ! So the straightforward implementation would be !   ((x.hi % 5) + (x.lo % 5)) % 5 ! But we go a step further and replace the outermost % with a ! lookup table: !             = {0,1,2,3,4,0,1,2,3}[(x.hi % 5) + (x.lo % 5)] (mod 5) ! which we encode as an octal literal. IF ( Y == 5 ) THEN R64 = IAND ( SHIFTR ( Lookup2 , 3_I8B * ( UMOD ( X % High , 5_I8B ) + UMOD ( X % Low , 5_I8B ))), 7_I8B ) R = UInt128 ( 0_I8B , R64 ) ELSE ! Y == 10 ! compute division by 5: !   x/5 = (x.hi*2&#94;64 + x.lo)/5 !       = (x.hi*(2&#94;64-1) + x.hi + x.lo)/5 !       = x.hi*((2&#94;64-1)/5) + (x.hi + x.lo)/5 since CST=(2&#94;64-1)/5 is exact !       = x.hi*CST + x.hi/5 + x.lo/5 + ((x.lo%5) + (x.hi%5) >= 5) ! We go a step further and replace the last adjustment term with a ! lookup table, which we encode as a binary literal. CALL UMul128 ( X % High , CST , Q % High , Q % Low ) CALL UDivMod ( X % High , 5_I8B , QHi , RHi ) CALL UDivMod ( X % Low , 5_I8B , QLo , RLo ) CALL Add ( Q , QHi + QLo ) AddendQ = IAND ( SHIFTR ( LookUp1 , RHi + RLo ), 1 ) CALL Add ( Q , AddendQ ) !-------------------------- R64 = IAND ( SHIFTR ( Lookup2 , 3_I8B * ( RHi + RLo )), 7_I8B ) R = UInt128 ( 0_I8B , R64 ) ! x % 10 = (x % 5)      if x / 5 is even !          (x % 5) + 5  if x / 5 is odd ! The compiler should be able to CSE the below computation of x/5 and ! the above modulus operations with a nearby inlined computation of x/10. AddendR = 5_I8B * IAND ( Q % Low , 1_I8B ) CALL Add ( R , AddendR ) END IF RETURN END FUNCTION Mod_By_Pow10Factor !************************************************************************** FUNCTION Pow5Factor_128Bits ( Value ) RESULT ( Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Pow5Factor_128Bits !** PURPOSE OF THIS SUBROUTINE: ! To compute the factor of power of 5 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ) :: Count !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Dividend TYPE ( UInt128 ) :: Quotient , Remainder !** FLOW Count = 0 Dividend = Value DO WHILE ( Dividend /= ZeroU128 ) CALL DivMod_By_Pow10Factor ( Dividend , 5 , Quotient , Remainder ) IF ( Remainder /= ZeroU128 ) RETURN Dividend = Quotient Count = Count + 1 END DO Count = 0 RETURN END FUNCTION Pow5Factor_128Bits !************************************************************************** FUNCTION IsMultipleOfPow5_128Bits ( Value , Exp ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: IsMultipleOfPow5_128Bits !** PURPOSE OF THIS SUBROUTINE: ! To check whether the given value is divisible by 5**Exp IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: ModInv5 ( 0 : 3 , 0 : MaxExp_ModInv5 ) = RESHAPE ([ & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'FFFFFFFFFFFFFFFF' , KIND = I8B ), INT ( Z 'FFFFFFFFFFFFFFFF' , KIND = I8B ), & INT ( Z 'CCCCCCCCCCCCCCCD' , KIND = I8B ), INT ( Z 'CCCCCCCCCCCCCCCC' , KIND = I8B ), & INT ( Z '3333333333333333' , KIND = I8B ), INT ( Z '3333333333333333' , KIND = I8B ), & INT ( Z '8F5C28F5C28F5C29' , KIND = I8B ), INT ( Z '28F5C28F5C28F5C2' , KIND = I8B ), & INT ( Z 'A3D70A3D70A3D70A' , KIND = I8B ), INT ( Z '0A3D70A3D70A3D70' , KIND = I8B ), & INT ( Z '1CAC083126E978D5' , KIND = I8B ), INT ( Z '6E978D4FDF3B645A' , KIND = I8B ), & INT ( Z 'ED916872B020C49B' , KIND = I8B ), INT ( Z '020C49BA5E353F7C' , KIND = I8B ), & INT ( Z 'D288CE703AFB7E91' , KIND = I8B ), INT ( Z '495182A9930BE0DE' , KIND = I8B ), & INT ( Z '95E9E1B089A02752' , KIND = I8B ), INT ( Z '0068DB8BAC710CB2' , KIND = I8B ), & INT ( Z '5D4E8FB00BCBE61D' , KIND = I8B ), INT ( Z 'DB76B3BB83CF2CF9' , KIND = I8B ), & INT ( Z '8461F9F01B866E43' , KIND = I8B ), INT ( Z '0014F8B588E368F0' , KIND = I8B ), & INT ( Z '790FB65668C26139' , KIND = I8B ), INT ( Z 'C57E23F24D8FD5CB' , KIND = I8B ), & INT ( Z '4DAD31FCD24E160D' , KIND = I8B ), INT ( Z '000431BDE82D7B63' , KIND = I8B ), & INT ( Z 'E5032477AE8D46A5' , KIND = I8B ), INT ( Z 'C1193A63A91CC45B' , KIND = I8B ), & INT ( Z '42BC3D3290760469' , KIND = I8B ), INT ( Z '0000D6BF94D5E57A' , KIND = I8B ), & INT ( Z 'C767074B22E90E21' , KIND = I8B ), INT ( Z 'F36B7213EE9F5A78' , KIND = I8B ), & INT ( Z '73BF3F70834ACDAE' , KIND = I8B ), INT ( Z '00002AF31DC46118' , KIND = I8B ), & INT ( Z '8E47CE423A2E9C6D' , KIND = I8B ), INT ( Z '97157D372FB9787E' , KIND = I8B ), & INT ( Z '4A59731680A88F89' , KIND = I8B ), INT ( Z '0000089705F4136B' , KIND = I8B ), & INT ( Z '4FA7F60D3ED61F49' , KIND = I8B ), INT ( Z '516AB2A4A3251819' , KIND = I8B ), & INT ( Z 'DBAB7D6AE6881CB5' , KIND = I8B ), INT ( Z '000001B7CDFD9D7B' , KIND = I8B ), & INT ( Z '0FEE64690C913975' , KIND = I8B ), INT ( Z '76AEF08753D43805' , KIND = I8B ), & INT ( Z '92557F7BC7B4D28A' , KIND = I8B ), INT ( Z '00000057F5FF85E5' , KIND = I8B ), & INT ( Z '3662E0E1CF503EB1' , KIND = I8B ), INT ( Z 'B156301B10C40B34' , KIND = I8B ), & INT ( Z 'EA11197F27F0F6E8' , KIND = I8B ), INT ( Z '000000119799812D' , KIND = I8B ), & INT ( Z 'A47A2CF9F6433FBD' , KIND = I8B ), INT ( Z '2377A3389CF4023D' , KIND = I8B ), & INT ( Z '2ED0384CA19697C8' , KIND = I8B ), INT ( Z '0000000384B84D09' , KIND = I8B ), & INT ( Z '54186F653140A659' , KIND = I8B ), INT ( Z '0717ED71B8FD9A0C' , KIND = I8B ), & INT ( Z '095CD80F538484C1' , KIND = I8B ), INT ( Z '00000000B424DC35' , KIND = I8B ), & INT ( Z '7738164770402145' , KIND = I8B ), INT ( Z 'CE37FC49F1CC5202' , KIND = I8B ), & INT ( Z 'CEAC2B3643E74DC0' , KIND = I8B ), INT ( Z '0000000024075F3D' , KIND = I8B ), & INT ( Z 'E4A4D1417CD9A041' , KIND = I8B ), INT ( Z 'F60B3275305C1066' , KIND = I8B ), & INT ( Z 'F6226F0ADA6175F3' , KIND = I8B ), INT ( Z '000000000734ACA5' , KIND = I8B ), & INT ( Z 'C75429D9E5C5200D' , KIND = I8B ), INT ( Z '6468A3B109AC0347' , KIND = I8B ), & INT ( Z '646D496892137DFD' , KIND = I8B ), INT ( Z '000000000170EF54' , KIND = I8B ), & INT ( Z 'C1773B91FAC10669' , KIND = I8B ), INT ( Z 'E0E1BA569B88CD74' , KIND = I8B ), & INT ( Z '47490EAE839D7F99' , KIND = I8B ), INT ( Z '000000000049C977' , KIND = I8B ), & INT ( Z '26B172506559CE15' , KIND = I8B ), INT ( Z '93605877B8B4F5E4' , KIND = I8B ), & INT ( Z 'A7DB69561A52B31E' , KIND = I8B ), INT ( Z '00000000000EC1E4' , KIND = I8B ), & INT ( Z 'D489E3A9ADDEC2D1' , KIND = I8B ), INT ( Z '83E011B18B576460' , KIND = I8B ), & INT ( Z '219248446BAA23D2' , KIND = I8B ), INT ( Z '000000000002F394' , KIND = I8B ), & INT ( Z '90E860BB892C8D5D' , KIND = I8B ), INT ( Z '4D9336BD1BDE4746' , KIND = I8B ), & INT ( Z 'A05074DA7BEED3F6' , KIND = I8B ), INT ( Z '000000000000971D' , KIND = I8B ), & INT ( Z '502E79BF1B6F4F79' , KIND = I8B ), INT ( Z 'DC50A48C38C60E41' , KIND = I8B ), & INT ( Z '2010175EE5962A64' , KIND = I8B ), INT ( Z '0000000000001E39' , KIND = I8B ), & INT ( Z 'DCD618596BE30FE5' , KIND = I8B ), INT ( Z '9276874F3E8E02D9' , KIND = I8B ), & INT ( Z '6CD004AC94513BAD' , KIND = I8B ), INT ( Z '000000000000060B' , KIND = I8B ), & INT ( Z '2C2AD1AB7BFA3661' , KIND = I8B ), INT ( Z 'EA17B4A972E933C5' , KIND = I8B ), & INT ( Z '7C299A88EA76A589' , KIND = I8B ), INT ( Z '0000000000000135' , KIND = I8B ), & INT ( Z '08D55D224BFED7AD' , KIND = I8B ), INT ( Z 'FB9E575516FB70C1' , KIND = I8B ), & INT ( Z 'E5A1EBB4FBB1544E' , KIND = I8B ), INT ( Z '000000000000003D' , KIND = I8B ), & INT ( Z '01C445D3A8CC9189' , KIND = I8B ), INT ( Z '658611776AFF168D' , KIND = I8B ), & INT ( Z '612062576589DDA9' , KIND = I8B ), INT ( Z '000000000000000C' , KIND = I8B ), & INT ( Z 'CD27412A54F5B6B5' , KIND = I8B ), INT ( Z 'E11AD04B156637B5' , KIND = I8B ), & INT ( Z '79D346DE4781F921' , KIND = I8B ), INT ( Z '0000000000000002' , KIND = I8B ), & INT ( Z '8F6E403BAA978AF1' , KIND = I8B ), INT ( Z 'F9D229A89DE13E57' , KIND = I8B ), & INT ( Z '7EC3DAF941806506' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'E97C733F221E4EFD' , KIND = I8B ), INT ( Z '31F6D521B92D0C77' , KIND = I8B ), & INT ( Z '195A5EFEA6B34767' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '2EB27D7306D2DC99' , KIND = I8B ), INT ( Z 'A397C439F1D5CF4B' , KIND = I8B ), & INT ( Z '051212FFBAF0A7E1' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '6FBD4C4A34909285' , KIND = I8B ), INT ( Z 'ED84C0D863912975' , KIND = I8B ), & INT ( Z '01039D66589687F9' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '16590F420A835081' , KIND = I8B ), INT ( Z '62B42691AD836EB1' , KIND = I8B ), & INT ( Z '0033EC47AB514E65' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '9E11CFDA021A434D' , KIND = I8B ), INT ( Z '46F0D483891A4956' , KIND = I8B ), & INT ( Z '000A6274BBDD0FAD' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'B936C32B9A0540A9' , KIND = I8B ), INT ( Z 'A7C9C41A4E9EDB77' , KIND = I8B ), & INT ( Z '000213B0F25F6989' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '583E2708B8677355' , KIND = I8B ), INT ( Z '87F52738761FC57E' , KIND = I8B ), & INT ( Z '00006A5696DFE1E8' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '44D93B01BE7B1711' , KIND = I8B ), INT ( Z 'E7FDD4A4E46CC119' , KIND = I8B ), & INT ( Z '0000154484932D2E' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '742B72338C7F049D' , KIND = I8B ), INT ( Z 'C7FF90EDC748F36B' , KIND = I8B ), & INT ( Z '00000440E750A2A2' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'B0D57D3D827FCDB9' , KIND = I8B ), INT ( Z '8E66502F8E41CA48' , KIND = I8B ), & INT ( Z '000000D9C7DCED53' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'BCF77F72B3B32925' , KIND = I8B ), INT ( Z '4FAE100982D9F541' , KIND = I8B ), & INT ( Z '0000002B8E5F62AA' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'BF64B316F0BD6EA1' , KIND = I8B ), INT ( Z 'A98936684D5ECAA6' , KIND = I8B ), & INT ( Z '00000008B61313BB' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'BFE0F09E3025E2ED' , KIND = I8B ), INT ( Z '21E83E14DC462887' , KIND = I8B ), & INT ( Z '00000001BE03D0BF' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'F32CFCEC700793C9' , KIND = I8B ), INT ( Z '6D2E72D0F8DAD4E7' , KIND = I8B ), & INT ( Z '000000005933F68C' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'CA3C3295B00183F5' , KIND = I8B ), INT ( Z '7C3C7D5CFE922A94' , KIND = I8B ), & INT ( Z '0000000011D7314F' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '5BA5A3B78999E731' , KIND = I8B ), INT ( Z '18D8E5DF661D3BB7' , KIND = I8B ), & INT ( Z '0000000003917043' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'ABEDED8B1B852E3D' , KIND = I8B ), INT ( Z '9E91C793146C3F24' , KIND = I8B ), & INT ( Z '0000000000B6B00D' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'EF2F95E89F1AA2D9' , KIND = I8B ), INT ( Z 'B9505B1D6A7C0CA0' , KIND = I8B ), & INT ( Z '000000000024899C' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'FCA31DFB530553C5' , KIND = I8B ), INT ( Z '8B76789F7BB268EC' , KIND = I8B ), & INT ( Z '0000000000074EB8' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '98ED6C65770110C1' , KIND = I8B ), INT ( Z '1BE47E864BF07B62' , KIND = I8B ), & INT ( Z '0000000000017624' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'B82F7C144B00368D' , KIND = I8B ), INT ( Z '6BFA7FB475967F13' , KIND = I8B ), & INT ( Z '0000000000004AD4' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '24D64C040F000AE9' , KIND = I8B ), INT ( Z 'AF32198A7DEAE637' , KIND = I8B ), & INT ( Z '0000000000000EF7' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '6DC4759A69666895' , KIND = I8B ), INT ( Z '230A051BB2C89471' , KIND = I8B ), & INT ( Z '00000000000002FE' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z 'E2C0E45215147B51' , KIND = I8B ), INT ( Z 'A09B9A9F23C1B749' , KIND = I8B ), & INT ( Z '0000000000000099' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '93C02DAA04374BDD' , KIND = I8B ), INT ( Z '201F1EECA0C057DB' , KIND = I8B ), & INT ( Z '000000000000001E' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '50C0092200D7DBF9' , KIND = I8B ), INT ( Z 'D3396C95B9C01192' , KIND = I8B ), & INT ( Z '0000000000000006' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B ), & INT ( Z '768CCEA066919265' , KIND = I8B ), INT ( Z '90A515B78B8CD050' , KIND = I8B ), & INT ( Z '0000000000000001' , KIND = I8B ), INT ( Z '0000000000000000' , KIND = I8B )], [ 4 , 56 ]) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Cache ( 0 : 3 ) TYPE ( UInt128 ) :: ModInverse , MaxQuotient !** FLOW Cache = ModInv5 (:, Exp ) ModInverse = UInt128 ( Cache ( 1 ), Cache ( 0 )) MaxQuotient = UInt128 ( Cache ( 3 ), Cache ( 2 )) Flag = Value * ModInverse . ULE . MaxQuotient RETURN END FUNCTION IsMultipleOfPow5_128Bits !************************************************************************** END SUBROUTINE Bin2Dec_Ryu !****************************************************************************** SUBROUTINE Bin2Dec_Schubfach ( SigRaw , ExpRaw , SigBin , ExpBin , SigDec , ExpDec ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a binary floating point number into the shortest and correctly ! rounded decimal representation based on the Schubfach algorithm. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigRaw ! The raw value of significand in IEEE 754 format INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpRaw ! The raw value of exponent in IEEE 754 format TYPE ( UInt128 ), INTENT ( IN ) :: SigBin ! The decoded value of significand in binary INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpBin ! The decoded value of exponent in binary TYPE ( UInt128 ), INTENT ( OUT ) :: SigDec ! The output value of significand in decimal INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpDec ! The output value of exponent in decimal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 TYPE ( UInt128 ) :: Cb , Cbl , Cbr , Vb , Vbl , Vbr INTEGER ( KIND = I4B ) :: kExp , hExp , Exp10 LOGICAL :: uInside , wInside TYPE ( UInt128 ) :: Sx , Sx4 , Sp TYPE ( UInt128 ) :: Upper , Lower , Middle !** FLOW: Cb = SHIFTL ( SigBin , 2 ) Cbr = Cb + TwoUInt ! check whether Cb is closer to the lower bound IF (( SigRaw == ZeroU128 ). AND .( ExpRaw > 1 )) THEN ! closer to the lower bound; irregular spacing Cbl = Cb - OneU128 kExp = Floor_Log10_ThreeQuartersPow2 ( ExpBin ) ELSE ! not closer to the lower bound; regular spacing Cbl = Cb - TwoUInt kExp = Floor_Log10_Pow2 ( ExpBin ) END IF ! compute Exp10 and shift Exp10 = - kExp hExp = ExpBin + Floor_Log2_Pow10 ( Exp10 ) + 1 ! get the cached pow10 value from Pow10_Sig_Table or compute it Pow10 = Get_Pow10_256Bits ( Exp10 ) IF (( Exp10 < Pow10_Min_Exact_Exp ). OR .( Exp10 > Pow10_Max_Exact_Exp )) THEN Pow10 ( 0 ) = Pow10 ( 0 ) + 1_I8B END IF ! To perform integer multiplications and get upper bits of rounded values Vbl = Round2Odd ( Pow10 , SHIFTL ( Cbl , hExp )) Vb = Round2Odd ( Pow10 , SHIFTL ( Cb , hExp )) Vbr = Round2Odd ( Pow10 , SHIFTL ( Cbr , hExp )) IF ( IAND ( SigBin , OneU128 ) == ZeroU128 ) THEN Lower = Vbl Upper = Vbr ELSE Lower = Vbl + OneU128 Upper = Vbr - OneU128 END IF Sx = SHIFTR ( Vb , 2 ) ! Sx = Vb / 4 IF ( Sx . UGE . TenUInt ) THEN ! Vb >= 40 Sp = Sx . UDIV . TenUInt ! Vb / 40 Sx4 = FortyUInt * Sp uInside = ( Lower . ULE . Sx4 ) wInside = ( Upper . UGE . ( Sx4 + FortyUInt )) IF ( uInside . NEQV . wInside ) THEN IF ( wInside ) THEN SigDec = Sp + OneU128 ELSE SigDec = Sp END IF ExpDec = kExp + 1 RETURN END IF END IF Sx4 = SHIFTL ( Sx , 2 ) uInside = ( Lower . ULE . Sx4 ) wInside = ( Upper . UGE . ( Sx4 + FourUInt )) ExpDec = kExp SigDec = Sx IF ( uInside . NEQV . wInside ) THEN IF ( wInside ) SigDec = SigDec + OneU128 RETURN END IF Middle = Sx4 + TwoUInt IF (( Vb . UGT . Middle ). OR .(( Vb == Middle ). AND .( IAND ( Sx , OneU128 ) /= ZeroU128 ))) THEN SigDec = SigDec + OneU128 END IF RETURN CONTAINS FUNCTION Round2Odd ( G , Cx ) RESULT ( Vx ) !** PURPOSE OF THIS SUBROUTINE: ! To perform the rounding of input IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: G ( 0 : 3 ) ! in little-endian order TYPE ( UInt128 ), INTENT ( IN ) :: Cx TYPE ( UInt128 ) :: Vx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: X_Hi , Y_Lo !** FLOW ! perform Cp * G%Lo and get the upper 64 bits of the result X_Hi = UMul256_Upper128 ( Cx , UInt128 ( G ( 1 ), G ( 0 ))) ! perform Cp * G%Hi + X_Hi and return Vx as the upper 64 bits of the result CALL UMul256_N_AddU128 ( Cx , UInt128 ( G ( 3 ), G ( 2 )), X_Hi , Vx , Y_Lo ) IF ( Y_Lo . UGT . OneU128 ) Vx = IOR ( Vx , OneU128 ) RETURN END FUNCTION Round2Odd !************************************************************************** SUBROUTINE UMul256 ( X , Y , ZHi , ZLo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute multiplication of two 128-bit unsigned integers and ! return the 256-bit unsigned result. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X , Y TYPE ( UInt128 ), INTENT ( OUT ) :: ZHi , ZLo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X64 ( 0 : 1 ), Y64 ( 0 : 1 ), Z64 ( 0 : 3 ) !** FLOW ! get input X64 ( 0 ) = X % Low X64 ( 1 ) = X % High Y64 ( 0 ) = Y % Low Y64 ( 1 ) = Y % High ! perform multiplication CALL MultiplyBasic ( X64 , 2 , Y64 , 2 , Z64 ) ! set output ZLo = UInt128 ( Z64 ( 1 ), Z64 ( 0 )) ZHi = UInt128 ( Z64 ( 3 ), Z64 ( 2 )) RETURN END SUBROUTINE UMul256 !************************************************************************** SUBROUTINE UMul256_N_AddU128 ( A , B , C , U256Hi , U256Lo ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply two 128-bit unsigned integers and add a 128-bit unsigned integer ! (A*B + C), and then return the 256-bit result as U256Hi, U256Lo. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: A , B , C TYPE ( UInt128 ), INTENT ( OUT ) :: U256Hi , U256Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: H , L !** FLOW ! multiply A and B CALL UMul256 ( A , B , H , L ) ! add C U256Lo = L + C U256Hi = H IF ( U256Lo . ULT . L ) CALL Increment ( U256Hi ) RETURN END SUBROUTINE UMul256_N_AddU128 !************************************************************************** END SUBROUTINE Bin2Dec_Schubfach !****************************************************************************** !------------------------------------------------------------------------------ ! !                       DECIMAL-TO-BINARY CONVERSION ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Dec2Bin_Clinger ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Valid ) ! To convert decimal floating point representation into its exact ! binary floating point representation using the Clinger algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Valid ! true if conversion can be done !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: RawFP INTEGER ( KIND = I4B ) :: Exp10 REAL ( KIND = QP ) :: FloatMantissa !** FLOW IF ( SHIFTR ( SigDec , SignificandBits ) /= ZeroU128 ) THEN Valid = FalseVal RETURN END IF FloatMantissa = ToR128 ( SigDec ) Exp10 = ExpDec IF ( Exp10 == 0 ) THEN RawFP = RawFP_FromFloat ( FloatMantissa ) END IF IF ( Exp10 > 0 ) THEN IF ( Exp10 > Num_Exact_Pow10 + Num_Mantissa_Digits ) THEN Valid = FalseVal RETURN END IF IF ( Exp10 > Num_Exact_Pow10 ) THEN FloatMantissa = FloatMantissa * Powers_Of_Ten ( Exp10 - Num_Exact_Pow10 ) Exp10 = Num_Exact_Pow10 END IF IF ( FloatMantissa > Max_Exact_Integer ) THEN Valid = FalseVal RETURN END  IF RawFP = RawFP_FromFloat ( FloatMantissa * Powers_Of_Ten ( Exp10 )) ELSEIF ( Exp10 < 0 ) THEN IF ( - Exp10 > Num_Exact_Pow10 ) THEN Valid = FalseVal RETURN END IF RawFP = RawFP_FromFloat ( FloatMantissa / Powers_Of_Ten ( - Exp10 )) END IF SigBin = RawFP_Significand ( RawFP ) ExpBin = RawFP_BiasedExponent ( RawFP ) Valid = TrueVal RETURN END FUNCTION Dec2Bin_Clinger !****************************************************************************** SUBROUTINE Dec2Bin_LibC ( SigDec , ExpDec , cStr , Start , Truncated , SigBin , ExpBin ) !** PURPOSE OF THIS SUBROUTINE: ! To use LibC algorithm to convert string to real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start LOGICAL , INTENT ( IN ) :: Truncated TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: FirstSigBin INTEGER ( KIND = I4B ) :: FirstExpBin !** FLOW ! try the Eisel-Lemire's algorithm IF ( Eisel_Lemire ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! the Eisel-Lemire's algorithm is possibly valid IF (. NOT . Truncated ) RETURN ! If the mantissa is truncated, then the result may be off by the LSB, so ! check if rounding the mantissa up changes the result. If not, then it's ! safe, else use the fallback. FirstSigBin = SigBin FirstExpBin = ExpBin IF ( Eisel_Lemire ( SigDec + OneU128 , ExpDec , SigBin , ExpBin )) THEN ! check if the Eisel-Lemire's algorithm is definitely valid IF (( SigBin == FirstSigBin ). AND .( ExpBin == FirstExpBin )) RETURN END IF END IF ! use the (very) slow Simple Decimal Conversion algorithm CALL Simple_Decimal_Conversion ( cStr , Start , LEN_TRIM ( cStr ), SigBin , ExpBin ) RETURN CONTAINS FUNCTION Eisel_Lemire ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Valid ) ! To convert decimal floating point representation into its closest ! binary floating point representation using the Eisel-Lemire algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Valid ! true if conversion can be done !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: MantU128 INTEGER ( KIND = I4B ) :: Exp2 INTEGER ( KIND = I4B ) :: CLZ TYPE ( UInt128 ) :: FinalApproxUpper , FinalApproxLower TYPE ( UInt128 ) :: SecondProductHi , SecondProductLo INTEGER ( KIND = I8B ) :: Mantissa ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) INTEGER ( KIND = I8B ) :: FirstProduct ( 0 : 3 ) INTEGER ( KIND = I8B ) :: SecondProduct ( 0 : 3 ) TYPE ( UInt128 ) :: FinalMantissa INTEGER ( KIND = I4B ) :: MSB !** FLOW ! normalization CLZ = LEADZ ( SigDec ) MantU128 = SHIFTL ( SigDec , CLZ ) Exp2 = Floor_Log2_Pow10 ( ExpDec ) + TotalBits + ExponentBias - CLZ ! multiplication Pow10 = Get_Pow10_256Bits ( ExpDec ) ! For small values of Q, e.g., Q in [0,55], the product is always exact. Mantissa ( 0 ) = MantU128 % Low Mantissa ( 1 ) = MantU128 % High CALL MultiplyBasic ( Mantissa , 2 , Pow10 ( 2 : 3 ), 2 , FirstProduct ) FinalApproxLower = UInt128 ( FirstProduct ( 1 ), FirstProduct ( 0 )) FinalApproxUpper = UInt128 ( FirstProduct ( 3 ), FirstProduct ( 2 )) ! Wider Approximation IF (( IAND ( FinalApproxUpper , HalfWay ) == HalfWay ). AND .( FinalApproxLower + MantU128 . ULT . MantU128 )) THEN CALL MultiplyBasic ( Mantissa , 2 , Pow10 ( 0 : 1 ), 2 , SecondProduct ) SecondProductLo = UInt128 ( SecondProduct ( 1 ), SecondProduct ( 0 )) SecondProductHi = UInt128 ( SecondProduct ( 3 ), SecondProduct ( 2 )) FinalApproxLower = FinalApproxLower + SecondProductHi IF ( SecondProductHi . UGT . FinalApproxLower ) CALL Increment ( FinalApproxUpper ) IF (( IAND ( SecondProductHi , HalfWay ) == HalfWay ). AND . & ( SecondProductLo + MantU128 . ULT . MantU128 )) THEN Valid = FalseVal RETURN END IF END IF ! Shifting to 113 bits MSB = ToI32 ( SHIFTR ( FinalApproxUpper , TotalBits - 1 )) FinalMantissa = SHIFTR ( FinalApproxUpper , ( MSB + TotalBits - ( SignificandBits + 3 ))) Exp2 = Exp2 - IEOR ( 1 , MSB ) ! same as NOT(MSB) ! Half-way ambiguity IF (( FinalApproxLower == ZeroU128 ). AND .( IAND ( FinalApproxUpper , HalfWay ) == & ZeroU128 ). AND .( IAND ( FinalMantissa , UInt128 ( 0_I8B , 3_I8B )) == OneU128 )) THEN Valid = FalseVal RETURN END IF ! From 113 to 112 bits FinalMantissa = FinalMantissa + IAND ( FinalMantissa , OneU128 ) FinalMantissa = SHIFTR ( FinalMantissa , 1 ) IF ( SHIFTR ( FinalMantissa , ( SignificandBits + 1 )) /= ZeroU128 ) THEN FinalMantissa = SHIFTR ( FinalMantissa , 1 ) Exp2 = Exp2 + 1 END IF ! check exponent validity IF (( Exp2 < 1 ). OR .( Exp2 > ( MaxExponent - 1 ))) THEN Valid = FalseVal RETURN END IF SigBin = FinalMantissa ExpBin = Exp2 Valid = TrueVal RETURN END FUNCTION Eisel_Lemire !****************************************************************************** SUBROUTINE Simple_Decimal_Conversion ( cStr , Start , Finish , SigBin , ExpBin ) ! To convert decimal string into its closest floating point binary representation ! using the Simple Decimal Conversion algorithm. ! The routine assumes that cStr is a 'VALID' floating point string and ! Start is less than Finish where !   - Start is the index of the first valid numeric character, and !   - Finish is the index of the last valid character (== length of the input !     string excluding trailing space(s)) !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: Start INTEGER ( KIND = I4B ), INTENT ( IN ) :: Finish TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( HPDecimal ) :: HP TYPE ( UInt128 ) :: FinalMantissa INTEGER ( KIND = I4B ) :: Exp2 INTEGER ( KIND = I4B ) :: ShiftAmount !** FLOW ! initialize Exp2 = 0 ! construct HPDecimal object CALL HP % Construct ( cStr , Start , Finish ) IF ( HP % NumDigits == 0 ) THEN SigBin = ZeroU128 ExpBin = 0 RETURN END IF ! If the exponent is too large and can't be represented in this size of ! float, return inf. IF (( HP % DecimalPoint > 0 ). AND .( Floor_Log2_Pow10 ( HP % DecimalPoint - 1 ) > ExponentBias )) THEN SigBin = ZeroU128 ExpBin = MaxExponent RETURN END IF ! If the exponent is too small even for a subnormal, return 0. IF (( HP % DecimalPoint < 0 ). AND . & ( Floor_Log2_Pow10 ( - HP % DecimalPoint ) > ( ExponentBias + SignificandBits ))) THEN SigBin = ZeroU128 ExpBin = 0 RETURN END IF ! Right shift until the number is smaller than 1. DO WHILE ( HP % DecimalPoint > 0 ) ShiftAmount = 0 IF ( HP % DecimalPoint >= Num_Powers_Of_Two ) THEN ShiftAmount = 60 ELSE ShiftAmount = Powers_Of_Two ( HP % DecimalPoint ) END IF Exp2 = Exp2 + ShiftAmount CALL HP % Shift ( - ShiftAmount ) END DO ! Left shift until the number is between 1/2 and 1 DO WHILE (( HP % DecimalPoint < 0 ). OR .(( HP % DecimalPoint == 0 ). AND .( HP % Digits ( 0 ) < 5 ))) ShiftAmount = 0 IF ( - HP % DecimalPoint >= Num_Powers_Of_Two ) THEN ShiftAmount = 60 ELSEIF ( HP % DecimalPoint /= 0 ) THEN ShiftAmount = Powers_Of_Two ( - HP % DecimalPoint ) ELSE ! This handles the case of the number being between .1 and .5 ShiftAmount = 1 END IF Exp2 = Exp2 - ShiftAmount CALL HP % Shift ( ShiftAmount ) END DO ! Left shift once so that the number is between 1 and 2 Exp2 = Exp2 - 1 CALL HP % Shift ( 1 ) ! Get the biased exponent Exp2 = Exp2 + ExponentBias ! Handle the exponent being too large (and return inf). IF ( Exp2 >= MaxExponent ) THEN SigBin = 0 ExpBin = MaxExponent RETURN END IF ! Shift left to fill the mantissa CALL HP % Shift ( SignificandBits ) CALL HP % RoundToUIntType ( FinalMantissa ) ! Handle subnormals IF ( Exp2 <= 0 ) THEN ! Shift right until there is a valid exponent DO WHILE ( Exp2 < 0 ) CALL HP % Shift ( - 1 ) Exp2 = Exp2 + 1 END DO ! Shift right one more time to compensate for the left shift to get it ! between 1 and 2. CALL HP % Shift ( - 1 ) CALL HP % RoundToUIntType ( FinalMantissa ) ! Check if by shifting right we've caused this to round to a normal number. IF ( SHIFTR ( FinalMantissa , SignificandBits ) /= ZeroU128 ) THEN Exp2 = Exp2 + 1 END IF END IF ! Check if rounding added a bit, and shift down if that's the case. IF ( FinalMantissa == SHIFTL ( UInt128 ( 2 ), SignificandBits )) THEN FinalMantissa = SHIFTR ( FinalMantissa , 1 ) Exp2 = Exp2 + 1 ! Check if this rounding causes Exp2 to go out of range and make the result ! INF. If this is the case, then finalMantissa and Exp2 are already the ! correct values for an INF result. IF ( Exp2 >= MaxExponent ) THEN ! report error if applicable END IF END IF IF ( Exp2 == 0 ) THEN ! report error if applicable END IF SigBin = FinalMantissa ExpBin = Exp2 RETURN END SUBROUTINE Simple_Decimal_Conversion !****************************************************************************** END SUBROUTINE Dec2Bin_LibC !****************************************************************************** SUBROUTINE Dec2Bin_FastFloat ( SigDec , ExpDec , cStr , SigCut , Indices , SigBin , ExpBin ) !** PURPOSE OF THIS SUBROUTINE: ! To use FastFloat algorithm to convert string to real number IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr LOGICAL , INTENT ( IN ) :: SigCut INTEGER ( KIND = I4B ), INTENT ( IN ) :: Indices ( 4 ) TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: EBase INTEGER ( KIND = I4B ) :: ECmp TYPE ( UInt128 ) :: MBase TYPE ( UInt128 ) :: MCmp !** FLOW ! compute float CALL Compute_Float ( ExpDec , SigDec , EBase , MBase ) IF ( SigCut . AND . EBase >= 0 ) THEN CALL Compute_Float ( ExpDec , SigDec + OneMant , ECmp , MCmp ) IF ( Is_AdjustedMantissa_NE ( EBase , MBase , ECmp , MCmp )) THEN CALL Compute_Error ( ExpDec , SigDec , EBase , MBase ) END IF END IF ! If we have an invalid power (EBase < 0), then we need to go ! the long way around again. This is very uncommon. IF ( EBase < 0 ) THEN BLOCK TYPE ( Parsed_Number_Info ) :: NumInfo ! set NumInfo NumInfo % Exp = ExpDec NumInfo % Sig = SigDec NumInfo % IntegralStart = Indices ( 1 ) NumInfo % IntegralEnd = Indices ( 2 ) NumInfo % FractionStart = Indices ( 3 ) NumInfo % FractionEnd = Indices ( 4 ) ECmp = EBase MCmp = MBase ! compare digits CALL Digit_Comparision ( cStr , NumInfo , ECmp , MCmp , EBase , MBase ) END BLOCK END IF SigBin = MBase ExpBin = EBase RETURN CONTAINS SUBROUTINE Compute_Product_Approximation ( Q , W , ProductHi , ProductLo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute or rather approximate W * 5**Q and return a pair of 64-bit words ! approximating the result, with the \"high\" part corresponding to the most ! significant bits and the low part corresponding to the least significant bits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 TYPE ( UInt128 ), INTENT ( IN ) :: W ! significand in base 10 TYPE ( UInt128 ) :: ProductHi , ProductLo ! product approximation !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: BitPrecision TYPE ( UInt128 ) :: PrecisionMask , SecondProductHi INTEGER ( KIND = I8B ) :: Mantissa ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) INTEGER ( KIND = I8B ) :: FirstProduct ( 0 : 3 ) INTEGER ( KIND = I8B ) :: SecondProduct ( 0 : 3 ) !** FLOW ! The required precision is Mantissa_Explicit_Bits + 3 because ! 1. We need the implicit bit ! 2. We need an extra bit for rounding purposes ! 3. We might lose a bit due to the \"UpperBit\" (result too small, requiring a shift) ! BitPrecision = 125 for 128-bit number BitPrecision = Mantissa_Explicit_Bits + 3 ! compute precision mask PrecisionMask = SHIFTR ( MaxMant , BitPrecision ) ! get 256-bit approximation of power of ten (or power of five) Pow10 = Get_Pow10_256Bits ( Q ) ! For small values of Q, e.g., Q in [0,55], the product is always exact. Mantissa ( 0 ) = W % Low Mantissa ( 1 ) = W % High CALL MultiplyBasic ( Mantissa , 2 , Pow10 ( 2 : 3 ), 2 , FirstProduct ) ProductLo = UInt128 ( FirstProduct ( 1 ), FirstProduct ( 0 )) ProductHi = UInt128 ( FirstProduct ( 3 ), FirstProduct ( 2 )) IF ( IAND ( ProductHi , PrecisionMask ) == PrecisionMask ) THEN ! could further guard with  (ProductLo + W < ProductLo) ! regarding the second product, we only need the upper bits of the product. CALL MultiplyBasic ( Mantissa , 2 , Pow10 ( 0 : 1 ), 2 , SecondProduct ) SecondProductHi = UInt128 ( SecondProduct ( 3 ), SecondProduct ( 2 )) ProductLo = ProductLo + SecondProductHi IF ( SecondProductHi . UGT . ProductLo ) CALL Increment ( ProductHi ) END IF RETURN END SUBROUTINE Compute_Product_Approximation !************************************************************************** FUNCTION Power ( Q ) RESULT ( E ) !** PURPOSE OF THIS SUBROUTINE: ! To compute power in base 2 based on the power in base 10 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! power in base 10 INTEGER ( KIND = I4B ) :: E ! power in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW E = Floor_Log2_Pow10 ( Q ) + MantTotalBits - 1 RETURN END FUNCTION Power !************************************************************************** SUBROUTINE Compute_Error_Scaled ( Q , W , LZ , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To create an adjusted mantissa, biased by the invalid power2 ! for significant digits already multiplied by 10 ** Q. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: LZ ! leading zeros in W INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( IN ) :: W ! significand in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: HiLZ , Bias !** FLOW HiLZ = IEOR ( ToI32 ( SHIFTR ( W , MantTotalBits - 1 )), 1 ) Bias = Mantissa_Explicit_Bits - Minimum_Exponent M = SHIFTL ( W , HiLZ ) E = Power ( Q ) + Bias - HiLZ - LZ - ( MantTotalBits - 2 ) + Invalid_AM_Bias RETURN END SUBROUTINE Compute_Error_Scaled !************************************************************************** SUBROUTINE Compute_Error ( Q , W , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute W * 10 ** Q, without rounding the representation up. ! the power2 in the exponent will be adjusted by Invalid_AM_Bias. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( IN ) :: W ! significand in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ TYPE ( UInt128 ) :: LocalW TYPE ( UInt128 ) :: ProductHi , ProductLo !** FLOW ! perform normalization LZ = LEADZ ( W ) LocalW = SHIFTL ( W , LZ ) ! compute the product approximation CALL Compute_Product_Approximation ( Q , LocalW , ProductHi , ProductLo ) ! compute the adjusted mantissa biased by the invalid power2 CALL Compute_Error_Scaled ( Q , ProductHi , LZ , E , M ) RETURN END SUBROUTINE Compute_Error !************************************************************************** SUBROUTINE Compute_Float ( Q , W , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To compute W * 10 ** Q ! The returned value should be a valid IEE64 number that simply need to be packed. ! However, in some very rare cases, the computation will fail. In such cases, we ! return an adjusted_mantissa with a negative power of 2: the caller should recompute ! in such cases. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Q ! exponent in base 10 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( IN ) :: W ! significand in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: LZ , UpperBit TYPE ( UInt128 ) :: LocalW TYPE ( UInt128 ) :: ProductHi , ProductLo !** FLOW ! check for special cases (may not be needed since it is taken care of in the caller?) IF (( W == ZeroU128 ) . OR . ( Q < Smallest_Power_of_Ten )) THEN E = 0 M = ZeroU128 ! result should be zero RETURN END IF IF ( Q > Largest_Power_of_Ten ) THEN ! we want to get infinity: E = Infinite_Power M = ZeroU128 RETURN END IF ! At this point in time Q is in [Smallest_Power_of_Ten, Largest_Power_of_Ten]. ! We want the most significant bit of i to be 1. Shift if needed. ! (i.e. perform normalization) LZ = LEADZ ( W ) LocalW = SHIFTL ( W , LZ ) ! compute the product approximation CALL Compute_Product_Approximation ( Q , LocalW , ProductHi , ProductLo ) ! The computed product is always sufficient.  See mathematical proof in [6]. ! Shifting to Mantissa_Explicit_Bits + 2 bits UpperBit = ToI32 ( SHIFTR ( ProductHi , MantTotalBits - 1 )) M = SHIFTR ( ProductHi , ( UpperBit + MantTotalBits - Mantissa_Explicit_Bits - 3 )) E = Power ( Q ) + UpperBit - LZ - Minimum_Exponent IF ( E <= 0 ) THEN ! we have a subnormal? ! Here have that E <= 0 so -E >= 0 IF ( - E + 1 >= MantTotalBits ) THEN ! if we have more than 'MantTotalBits' bits below the minimum exponent, you have a zero for sure. E = 0 M = ZeroU128 ! result should be zero RETURN END IF ! next line is safe because -E + 1 < MantTotalBits M = SHIFTR ( M , - E + 1 ) ! Thankfully, we can't have both \"round-to-even\" and subnormals because ! \"round-to-even\" only occurs for powers close to 0. M = M + IAND ( M , OneMant ) ! round up M = SHIFTR ( M , 1 ) ! There is a weird scenario where we don't have a subnormal but just. ! Suppose we start with 2.2250738585072013e-308, we end up ! with 0x3fffffffffffff x 2&#94;-1023-53 which is technically subnormal ! whereas 0x40000000000000 x 2&#94;-1023-53  is normal. Now, we need to round ! up 0x3fffffffffffff x 2&#94;-1023-53  and once we do, we are no longer ! subnormal, but we can only know this after rounding. ! So we only declare a subnormal if we are smaller than the threshold. ! IF (M .ULT. SHIFTL(OneMant, Mantissa_Explicit_Bits)) THEN IF ( M . ULT . Hidden_Bit_Mask ) THEN E = 0 ELSE E = 1 END IF RETURN END IF ! usually, we round *up*, but if we fall right in between and and we have an ! even basis, we need to round down ! We are only concerned with the cases where 5**Q fits in single 64-bit word. IF (( ProductLo . ULE . OneMant ) . AND . ( Q >= Min_Exponent_Round_To_Even ) . AND . & ( Q <= Max_Exponent_Round_To_Even ) . AND . & ( IAND ( M , ThreeUInt ) == OneMant )) THEN ! we may fall between two floats! ! To be in-between two floats we need that in doing !   M = ProductHi >> (UpperBit + 64 - Mantissa_Explicit_Bits - 3) ! ... we dropped out only zeroes. But if this happened, then we can go back!!! IF ( SHIFTL ( M , ( UpperBit + MantTotalBits - Mantissa_Explicit_Bits - 3 )) == & ProductHi ) THEN M = IAND ( M , NotOneMant ) ! flip it so that we do not round up END IF END IF M = M + IAND ( M , OneMant ) ! round up M = SHIFTR ( M , 1 ) IF ( M . UGE . Max_Mantissa_Fast_Path ) THEN M = SHIFTL ( OneMant , Mantissa_Explicit_Bits ) E = E + 1 ! undo previous addition END IF M = IAND ( M , NotSigHidBitMask ) IF ( E >= Infinite_Power ) THEN ! infinity E = Infinite_Power M = ZeroU128 END IF RETURN END SUBROUTINE Compute_Float !************************************************************************** FUNCTION Scientific_Exponent ( Number ) RESULT ( Exponent ) !** PURPOSE OF THIS SUBROUTINE: ! To calculate the exponent, in scientific notation, of the number. ! this algorithm is not even close to optimized, but it has no practical ! effect on performance: in order to have a faster algorithm, we'd need ! to slow down performance for faster algorithms, and this is still fast. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: Number INTEGER ( KIND = I4B ) :: Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Mantissa !** FLOW Mantissa = Number % Sig ! implicit narrow conversion for 32-bit Exponent = Number % Exp DO WHILE ( Mantissa . UGE . TenThousandUInt ) Mantissa = DivByPow10 ( Mantissa , 4 ) Exponent = Exponent + 4 END DO DO WHILE ( Mantissa . UGE . HundredUInt ) Mantissa = DivByPow10 ( Mantissa , 2 ) Exponent = Exponent + 2 END DO DO WHILE ( Mantissa . UGE . TenUInt ) Mantissa = DivByPow10 ( Mantissa , 1 ) Exponent = Exponent + 1 END DO RETURN END FUNCTION Scientific_Exponent !************************************************************************** SUBROUTINE Digit_Comparision ( cStr , NumInfo , EIn , MIn , EOut , MOut ) !** PURPOSE OF THIS SUBROUTINE: ! To parse the significant digits as a big integer to unambiguously round the ! the significant digits. here, we are trying to determine how to round ! an extended float representation close to `b+h`, halfway between `b` ! (the float rounded-down) and `b+u`, the next positive float. this ! algorithm is always correct, and uses one of two approaches. when ! the exponent is positive relative to the significant digits (such as ! 1234), we create a big-integer representation, get the high 64-bits, ! determine if any lower bits are truncated, and use that to direct ! rounding. in case of a negative exponent relative to the significant ! digits (such as 1.2345), we create a theoretical representation of ! `b` as a big-integer type, scaled to the same binary exponent as ! the actual digits. we then compare the big integer representations ! of both, and use that to direct rounding. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: NumInfo INTEGER ( KIND = I4B ), INTENT ( IN ) :: EIn INTEGER ( KIND = I4B ), INTENT ( OUT ) :: EOut TYPE ( UInt128 ), INTENT ( IN ) :: MIn TYPE ( UInt128 ), INTENT ( OUT ) :: MOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BigUInt ) :: Big INTEGER ( KIND = I4B ) :: Sci_Exp , Digits , Exponent INTEGER ( KIND = I4B ) :: EIn2 !** FLOW ! remove the invalid exponent bias EIn2 = EIn - Invalid_AM_Bias Sci_Exp = Scientific_Exponent ( NumInfo ) Digits = 0 CALL Parse_Mantissa ( cStr , Big , NumInfo , Max_Digits , Digits ) ! can't underflow, since digits is at most max_digits. Exponent = Sci_Exp + 1 - Digits IF ( Exponent >= 0 ) THEN CALL Positive_Digit_Comparision ( Big , Exponent , EOut , MOut ) ELSE CALL Negative_Digit_Comparision ( Big , EIn2 , MIn , Exponent , EOut , MOut ) END IF RETURN END SUBROUTINE Digit_Comparision !************************************************************************** FUNCTION Is_AdjustedMantissa_NE ( ELhs , MLhs , ERhs , MRhs ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To compare whether LHS /= RHS. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: ELhs INTEGER ( KIND = I4B ), INTENT ( IN ) :: ERhs TYPE ( UInt128 ), INTENT ( IN ) :: MLhs TYPE ( UInt128 ), INTENT ( IN ) :: MRhs LOGICAL :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( MLhs /= MRhs ). OR .( ELhs /= ERhs ) RETURN END FUNCTION Is_AdjustedMantissa_NE !************************************************************************** END SUBROUTINE Dec2Bin_FastFloat !****************************************************************************** SUBROUTINE Round ( E , M , CB ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float to the nearest machine float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 PROCEDURE ( CB_Round ) :: CB ! actual procedure that perform rounding !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Mantissa_Shift , Shift !** FLOW Mantissa_Shift = MantTotalBits - Mantissa_Explicit_Bits - 1 IF ( - E >= Mantissa_Shift ) THEN ! have a denormal float Shift = - E + 1 CALL CB ( E , M , MIN ( Shift , MantTotalBits )) ! check for round-up: if rounding-nearest carried us to the hidden bit. IF ( M . ULT . Hidden_Bit_Mask ) THEN E = 0 ELSE E = 1 END IF RETURN END IF ! have a normal float, use the default shift. CALL CB ( E , M , Mantissa_Shift ) ! check for carry IF ( M . UGE . Max_Mantissa_Fast_Path ) THEN M = Hidden_Bit_Mask E = E + 1 END IF ! check for infinite: we could have carried to an infinite power M = IAND ( M , NotSigHidBitMask ) IF ( E >= Infinite_Power ) THEN E = Infinite_Power M = 0_I8B END IF RETURN END SUBROUTINE Round !****************************************************************************** SUBROUTINE Round_Nearest_Tie_Even ( E , M , Shift , CB ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float to the nearest tie to even. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift PROCEDURE ( CB_Round_Nearest ) :: CB !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Mask , Halfway , Truncated_Bits LOGICAL :: Is_Above , Is_Halfway , Is_Odd !** FLOW IF ( Shift == MantTotalBits ) THEN Mask = MaxMant ELSE Mask = SHIFTL ( OneMant , Shift ) - OneMant END IF IF ( Shift == 0 ) THEN Halfway = ZeroU128 ELSE Halfway = SHIFTL ( OneMant , ( Shift - 1 )) END IF Truncated_Bits = IAND ( M , Mask ) Is_Above = Truncated_Bits . UGT . Halfway Is_Halfway = Truncated_Bits == Halfway ! shift digits into position IF ( Shift == MantTotalBits ) THEN M = ZeroU128 ELSE M = SHIFTR ( M , Shift ) END IF E = E + Shift Is_Odd = IAND ( M , OneMant ) == OneMant IF ( CB ( Is_Odd , Is_Halfway , Is_Above )) M = M + OneMant RETURN END SUBROUTINE Round_Nearest_Tie_Even !****************************************************************************** SUBROUTINE Parse_Mantissa ( cStr , Big , NumInfo , Max_Digits , Digits ) !** PURPOSE OF THIS SUBROUTINE: ! To parse the significant digits into a BigUInt IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr TYPE ( BigUInt ), INTENT ( INOUT ) :: Big TYPE ( Parsed_Number_Info ), INTENT ( IN ) :: NumInfo INTEGER ( KIND = I4B ), INTENT ( IN ) :: Max_Digits INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Digits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx , IEnd INTEGER ( KIND = I4B ) :: Counter , Step INTEGER ( KIND = I8B ) :: Value LOGICAL :: Truncated !** FLOW ! try to minimize the number of big integer and scalar multiplication. ! therefore, try to parse 8 digits at a time, and multiply by the largest ! scalar value (19 digits) for each step. Counter = 0 Digits = 0 Value = 0_I8B Step = 19 ! process all integer digits. IF ( NumInfo % IntegralStart /= 0 ) THEN Indx = NumInfo % IntegralStart IEnd = NumInfo % IntegralEnd CALL Skip_Zeros ( cStr , Indx , IEnd ) ! process all digits, in increments of step per loop DO WHILE ( Indx <= IEnd ) DO WHILE (( Indx + 7 <= IEnd ). AND .( Step - Counter >= 8 ). AND .( Max_Digits - Digits >= 8 )) CALL Parse_Eight_Digits ( cStr , Indx , Value , Counter , Digits ) END DO DO WHILE (( Counter < Step ). AND .( Indx <= IEnd ). AND .( Digits < Max_Digits )) CALL Parse_One_Digit ( cStr , Indx , Value , Counter , Digits ) END DO IF ( Digits == Max_Digits ) THEN ! add the temporary value, then check if we've truncated any digits CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Truncated = Is_Truncated ( cStr , Indx , IEnd ) IF ( NumInfo % FractionStart /= 0 ) THEN Truncated = Truncated . OR . Is_Truncated ( cStr , NumInfo % FractionStart , NumInfo % FractionEnd ) END IF IF ( Truncated ) THEN CALL Round_Up_BigUInt ( Big , Digits ) END IF RETURN ELSE CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Counter = 0 Value = 0_I8B END IF END DO END IF ! add our fraction digits, if they're available. IF ( NumInfo % FractionStart /= 0 ) THEN Indx = NumInfo % FractionStart IEnd = NumInfo % FractionEnd IF ( Digits == 0 ) THEN CALL Skip_Zeros ( cStr , Indx , IEnd ) END IF ! process all digits, in increments of step per loop DO WHILE ( Indx <= IEnd ) DO WHILE (( Indx + 7 <= IEnd ). AND .( Step - Counter >= 8 ). AND .( Max_Digits - Digits >= 8 )) CALL Parse_Eight_Digits ( cStr , Indx , Value , Counter , Digits ) END DO DO WHILE (( Counter < Step ). AND .( Indx <= IEnd ). AND .( Digits < Max_Digits )) CALL Parse_One_Digit ( cStr , Indx , Value , Counter , Digits ) END DO IF ( Digits == Max_Digits ) THEN ! add the temporary value, then check if we've truncated any digits CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) IF ( Is_Truncated ( cStr , Indx , IEnd )) THEN CALL Round_Up_BigUInt ( Big , Digits ) END IF RETURN ELSE CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) Counter = 0 Value = 0_I8B END IF END DO END IF IF ( Counter /= 0 ) THEN CALL Add_Native ( Big , Powers_of_Ten_Uint64 ( Counter ), Value ) END IF RETURN CONTAINS SUBROUTINE Skip_Zeros ( cStr , IStart , IEnd ) !DIR$ ATTRIBUTES FORCEINLINE :: Skip_Zeros !** PURPOSE OF THIS SUBROUTINE: ! To find IStart by skipping zeros. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: IStart INTEGER ( KIND = I4B ), INTENT ( IN ) :: IEnd !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MConst = INT ( Z '3030303030303030' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW DO WHILE ( IStart + 7 <= IEnd ) wStr = cStr ( IStart : IStart + 7 ) IF ( wVal /= MConst ) EXIT IStart = IStart + 8 END DO DO WHILE ( IStart <= IEnd ) IF ( cStr ( IStart : IStart ) /= '0' ) EXIT IStart = IStart + 1 END DO RETURN END SUBROUTINE Skip_Zeros !************************************************************************** FUNCTION Is_Truncated ( cStr , IStart , IEnd ) RESULT ( Flag ) !DIR$ ATTRIBUTES FORCEINLINE :: Is_Truncated !** PURPOSE OF THIS SUBROUTINE: ! To determine if any non-zero digits were truncated. ! all characters must be valid digits. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( IN ) :: IStart INTEGER ( KIND = I4B ), INTENT ( IN ) :: IEnd LOGICAL :: Flag !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MConst = INT ( Z '3030303030303030' , KIND = I8B ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Indx CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW ! initialize Indx = IStart Flag = TrueVal ! do 8-bit optimizations, can just compare to 8 literal 0s. DO WHILE ( Indx + 7 <= IEnd ) wStr = cStr ( Indx : Indx + 7 ) IF ( wVal /= MConst ) RETURN Indx = Indx + 8 END DO DO WHILE ( Indx <= IEnd ) IF ( cStr ( Indx : Indx ) /= '0' ) RETURN Indx = Indx + 1 END DO Flag = FalseVal RETURN END FUNCTION Is_Truncated !************************************************************************** SUBROUTINE Parse_Eight_Digits ( cStr , Indx , Value , Counter , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_Eight_Digits !** PURPOSE OF THIS SUBROUTINE: ! To parse 8 digits immediately. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx , Counter , Count INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CHARACTER ( LEN = 8 ) :: wStr INTEGER ( KIND = I8B ) :: wVal EQUIVALENCE ( wStr , wVal ) !** FLOW wStr = cStr ( Indx : Indx + 7 ) Value = Value * 100000000_I8B + Parse_Eight_Digits_Unrolled ( wVal ) Indx = Indx + 8 Counter = Counter + 8 Count = Count + 8 RETURN END SUBROUTINE Parse_Eight_Digits !************************************************************************** SUBROUTINE Parse_One_Digit ( cStr , Indx , Value , Counter , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Parse_One_Digit !** PURPOSE OF THIS SUBROUTINE: ! To parse 1 digit IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Indx , Counter , Count INTEGER ( KIND = I8B ), INTENT ( INOUT ) :: Value !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Value = Value * 10_I8B + ( IACHAR ( cStr ( Indx : Indx )) - A0 ) Indx = Indx + 1 Counter = Counter + 1 Count = Count + 1 RETURN END SUBROUTINE Parse_One_Digit !************************************************************************** SUBROUTINE Add_Native ( Big , Power , Value ) !DIR$ ATTRIBUTES FORCEINLINE :: Add_Native !** PURPOSE OF THIS SUBROUTINE: ! To add value to BigUInt IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I8B ), INTENT ( IN ) :: Power , Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL Big % SmallMul ( Power ) CALL Big % Add ( Value ) RETURN END SUBROUTINE Add_Native !************************************************************************** SUBROUTINE Round_Up_BigUInt ( Big , Count ) !DIR$ ATTRIBUTES FORCEINLINE :: Round_Up_BigUInt !** PURPOSE OF THIS SUBROUTINE: ! To round BigUInt up IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: Count !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! need to round-up the digits, but need to avoid rounding ! ....9999 to ...10000, which could cause a false halfway point. CALL Add_Native ( Big , 10_I8B , 1_I8B ) Count = Count + 1 RETURN END SUBROUTINE Round_Up_BigUInt !************************************************************************** END SUBROUTINE Parse_Mantissa !****************************************************************************** SUBROUTINE Positive_Digit_Comparision ( Big , Exp , E2 , M2 ) !** PURPOSE OF THIS SUBROUTINE: ! To compare BigInt for positive exponent. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E2 ! exponent in base 2 TYPE ( UInt128 ), INTENT ( OUT ) :: M2 ! adjusted significand in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Offset = Mantissa_Explicit_Bits - Minimum_Exponent - MantTotalBits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: LOGICAL :: Truncated !** FLOW CALL Big % Pow10 ( Exp ) M2 = Big % Hi128 ( Truncated ) E2 = Big % BitLen () + Offset CALL Round ( E2 , M2 , Callback_Round ) RETURN CONTAINS SUBROUTINE Callback_Round ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Nearest_Tie_Even ( E , M , Shift , Callback_Round_Nearest ) RETURN END SUBROUTINE !************************************************************************** FUNCTION Callback_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) ! arguments LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag ! execution Flag = IsAbove . OR .( IsHalfway . AND . Truncated ). OR .( IsOdd . AND . IsHalfway ) RETURN END FUNCTION !************************************************************************** END SUBROUTINE Positive_Digit_Comparision !****************************************************************************** SUBROUTINE Negative_Digit_Comparision ( Big , EIn , MIn , Exp , EOut , MOut ) !** PURPOSE OF THIS SUBROUTINE: ! To compare BigInt for negative exponent. ! ! The scaling here is quite simple: we have, for the real digits `m * 10&#94;e`, ! and for the theoretical digits `n * 2&#94;f`. Since `e` is always negative, ! to scale them identically, we do `n * 2&#94;f * 5&#94;-f`, so we now have `m * 2&#94;e`. ! we then need to scale by `2&#94;(f- e)`, and then the two significant digits ! are of the same magnitude. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BigUInt ), TARGET , INTENT ( INOUT ) :: Big INTEGER ( KIND = I4B ), INTENT ( IN ) :: EIn INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp INTEGER ( KIND = I4B ), INTENT ( OUT ) :: EOut TYPE ( UInt128 ), INTENT ( IN ) :: MIn TYPE ( UInt128 ), INTENT ( OUT ) :: MOut !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BigUInt ), POINTER :: RealDigits => NULL () TYPE ( BigUInt ) :: TheoryDigits INTEGER ( KIND = I4B ) :: RealExp , TheoryExp INTEGER ( KIND = I4B ) :: Pow2_Exp , Pow5_Exp INTEGER ( KIND = I4B ) :: Ord REAL ( KIND = QP ) :: FloatBase INTEGER ( KIND = I4B ) :: EBase INTEGER ( KIND = I4B ) :: ETheory TYPE ( UInt128 ) :: MBase TYPE ( UInt128 ) :: MTheory !** FLOW ! set working variables RealDigits => Big RealExp = Exp ! get the value of `b`, rounded down, and get a bigint representation of b+h EBase = EIn MBase = MIn CALL Round ( EBase , MBase , CBRound ) CALL To_Float ( FalseVal , EBase , MBase , FloatBase ) CALL To_Extended_Halfway ( FloatBase , ETheory , MTheory ) CALL TheoryDigits % FromU128 ( MTheory ) TheoryExp = ETheory ! scale real digits and theor digits to be same power. Pow2_Exp = TheoryExp - RealExp Pow5_Exp = - RealExp IF ( Pow5_Exp /= 0 ) THEN CALL TheoryDigits % Pow5 ( Pow5_Exp ) END IF IF ( Pow2_Exp > 0 ) THEN CALL TheoryDigits % Pow2 ( Pow2_Exp ) ELSEIF ( Pow2_Exp < 0 ) THEN CALL RealDigits % Pow2 ( - Pow2_Exp ) END IF ! compare digits, and use it to director rounding Ord = RealDigits % Compare ( TheoryDigits ) EOut = EIn MOut = MIn CALL Round ( EOut , MOut , Callback_Round ) ! free pointer NULLIFY ( RealDigits ) RETURN CONTAINS SUBROUTINE CBRound ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Down ( E , M , Shift ) RETURN END SUBROUTINE !************************************************************************** SUBROUTINE Callback_Round ( E , M , Shift ) ! arguments INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift ! execution CALL Round_Nearest_Tie_Even ( E , M , Shift , Callback_Round_Nearest ) RETURN END SUBROUTINE !************************************************************************** FUNCTION Callback_Round_Nearest ( IsOdd , IsHalfway , IsAbove ) RESULT ( Flag ) ! arguments LOGICAL , INTENT ( IN ) :: IsOdd , IsHalfway , IsAbove LOGICAL :: Flag ! execution IF ( Ord > 0 ) THEN Flag = TrueVal ELSEIF ( Ord < 0 ) THEN Flag = FalseVal ELSE Flag = IsOdd END IF RETURN END FUNCTION !************************************************************************** SUBROUTINE To_Extended ( Value , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a native floating-point number to an extended-precision float. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: Bias = Mantissa_Explicit_Bits - Minimum_Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Bits !** FLOW Bits = RawFP_FromFloat ( Value ) IF ( IAND ( Bits , Exponent_Mask ) == ZeroU128 ) THEN ! denormal E = 1 - Bias M = IAND ( Bits , Mantissa_Mask ) ELSE ! normal E = ToI32 ( SHIFTR ( IAND ( Bits , Exponent_Mask ), Mantissa_Explicit_Bits )) - Bias M = IOR ( IAND ( Bits , Mantissa_Mask ), Hidden_Bit_Mask ) END IF RETURN END SUBROUTINE To_Extended !************************************************************************** SUBROUTINE To_Extended_Halfway ( Value , E , M ) !** PURPOSE OF THIS SUBROUTINE: ! To get the extended precision value of the halfway point between b and b+u. ! we are given a native float that represents b, so we need to adjust it ! halfway between b and b+u. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: REAL ( KIND = QP ), INTENT ( IN ) :: Value INTEGER ( KIND = I4B ), INTENT ( OUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( OUT ) :: M ! adjusted significand in base 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL To_Extended ( Value , E , M ) M = SHIFTL ( M , 1 ) + OneMant E = E - 1 RETURN END SUBROUTINE To_Extended_Halfway !************************************************************************** SUBROUTINE Round_Down ( E , M , Shift ) !** PURPOSE OF THIS SUBROUTINE: ! To round an extended-precision float down. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( INOUT ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( INOUT ) :: M ! adjusted significand in base 2 INTEGER ( KIND = I4B ), INTENT ( IN ) :: Shift !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( Shift == MantTotalBits ) THEN M = ZeroU128 ELSE M = SHIFTR ( M , Shift ) END IF E = E + Shift RETURN END SUBROUTINE Round_Down !************************************************************************** SUBROUTINE To_Float ( Negative , E , M , Value ) !** PURPOSE OF THIS SUBROUTINE: ! To convert adjusted mantissa to double-precision value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: LOGICAL , INTENT ( IN ) :: Negative INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! exponent in base 2 TYPE ( UInt128 ), INTENT ( IN ) :: M ! adjusted significand in base 2 REAL ( KIND = QP ), INTENT ( OUT ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BinRep ) :: FpBin TYPE ( UInt128 ) :: Word !** FLOW ! get input FpBin % Negative = Negative FpBin % Exponent = E FpBin % Significand = M ! implicit narrowing conversion for 32 bit ! compose the component parts into word Word = RawFP_Construct ( FpBin ) ! convert word to real number Value = RawFP_ToFloat ( Word ) RETURN END SUBROUTINE To_Float !************************************************************************** END SUBROUTINE Negative_Digit_Comparision !****************************************************************************** FUNCTION Dec2Bin_YY ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use YY's algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand, base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent, base 10 LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information TYPE ( UInt128 ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange - UIntSafeDigits !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigBin ! significand, base 2 INTEGER ( KIND = I4B ) :: ExpBin ! exponent, base 2 !** FLOW ! check whether to use YY's fast path IF ((. NOT . Aux % Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN IF ( D2B_YY_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! YY's fast path is success so set sign bit IF ( Negative ) THEN RawFP = SignMask ELSE RawFP = ZeroU128 END IF ! then, add exponent bits RawFP = IOR ( RawFP , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! finally, add (both implicit and explicit) significand bits RawFP = IOR ( RawFP , IAND ( SigBin , SignificandMask )) RETURN END IF END IF ! perform decimal to binary conversion using YY's slow path RawFP = D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RETURN CONTAINS FUNCTION D2B_YY_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_YY_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use YY's fast path algorithm to convert from decimal representation ! to binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I8B ) :: Mantissa ( 0 : 1 ), Sig2 ( 0 : 1 ), Sig2_Ext ( 0 : 1 ) INTEGER ( KIND = I8B ) :: FirstProduct ( 0 : 3 ) INTEGER ( KIND = I8B ) :: SecondProduct ( 0 : 3 ) TYPE ( UInt128 ) :: Hi , Lo , Hi2 TYPE ( UInt128 ) :: Sig1 , Add , Bits INTEGER ( KIND = I4B ) :: Exp2 , Lz LOGICAL :: Exact !** FLOW ! To keep it simple, we only accept normal number here, ! let the slow path handle subnormal and infinity number. ! The result value is exactly equal to (SigDec * 10**ExpDec), ! the exponent part (10**ExpDec) can be converted to (Sig2 * 2**Exp2). ! The Sig2 can be an infinite length number, only the highest 256 bits ! is cached in the Pow10_Sig_Table. ! (Quad uses 256 bits, Double uses 128 bits, and Single uses 64 bits) ! Now we have these bits: ! Sig1 (normalized 128/64/32 bit)   : aaaaaaaaaaaaaaaa ! Sig2 (higher 128/64/32 bit)       : bbbbbbbbbbbbbbbb ! Sig2_Ext (lower 128/64/32 bit)    : cccccccccccccccc ! Sig2_Cut (extra unknown bits)     : dddddddddddddddddddddddd.... ! And the calculation process is: ! ------------------------------------------------------------- !         aaaaaaaaaaaaaaaa * !         bbbbbbbbbbbbbbbbccccccccccccccccdddddddddddd.... ! ------------------------------------------------------------- ! abababababababababababababababab + !         acacacacacacacacacacacacacacacac + !                 adadadadadadadadadadadadadadadadadadadad.... ! ------------------------------------------------------------- ! [Hi____][Lo____] + !         [Hi2___][Lo2___] + !                 [unknown___________....] ! ------------------------------------------------------------- ! The addition with carry may affect higher bits, but if there is a 0 ! in higher bits, the bits higher than 0 will not be affected. ! 'Lo2' + 'unknown' may get a carry bit and may affect 'Hi2', the max value ! of 'Hi2' is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE/0xFFFFFFFFFFFFFFFE/0xFFFFFFFE, ! so 'Hi2' will not overflow. ! 'Lo' + 'Hi2' may alse get a carry bit and may affect 'Hi', but only ! the highest significant 113/53/24 bits of 'Hi' is needed. If there is a 0 ! in the lower bits of 'Hi', then all the following bits can be dropped. ! To convert the result to IEEE-754 double number, we need to perform ! correct rounding: ! 1. if bit 114/54/25 is 0, round down, ! 2. if bit 114/54/25 is 1 and any bit beyond bit 114/54/25 is 1, round up, ! 3. if bit 114/54/25 is 1 and all bits beyond bit 114/54/25 are 0, round to even, !    as the extra bits is unknown, this case will not be handled here. ! initialize Exact = FalseVal Success = FalseVal ! convert (10*ExpDec) to (Sig2 * 2**Exp2) Pow10 = Get_Pow10_256Bits ( ExpDec ) Sig2 = Pow10 ( 2 : 3 ) Sig2_Ext = Pow10 ( 0 : 1 ) Exp2 = Floor_Log2_Pow10 ( ExpDec ) - SignBits ! normalize and multiply Lz = LEADZ ( SigDec ) Sig1 = SHIFTL ( SigDec , Lz ) Exp2 = Exp2 - Lz Mantissa ( 0 ) = Sig1 % Low Mantissa ( 1 ) = Sig1 % High CALL MultiplyBasic ( Mantissa , 2 , Sig2 , 2 , FirstProduct ) Lo = UInt128 ( FirstProduct ( 1 ), FirstProduct ( 0 )) Hi = UInt128 ( FirstProduct ( 3 ), FirstProduct ( 2 )) ! To get normalized value, 'Hi' should be shifted to the left by 0 or 1. ! The highest significant 113/53/24 bits is used by IEEE-754 double number, ! and the bit 114/54/25 is used to detect rounding direction. ! The lowest 13 (= 128 - 114 - 1) / 9 (= 64 - 54 - 1) / 6 (= 32 - 25 - 1) bits (LowBits) ! is used to check whether it contains 0. ! Note: BitMask = SHIFTL(1, LowBits) - 1 Bits = IAND ( Hi , BitMask ) IF (( Bits /= ZeroU128 ). AND .( Bits /= BitMask )) THEN ! The 'Bits' is not zero, so we don't need to check 'round to even' case. ! The 'Bits' contains bit '0', so we can drop the extra bits after '0'. Exact = TrueVal ELSE ! The 'Bits' is filled with all '0' or all '1', so we need to check ! more lower bits with another multiplication. CALL MultiplyBasic ( Mantissa , 2 , Sig2_Ext , 2 , SecondProduct ) Hi2 = UInt128 ( SecondProduct ( 3 ), SecondProduct ( 2 )) Add = Lo + Hi2 IF (( Add /= ZeroU128 ). AND .( Add /= MaxUInt )) THEN ! The 'Add' is not zero, so we don't need to check 'round to even' case. ! The 'Add' contains bit '0', so we can drop the extra bits after '0'. ! The 'Hi' cannot be MaxUInt, so it will not overflow. IF (( Add . ULT . Lo ). OR .( Add . ULT . Hi2 )) Hi = Hi + OneU128 Exact = TrueVal END IF END IF IF ( Exact ) THEN ! normalize IF ( Hi . ULT . SignMask ) THEN Hi = SHIFTL ( Hi , 1 ) Exp2 = Exp2 - 1 END IF Exp2 = Exp2 + TotalBits ! test the bit 114 and get rounding direction IF ( IAND ( Hi , AddRound ) /= ZeroU128 ) Hi = Hi + AddRound ! test overflow IF ( Hi . ULT . AddRound ) THEN Hi = SignMask Exp2 = Exp2 + 1 END IF ! This is a normal number, convert it to binary representation. SigBin = SHIFTR ( Hi , ExponentBits ) ExpBin = Exp2 + ( ExponentBits + SignificandBits ) + ExponentBias Success = TrueVal END IF RETURN END FUNCTION D2B_YY_FastPath !************************************************************************** END FUNCTION Dec2Bin_YY !****************************************************************************** FUNCTION D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use YY's slow path algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information TYPE ( UInt128 ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: ERR_ULP_LOG = 3 INTEGER ( KIND = I4B ), PARAMETER :: ERR_ULP = SHIFTL ( 1 , ERR_ULP_LOG ) INTEGER ( KIND = I4B ), PARAMETER :: ERR_CACHED_POW = ERR_ULP / 2 INTEGER ( KIND = I4B ), PARAMETER :: ERR_MUL_FIXED = ERR_ULP / 2 INTEGER ( KIND = I4B ), PARAMETER :: DIY_SIG_BITS = TotalBits INTEGER ( KIND = I4B ), PARAMETER :: EXP_BIAS = ExponentBias + SignificandBits INTEGER ( KIND = I4B ), PARAMETER :: EXP_SUBNORMAL = - EXP_BIAS + 1 INTEGER ( KIND = I4B ), PARAMETER :: A0 = IACHAR ( '0' ) !** SUBROUTINE DERIVED TYPE DEFINITIONS ! \"Do It Yourself Floating Point\" TYPE Diy_Fp TYPE ( UInt128 ) :: Sig ! significand INTEGER ( KIND = I4B ) :: Exp ! exponent, base 2 END TYPE ! ---------------------------------------------------------------------------- !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Sign TYPE ( UInt128 ) :: FpErr , PrecisionBits , HalfWay INTEGER ( KIND = I4B ) :: Bits INTEGER ( KIND = I4B ) :: Order_of_Magnitude , Effective_Significand_Size INTEGER ( KIND = I4B ) :: PrecisionDigitsCount , Cmp , Exp10 TYPE ( Diy_Fp ) :: Fp , FpUpper TYPE ( BigUInt ) :: BigFull , BigComp !** FLOW ! Slow path: read floating-point number exactly with diyfp. ! 1. Use cached diyfp to get an approximation value. ! 2. Use bigcomp to check the approximation value if needed. ! This algorithm refers to google's double-conversion project: ! https://github.com/google/double-conversion ! initialize IF ( Negative ) THEN Sign = OneU128 ELSE Sign = ZeroU128 END IF Fp % Sig = SigDec Fp % Exp = 0 IF ( Aux % Truncated ) THEN FpErr = UInt128 ( ERR_ULP / 2 ) ! round up if the next digit after the cut is more than or equal to 5 IF (( IACHAR ( cStr ( Aux % SigCut : Aux % SigCut )) - A0 ) >= 5 ) Fp % Sig = Fp % Sig + OneU128 ELSE FpErr = ZeroU128 END IF ! normalize Bits = LEADZ ( Fp % Sig ) Fp % Sig = SHIFTL ( Fp % Sig , Bits ) Fp % Exp = Fp % Exp - Bits FpErr = SHIFTL ( FpErr , Bits ) ! multiply and add error Fp = Diy_Fp_Mul ( Fp , Diy_Fp_Get_Cached_Pow10 ( ExpDec )) IF ( FpErr == ZeroU128 ) THEN FpErr = FpErr + UInt128 ( ERR_CACHED_POW + ERR_MUL_FIXED ) ELSE FpErr = FpErr + UInt128 ( ERR_CACHED_POW + ERR_MUL_FIXED + 1 ) END IF ! normalize Bits = LEADZ ( Fp % Sig ) Fp % Sig = SHIFTL ( Fp % Sig , Bits ) Fp % Exp = Fp % Exp - Bits FpErr = SHIFTL ( FpErr , Bits ) ! effective significand Order_of_Magnitude = DIY_SIG_BITS + Fp % Exp IF ( Order_of_Magnitude >= EXP_SUBNORMAL + BinaryPrecision ) THEN Effective_Significand_Size = BinaryPrecision ELSEIF ( Order_of_Magnitude <= EXP_SUBNORMAL ) THEN Effective_Significand_Size = 0 ELSE Effective_Significand_Size = Order_of_Magnitude - EXP_SUBNORMAL END IF ! precision digits count PrecisionDigitsCount = DIY_SIG_BITS - Effective_Significand_Size IF ( PrecisionDigitsCount + ERR_ULP_LOG >= DIY_SIG_BITS ) THEN BLOCK INTEGER ( KIND = I4B ) :: Shr Shr = ( PrecisionDigitsCount + ERR_ULP_LOG ) - DIY_SIG_BITS + 1 Fp % Sig = SHIFTR ( Fp % Sig , Shr ) Fp % Exp = Fp % Exp + Shr FpErr = SHIFTR ( FpErr , Shr ) + UInt128 ( 1 + ERR_ULP ) PrecisionDigitsCount = PrecisionDigitsCount - Shr END BLOCK END IF ! half way PrecisionBits = IAND ( Fp % Sig , ( SHIFTL ( OneU128 , PrecisionDigitsCount ) - OneU128 )) PrecisionBits = PrecisionBits * ERR_ULP HalfWay = SHIFTL ( OneU128 , ( PrecisionDigitsCount - 1 )) HalfWay = HalfWay * ERR_ULP ! rounding Fp % Sig = SHIFTR ( Fp % Sig , PrecisionDigitsCount ) IF ( PrecisionBits . UGE . HalfWay + FpErr ) Fp % Sig = Fp % Sig + OneU128 Fp % Exp = Fp % Exp + PrecisionDigitsCount ! get IEEE raw value RawFP = Diy_Fp_To_IEEE_Raw ( Fp ) IF ( RawFP == FpRawInf ) THEN RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN END IF IF (( PrecisionBits . ULE . HalfWay - FpErr ). OR .( PrecisionBits . UGE . HalfWay + FpErr )) THEN ! number is accurate RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN END IF ! ------------------------------------------------------------------------- ! now the number is the correct value, or the next lower value ! ------------------------------------------------------------------------- ! upper boundary IF ( IAND ( RawFP , ExponentMask ) /= ZeroU128 ) THEN FpUpper % Sig = IAND ( RawFP , SignificandMask ) + SHIFTL ( OneU128 , SignificandBits ) FpUpper % Exp = ToI32 ( SHIFTR ( IAND ( RawFP , ExponentMask ), SignificandBits )) ELSE FpUpper % Sig = IAND ( RawFP , SignificandMask ) FpUpper % Exp = 1 END IF FpUpper % Exp = FpUpper % Exp - ( ExponentBias + SignificandBits ) FpUpper % Sig = SHIFTL ( FpUpper % Sig , 1 ) FpUpper % Exp = FpUpper % Exp - 1 FpUpper % Sig = FpUpper % Sig + 1 ! add half ulp ! compare with BigInt Exp10 = ExpDec CALL BigInt_Set_String ( BigFull , SigDec , Exp10 , cStr , Aux ) CALL BigInt_Set_UIntType ( BigComp , FpUpper % Sig ) IF ( Exp10 >= 0 ) THEN CALL BigInt_Mul_Pow10 ( BigFull , + Exp10 ) ELSE CALL BigInt_Mul_Pow10 ( BigComp , - Exp10 ) END IF IF ( FpUpper % Exp > 0 ) THEN CALL BigInt_Mul_Pow2 ( BigComp , + FpUpper % Exp ) ELSE CALL BigInt_Mul_Pow2 ( BigFull , - FpUpper % Exp ) END IF Cmp = BigInt_Compare ( BigFull , BigComp ) IF ( Cmp /= 0 ) THEN ! round down or round up IF ( Cmp > 0 ) RawFP = RawFP + OneU128 ELSE ! falls midway, round to even IF ( IAND ( RawFP , OneU128 ) /= ZeroU128 ) RawFP = RawFP + OneU128 END IF RawFP = IOR ( SHIFTL ( Sign , SignBits ), RawFP ) RETURN CONTAINS FUNCTION Diy_Fp_Get_Cached_Pow10 ( Exp10 ) RESULT ( Fp ) !** PURPOSE OF THIS SUBROUTINE: ! To get cached rounded diy_fp with pow(10, e). The input value must in range ! [POW10_SIG_TABLE_MIN_EXP, POW10_SIG_TABLE_MAX_EXP]. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp10 ! an exponent TYPE ( Diy_Fp ) :: Fp ! Diy_Fp data !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 TYPE ( UInt128 ) :: Sig_Ext !** FLOW Pow10 = Get_Pow10_256Bits ( Exp10 ) Fp % Sig = UInt128 ( Pow10 ( 3 ), Pow10 ( 2 )) Sig_Ext = UInt128 ( Pow10 ( 1 ), Pow10 ( 0 )) Fp % Exp = Floor_Log2_Pow10 ( Exp10 ) - SignBits Fp % Sig = Fp % Sig + SHIFTR ( Sig_Ext , SignBits ) RETURN END FUNCTION Diy_Fp_Get_Cached_Pow10 !************************************************************************** FUNCTION Diy_Fp_Mul ( Fp1 , Fp2 ) RESULT ( Fp ) !** PURPOSE OF THIS SUBROUTINE: ! To evaluate 'fp1 * fp2'. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Diy_Fp ), INTENT ( IN ) :: Fp1 , Fp2 TYPE ( Diy_Fp ) :: Fp !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Hi , Lo !** FLOW CALL UMul256 ( Fp1 % Sig , Fp2 % Sig , Hi , Lo ) Fp % Sig = Hi + SHIFTR ( Lo , SignBits ) Fp % Exp = Fp1 % Exp + Fp2 % Exp + TotalBits RETURN END FUNCTION Diy_Fp_Mul !************************************************************************** FUNCTION Diy_Fp_To_IEEE_Raw ( Fp ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: ! To convert diy_fp to IEEE-754 raw value. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Diy_Fp ), INTENT ( IN ) :: Fp TYPE ( UInt128 ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: Sig INTEGER ( KIND = I4B ) :: Exp INTEGER ( KIND = I4B ) :: Lz_Bits !** FLOW ! initialize Sig = Fp % Sig Exp = Fp % Exp Val = ZeroU128 IF ( Sig == ZeroU128 ) RETURN ! compute significand and exponent Lz_Bits = LEADZ ( Sig ) Sig = SHIFTL ( Sig , Lz_Bits ) Sig = SHIFTR ( Sig , ExponentBits ) Exp = Exp - Lz_Bits + ExponentBits + SignificandBits ! check which range the result falls IF ( Exp >= MaxExpBin ) THEN ! overflow Val = RawFP_SetInfinity ( FalseVal ) ELSEIF ( Exp >= ( MinExpBin - 1 )) THEN ! normal Exp = Exp + ExponentBias Val = IOR ( SHIFTL ( UInt128 ( Exp ), SignificandBits ), IAND ( Sig , SignificandMask )) ELSEIF ( Exp >= ( MinExpBin - BinaryPrecision )) THEN ! subnormal Val = SHIFTR ( Sig , ( MinExpBin - Exp - 1 )) ELSE ! underflow Val = ZeroU128 END IF RETURN END FUNCTION Diy_Fp_To_IEEE_Raw !************************************************************************** END FUNCTION D2B_YY_SlowPath !****************************************************************************** FUNCTION Dec2Bin_Lemire ( SigDec , ExpDec , Negative , cStr , Aux ) RESULT ( RawFP ) !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's algorithm to convert from decimal representation ! to (raw) binary representation IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand, base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent, base 10 LOGICAL , INTENT ( IN ) :: Negative ! true if the floating point value is negative CHARACTER ( LEN =* ), INTENT ( IN ) :: cStr ! floating-point number string TYPE ( StringAux ), INTENT ( IN ) :: Aux ! auxiliary string information TYPE ( UInt128 ) :: RawFP ! floating point number as an unsigned integer !** SUBROUTINE PARAMETER DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: MinExpFastPath = - DecimalRange - UIntSafeDigits + 1 INTEGER ( KIND = I4B ), PARAMETER :: MaxExpFastPath = DecimalRange + 2 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: SigBin ! significand, base 2 INTEGER ( KIND = I4B ) :: ExpBin ! exponent, base 2 !** FLOW ! check whether to use Lemire's fast path IF ((. NOT . Aux % Truncated ). AND .( ExpDec > MinExpFastPath ). AND .( ExpDec < MaxExpFastPath )) THEN IF ( D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin )) THEN ! Lemire's fast path is success so set sign bit IF ( Negative ) THEN RawFP = SignMask ELSE RawFP = ZeroU128 END IF ! then, add exponent bits RawFP = IOR ( RawFP , SHIFTL ( UInt128 ( ExpBin ), SignificandBits )) ! finally, add (both implicit and explicit) significand bits RawFP = IOR ( RawFP , IAND ( SigBin , SignificandMask )) RETURN END IF END IF ! perform decimal to binary conversion using YY's slow path RawFP = D2B_YY_SlowPath ( SigDec , ExpDec , Negative , cStr , Aux ) RETURN CONTAINS FUNCTION D2B_Lemire_FastPath ( SigDec , ExpDec , SigBin , ExpBin ) RESULT ( Success ) !DIR$ ATTRIBUTES FORCEINLINE :: D2B_Lemire_FastPath !** PURPOSE OF THIS SUBROUTINE: ! To use Lemire's fast path algorithm to convert from decimal to binary representation. ! Note: This routine is based on 'Fast Double Parser' implementation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: SigDec ! significand in base 10 INTEGER ( KIND = I4B ), INTENT ( IN ) :: ExpDec ! exponent in base 10 TYPE ( UInt128 ), INTENT ( OUT ) :: SigBin ! significand in base 2 INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ExpBin ! exponent in base 2 LOGICAL :: Success ! true if conversion can be handled !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: Pow10 ( 0 : 3 ) ! in little endian order; most significant byte is 3 INTEGER ( KIND = I8B ) :: Mantissa ( 0 : 1 ) INTEGER ( KIND = I8B ) :: MulProduct ( 0 : 3 ) INTEGER ( KIND = I4B ) :: LZ INTEGER ( KIND = I4B ) :: Upperbit TYPE ( UInt128 ) :: Significand TYPE ( UInt128 ) :: Lower , Upper INTEGER ( KIND = I4B ) :: Exponent !** FLOW ! get 256/128/64-bit approximation of power of 10 (or power of 5) Pow10 = Get_Pow10_256Bits ( ExpDec ) ! compute the exponent Exponent = Floor_Log2_Pow10 ( ExpDec ) + MaxExpBin + SignBits ! +++ normalize the significand +++ ! We want the most significant bit of Significand to be 1. Shift if needed. LZ = LEADZ ( SigDec ) Significand = SHIFTL ( SigDec , LZ ) ! +++ perform multiplication +++ ! We want the most significant 128/64/32 bits of the product. We know this will be non-zero ! because the most significant bit of Significand is 1. Mantissa ( 0 ) = Significand % Low Mantissa ( 1 ) = Significand % High CALL MultiplyBasic ( Mantissa , 2 , Pow10 ( 2 : 3 ), 2 , MulProduct ) Lower = UInt128 ( MulProduct ( 1 ), MulProduct ( 0 )) Upper = UInt128 ( MulProduct ( 3 ), MulProduct ( 2 )) ! We know that Upper has at most one leading zero because both Significand and  Pow10 have a leading one. ! As long as the first 13/9/6 bits of \"upper\" are not \"1\", then we know that we have an exact computed ! value for the leading 125/55/26 bits because any imprecision would play out as a +1, in the worst case. ! Having 125/55/26 bits is necessary because we need 123/53/24 bits for the mantissa but we have to have ! one rounding bit and we can waste a bit if the most significant bit of the product is zero. We expect ! this next branch to be rarely taken (say 1% of the time). When (Upper & BitMask) == BitMask, ! it can be common for Lower + Significand < Lower to be true (proba. much higher than 1%). ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ IF (( IAND ( Upper , BitMask ) == BitMask ). AND .(( Lower + Significand ) . ULT . Lower )) THEN BLOCK ! --- declaration --- TYPE ( UInt128 ) :: Product_Low , Product_High TYPE ( UInt128 ) :: Product_Middle , Product_Middle1 , Product_Middle2 ! --- execution --- ! perform multiplication CALL MultiplyBasic ( Mantissa , 2 , Pow10 ( 0 : 1 ), 2 , MulProduct ) Product_Low = UInt128 ( MulProduct ( 1 ), MulProduct ( 0 )) Product_Middle2 = UInt128 ( MulProduct ( 3 ), MulProduct ( 2 )) Product_Middle1 = Lower Product_High = Upper Product_Middle = Product_Middle1 + Product_Middle2 ! overflow carry IF ( Product_Middle . ULT . Product_Middle1 ) Product_High = Product_High + OneU128 ! we want to check whether Pow10*Significand + Significand would affect our result ! This does happen, e.g. with 7.3177701707893310E+15 (for double-precision) IF ((( Product_Middle + OneU128 == ZeroU128 ). AND .( IAND ( Product_High , BitMask ) == BitMask ) & . AND .( Product_Low + Significand . ULT . Product_Low ))) THEN ! let us be prudent and bail out. Success = FalseVal RETURN END IF Lower = Product_Middle Upper = Product_High END BLOCK END IF ! The final mantissa should be 123/53/24 (BinaryPrecision) bits with a leading 1. ! We shift it so that it occupies 124/54/25 (BinaryPrecision+1) bits with a leading 1. Upperbit = ToI32 ( SHIFTR ( Upper , SignBits )) SigBin = SHIFTR ( Upper , ( Upperbit + LowBits )) LZ = LZ + IEOR ( 1 , Upperbit ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision+1). ! We have to round to even. The \"to even\" part ! is only a problem when we are right in between two floats ! which we guard against. ! If we have lots of trailing zeros, we may fall right between two ! floating-point values. IF (( Lower == ZeroU128 ). AND .( IAND ( Upper , BitMask ) == ZeroU128 ). AND . & ( IAND ( SigBin , ThreeUInt ) == OneU128 )) THEN ! if IAND(SigBin, 1) == 1 we might need to round up. ! Scenarios: ! 1. We are not in the middle. Then we should round up. ! 2. We are right in the middle. Whether we round up depends on the last significant !    bit: if it is \"one\" then we round up (round to even) otherwise, we do not. ! So if the last significant bit is 1, we can safely round up.  Hence we only need ! to bail out if IAND(SigBin, 3) == 1.  Otherwise we may need more accuracy or analysis ! to determine whether we are exactly between two floating-point numbers. ! It can be triggered with 1E23. ! Note: because the factor_mantissa and factor_mantissa_low are almost always rounded !       down (except for small positive powers), almost always should round up. Success = FalseVal RETURN END IF SigBin = SHIFTR ( SigBin + IAND ( SigBin , OneU128 ), 1 ) ! Here we have SigBin < SHIFTL(1, BinaryPrecision), unless there was an overflow IF ( SigBin . UGE . MaxMantissa ) THEN ! This will happen when parsing values such as 7.2057594037927933E+16 SigBin = SigHidBitMask ! undo previous addition LZ = LZ - 1 END IF SigBin = IAND ( SigBin , NOT ( SigHidBitMask )) ExpBin = Exponent - LZ ! we have to check that ExpBin is in range, otherwise we bail out IF (( ExpBin < 1 ). OR .( ExpBin > ( MaxExponent - 1 ))) THEN Success = FalseVal ELSE Success = TrueVal END IF RETURN END FUNCTION D2B_Lemire_FastPath !************************************************************************** END FUNCTION Dec2Bin_Lemire !****************************************************************************** !------------------------------------------------------------------------------ ! !                           REAL128 AUXILIARY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION DivByPow10 ( X , P ) RESULT ( Y ) !** PURPOSE OF THIS SUBROUTINE: ! To compute Y = X .UDIV. (10**P) IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X ! X <= 10**40 INTEGER ( KIND = I4B ), INTENT ( IN ) :: P ! 1 <= P <= 10 TYPE ( UInt128 ) :: Y !** SUBROUTINE PARAMETER DECLARATIONS: ! Parameters for division by power of 10 applicable for N <= 40 digits ! (i.e. used for division of the 'Significand') ! Note: elements in the row are in little-endian order ! (i.e. element 0 is the least significant byte and element 1 is the most one) INTEGER ( KIND = I8B ), PARAMETER :: MagicM ( 0 : 2 , 1 : 10 ) = RESHAPE ([ & INT ( Z '3333333333333334' , KIND = I8B ), INT ( Z '3333333333333333' , KIND = I8B ), INT ( Z '0000000000000033' , KIND = I8B ), & INT ( Z '5C28F5C28F5C28F6' , KIND = I8B ), INT ( Z 'F5C28F5C28F5C28F' , KIND = I8B ), INT ( Z '0000000000000028' , KIND = I8B ), & INT ( Z '16872B020C49BA5F' , KIND = I8B ), INT ( Z 'C49BA5E353F7CED9' , KIND = I8B ), INT ( Z '0000000000000020' , KIND = I8B ), & INT ( Z 'F0D844D013A92A31' , KIND = I8B ), INT ( Z '6DC5D63886594AF4' , KIND = I8B ), INT ( Z '0000000000000034' , KIND = I8B ), & INT ( Z 'F3E0370CDC8754F4' , KIND = I8B ), INT ( Z 'F16B11C6D1E108C3' , KIND = I8B ), INT ( Z '0000000000000029' , KIND = I8B ), & INT ( Z '8FE69270B06C43F6' , KIND = I8B ), INT ( Z '8DEF416BDB1A6D69' , KIND = I8B ), INT ( Z '0000000000000021' , KIND = I8B ), & INT ( Z '4CA41D811A46D324' , KIND = I8B ), INT ( Z 'AFE535795E90AF0F' , KIND = I8B ), INT ( Z '0000000000000035' , KIND = I8B ), & INT ( Z '70834ACDAE9F0F50' , KIND = I8B ), INT ( Z 'F31DC4611873BF3F' , KIND = I8B ), INT ( Z '000000000000002A' , KIND = I8B ), & INT ( Z '5A02A23E254C0C40' , KIND = I8B ), INT ( Z '5C17D04DAD2965CC' , KIND = I8B ), INT ( Z '0000000000000022' , KIND = I8B ), & INT ( Z '5CD10396A21346CC' , KIND = I8B ), INT ( Z 'F9BFB3AF7B756FAD' , KIND = I8B ), INT ( Z '0000000000000036' , KIND = I8B )], & [ 3 , 10 ]) INTEGER ( KIND = I4B ), PARAMETER :: MagicS ( 1 : 10 ) = [ 137 , 140 , 143 , 147 , 150 , 153 , 157 , 160 , 163 , 167 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: MulProduct ( 0 : 4 ) INTEGER ( KIND = I8B ) :: Input ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Multiplier ( 0 : 2 ) INTEGER ( KIND = I4B ) :: Shift !** FLOW Input ( 0 ) = X % Low Input ( 1 ) = X % High Multiplier = MagicM (:, P ) Shift = MagicS ( P ) CALL Multiply_N_ShiftRight ( Input , 2 , Multiplier , 3 , Shift , MulProduct ) Y = UInt128 ( MulProduct ( 1 ), MulProduct ( 0 )) RETURN END FUNCTION DivByPow10 !****************************************************************************** SUBROUTINE UMul256 ( X , Y , Hi , Lo ) !** PURPOSE OF THIS SUBROUTINE: ! To compute multiplication of two 128-bit unsigned integers. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X , Y TYPE ( UInt128 ), INTENT ( OUT ) :: Hi , Lo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X64 ( 0 : 1 ), Y64 ( 0 : 1 ) INTEGER ( KIND = I8B ) :: Z64 ( 0 : 3 ) !** FLOW ! get input X64 ( 0 ) = X % Low X64 ( 1 ) = X % High Y64 ( 0 ) = Y % Low Y64 ( 1 ) = Y % High ! perform multiplication CALL MultiplyBasic ( X64 , 2 , Y64 , 2 , Z64 ) ! set output Hi = UInt128 ( Z64 ( 3 ), Z64 ( 2 )) Lo = UInt128 ( Z64 ( 1 ), Z64 ( 0 )) RETURN END SUBROUTINE UMul256 !****************************************************************************** FUNCTION UMul256_Upper128 ( X , Y ) RESULT ( Z256Hi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute multiplication of two 128-bit unsigned integers and ! return the upper 128 bits of the 256-bit unsigned result. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: X , Y TYPE ( UInt128 ) :: Z256Hi !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: X64 ( 0 : 1 ), Y64 ( 0 : 1 ), Z64 ( 0 : 3 ) !** FLOW ! get input X64 ( 0 ) = X % Low X64 ( 1 ) = X % High Y64 ( 0 ) = Y % Low Y64 ( 1 ) = Y % High ! perform multiplication CALL MultiplyBasic ( X64 , 2 , Y64 , 2 , Z64 ) ! set output Z256Hi = UInt128 ( Z64 ( 3 ), Z64 ( 2 )) RETURN END FUNCTION UMul256_Upper128 !****************************************************************************** FUNCTION Write_RealQP ( Fp , Ep , cStr , IsScientific ) RESULT ( sLen ) !DIR$ ATTRIBUTES INLINE :: Write_RealQP !** PURPOSE OF THIS SUBROUTINE: ! To format the decimal F*10**E IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Fp ! significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: Ep ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string LOGICAL , OPTIONAL , INTENT ( IN ) :: IsScientific ! format flag ! true  if to write the given number in scientific format ! false if to write the given number in general format ! default is false INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE PARAMETER DECLARATIONS: ! shift and multiplier parameters (i.e. magic number) for integer division INTEGER ( KIND = I8B ), PARAMETER :: TenPow9 = 1000000000_I8B ! multiplier and shift for 18 digits and divisor of 10**9 INTEGER ( KIND = I4B ), PARAMETER :: S189 = 26 ! 90 - 64 INTEGER ( KIND = I8B ), PARAMETER :: M189 = INT ( Z '112E0BE826D694B3' , KIND = I8B ) ! multiplier and shift for 17 digits and divisor of 10**8 INTEGER ( KIND = I4B ), PARAMETER :: S178 = 20 ! 84 - 64 INTEGER ( KIND = I8B ), PARAMETER :: M178 = 193428131138340668_I8B INTEGER ( KIND = I8B ), PARAMETER :: DivE8 = 100000000_I8B ! Used for left-to-tight digit extraction. INTEGER ( KIND = I4B ), PARAMETER :: MASK_28 = SHIFTL ( 1 , 28 ) - 1 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( UInt128 ) :: F INTEGER ( KIND = I8B ) :: Hi , Lo INTEGER ( KIND = I4B ) :: E , HiHi , HiLo , LoHi , LoLo LOGICAL :: IsGeneral ! true if to write the given number in general format LOGICAL :: IsPlainWOLZ ! true if to write the number in plain format without leading zeroes !** FLOW ! check for special cases IF ( Ep == ExceptionalExponent ) THEN ! either NaN or Infinity IF ( Fp /= ZeroU128 ) THEN cStr ( 1 : 3 ) = 'NaN' sLen = 3 ELSE cStr ( 1 : 8 ) = 'Infinity' sLen = 8 END IF RETURN END IF IF ( Fp == ZeroU128 ) THEN ! zero cStr ( 1 : 3 ) = '0.0' sLen = 3 RETURN END IF ! set format flag IsGeneral = TrueVal IF ( PRESENT ( IsScientific )) IsGeneral = . NOT . IsScientific ! For details not discussed here see section 10 of [3]. ! Determine sLen such that 10**(sLen-1) <= F < 10**sLen sLen = Floor_Log10_Pow2 ( 128 - LEADZ ( Fp )) IF ( Fp . UGE . PowTen ( sLen )) sLen = sLen + 1 ! Let Fp and Ep be the original F and E, respectively. ! Transform F and E to ensure !    10**(H-1) <= F < 10**H !    Fp*10**Ep = F*10**(E-H) = 0.F*10**E E = Ep + sLen IF (( 0 < E ). AND .( E <= 7 ). AND .( sLen < 36 ). AND .( IsGeneral )) THEN IsPlainWOLZ = TrueVal ELSE IsPlainWOLZ = FalseVal END IF IF ( sLen > 0 ) THEN IF ( IsPlainWOLZ ) THEN ! Note: 'ToChar_Plain_Without_LZ' only handles 35 digits F = Fp * PowTen ( H - sLen - 1 ) ELSE F = Fp * PowTen ( H - sLen ) END IF ELSE ! Is this possible?  Have we handled this case already above? F = Fp * PowTen36 END IF ! 'ToChar_...' routines perform digits extraction using 32-bit integers, ! provided that the arguments are limited to 9 digits. ! Therefore, split the H = 36 digits (or 35 digits if IsPlainWOLZ is true) of F into: !     HiHi = the most 9 (or 8 if IsPlainWOLZ is true) significant digit of F !     HiLo = the next 9 most significant digits of F !     LoHi = the next 9 most significant digits of F !     LoLo = the last 9 least significant digits of F CALL DivModBy10Pow18 ( F , Hi , Lo ) HiHi = SHIFTR ( UMul128_Upper64 ( Hi , M189 ), S189 ) ! HiHi = Hi/TenPow9 HiLo = Hi - HiHi * TenPow9 ! HiLo = MOD(Hi, TenPow9) LoHi = SHIFTR ( UMul128_Upper64 ( Lo , M189 ), S189 ) ! HiHi = Hi/TenPow9 LoLo = Lo - LoHi * TenPow9 ! HiLo = MOD(Hi, TenPow9) ! write output IF ( IsGeneral ) THEN IF ( IsPlainWOLZ ) THEN ! plain format without leading zeroes sLen = ToChar_Plain_Without_LZ ( HiHi , HiLo , LoHi , LoLo , E , cStr ) ELSEIF (( - 3 < E ). AND .( E <= 0 )) THEN ! plain format with leading zeroes sLen = ToChar_Plain_With_LZ ( HiHi , HiLo , LoHi , LoLo , E , cStr ) ELSE ! scientific notation sLen = ToChar_Scientific ( HiHi , HiLo , LoHi , LoLo , E , cStr ) END IF ELSE ! scientific notation sLen = ToChar_Scientific ( HiHi , HiLo , LoHi , LoLo , E , cStr ) END IF RETURN CONTAINS FUNCTION ToChar_Plain_Without_LZ ( HH , HL , LH , LL , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Plain_Without_LZ !** PURPOSE OF THIS SUBROUTINE: ! For 0 < E <= 7, plain format without leading zeroes. ! Left-to-right digits extraction: ! algorithm 1 in [7], with b = 10, k = 8, n = 28. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: HH , HL , LH , LL ! components of significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Y , T , I , Pos !** FLOW Pos = 1 ! Algorithm 1 in [7] needs computation of floor((a + 1) 2&#94;n / b&#94;k) - 1 ! with a < 10&#94;8, b = 10, k = 8, n = 28. ! Noting that (a + 1) 2&#94;n <= 10&#94;8 2&#94;28 < 10&#94;17 ! For n = 17, m = 8 the table in section 10 of [3] leads to: Y = INT ( SHIFTR ( UMul128_Upper64 ( SHIFTL ( INT ( HH + 1 , KIND = I8B ), 28 ), M178 ), S178 ), KIND = I4B ) - 1 I = 0 DO WHILE ( I < E ) T = 10 * Y ! append digit cStr ( Pos : Pos ) = Char1Digit ( SHIFTR ( T , 28 )) Pos = Pos + 1 Y = IAND ( T , MASK_28 ) I = I + 1 END DO ! append period cStr ( Pos : Pos ) = '.' Pos = Pos + 1 DO WHILE ( I < 8 ) T = 10 * Y ! append digit cStr ( Pos : Pos ) = Char1Digit ( SHIFTR ( T , 28 )) Pos = Pos + 1 Y = IAND ( T , MASK_28 ) I = I + 1 END DO ! append HL Pos = Pos + Write_9_Digits ( HL , cStr ( Pos :)) ! append LH and LL Pos = Pos + Write_18_Digits ( LH , LL , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! set length sLen = Pos RETURN END FUNCTION ToChar_Plain_Without_LZ !****************************************************************************** FUNCTION ToChar_Plain_With_LZ ( HH , HL , LH , LL , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Plain_With_LZ !** PURPOSE OF THIS SUBROUTINE: ! For -3 < E <= 0: plain format with leading zeroes. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: HH , HL , LH , LL ! components of significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pos !** FLOW ! fill the first 4 characters cStr ( 1 : 4 ) = '0.00' ! compute Pos Pos = 3 - E ! append HH and HL Pos = Pos + Write_18_Digits ( HH , HL , cStr ( Pos :)) ! append LH and LL Pos = Pos + Write_18_Digits ( LH , LL , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! set length sLen = Pos RETURN END FUNCTION ToChar_Plain_With_LZ !****************************************************************************** FUNCTION ToChar_Scientific ( HH , HL , LH , LL , E , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: ToChar_Scientific !** PURPOSE OF THIS SUBROUTINE: ! For E <= -3 or E > 7: computerized scientific notation. IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: HH , HL , LH , LL ! components of significand INTEGER ( KIND = I4B ), INTENT ( IN ) :: E ! expoenent CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: Pos , HH_Hi , HH_Lo !** FLOW ! handle HH by splitting it into HH_Hi with 1 digit and HH_Lo with 8 digits HH_Hi = HH / 100000000 HH_Lo = HH - HH_Hi * 100000000 ! append HH_Hi cStr ( 1 : 1 ) = Char1Digit ( HH_Hi ) ! append period cStr ( 2 : 2 ) = '.' Pos = 3 ! append HH_Lo and HL Pos = Pos + Write_17_Digits ( HH_Lo , HL , cStr ( Pos :)) ! append LH and LL Pos = Pos + Write_18_Digits ( LH , LL , cStr ( Pos :)) - 1 ! remove trailing zero(s) DO WHILE ( cStr ( Pos : Pos ) == '0' ) Pos = Pos - 1 END DO ! ... but do not remove the one directly to the right of '.' IF ( cStr ( Pos : Pos ) == '.' ) Pos = Pos + 1 ! append exponent Pos = Pos + 1 cStr ( Pos : Pos ) = 'E' sLen = Pos + Write_I32_Exponent ( E - 1 , cStr ( Pos + 1 :)) RETURN END FUNCTION ToChar_Scientific !****************************************************************************** FUNCTION Write_18_Digits ( Hi , Lo , cStr ) RESULT ( SLen ) !** PURPOSE OF THIS SUBROUTINE: ! To write two integer numbers with a total length of 18 digits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Hi , Lo CHARACTER ( LEN =* ), INTENT ( OUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW sLen = Write_9_Digits ( Hi , cStr ( 1 : 9 )) + Write_9_Digits ( Lo , cStr ( 10 : 18 )) RETURN END FUNCTION Write_18_Digits !****************************************************************************** FUNCTION Write_17_Digits ( Hi , Lo , cStr ) RESULT ( SLen ) !** PURPOSE OF THIS SUBROUTINE: ! To write two integer numbers with a total length of 17 digits IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Hi , Lo CHARACTER ( LEN =* ), INTENT ( OUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW sLen = Write_8_Digits ( Hi , cStr ( 1 : 8 )) + Write_9_Digits ( Lo , cStr ( 9 : 17 )) RETURN END FUNCTION Write_17_Digits !****************************************************************************** FUNCTION Write_9_Digits ( Number , cStr ) RESULT ( SLen ) !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 9 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( OUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: ABBCC , DDEE , BBCC , A !** FLOW ! ABBCC = Number/10000 ABBCC = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * INT ( Z '0000000068DB8BAD' , KIND = I8B ), 44 ), KIND = I4B ) ! DDEE  = MOD(Number, 10000) DDEE = Number - ABBCC * 10000 ! A = ABBCC/10000 A = INT ( SHIFTR ( INT ( ABBCC , KIND = I8B ) * INT ( Z '000000000001A36F' , KIND = I8B ), 30 ), KIND = I4B ) ! BBCC  = MOD(ABBCC, 10000) BBCC = ABBCC - A * 10000 cStr ( 1 : 1 ) = Char1Digit ( A ) cStr ( 2 : 5 ) = Char4Digits ( BBCC ) cStr ( 6 : 9 ) = Char4Digits ( DDEE ) sLen = 9 RETURN END FUNCTION Write_9_Digits !************************************************************************** FUNCTION Write_8_Digits ( Number , cStr ) RESULT ( SLen ) !** PURPOSE OF THIS SUBROUTINE: ! To write an (unsigned) integer number with a length of 8 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Number ! number CHARACTER ( LEN =* ), INTENT ( OUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: AABB , CCDD !** FLOW ! AABB = Number/10000 AABB = INT ( SHIFTR ( INT ( Number , KIND = I8B ) * 109951163_I8B , 40 ), KIND = I4B ) ! CCDD  = MOD(Number, 10000) CCDD = Number - AABB * 10000 cStr ( 1 : 4 ) = Char4Digits ( AABB ) cStr ( 5 : 8 ) = Char4Digits ( CCDD ) sLen = 8 RETURN END FUNCTION Write_8_Digits !************************************************************************** FUNCTION Write_I32_Exponent ( Exp , cStr ) RESULT ( sLen ) !DIR$ ATTRIBUTES FORCEINLINE :: Write_I32_Exponent !** PURPOSE OF THIS SUBROUTINE: ! To write a signed integer in the range -4966 to 4932 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I4B ), INTENT ( IN ) :: Exp ! exponent number CHARACTER ( LEN =* ), INTENT ( INOUT ) :: cStr ! character string INTEGER ( KIND = I4B ) :: sLen ! length of string written !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: PosExp !** FLOW IF ( Exp < 0 ) THEN cStr ( 1 : 1 ) = '-' ELSE cStr ( 1 : 1 ) = '+' END IF PosExp = ABS ( Exp ) IF ( PosExp < 1000 ) THEN IF ( PosExp < 100 ) THEN IF ( PosExp < 10 ) THEN ! 1 digit cStr ( 2 : 2 ) = Char1Digit ( PosExp ) sLen = 2 ELSE ! 2 digits cStr ( 2 : 3 ) = Char2Digits ( PosExp ) sLen = 3 END IF ELSE ! 3 digits cStr ( 2 : 4 ) = Char4Digits ( PosExp )( 2 : 4 ) sLen = 4 END IF ELSE ! 4 digits cStr ( 2 : 5 ) = Char4Digits ( PosExp ) sLen = 5 END IF RETURN END FUNCTION Write_I32_Exponent !************************************************************************** SUBROUTINE DivModBy10Pow18 ( Dividend , Quotient , Remainder ) !** PURPOSE OF THIS SUBROUTINE: ! To perform division Dividend / Divisor where the Divisor is equal to 10**18 IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UInt128 ), INTENT ( IN ) :: Dividend ! the dividend INTEGER ( KIND = I8B ) :: Quotient ! the quotient INTEGER ( KIND = I8B ) :: Remainder ! the remainder !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ), PARAMETER :: LSh = 4 ! = LEADZ(Divisor) INTEGER ( KIND = I8B ), PARAMETER :: Denom = INT ( Z 'DE0B6B3A76400000' , KIND = I8B ) ! = SHIFTL(Divisor, LSh) INTEGER ( KIND = I8B ), PARAMETER :: V = INT ( Z '2725DD1D243ABA0E' , KIND = I8B ) ! = Reciprocal_2By1(Denom) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I4B ) :: RSh INTEGER ( KIND = I8B ) :: NumerHi , NumerLo INTEGER ( KIND = I8B ) :: NumerEx , RshMask , QuotHi INTEGER ( KIND = I8B ) :: R1 , R2 !** FLOW RSh = 64 - LSh RShMask = - 1_I8B NumerLo = SHIFTL ( Dividend % Low , LSh ) NumerHi = IOR ( SHIFTL ( Dividend % High , LSh ), IAND ( SHIFTR ( Dividend % Low , RSh ), RShMask )) NumerEx = IAND ( SHIFTR ( Dividend % High , RSh ), RShMask ) CALL UDivRem_2By1 ( NumerEx , NumerHi , Denom , V , QuotHi , R1 ) CALL UDivRem_2By1 ( R1 , NumerLo , Denom , V , Quotient , R2 ) Remainder = SHIFTR ( R2 , LSh ) RETURN END SUBROUTINE DivModBy10Pow18 !************************************************************************** SUBROUTINE UDivRem_2By1 ( UHi , ULo , D , V , Q , R ) !** PURPOSE OF THIS SUBROUTINE: ! To perform 128-bit unsigned integer division by 64-bit unsigned integer IMPLICIT NONE ! Enforce explicit typing of all variables in this routine !** SUBROUTINE ARGUMENT DECLARATIONS: INTEGER ( KIND = I8B ), INTENT ( IN ) :: UHi , ULo , D , V INTEGER ( KIND = I8B ), INTENT ( OUT ) :: Q , R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ), PARAMETER :: MinInt64 = INT ( Z '8000000000000000' , KIND = I8B ) ! -9223372036854775808 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: INTEGER ( KIND = I8B ) :: QHi , QLo , NewLo !** FLOW ! Q128 = V*UHi CALL UMul128 ( V , UHi , QHi , QLo ) ! Q128 = Q128 + U128 NewLo = QLo + ULo IF ( IEOR ( NewLo , MinInt64 ) < IEOR ( QLo , MinInt64 )) THEN QHi = QHi + UHi + 1_I8B ELSE QHi = QHi + UHi END IF QLo = NewLo QHi = QHi + 1_I8B R = ULo - QHi * D IF ( IEOR ( R , MinInt64 ) > IEOR ( QLo , MinInt64 )) THEN QHi = QHi - 1_I8B R = R + D END IF IF ( IEOR ( R , MinInt64 ) >= IEOR ( D , MinInt64 )) THEN QHi = QHi + 1_I8B R = R - D END IF Q = QHi RETURN END SUBROUTINE UDivRem_2By1 !************************************************************************** END FUNCTION Write_RealQP !****************************************************************************** END MODULE ModBase_RealQP_CharConv !******************************************************************************","tags":"","loc":"sourcefile\\modbase - realqp - charconv.f90.html"}]}